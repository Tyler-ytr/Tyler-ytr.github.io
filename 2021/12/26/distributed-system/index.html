<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>分布式系统 | Tyler-yin&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="分布式系统">
    <meta name="description" content="分布式系统的特征以及系统模型什么是分布式系统 分布式系统是若干独立计算机的集合，在用户看来是一个单一相关系统。 例如:分配给用户的工作站网络、机房中动态分配的处理器池、单个文件系统等。 分布式系统涉及到网络、处理器、内存、存储、协议等。 分布式系统的目标  使资源可访问 透明性 开放性 可扩展性  为什么要分布式  经济：相比于大型机，微型处理器的性价比更高 速度：分布式系统比大型机计算能力更强">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式系统">
<meta property="og:url" content="http://tyler-ytr.github.io/2021/12/26/distributed-system/index.html">
<meta property="og:site_name" content="Tyler-yin&#39;s blog">
<meta property="og:description" content="分布式系统的特征以及系统模型什么是分布式系统 分布式系统是若干独立计算机的集合，在用户看来是一个单一相关系统。 例如:分配给用户的工作站网络、机房中动态分配的处理器池、单个文件系统等。 分布式系统涉及到网络、处理器、内存、存储、协议等。 分布式系统的目标  使资源可访问 透明性 开放性 可扩展性  为什么要分布式  经济：相比于大型机，微型处理器的性价比更高 速度：分布式系统比大型机计算能力更强">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226175558158.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226180719684.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226211552973.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226211748596.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226211922476.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226212647705.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226212655369.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226214358553.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226214447039.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211226214734990.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227140800732.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227151251247.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227153318439.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227154006443.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227154100592.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227222919525.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227223041307.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227223758776.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227224429102.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227231113593.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227233130739.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211227233428655.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228142648852.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228150820914.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228153131011.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228153136952.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228163203615.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228163229625.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228171012230.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228194256257.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211228194433000.png">
<meta property="og:image" content="http://tyler-ytr.github.io/picture/image-20211229105045012.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2021/12/26/distributed-system/picture/image-20211229104843788.png">
<meta property="article:published_time" content="2021-12-26T03:35:38.000Z">
<meta property="article:modified_time" content="2021-12-29T03:00:35.720Z">
<meta property="article:author" content="Tyler-yin">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tyler-ytr.github.io/picture/image-20211226175558158.png">
    
        <link rel="alternate" type="application/atom+xml" title="Tyler-yin&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/Tyler.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Tyler-yin</h5>
          <a href="mailto:ytrpossible@gmail.com" title="ytrpossible@gmail.com" class="mail">ytrpossible@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Index
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Tyler-ytr/" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-address-book"></i>
                Friends
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-link"></i>
                link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">分布式系统</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">分布式系统</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-12-26T03:35:38.000Z" itemprop="datePublished" class="page-time">
  2021-12-26
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分布式系统的特征以及系统模型"><span class="post-toc-number">1.</span> <span class="post-toc-text">分布式系统的特征以及系统模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分布式系统架构"><span class="post-toc-number">2.</span> <span class="post-toc-text">分布式系统架构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程与线程"><span class="post-toc-number">3.</span> <span class="post-toc-text">进程与线程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#通信"><span class="post-toc-number">4.</span> <span class="post-toc-text">通信</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#同步和资源管理"><span class="post-toc-number">5.</span> <span class="post-toc-text">同步和资源管理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#复制与一致性"><span class="post-toc-number">6.</span> <span class="post-toc-text">复制与一致性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#容错"><span class="post-toc-number">7.</span> <span class="post-toc-text">容错</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分布式一致性协议"><span class="post-toc-number">8.</span> <span class="post-toc-text">分布式一致性协议</span></a></li></ol>
        </nav>
    </aside>


<article id="post-distributed-system"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">分布式系统</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-12-26 11:35:38" datetime="2021-12-26T03:35:38.000Z"  itemprop="datePublished">2021-12-26</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="分布式系统的特征以及系统模型"><a href="#分布式系统的特征以及系统模型" class="headerlink" title="分布式系统的特征以及系统模型"></a>分布式系统的特征以及系统模型</h2><p><strong>什么是分布式系统</strong></p>
<p>分布式系统是若干独立计算机的集合，在用户看来是一个单一相关系统。</p>
<p>例如:分配给用户的工作站网络、机房中动态分配的处理器池、单个文件系统等。</p>
<p>分布式系统涉及到网络、处理器、内存、存储、协议等。</p>
<p><strong>分布式系统的目标</strong></p>
<ul>
<li>使资源可访问</li>
<li>透明性</li>
<li>开放性</li>
<li>可扩展性</li>
</ul>
<p><strong>为什么要分布式</strong></p>
<ul>
<li>经济：相比于大型机，微型处理器的性价比更高</li>
<li>速度：分布式系统比大型机计算能力更强</li>
<li>内在分布：一些应用需要在不同空间的机器上运行</li>
<li>可靠性：当某一台机器挂掉时，分布式系统仍能运行</li>
<li>可增加：通过增加分布式系统的组件使其计算能力增强</li>
</ul>
<p><strong>使资源可访问</strong></p>
<p>分布式系统的最主要目标是使用户能够方便地访问远程资源，并且以一种受控方式与其他用户共享这些资源。</p>
<p><strong>透明性</strong></p>
<p>对用户和应用程序员屏蔽分布式系统组件和分散性，系统被认为是一个整体，而不是独立的组件集合。透明性对用户和应用程序员隐藏了与手头任务无直接关系的资源，并匿名使用，使得分布的某些特性对应用程序员具有不可见性，这样应用程序员只要关心特定应用的设计问题。</p>
<p><strong>开放性</strong></p>
<p>能与其他开放的系统进行交互，不考虑底层环境，要求系统：</p>
<ol>
<li>良好说明的接口</li>
<li>支持程序的可移植性</li>
<li>系统容易交互</li>
</ol>
<p><strong>可拓展性</strong></p>
<p>三个方面：</p>
<ol>
<li><strong>规模</strong>上可扩展（用户和处理器数目）</li>
<li><strong>地域</strong>上可扩展（节点最大距离）</li>
<li><strong>管理</strong>上可扩展（管理域数）</li>
</ol>
<p><strong>分布式系统的类型</strong></p>
<ul>
<li>分布式计算系统：<ul>
<li>集群计算：本质是通过高速局域网连接的一组高端系统，每个节点运行相同的操作系统，硬件几乎相同，只有一个管理节点，同构性</li>
<li>网格计算：异构性，硬件、操作系统、网络、管理域都不尽相同，可以跨广域网</li>
</ul>
</li>
<li>分布式信息系统：<ul>
<li>事务处理系统：有ACID四种特性，主要应用于数据库，邮件系统，财务系统等<ul>
<li>原子性：对于外部来说，事务处理不可见</li>
<li>一致性：事务处理不会违反系统的不变性</li>
<li>独立性：并发的事务不会相互干扰</li>
<li>持久性：事务处理一旦提交，所发生改变是永久性的</li>
</ul>
</li>
</ul>
</li>
<li>分布式普适系统：新兴的下一代分布式系统，其中节点小，移动，并且经常嵌入在更大的系统中，其特<br>征在于系统自然地混合到用户环境中；</li>
</ul>
<p><strong>如何理解机制与策略</strong></p>
<p>在开放的分布式系统中要获得灵活性，就要把系统组织成规模相对较小且容易修改和替换的组件，需要将策略和机制分离。</p>
<p><strong>分布式操作系统、网络操作系统和基于中间件的系统</strong></p>
<ul>
<li>分布式操作系统：配置在分布式系统上的操作系统，能够直接对分布式系统中的各种资源进行动态分<br>配，并能有效地控制和协调分布式系统中各任务的并行执行，同时还向用户提供了一个方便的、透明的<br>使用整个分布式系统的界面。</li>
<li>网络操作系统：是在网络环境下实现对网络资源的管理和控制的操作系统，是用户与网络资源之间的接<br>口。网络操作系统是建立在独立的操作系统之上，为网络用户提供使用网络系统资源的桥梁。在多个用<br>户争用系统资源时，网络操作系统进行资源调剂管理，它依靠各个独立的计算机操作系统对所属资源进<br>行管理，协调和管理网络用户进程或程序与联机操作系统进行交互。</li>
<li>基于中间件的系统：在网络操作系统之上增加一个中间层，屏蔽各底层平台之间的异构性，从而增加分<br>布式系统的透明性</li>
</ul>
<hr>
<h2 id="分布式系统架构"><a href="#分布式系统架构" class="headerlink" title="分布式系统架构"></a>分布式系统架构</h2><p><strong>分布式系统架构的风格</strong></p>
<ol>
<li><p>组织成逻辑上不同的组件，并且将这些组件分布在不同的机器上</p>
<ol>
<li>分层体系结构（client-server架构）</li>
<li>Object-based style for distributed object systems 对于分布式对象系统使用基于对象的风格</li>
</ol>
<p><img src="/picture/image-20211226175558158.png" alt="image-20211226175558158"></p>
</li>
<li><p>在空间（匿名）时间（异步）的解耦过程中产生了替代的样式（Decoupling processes in space (“anonymous”) and also time (“asynchronous”) has led to alternative styles）</p>
<ol>
<li><p>以数据为中心的体系结构</p>
<p>思想：进程通信需要一个公用仓库（共享的分布式文件系统）</p>
</li>
<li><p>基于事件的体系结构</p>
<p><img src="/picture/image-20211226180719684.png" alt="image-20211226180719684"></p>
</li>
</ol>
<p>a图是空间解耦，进程通过事件的传播来通信，事件传播可以有选择地携带数据，分布式系统的事件传播通常与发布/订阅系统有关；</p>
<p>b图是时间空间都解耦，将基于事件的体系结构与以数据为中心的体系结构组合形成共享数据空间</p>
</li>
</ol>
<p><strong>分布式系统组织形式</strong></p>
<ol>
<li><p>集中式</p>
<ol>
<li><p>客户端服务器模式：</p>
<ul>
<li><p>提供服务器的进程</p>
</li>
<li><p>提供客户端的进程</p>
</li>
<li><p>客户端和服务器可以在不同的机器上运行</p>
</li>
<li><p>客户端遵守<strong>请求/回复行为</strong>来使用服务</p>
<p><img src="/picture/image-20211226211552973.png" alt="客户端服务器之间的交互"></p>
</li>
</ul>
</li>
<li><p>为了在客户和服务器之间划分界限，使用了应用分层：</p>
<ol>
<li><p>用户接口层：含有与用户交互所需的一切如显示管理</p>
</li>
<li><p>处理层：应用程序</p>
</li>
<li><p>数据层：使用的实际数据</p>
<p><img src="/picture/image-20211226211748596.png" alt="搜索引擎的抽象"></p>
</li>
</ol>
</li>
<li><p>多层体系结构</p>
<ol>
<li>单层：哑终端/主机</li>
<li>双层：客户端/单服务器</li>
<li>三层：每一层都在不同的机器上运行</li>
</ol>
<p><img src="/picture/image-20211226211922476.png" alt="各种客户服务器的组织架构"></p>
<p>其中a-c式瘦客户，后面的是胖客户</p>
</li>
</ol>
</li>
<li><p>非集中式</p>
<ol>
<li><p>结构化的点对点系统：</p>
<p>比如chord，CAN等等，特点在于节点以特定的分布式数据结构进行组织。在一个结构化的覆盖网络(如逻辑环或超立方体)中组织节点，并使特定节点仅根据其ID负责某些服务。</p>
<p><img src="/picture/image-20211226212647705.png" alt="image-20211226212647705"></p>
<p><img src="/picture/image-20211226212655369.png" alt="image-20211226212655369"></p>
</li>
<li><p>非结构化的点对点系统 </p>
<p>构建类似于随机图的覆盖网络，基本模型是每一个节点都维护一个含有c个邻节点的列表。随机选择一个邻居v，如果v有答案，它会回答，否则v随机选择它的一个邻居。（维护一个超级节点）</p>
</li>
</ol>
</li>
<li><p>混合式</p>
<p>它将客户服务器体系结构和非集中式体系结构组合在了一起</p>
<ol>
<li><p>边界服务器系统：用于内容分发网络，在进行过滤和编码转换后提供内容服务，还可用于优化内容和应用程序的分布性。</p>
<p><img src="/picture/image-20211226214358553.png" alt="把英特网堪称一系列边界服务器"></p>
</li>
<li><p>协作分布式系统：比如BitTorrent文件共享，点对点文件下载：</p>
<p><img src="/picture/image-20211226214447039.png" alt="BitTorrent工作原理"></p>
<p>一旦一个节点确定了从哪里下载文件，它就加入了一群下载者的行列，这些下载者并行地从源文件获取文件块，但也在彼此之间分发这些文件块。</p>
</li>
</ol>
</li>
</ol>
<p><strong>分布式系统组织为中间件</strong></p>
<p>中间件在<strong>应用程序</strong>和<strong>分布式平台</strong>之间形成了一个层，可以提供<strong>分布式透明性</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/picture/image-20211226214734990.png" alt="image-20211226214734990" title="">
                </div>
                <div class="image-caption">image-20211226214734990</div>
            </figure>
<p>方式之一为中断器：作为一种软件结构，能中断正常的控制流，从而允许其他代码运行。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程线程的定义</strong></p>
<p>进程是特定上下文里一个执行的流，可以包含多个线程，有自己独立的内存管理单元，切换时也需要一<br>个进程所拥有的全部内容。<br>线程是一段执行流，是轻量级的进程，只需要简单切换堆栈和寄存器内的值即可，共享内存单元。</p>
<p><strong>LWP</strong></p>
<p>轻量级进程，这个采用了用户级线程和内核级线程的混合形式,</p>
<p>其中对于用户级线程：</p>
<ul>
<li>所有的线程都在用户的进程地址空间中创建。</li>
<li>优点：所有的操作都能在单个进程中完成，导致实现起来很高效。</li>
<li>缺点：难以从操作系统和block中得到支持。内核提供的所有服务都是代表线程所在的进程执行的，如果内核决定阻塞一个线程，那么整个进程将被阻塞。</li>
</ul>
<p>内核级线程：</p>
<ul>
<li>可以解决上述问题</li>
<li>但是由于每一个线程操作（创建删除同步化）都需要内核来进行执行，需要系统调用，导致内核级线程的开销可能和进程差不多大</li>
</ul>
<p>LWP：</p>
<ul>
<li><p>运行在单个重量级进程的上下文中，每一个进程都可以包含多个LWP。另外系统还提供用户级线程包，包括了用于线程同步的工具，这部分内容完全在用户空间实现。并且可以被多个LWP共用。</p>
<p><img src="/picture/image-20211227140800732.png" alt="image-20211227140800732"></p>
</li>
<li><p>优点在于：线程创建，销毁，同步化工作开销小不需要内核干预，并且如果进程中有足够数量的LWP，阻塞的系统调用将不需要整个进程被挂起，另外应用程序不需要知道LWP存在，事实上只能见到用户级线程，并且通过在不同CPU执行不同的LWP，可以在多处理器系统中方便的使用</p>
</li>
<li><p>缺点在于：必须进行LWP的创建和销毁工作，开销不必内核级线程小，但是只需要偶尔进行，并且受到操作系统的完全控制</p>
</li>
</ul>
<hr>
<p><strong>代码迁移</strong></p>
<ul>
<li><p>代码迁移的方法：</p>
<ul>
<li>代码段(Code Segment)：包含实际的代码</li>
<li>数据段(Data Segment)：包含状态</li>
<li>执行状态(Execution State)：包含线程执行对象代码的上下文</li>
</ul>
</li>
<li><p>强弱迁移</p>
<ul>
<li><p>弱迁移：只迁移代码部分和数据部分，最后被目标进程或另外一个独立进程执行</p>
</li>
<li><p>强迁移：迁移执行部分，要么复制进程，要么克隆(所有数据完全复制，和原来的进程并行)</p>
<p><img src="/picture/image-20211227151251247.png" alt="image-20211227151251247"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p><strong>通信的类型</strong></p>
<ul>
<li>瞬时通信(Transient Commnunication)：通讯系统只有在发送和接收应用程序正<br>在运行时才能存储消息</li>
<li>持久通信(Persistent Communication)：提交传输的消息一直由通信中间件存储，<br>直到该消息被传送给接收方为止</li>
<li>异步通信(Asynchronous Communication)：发信方发信后立即继续，消息存储在发信方主机或者通信服务器的缓冲区中。</li>
<li>同步通信(Synchronous Communication)：发信方在到达同步点前保持阻塞。</li>
</ul>
<p><strong>远程过程调用RPC</strong></p>
<p>PS: 一般程序的调用：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/picture/image-20211227153318439.png" alt="image-20211227153318439" title="">
                </div>
                <div class="image-caption">image-20211227153318439</div>
            </figure>
<p>RPC的工作过程：</p>
<ol>
<li><p>客户过程以正常的方式调用客户存根(client stub)；</p>
</li>
<li><p>客户存根生成一个消息，然后调用本地操作系统；</p>
</li>
<li><p>客户端操作系统将消息发送给远程操作系统；</p>
</li>
<li><p>远程操作系统将消息交给服务器存根；</p>
</li>
<li><p>服务器存根调将参数提取出来，而后调用服务器；</p>
</li>
<li><p>服务器执行要求的操作，操作完成后将结果返回给服务器存根；</p>
</li>
<li><p>服务器存根将结果打包成一个消息，而后调用本地操作系统；</p>
</li>
<li><p>服务器操作系统将含有结果的消息发送给客户端操作系统；</p>
</li>
<li><p>客户端操作系统将消息交给客户存根；</p>
</li>
<li><p>客户存根将结果从消息中提取出来，返回给调用它的客户存根</p>
<p><img src="/picture/image-20211227154006443.png" alt="image-20211227154006443"></p>
<p><img src="/picture/image-20211227154100592.png" alt="image-20211227154100592"></p>
</li>
</ol>
<p><strong>故障处理</strong></p>
<p>5 种故障</p>
<ol>
<li><p>客户端不能定位服务器：使用特定的返回值 (异常处理)</p>
<p>例如：服务器故障，服务器进化但客户端使用过期的客户端存根<br>可能的解决方案：用特殊代码（如-1）作为返回值声明故障；抛出异常或信号</p>
</li>
<li><p>客户端到服务器的请求消息丢失：设置一个计时器 超时重发</p>
</li>
<li><p>服务器发给客户的应答消息丢失：设置一个计时器，对于不幂等的请求 为客户请求分配序号 服务器<br>区别不同的请求。</p>
</li>
<li><p>服务器在收到消息后崩溃(接受后执行前崩溃或者执行后发送前崩溃)：等待服务器启动 然后重发请<br>求(至少一次)；或者立即放弃并报告失败(至多一次)；或者不做任何保证 ;</p>
</li>
<li><p>客户机在发送消息后崩溃：</p>
<p>客户端在发送请求后，在收到服务器响应前故障，通讯是活跃的，但没有parent 在等待响应，形成孤儿</p>
<ol>
<li>消除 extermination: 在日志文件中纪录 RPC 请求 重启后清除孤儿 。</li>
<li>再生 reincarnation: 按时间顺序编号不同的时间段。当客户端重启时，广播 一条消息宣布新的时间段开始，当广播到达时终止所有远程计算，无需日志。(服务端杀死所有的)（另一种说法：设置一个epoch,每个客户端进程重启为一个新的epoch。新epoch到达意味着之前的计算全部杀死）</li>
<li>温和再生 gentle reincarnation: 与再生相似，但是当广播到达时，每台机器会寻找远程计算的所<br>有者，仅当找不到所有者时，计算才会被终止 。（服务端杀死掉线的）（另一种说法：设置一个epoch,每个客户端进程重启为一个新的epoch。新epoch 到达意味着将没有主的孤儿进程杀死 ）</li>
<li>过期 expiration: 赋予每个RPC一个标准时间配额，未完成任务明确申请额外配额。</li>
</ol>
</li>
</ol>
<p><strong>动态绑定</strong></p>
<p>绑定：一种让客户端找到服务器的方法</p>
<p>静态绑定：将服务器地址（IP、端口）硬编码到客户端代码中</p>
<p>动态绑定过程：</p>
<ol>
<li>服务器启动时向Binder 注册<br>Register 请求：参数:ID、名字、版本、地址<br>Unregister 请求：参数:ID、名字、版本</li>
<li>客户端存根向Binder 查找服务器接口<br>Lookup 请求：参数: 名字、版本；返回：ID、地址<br>调用：客户端根据地址发送RPC 调用</li>
</ol>
<p>优点：灵活性，可以支持多个支持同一接口的服务器，绑定程序可以验证客户端和服务器都使用相同版本的接口</p>
<p>缺点：导出/导入接口的额外开销花费时间，绑定程序可能成为大型分布式系统中的瓶颈</p>
<hr>
<p><strong>基于消息的通信</strong></p>
<ul>
<li>瞬时通信(Transient Commnunication)：通讯系统只有在发送和接收应用程序正<br>在运行时才能存储消息</li>
<li>持久通信(Persistent Communication)：提交传输的消息一直由通信中间件存储，<br>直到该消息被传送给接收方为止</li>
<li>异步通信(Asynchronous Communication)：发信方发信后立即继续，消息存储在发信方主机或者通信服务器的缓冲区中。</li>
<li>同步通信(Synchronous Communication)：发信方在到达同步点前保持阻塞。</li>
</ul>
<p><strong>面向流的通信</strong></p>
<ul>
<li><p>分类</p>
<ul>
<li>连续数据流：支持异构数据传输的通信设施</li>
<li>离散媒体：数据项在时间上的联系不重要</li>
<li>连续媒体：不同数据项在时间上的联系非常重要，如：音频、视频、动画</li>
</ul>
</li>
<li><p>不同传输模式</p>
<ul>
<li>异步传输模式（离散媒体）：没有时间限制</li>
<li>同步传输模式（连续媒体）：没有最大延迟时间</li>
<li>等时传输模式（连续媒体）：最大延迟时间、最小延迟时间</li>
</ul>
</li>
<li>流与Qos<ul>
<li>利用区分服务为不同类型的数据提供服务</li>
<li>利用缓冲区减少延时抖动</li>
<li>交错传输来降低丢包影响</li>
</ul>
</li>
</ul>
<h2 id="同步和资源管理"><a href="#同步和资源管理" class="headerlink" title="同步和资源管理"></a>同步和资源管理</h2><p><strong>Lamport时钟</strong></p>
<p>参考了该<a href="https://yang.observer/2020/07/26/time-lamport-logical-time/" target="_blank" rel="noopener">博客</a></p>
<ol>
<li><p>先后关系：把事件 a 发生在 b 之前定义为 a → b，以下三种条件满足a → b：</p>
<ol>
<li>a和b是同一个进程内的事件，a发生在b之前，则 a → b。</li>
<li>a和b在不同的进程中，a是发送进程内的发送事件，b是同一消息接收进程内的接收事件，则 a → b。</li>
<li>如果a → b并且b → c，则a → c。</li>
</ol>
<p>如果a和b没有先后关系，则称两个事件是并发的，记作 a || b。<br>例子：</p>
<p><img src="/picture/image-20211227222919525.png" alt="image-20211227222919525"></p>
<p>​    这个例子中：</p>
<ul>
<li>a → b → c → d</li>
<li>a → b → e</li>
<li>f → c → d</li>
<li>a || f</li>
<li>e || d</li>
<li>b || f</li>
<li>e || c</li>
</ul>
<ol start="2">
<li><p>逻辑时钟算法：分布式系统中每个进程Pi保存一个本地逻辑时钟值Ci，Ci (a) 表示进程Pi发生事件a时的逻辑时钟值，Ci的更新算法如下：</p>
<ol>
<li>进程Pi每发生一次事件，Ci加1。</li>
<li>进程Pi给进程Pj发送消息，需要带上自己的本地逻辑时钟Ci。</li>
<li>进程Pj接收消息，更新Cj为 max (Ci, Cj) + 1。</li>
</ol>
<p>上述例子的逻辑时钟：</p>
<p><img src="/picture/image-20211227223041307.png" alt="image-20211227223041307"></p>
<p>从以上算法可以很容易地得出下面两个结论：</p>
<ol>
<li>同一个进程内的两个事件a和b，如果 a → b，那么 Ci (a) &lt; Ci (b)。</li>
<li>a是Pi进程的消息发送事件，b是Pj进程该消息的接收事件，那么 Ci (a) &lt; Cj (b)。</li>
</ol>
</li>
<li><p>另外如果 C (a) &lt; C (b)，那么可以得出 a → b 吗？</p>
<p>答案是不能，举个反例，图二中C (e) = 2，C (d) = 3，虽然 C (e) &lt; C (d)，但并不能得出 e → d，e和d实际上是并发关系 e || d，也就是说由于并发的存在，导致反向的推论并不成立。</p>
</li>
</ol>
</li>
</ol>
<p><strong>向量时钟</strong></p>
<p>在向量时钟中如果C (a) &lt; C (b)，可以得出 a → b，它的思想是进程间通信的时候，不光同步本进程的时钟值，还同步自己知道的其他进程的时钟值。</p>
<p>分布式系统中每个进程Pi保存一个本地逻辑时钟向量值VCi，向量的长度是分布式系统中进程的总个数。VCi (j) 表示进程Pi知道的进程Pj的本地逻辑时钟值，VCi的更新算法如下：</p>
<ol>
<li>初始化VCi的值全为0：VCi = [0, … , 0]</li>
<li>进程Pi每发生一次事件，VCi[i]加1。</li>
<li>进程Pi给进程Pj发送消息，需要带上自己的向量时钟VCi。</li>
<li>进程Pj接收消息，需要做两步操作。<ol>
<li>对于VCj向量中的每个值VCj[k]，更新为 max (VCi[k], VCj[k])。</li>
<li>将VCj中自己对应的时钟值加1，即VCj[j]加1</li>
</ol>
</li>
</ol>
<p>例子：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/picture/image-20211227223758776.png" alt="image-20211227223758776" title="">
                </div>
                <div class="image-caption">image-20211227223758776</div>
            </figure>
<p>向量时钟中的向量的偏序关系定义如下：</p>
<ul>
<li>如果向量VCi中的每个元素VCi[k]都小于等于VCj中的对应元素VCj[k]，则VCi <em>≤</em> VCj。</li>
<li>如果VCi中的每个元素VCi[k]都和VCj中的对应元素VCj[k]相等，则VCi = VCj。</li>
<li>如果VCi和VCj不能比较大小，则称两个向量是并发的 VCi || VCj。</li>
</ul>
<p>因此可以有以下推论：</p>
<ul>
<li>同一个进程内的两个事件a和b，如果 a → b，那么 VCi (a) &lt; VCi (b)。</li>
<li>a是Pi进程的消息发送事件，b是Pj进程该消息的接收事件，那么 VCi (a) &lt; VCj (b)。</li>
</ul>
<p>然后可以推出：<strong>对于任意两个事件a和b，如果 a → b，那么 VC (a) &lt; VC (b)</strong>。</p>
<p>证明VC(a) &lt; VC(b) 可以推导a → b：</p>
<ul>
<li><p>如果事件a和b在同一个进程内，很显然 a → b。</p>
</li>
<li><p>如果事件a和b在不同进程内，比如Pa和Pb。</p>
<p>设VCa = [m ,n], VCb = [s, t]。</p>
<p>因为VCa &lt; VCb，所以m <em>≤</em> s，所以必然在不早于a之前和不晚于b之后的时间内，Pa向Pb发送了消息，否则Pb对Pa的计数器得不到及时刷新，s就不会小于m。</p>
<p>实际上可以分为如下四种情况：</p>
<p><img src="/picture/image-20211227224429102.png" alt="image-20211227224429102"></p>
<ol>
<li>当a = c且d = b，易得a → b。</li>
<li>当a = c且d → b，由传递性，得a → b。</li>
<li>同样对于d = b且a → c的情况。</li>
<li>当a → c且d → b，根据进程内的算法逻辑性和传递性，也很容易得出结论。</li>
</ol>
</li>
<li><p>综上: VCa &lt; VCb 推导出 a → b 得证。</p>
</li>
</ul>
<hr>
<p><strong>分布式系统中的互斥访问</strong></p>
<ol>
<li><p>集中式算法：基于上述的选举算法，选出一个进程作为集中协调者，该协调者同时管理一个请求等<br>待队列。当队列为空时，协调者对临界区请求应答。当队列不为空或者临界区尚未释放时，把请求添加<br>到等待队列的队尾，然后或者对请求不予应答，或者直接拒绝（此时该请求会一直查询临界区使用状<br>态），直至从队头取出该请求后再允许其进入临界区。</p>
<p>优点：</p>
<ul>
<li>保持互斥</li>
<li>公平</li>
<li>无饥饿</li>
<li>容易失效：请求、授权、释放</li>
</ul>
<p>缺点：</p>
<ul>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>无法区分coordinator 失效or 权限拒绝</li>
</ul>
<p>PS: 非集中式 多个leader</p>
</li>
<li><p>分布式算法：基于时间戳；</p>
<ol>
<li>进程如果想进入临界区，那么构建含临界区名字、进程编号、当前时间的消息发给所有进程；</li>
<li>进程收到请求消息：<ol>
<li>如果接收方未在临界区<ol>
<li>想进入临界区：对比消息的timestamp，如果接收消息的timestamp比较早，返回<br>OK；否则缓存请求，返回空</li>
<li>不想进入临界区：返回OK</li>
</ol>
</li>
<li>如果接收方已在临界区，缓存请求</li>
</ol>
</li>
</ol>
</li>
<li><p>令牌环算法：</p>
<ol>
<li>用软件的方法，按照进程的地址或者编号等，为总线型的网络构造一个逻辑环。一个令牌环只能<br>对应进入一个临界区。</li>
<li>过程：令牌环绕进程环依次传递，如果接受进程如果不需要进入临界区，则继续传递给下一个进程，如<br>果接受进程需要进入临界区，那么此时传递暂停，令牌等待，直到进程从临界区返回后继续。</li>
<li>缺点：令牌丢失的检测和再生因为无法确定时间间隔而非常困难；进程崩溃虽然可以恢复，但是需要通<br>过每个进程向前继进程发送确认消息来实现，也就需要每个进程都维护当前的配置信息。</li>
</ol>
</li>
<li><p>比较：</p>
<p><img src="/picture/image-20211227231113593.png" alt="image-20211227231113593"></p>
</li>
</ol>
<p><strong>分布式系统中的选举机制</strong></p>
<ol>
<li><p>bully算法：</p>
<ol>
<li><p>发起选举的条件，一是任何进程发现原有协调者崩溃时，可以发起选举；二是原来崩溃的进程P恢复以<br>后，可以重新发起选举，但是最后不一定会赢得选举，因为可能还有编号比P大的进程在P崩溃期间已经<br>开始运行。</p>
</li>
<li><p>选举过程：</p>
<ol>
<li>发起选举的进程Q只能向编号比自己大的进程发起election消息</li>
<li>如果Q一直没有接受到OK应答消息，则由Q获胜充当协调者，否则，退出选举</li>
</ol>
<p>因此最大的进程总是取胜，所以叫 bully(欺凌)算法</p>
</li>
<li><p>例子：</p>
<p><img src="/picture/image-20211227233130739.png" alt="image-20211227233130739"></p>
</li>
</ol>
</li>
<li><p>环算法：</p>
<ol>
<li><p>发起选举的条件：所有进程已经按照编号进行排序并且链接成环，任何一个或者多个进程发现原有协<br>调者崩溃或者没有响应时，开始发起选举。</p>
</li>
<li><p>选举过程：发起消息者构造election消息，依次向后传递。传递过程中如果后继进程已经崩溃，则绕<br>过（不仅仅是刚刚崩溃了的协调者），如果后继进程正在运行，则把编号添加进election消息成员列表。待绕环一周返回到发起者后，根据选举消息中的编号（选取成员列表里面最大的那个）选出协调者，并用coordinator消息绕环通知所有进程，循环一周后该消息被删除。</p>
</li>
<li><p>栗子：</p>
<p><img src="/picture/image-20211227233428655.png" alt="image-20211227233428655"></p>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="复制与一致性"><a href="#复制与一致性" class="headerlink" title="复制与一致性"></a>复制与一致性</h2><p><strong>复制的优势和不足</strong>（分布式系统多副本的优点和缺点）</p>
<ul>
<li>优点：<ul>
<li>可靠性：避免单点故障</li>
<li>性能：对服务器数量和地理区域上的扩展</li>
</ul>
</li>
<li>不足：<ul>
<li>复制透明性：某个用户不知道某个对象是复制的</li>
<li>一致性问题：更新过程开销大，可能影响系统可用性</li>
</ul>
</li>
</ul>
<hr>
<p>一致性模型实质上是进程和数据存储之间的一个约定，也就是如果进程同意遵守某些规则，那么数据存储将正常运行</p>
<p>PS：一致性模型的类型：</p>
<ul>
<li>面向数据一致性模型：本地数据存储的组织通常在分布在多个进程，并进行复制</li>
<li>面向客户的一致性模型：保证单个客户端访问数据存储的一致性</li>
</ul>
<p><strong>数据一致性模型</strong></p>
<p>参考了<a href="https://int64.me/2020/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0.html" target="_blank" rel="noopener">博客1</a>以及<a href="https://cloud.tencent.com/developer/article/1015442" target="_blank" rel="noopener">博客2</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/picture/image-20211228142648852.png" alt="image-20211228142648852" title="">
                </div>
                <div class="image-caption">image-20211228142648852</div>
            </figure>
<p><strong>不引入同步操作的一致性模型</strong></p>
<ul>
<li><p>严格一致性（Strict Consistency）：</p>
<p>所有共享访问事项的绝对时间顺序</p>
<ul>
<li>任何读操作返回与最新写操作结果对应的值</li>
<li>依赖绝对全局时间; 所有写入对所有进程都即时可见，并维护绝对全局时间顺序</li>
<li>分布式系统中无法实现</li>
</ul>
</li>
<li><p>线性一致性（Linearizability），又称为强一致性或者原子一致性：</p>
<p>所有进程都必须以相同的顺序查看所有共享访问。此外，访问根据（非唯一）全局时间戳排序;</p>
<p><strong>一旦某一个读操作返回了新值，之后所有的读（包括相同或不同的客户端）都必须返回新值</strong></p>
</li>
<li><p>顺序一致性(Sequential)：</p>
<p>所有进程都以相同的顺序查看所有共享访问。访问不是按时间排序；</p>
<ul>
<li>与线性一致性类似，对时间顺序无要求</li>
<li>从单个处理器 (线程或者进程)的角度来看，执行指令的顺序以编程中的顺序为准。</li>
<li>从所有的处理器(线程或者进程)的角度来看，指令的执行保持一个单一的顺序。</li>
</ul>
<p>与线性一致性比较的例子：</p>
<p><img src="/picture/image-20211228150820914.png" alt="image-20211228150820914"></p>
<p>因为a中可以找到一个执行序列： <code>Write(&quot;y&quot;, 1) -&gt; Read(&quot;x&quot; -&gt; 0) -&gt; Write(&quot;x&quot;, 1) -&gt; Read(&quot;y&quot; -&gt; 1)</code> 满足顺序一致性。但是从时间角度看<code>Write(&quot;x&quot;,1)</code> 要先于 <code>Read(&quot;x&quot;) -&gt; 0</code> 执行，但是 Read 却没有读取到最新值，所以不满足线性一致性。</p>
<p>b中都满足</p>
<p>c中找不到这样的执行序列，所以不满足顺序一致性；</p>
<p><strong>顺序一致性和线性一致性都是要找到一个满足 “写后读” 的一组操作历史，差异在于线性一致性要求严格的时间序，而顺序一致性只要求满足编程顺序</strong>。</p>
</li>
<li><p>因果一致性（Causal Consistency）</p>
<p>所有进程都以相同的顺序查看与因果相关的共享访问</p>
<ul>
<li>有因果关系的写操作，不同的进程看到相同的顺序</li>
<li>没有因果关系的写操作，不同的进程可以看到不同顺序</li>
</ul>
<p>来自这个<a href="https://zhuanlan.zhihu.com/p/71913226" target="_blank" rel="noopener">知乎</a>的例子:</p>
<p><img src="/picture/image-20211228153131011.png" alt="image-20211228153131011"></p>
<p><img src="/picture/image-20211228153136952.png" alt="image-20211228153136952"></p>
</li>
<li><p>管道一致性（FIFO Consistency/PRAM）</p>
<p>所有进程都按使用顺序看到彼此的写入；不同进程的写入可能并不总是按相同的顺序显示</p>
<ul>
<li>由同一个进程进行的写操作，必须看到相同的顺序</li>
<li>不同进程的写操作，不同进程可以看到不同顺序</li>
</ul>
<p>这个算是一种弱一致性</p>
</li>
</ul>
<hr>
<p><strong>引入同步操作的一致性模型</strong></p>
<ul>
<li><p>弱一致性（Weak Consistency）</p>
<p>只有在同步完成后，才能让共享数据保持一致</p>
<p>具体限制：</p>
<ul>
<li>对数据存储所关联的同步变量的访问是顺序一致的；说明了所有进程都以相同的顺序看到对同步变量进行的所有操作</li>
<li>每个拷贝完成所有先前执行的写操作之前，不允许对同步变量进行任何操作（说明了同步”清空管道”）</li>
<li>所有先前对同步变量执行的操作都执行完毕之前，不允许对数据项进行任何读或写操作（说明访问数据项时，无论读数据或写数据,所有先前的同步都已经完成。）</li>
</ul>
</li>
<li><p>释放一致性（Release Consistency）</p>
<p>退出关键区域时，共享数据保持一致</p>
<ul>
<li>获取操作：用于通知数据存储进程进入临界区的操作</li>
<li>释放操作︰表明进程刚刚离开临界区的操作</li>
</ul>
<p>具体限制：</p>
<ul>
<li>对共享数据执行读操作或写操作之前，所有进程先前执行的获取操作都必须已经成功完成</li>
<li>在释放操作被允许执行前，所有进程先前执行的读操作和写操作都必须已经完成</li>
<li>对同步变量的访问是FIFO一致的(不需要顺序一致)</li>
</ul>
</li>
<li><p>入口一致性：</p>
<p>进入共享数据对应临界区时，共享数据一致</p>
<ul>
<li>要求每个普通的共享数据项都要与某种同步变量关联</li>
<li>具体限制为<ul>
<li>在一个进程可以获取一个同步变量之前，所有的由此同步变量保护的共享数据的更新都必须已经相对于该进程执行完毕<ul>
<li>执行获取操作时，所有的受保护数据的远程改变都必须已经可见</li>
</ul>
</li>
<li>在一个进程对一个同步变量的独占访问被允许执行之前，其他的进程不可以拥有这个同步变量，甚至也不能以非独占的方式拥有这个同步变量<ul>
<li>更新共享数据项之前，必须以独占的方式进入临界区</li>
</ul>
</li>
<li>一个进程对一个同步变量执行独占访问之后，在对该同步变量的所有者进行检查之前，任何其他的进程都不能执行下一个非独占访问<ul>
<li>非独占方式进入临界区之前，必须检查保护这个临界区同步变量的所有者,以获得受保护的共享数据的最新副本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>以客户为中心的一致性模型</strong></p>
<ul>
<li><p>最终一致性</p>
<p>如果在一段相当长的时间内没有更新操作, 那么所有的副本将逐渐成为一致的</p>
</li>
<li><p>单调读：</p>
<p>如果一个进程数据项x 的值，那么该进程对x 执行的任何后续读操作将总是得到第一次读取的那个值或更新的值，保证之后不会看到x的更老的版本</p>
</li>
<li><p>单调写：</p>
<p>一个进程对数据项x 执行的写操作必须在该进程对x 执行任何后续写操作之前完成；写操作必须顺序完成，不能交叉</p>
</li>
<li><p>写后读 Read your writes（读写一致性）：</p>
<p>一个进程对数据项x 执行一次写操作的结果总是会被该进程对x执行的后续读操作看见；保证读取最新</p>
<p><img src="/picture/image-20211228163203615.png" alt="image-20211228163203615"></p>
</li>
<li><p>读后写 writes-follow-reads consistency （写读一致性）：</p>
<p>同一个进程对数据项x 执行的读操作之后的写操作，保证发生在与x 读取值相同或比之更新的值上；更新作为前一个读操作结果传播</p>
<p><img src="/picture/image-20211228163229625.png" alt="image-20211228163229625"></p>
</li>
</ul>
<hr>
<p><strong>数据一致性协议实例</strong></p>
<p><strong>基于法定数量的协议 Quorum-based protocols</strong></p>
<ul>
<li>对于一个具有 N 个副本的文件<ul>
<li>客户要读取时，必须组织一个服务器数量为 Nr 的读团体(read quorum)</li>
<li>客户要修改时，必须组织一个服务器数量为 Nw 的写团体(write quorum)</li>
</ul>
</li>
<li>其中，Nr 与 Nw 满足以下限制条件<ul>
<li>Nr+Nw&gt;N: 用于防止读写冲突</li>
<li>Nw&gt;N/2: 用于防止写写冲突</li>
</ul>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/picture/image-20211228171012230.png" alt="image-20211228171012230" title="">
                </div>
                <div class="image-caption">image-20211228171012230</div>
            </figure>
<hr>
<h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p><strong>可靠（Dependable System）的系统的特征</strong> </p>
<p>有群友总结为 ASMR</p>
<ul>
<li>可用性：在任意给定的时刻，系统都可以正确及时地工作，并执行用户的请求。 A</li>
<li>安全性：系统偶然出现故障时还能正确操作和执行。 S</li>
<li>可维护性：表示发生故障后系统能被恢复到可用性的难易程度 M</li>
<li>可靠性：系统可以无故障持续运行； R</li>
</ul>
<p>PS 基础定义：</p>
<p>error → fault → failure</p>
<ul>
<li>fault: 造成error 的原因</li>
<li>error：系统错误的状态，可能导致failure</li>
<li>failure：没有满足承诺，无法提供服务</li>
</ul>
<p>故障分类：</p>
<ul>
<li>Crash failure（服务器重启，重启正常）</li>
<li>Omission failure（遗漏错误）</li>
<li>Timing failure（超时）</li>
<li>Responsne failure</li>
<li>Byzantine faiure</li>
</ul>
<p><strong>提高系统可信性的途径</strong></p>
<ul>
<li>使用冗余来掩盖故障：<ul>
<li>信息冗余：添加额外的位或码恢复错乱的信息。</li>
<li>时间冗余：多次执行需要的动作。可以使用事务。适用于临时性或者间歇性的错误。</li>
<li>物理冗余：添加额外的装备（硬件）或者进程（软件）使系统整体容忍部分错误。</li>
</ul>
</li>
</ul>
<p><strong>K容错系统</strong></p>
<p>参考<a href="https://chenxfeng.github.io/2017/06/13/parellel_and_distributed_computing/distributed_compute6/" target="_blank" rel="noopener">博客</a></p>
<p>K容错：系统能够经受k个组件的故障并且还能满足规范要求。当这些组件是失败沉默的情况下，需要<br>k+1个组件可以提供k容错；如果发生拜占庭失败，至少需要2k+1个进程才能获得k容错。 课本P242页</p>
<p>怎么证明可以参考这个<a href="https://zhuanlan.zhihu.com/p/44198965" target="_blank" rel="noopener">知乎</a></p>
<p><strong>拜占庭问题</strong></p>
<p>在容错计算机系统中，经常需要部件之间的信息传递与分发，而一个失效的部件将会向其他部件发送错误的消息。容错计算机中失效部件向不同部件发送错误消息的问题，可被抽象为拜占庭将军问题：</p>
<p>算法流程：</p>
<ul>
<li>每个将军向其他n-1 个将军告知自己的兵力（真实或说谎）</li>
<li>每个将军将收到的消息组成一个长度为n 的向量</li>
<li>每个将军将自己的向量发送给其他n-1 个将军</li>
<li>每个将军检查每个接收到的向量中的第i 个元素，将其众数作为其结果向量的第i个元素</li>
</ul>
<p>例子：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/picture/image-20211228194256257.png" alt="image-20211228194256257" title="">
                </div>
                <div class="image-caption">image-20211228194256257</div>
            </figure>
<p><strong>系统恢复</strong></p>
<p>恢复：发生故障的进程能够恢复到正确的状态</p>
<ul>
<li><p>两种形式</p>
<ul>
<li>后向恢复：从当前错误状态回退到先前正确状态</li>
<li>前向恢复：尝试从某点继续执行，把系统带入一个正确的新状态</li>
</ul>
</li>
<li><p>检查点：系统定时记录状态到稳定存储</p>
<ul>
<li><p>每个进程独立地设置本地检查点，依赖项的记录方式使进程可以联合回滚到一致的全局状态</p>
</li>
<li><p>但每个进程回退的状态可能不一致，需要继续回退，可能造成多米诺效应</p>
<p><img src="/picture/image-20211228194433000.png" alt="image-20211228194433000"></p>
</li>
</ul>
</li>
<li><p>协调的检查点：</p>
<ul>
<li>所有进程同步地把各自状态写到本地稳定存储中</li>
</ul>
</li>
</ul>
<hr>
<p><strong>PS 两阶段提交</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/picture/image-20211229105045012.png" alt="二阶段提交" title="">
                </div>
                <div class="image-caption">二阶段提交</div>
            </figure>
<p>为什么两阶段提交叫做阻塞提交协议？</p>
<p>当所有参与者都从协作者那里接收到信息变成READY状态的时候，并且同时协作者崩溃的时候就会发生阻塞</p>
<hr>
<h2 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h2><p>Paxos协议</p>
<p>参考的<a href="https://zhuanlan.zhihu.com/p/29706905" target="_blank" rel="noopener">知乎</a></p>
<p>Paxos 保证了：安全性 和 最终一致性（Eventual liveness）：</p>
<ul>
<li>安全性：只有被提议的值才可能会被选择，只有一个值会被选择，只有最终被选择的值才会被进程所保存。</li>
<li>Eventual liveness, 如果系统正常运行下去，在未来的某一个点，最终会达成共识。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="picture/image-20211229104843788.png" alt="通信实例" title="">
                </div>
                <div class="image-caption">通信实例</div>
            </figure>
<p>Raft协议</p>
<ul>
<li>用户选举</li>
<li>Log Replication</li>
</ul>
<p>Gossip协议</p>
<p>需要O(logN)轮才能把信息传播到所有节点，push SI总共传播的信息数量O(NlogN);Pulland push-pull SI 需要传播的信息数量O(NloglogN)</p>
<p><strong>大数据处理系统</strong></p>
<p>对于DAG型作业Spark+Yarn的优势在哪里？</p>
<ul>
<li>DAG型的每个中间结果hadoop会有频繁的磁盘IO，spark用分布式弹性数据集把中间结果存在内存中，避免了DAG中间结构的频繁IO</li>
<li>hadoop+hdfs的集群，集群需要同时进行资源管理和任务控制，耦合度高。Yarn只负责资源管理，将任务控制交给应用去设计，耦合度低。虽然Yarn应用的逻辑变复杂了，但可以支持更多的编程模型和设备。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th></th>
<th>容错</th>
<th>拜占庭协定</th>
</tr>
</thead>
<tbody>
<tr>
<td>沉默错</td>
<td>k+1</td>
<td>2k+1</td>
</tr>
<tr>
<td>拜占庭错</td>
<td>2k+1</td>
<td>3k+1</td>
</tr>
</tbody>
</table>
<p>(所有挂k个，表格里面是总量)</p>
<hr>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2021-12-29T03:00:35.720Z" itemprop="dateUpdated">2021-12-29 11:00:35</time>
</span><br>


        
        Link：<a href="/2021/12/26/distributed-system/" target="_blank" rel="external">http://tyler-ytr.github.io/2021/12/26/distributed-system/</a>
        
    </div>
    
    <footer>
        <a href="http://Tyler-ytr.github.io">
            <img src="/img/Tyler.png" alt="Tyler-yin">
            Tyler-yin
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag">分布式系统</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2021/12/26/distributed-system/&title=《分布式系统》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2021/12/26/distributed-system/&title=《分布式系统》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2021/12/26/distributed-system/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《分布式系统》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2021/12/26/distributed-system/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2021/12/26/distributed-system/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/12/25/pdf-trick/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">PDF技巧记录</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "NoLhoWnmbSW89zV4zc04RPwx-gzGzoHsz",
            appKey: "SSdRGaHcdjoKc7cJJpOlJIqJ",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Tyler-yin &copy; 2015 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2021/12/26/distributed-system/&title=《分布式系统》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2021/12/26/distributed-system/&title=《分布式系统》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2021/12/26/distributed-system/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《分布式系统》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2021/12/26/distributed-system/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2021/12/26/distributed-system/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKklEQVR42u3aS3KDQAwFQN//0s4BEsh7GhIXQ7Ny2XymWcgaSa9XfLy/HUe/Hp3//arzp7z+4sDAwLgt4316JOecX5U/q30uBgbG0xhHEez8nPP7rCw0XxsGBgZG8jlZxBFy9vowMDAw8kXkj0wYH/jfwMDAuBWjDZ1J6S3ZfH5gL46BgXFDRl51///Pf9LfwMDAuBVjVu5v25x52B2uCgMDY2tGW/S/ast6/mqGYxkYGBibMpJguhJAlzac+aAYBgbGAxjXti3bQt6sSfBDwMXAwNiUkd/oPOy2V802w8N+LAYGxs0ZuXVlhCsPoPkIyC//GxgYGBsxZsnZrMQ/27LWm2EMDIztGG3Ct/7O8mZAsrbDxgAGBsZGjKuidVsUS5LCutyGgYGxKSMvja2Mi83ARVsUAwNja0Yb/hLeyrDFyqAYBgbGExjXlvXblmQe9IsMFwMDYwvG+k2TlLH9tW4qYGBgPIDRBtyV5sHK+YffY2BgbM2YFbaSJG+9AFcPcGBgYDyM0ZbV2oGM/J4FGwMD42GMduPatirzDXOejGJgYDyN0SZns9C80uYsUkMMDIybM97lMWtJtstq01AMDIy9GW1RrG15zkbEhjMjGBgYWzPyILtS7p8lf3kTFAMD4wmMNvBdG3zXkRgYGBjJyEU72lUU/RMqBgYGRjAAkSxoNnCWJK8YGBhPYMyaAW0gXkdeUG7DwMC4IaMtnyWA2ZjXrJCHgYGxNeMLjy9Bz+Pr+PoAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '＞﹏＜';
            clearTimeout(titleTime);
        } else {
            document.title = '~\(≧▽≦)/~';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


</body>
</html>
