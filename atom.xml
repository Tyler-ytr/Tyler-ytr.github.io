<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tyler-yin&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/9cf7a8e81293a5a77561848afbba692b</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Tyler-ytr.github.io/"/>
  <updated>2020-08-31T13:13:23.891Z</updated>
  <id>http://Tyler-ytr.github.io/</id>
  
  <author>
    <name>Tyler-yin</name>
    <email>ytrpossible@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode96_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/</id>
    <published>2020-08-31T13:10:02.000Z</published>
    <updated>2020-08-31T13:13:23.891Z</updated>
    
    <content type="html"><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>难度中等537</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:i个结点的时候二叉搜索树的个数</span></span><br><span class="line">        <span class="comment">//空树只有一种情况:dp[0]=1</span></span><br><span class="line">        <span class="comment">//dp[1]=1</span></span><br><span class="line">        <span class="comment">//dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-bin
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode64_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/</id>
    <published>2020-08-31T13:09:13.000Z</published>
    <updated>2020-08-31T13:09:41.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>难度中等486</p><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]:到i,j 的最小路径和;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(grid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m=dp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n=dp[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/</id>
    <published>2020-08-31T13:04:05.000Z</published>
    <updated>2020-08-31T13:07:52.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>难度中等560</p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/robot_maze.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#x2F;&#x2F;dp[0][0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;dp[0][1]&#x3D;1&#39;</span><br><span class="line">        &#x2F;&#x2F;dp[1][0]&#x3D;1;</span><br><span class="line">        if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt;tmp(m,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n,tmp);</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            dp[0][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][0]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;m;j++)&#123;</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode53_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/</id>
    <published>2020-08-31T13:03:25.000Z</published>
    <updated>2020-08-31T13:03:46.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><p>水题:</p><p>dp[i]表示第i个之前的连续子数组的最大和</p><p>dp[i]=max(dp[i],dp[i-1]+dp[i]) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnum;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums)</span></span>;</span><br><span class="line">        maxnum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;53-最大子序和&quot;&gt;&lt;a href=&quot;#53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. 最大子序和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode32_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/</id>
    <published>2020-08-31T13:01:40.000Z</published>
    <updated>2020-08-31T13:02:23.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><p>难度困难784</p><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>通过次数74,856</p><p>提交次数233,569</p><p>题解见注释:主要是要两两字符判断;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度;</span></span><br><span class="line">        <span class="comment">//对于...............():</span></span><br><span class="line">        <span class="comment">//dp[i]=dp[i-2]+2;</span></span><br><span class="line">        <span class="comment">//对于...............)):</span></span><br><span class="line">        <span class="comment">//dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) </span></span><br><span class="line">        <span class="comment">//判断s[i-dp[i-1]-1],如果是(:</span></span><br><span class="line">        <span class="comment">//dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.length();;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i]=<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                        dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>+dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]; </span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;32-最长有效括号&quot;&gt;&lt;a href=&quot;#32-最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32. 最长有效括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-pa
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/</id>
    <published>2020-08-31T13:00:48.000Z</published>
    <updated>2020-08-31T13:01:10.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>难度中等</p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><p>这题目可以使用动态规划</p><p>我觉得很棒的一个<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> len=s.length();</span><br><span class="line">       <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[j][i]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][i]=dp[j+<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=i-j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;maxl)&#123;</span><br><span class="line">                        maxl=temp;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5. 最长回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HDU_1284</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU-1284/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU-1284/</id>
    <published>2020-08-31T12:58:32.000Z</published>
    <updated>2020-08-31T12:59:37.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 15976  Accepted Submission(s): 9546<br>**</strong></p><p>Problem Description</p><p>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。</p><p>Input</p><p>每行只有一个正整数N，N小于32768。</p><p>Output</p><p>对应每个输入，输出兑换方法数。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2934</span><br><span class="line">12553</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">718831</span><br><span class="line">13137761</span><br></pre></td></tr></table></figure><p>Author</p><p>SmallBeer(CML)</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%BA%BC%B5%E7ACM%BC%AF%D1%B5%B6%D3%D1%B5%C1%B7%C8%FC%A3%A8VII%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">杭电ACM集训队训练赛（VII）</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//相当于3件物品，容量为N的背包，第i件物品的重量是i</span></span><br><span class="line"><span class="comment">//初始化: dp[0][0]=1</span></span><br><span class="line"><span class="comment">//dp[i][j]表示用前i件物品组成j的方案数量</span></span><br><span class="line"><span class="comment">//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;</span></span><br><span class="line"><span class="comment">//滚动数组优化：</span></span><br><span class="line"><span class="comment">//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">33000</span>;<span class="comment">//32468</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;maxn;j++)&#123;</span><br><span class="line">            dp[j]+=dp[j-i];</span><br><span class="line">          <span class="comment">//  printf("%lld\n",dp[j]);</span></span><br><span class="line">           <span class="comment">// dp[j]+=max(dp[j],dp[j-i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf("here");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    scanf("%d",&amp;temp);</span></span><br><span class="line"><span class="comment">//        printf("%lld",dp[temp]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,dp[temp]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;钱币兑换问题&quot;&gt;&lt;a href=&quot;#钱币兑换问题&quot; class=&quot;headerlink&quot; title=&quot;钱币兑换问题&quot;&gt;&lt;/a&gt;钱币兑换问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Time Limit: 2000/1000 MS (Java/Other
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode19_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/</id>
    <published>2020-08-31T03:12:38.000Z</published>
    <updated>2020-08-31T12:50:14.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h4><p>难度中等947收藏分享切换为英文关注反馈</p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗</p><p>快慢指针的想法来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* l;</span><br><span class="line">        ListNode*r;</span><br><span class="line">        l=head;</span><br><span class="line">        r=head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(cnt=<span class="number">0</span>;cnt&lt;n;cnt++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;r-&gt;val&lt;&lt;endl;      </span></span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;l-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        l-&gt;next=l-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;19-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode16_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/</id>
    <published>2020-08-31T03:11:14.000Z</published>
    <updated>2020-08-31T12:50:07.255Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><p>难度中等530</p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p>通过次数141,122</p><p>提交次数308,415</p><p>和leetcode15相似,主要思路还是排序+双指针</p><p>我使用了minA维护了当前的最小值,然后使用res记录和;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#排序: -4 -1 1 2</span></span><br><span class="line">        <span class="comment">#minA 对于遍历到的每一个i,维护minA;</span></span><br><span class="line">        <span class="comment">#每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回;</span></span><br><span class="line"></span><br><span class="line">        n=len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> NULL</span><br><span class="line">        minA=sys.maxsize <span class="comment"># INT最大值</span></span><br><span class="line">        res=minA</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-2</span>):</span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                cur=nums[i]+nums[L]+nums[R]</span><br><span class="line">                <span class="keyword">if</span> cur==target:</span><br><span class="line">                    minA=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> cur</span><br><span class="line">                <span class="keyword">elif</span> cur&lt;target:</span><br><span class="line">                    tempres=target-cur</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tempres=cur-target</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur        </span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-close
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode15_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/</id>
    <published>2020-08-31T03:06:50.000Z</published>
    <updated>2020-08-31T12:50:01.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>难度中等2455</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数293,697</p><p>提交次数1,016,765</p><p>还是看了题解,排序太香了！</p><p>主要操作是排序使用双指针进行检查;同时记得去重;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#从i遍历到n-2,使用双指针维护和探查;</span></span><br><span class="line">        <span class="comment">#记得去重,也就是对于相同的找最后的;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#去重</span></span><br><span class="line">            </span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="number">0</span>):</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]):</span><br><span class="line">                        L=L+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L&lt; R <span class="keyword">and</span> nums[R]==nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R=R<span class="number">-1</span></span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R]&lt;<span class="number">0</span>:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      咸鱼leetcode刷题ing
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>cmd_vs_rsa</title>
    <link href="http://Tyler-ytr.github.io/2020/08/10/cmd_vs_rsa/"/>
    <id>http://Tyler-ytr.github.io/2020/08/10/cmd_vs_rsa/</id>
    <published>2020-08-10T12:30:55.848Z</published>
    <updated>2020-08-10T12:31:48.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于windows密钥登录服务器"><a href="#关于windows密钥登录服务器" class="headerlink" title="关于windows密钥登录服务器"></a>关于windows密钥登录服务器</h2><p>前言:windows的权限管理太屑了</p><p>参考<a href="https://blog.csdn.net/joshua2011/article/details/90208741" target="_blank" rel="noopener">https://blog.csdn.net/joshua2011/article/details/90208741</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于windows密钥登录服务器&quot;&gt;&lt;a href=&quot;#关于windows密钥登录服务器&quot; class=&quot;headerlink&quot; title=&quot;关于windows密钥登录服务器&quot;&gt;&lt;/a&gt;关于windows密钥登录服务器&lt;/h2&gt;&lt;p&gt;前言:windows的权限管
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Winter plan</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/</id>
    <published>2020-01-22T09:17:23.000Z</published>
    <updated>2020-01-22T09:23:27.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>需要完成的目标:</p><ul><li>线性代数复习</li><li>学习cs224n</li><li>刷leetcode</li><li>算法竞赛入门经典</li></ul></li><li><p>目前进度:</p><ul><li>线性代数: <ul><li>1.22 </li></ul></li><li>cs224n<ul><li>1.22 </li></ul></li><li>leetcode<ul><li>1.22 </li></ul></li><li>算法竞赛入门经典</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要完成的目标:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性代数复习&lt;/li&gt;
&lt;li&gt;学习cs224n&lt;/li&gt;
&lt;li&gt;刷leetcode&lt;/li&gt;
&lt;li&gt;算法竞赛入门经典&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前进度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线
      
    
    </summary>
    
      <category term="个人计划" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="flag" scheme="http://Tyler-ytr.github.io/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu教程</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/</id>
    <published>2020-01-22T08:28:15.000Z</published>
    <updated>2020-01-24T07:42:44.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;</li><li>重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜</li></ul><h2 id="复活操作"><a href="#复活操作" class="headerlink" title="复活操作"></a>复活操作</h2><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><ul><li>管理员权限,换源,安装vim  <pre><code>  sudo passwd(修改sudo密码)  sudo apt-get update  sudo apt-get install vim  </code></pre></li><li>更换国内源,这里我选择的是<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华源</a>用下面的命令打开文件,并且注释里面的所有内容,<br> <pre><code> sudo vim /etc/apt/sources.list<br></code></pre> <ul><li>然后粘贴下面的内容到打开的文件里面<br><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br></code></pre><br>如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下;</li></ul></li><li>安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇<a href="https://blog.csdn.net/qq_33159059/article/details/85019467" target="_blank" rel="noopener">博客</a></li><li>然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义<pre><code>suapt-get install build-essentialapt-get install man                # on-line reference manualapt-get install gcc-doc            # manual for GCCapt-get install gdb                # GNU debuggerapt-get install git                # reversion control systemapt-get install libreadline-dev    # a library to use compile the project laterapt-get install libsdl2-dev        # a library to use compile the project laterapt-get install qemu-system-x86    # QEMU</code></pre></li><li>安装chrome:请使用bing搜索;用gmail同步很香;</li></ul><h4 id="科学的看世界"><a href="#科学的看世界" class="headerlink" title="科学的看世界"></a>科学的看世界</h4><ul><li>我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) <pre><code> mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json </code></pre></li><li>将下面的内容根据自己的配置放进去:<pre><code>{  "server":"my_server_ip",  "server_port":53450,  "local_address": "127.0.0.1",  "local_port":1080,  "password":"密码",  "timeout":300,  "method":"aes-256-gcm",  "fast_open": false}</code></pre></li><li>然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;<br>自己测试一下有没有问题;</li><li>感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)：<ul><li>先写一个自启动脚本：<pre><code> touch ~/.ssstart.shvim ~/.ssstart.sh</code></pre>内容是:<pre><code>#!/bin/bashss-local -c ~/shadowsocks/shadowsocks.json </code></pre></li><li>然后在终端里面起别名:<br><pre><code>vim ~/.bashrc<br>在末尾添加:<br>alias ss=’. ~/.ssstart.sh’<br>:wq 保存,退出<br>在终端里面:<br>source ~/.bashrc<br>(如果是zsh:source ~/.zshrc)<br></code></pre><br>尝试一下在终端输入ss,它lei了;</li></ul></li><li><p>因为后面的netdata需要<strong>终端</strong>翻墙,我也就尝试了一下,如果没有需求可以跳过这一步:</p><ul><li>主要参考的是谷歌出来的<a href="http://www.totorocyx.me/2018/10/02/ubuntu_shadowsocks/" target="_blank" rel="noopener">网站</a></li><li>首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装</li><li><p>下面尝试全局代理(我也不确定能不能成功)：</p><ul><li>sudo pip install genpac</li><li>选择安装配置文件的目录,我选择的是:<pre><code>/home/larryytr/shadowsocks</code></pre></li><li>然后执行以下命令:<pre><code>sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a></code></pre></li><li>下面是一句搬运,我没有遇到过:<pre><code>注意：如果报错“fetch gfwlist fail.online: <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a><br></pre></code></li><li>执行完之后,目录下面会有一个autoproxy.pac文件。</li><li><p>然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写：</p><pre><code>file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改)</code></pre></li></ul></li><li><p>然后使得终端也能使用代理。我们需要<strong>privoxy</strong>代理工具:</p><ul><li><p>安装很自然:sudo apt-get install privoxy</p></li><li><p>然后编辑配置文件<pre><code>sudo vim /etc/privoxy/config </pre></code></p></li><li><p>在文档中搜索(vim 使用/搜索)“<strong>listen-address</strong>”（即监听地址），找到如下一行：<strong>listen-address localhost:8118</strong> 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“<strong>forward-socks5t</strong>”，找到如下一行：<strong>forward-socks5t / 127.0.0.1:1080</strong> . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure></li><li><p>最后，再配置/etc/profile：<pre><code></p><pre><code># 先进入编辑模式</code></pre><p>sudo vim /etc/profile</p><pre><code># 在末尾添加以下三行：</code></pre><p>export http_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export https_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export ftp_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a></p><pre><code># 退出之后记得执行source /etc/profile</code></pre><p></code></pre></p></li><li><p>验证是否成功:curl <a href="http://www.google.com或wget" target="_blank" rel="noopener">www.google.com或wget</a> <a href="http://www.google.com判断是否可以访问" target="_blank" rel="noopener">www.google.com判断是否可以访问</a></p></li><li><p>HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！</p></li></ul></li></ul></li></ul><h4 id="优化美化"><a href="#优化美化" class="headerlink" title="优化美化"></a>优化美化</h4><ul><li>官网安装网易云</li><li>官网安装vscode</li><li>配置zsh,tmux,vim:</li></ul><h5 id="zsh安装与美化"><a href="#zsh安装与美化" class="headerlink" title="zsh安装与美化"></a>zsh安装与美化</h5><ul><li>学习了:<a href="https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/" target="_blank" rel="noopener">https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/</a><br><a href="https://segmentfault.com/a/1190000013612471这两篇教程" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013612471这两篇教程</a>;</li><li>感谢何伟的配置文件;</li><li>相应的setting请参考我的github<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>.</li><li>安装zsh:<pre><code>sudo apt-get updatesudo apt-get install zshchsh -s /bin/zsh (设置zsh为默认)</code></pre></li><li>重启你的ubuntu</li><li>安装oh-my-zsh插件:<pre><code> wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre></li><li>不改theme一无所有</li><li>准备使用powerline主题  </li><li>首先安装powerline字体：<pre><code>git clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts</code></pre></li><li>安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久)</li><li>安装powerline: sudo apt install powerline </li><li>我的配置见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting .zshrc</li><li>颜色选择困难请: <pre><code>for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f”</code></pre></li><li>改完请source ~/.zshrc</li></ul><h5 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h5><ul><li>tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程;</li><li>我使用了何伟的配置,具体见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting</li><li>我又加了一个插件使得tmux在重启之后状态可以恢复:<ul><li>主要参考这个<a href="https://zhuanlan.zhihu.com/p/24660412" target="_blank" rel="noopener">知乎教程</a></li><li><pre><code>git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp</code></pre></li><li>在~/.tmux.conf.local里面加上:<pre><code>run-shell ~/tmux_tmp/resurrect.tmux</code></pre></li><li>最后载入这个配置：<pre><code>tmux source-file ~/.tmux.conf<br></code></pre></li></ul></li></ul><h5 id="vim的美化"><a href="#vim的美化" class="headerlink" title="vim的美化"></a>vim的美化</h5><ul><li>使用啦懒人vim: spf13-vim美化</li><li>请看<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh</li><li>我的配置同样在<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting里面;</li><li>这个时候的vim没有办法和系统剪切版交互,我根据<a href="https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html" target="_blank" rel="noopener">https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html</a> 下载了其他一些插件:<br><pre><code>sudo apt-get install vim-scripts vim-gtk vim-gnome</pre></code><br>这样 vim –version|grep “cliboard” 会看到 +clipboard;<br>然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！</li></ul><h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容:"></a>其他内容:</h4><ul><li>OSlab还需要:<ul><li>sudo apt-get install curl</li><li>sudo apt-get install gcc-multilib</li></ul></li><li>git 配置请搜索廖雪峰</li><li>ctags 可以参考Mengzelev的<a href="https://mengzelev.github.io/2018/10/04/pa-inspirations/" target="_blank" rel="noopener">博客</a></li><li>感谢xnr给我推荐的network来查看linux的运行情况<ul><li>这是netdata的官方网站:<a href="https://github.com/netdata/netdata#user-base" target="_blank" rel="noopener">https://github.com/netdata/netdata#user-base</a></li><li>但是由于GFW,安装会出现报错,事实上需要终端翻墙才行</li><li>可以通过这篇<a href="https://blog.csdn.net/zhangvalue/article/details/80270169" target="_blank" rel="noopener">教程</a><br><pre><code> sudo apt-get install net-tools<br>  ifconfig<br></code></pre><br>查看inet 之后的内容来得知自己的server_ip</li><li>成功之后,进入 <a href="http://127.0.0.1:19999/" target="_blank" rel="noopener">http://127.0.0.1:19999/</a> (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验</li><li>相应配置可以参考这篇<a href="https://cloud.tencent.com/developer/article/1181577" target="_blank" rel="noopener">博客</a>或者自己搜索</li></ul></li><li>OSlab的kvm bug处理方法：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1479558" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=1479558</a><pre><code>chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content:KERNEL=="kvm", GROUP="kvm", MODE="0666"</code></pre></li><li>texlive 安装<pre><code>sudo apt install texlive-full</code></pre>相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting)vscode的保存即编译请<pre><code>Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾；</code></pre></li><li>ubuntu的截图:我参考了这篇<a href="https://blog.csdn.net/qq_17448289/article/details/56480805" target="_blank" rel="noopener">博客</a><ul><li>打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+</li><li>显然的配置好按键,然后在命令里面写<pre><code>gnome-screenshot -a</code></pre></li><li>hint:上面的命令终端输入也有效<br>截屏的图在文件夹的图片(picture)里面;</li></ul></li></ul><h4 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h4><ul><li>有空再研究怎么换主题;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;&lt;/li&gt;
&lt;li&gt;重装很多次的原因是因为
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Tyler-ytr.github.io/2020/01/21/hello-world/"/>
    <id>http://Tyler-ytr.github.io/2020/01/21/hello-world/</id>
    <published>2020-01-20T19:20:25.723Z</published>
    <updated>2020-01-20T19:20:25.723Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
