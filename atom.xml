<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tyler-yin&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/9cf7a8e81293a5a77561848afbba692b</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Tyler-ytr.github.io/"/>
  <updated>2021-07-02T07:48:14.552Z</updated>
  <id>http://Tyler-ytr.github.io/</id>
  
  <author>
    <name>Tyler-yin</name>
    <email>ytrpossible@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git以及ssh代理的配置</title>
    <link href="http://Tyler-ytr.github.io/2021/07/02/git%E4%BB%A5%E5%8F%8Assh%E4%BB%A3%E7%90%86%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://Tyler-ytr.github.io/2021/07/02/git以及ssh代理的配置/</id>
    <published>2021-07-02T07:43:45.000Z</published>
    <updated>2021-07-02T07:48:14.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git以及ssh代理的配置"><a href="#git以及ssh代理的配置" class="headerlink" title="git以及ssh代理的配置"></a>git以及ssh代理的配置</h2><p>鄢老师提供的方案并根据自己的情况进行了调整；</p><h4 id="修改ssh的config文件"><a href="#修改ssh的config文件" class="headerlink" title="修改ssh的config文件"></a>修改ssh的config文件</h4><p>文件位置在<code>C:\Users\用户名\.ssh</code></p><p>目前的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    ProxyCommand connect -H 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure><h4 id="修改gitconfig文件"><a href="#修改gitconfig文件" class="headerlink" title="修改gitconfig文件"></a>修改gitconfig文件</h4><p>文件位置在<code>C:\Users\用户名\.gitconfig</code>里面;</p><p>目前的版本:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email &#x3D; 邮箱</span><br><span class="line">name &#x3D; 名字</span><br><span class="line">[core]</span><br><span class="line">autocrlf&#x3D;input</span><br><span class="line">[socks]</span><br><span class="line">proxy&#x3D;127.0.0.1:7890</span><br><span class="line">[http &quot;http:&#x2F;&#x2F;github.com&quot;]</span><br><span class="line">proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890</span><br><span class="line">[filter &quot;lfs&quot;]</span><br><span class="line">clean&#x3D;git-lfs clean -- %f</span><br><span class="line">smudge&#x3D;git-lfs smudge -- %f</span><br><span class="line">process&#x3D;git-lfs filter-process</span><br><span class="line">required&#x3D;true</span><br></pre></td></tr></table></figure><p>如果改了代理的客户端请修改端口7890即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git以及ssh代理的配置&quot;&gt;&lt;a href=&quot;#git以及ssh代理的配置&quot; class=&quot;headerlink&quot; title=&quot;git以及ssh代理的配置&quot;&gt;&lt;/a&gt;git以及ssh代理的配置&lt;/h2&gt;&lt;p&gt;鄢老师提供的方案并根据自己的情况进行了调整；&lt;/p&gt;
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>学校服务器访问外网的配置</title>
    <link href="http://Tyler-ytr.github.io/2021/07/02/%E5%AD%A6%E6%A0%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://Tyler-ytr.github.io/2021/07/02/学校服务器访问外网的配置/</id>
    <published>2021-07-02T07:37:05.000Z</published>
    <updated>2021-07-02T07:38:25.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问外网的配置"><a href="#访问外网的配置" class="headerlink" title="访问外网的配置"></a>访问外网的配置</h1><p>服务器1命令行中使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setproxy</span><br></pre></td></tr></table></figure><p>就可以通过代理服务器1的服务器1的端口访问外网。</p><h3 id="NAT的方法-目前不用，仅作参考"><a href="#NAT的方法-目前不用，仅作参考" class="headerlink" title="NAT的方法(目前不用，仅作参考)"></a>NAT的方法(目前不用，仅作参考)</h3><p>服务器1可以上外网；服务器2不能上外网，但是在内网与服务器1互通；下面的操作是用iptables在服务器1上对服务器2搭建一个NAT; 并且修改服务器2的默认路由，达到服务器2访问外网的目的；</p><h4 id="服务器1"><a href="#服务器1" class="headerlink" title="服务器1"></a>服务器1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 服务器2 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>查看iptables：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -L</span><br></pre></td></tr></table></figure><p>带检索的查看iptables:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -L POSTROUTING --line-numbers</span><br></pre></td></tr></table></figure><p>删除刚刚操作之后的表项:(请根据查询的编号决定是不是1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -D POSTROUTING 1</span><br></pre></td></tr></table></figure><h4 id="服务器2"><a href="#服务器2" class="headerlink" title="服务器2"></a>服务器2</h4><p>查看路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>增加默认路由:(这个操作可能会让ssh连接断掉)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add default gw 服务器1</span><br></pre></td></tr></table></figure><p>删除路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route del default gw 服务器1</span><br></pre></td></tr></table></figure><h4 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程:"></a>具体实现流程:</h4><p>A表示服务器1；B表示服务器2</p><p>首先用在A上iptables -t nat -A POSTROUTING -s B的地址 -j MASQUERADE；然后SSH连接B；B上用sudo route add default gw A的地址；此时SSH 会连接B失败；然后从A上用SSH连接B；此时连接的B可以通过A的NAT访问外网然后安装v2ray;然后删除路由;退出之后在A上删除刚刚的iptables表项</p><p>iptables那步的作用是搭建了A对于B开启了nat服务;B通过修改路由把数据包转发到A上，进而访问外网;</p><p>上面的方法也是一种上网方法；只不过不是很方便</p><p>配置完之后通过v2ray访问外网;</p><h4 id="实现流程的反思"><a href="#实现流程的反思" class="headerlink" title="实现流程的反思"></a>实现流程的反思</h4><p>实际上可能不需要那么复杂。在能出外网的服务器1上面安装v2ray，更改配置文件保证http,socks5的代理就行了；不能连接外网的服务器通过export ALL_PROXY=socks5://服务器1的地址:端口;就可以出去了</p><h3 id="v2ray（目前使用）"><a href="#v2ray（目前使用）" class="headerlink" title="v2ray（目前使用）"></a>v2ray（目前使用）</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>通过来自<a href="https://github.com/v2fly/fhs-install-v2ray的脚本安装" target="_blank" rel="noopener">https://github.com/v2fly/fhs-install-v2ray的脚本安装</a>;</p><p><strong>v2ray启用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable v2ray</span><br></pre></td></tr></table></figure><p><strong>v2ray打开:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start v2ray</span><br></pre></td></tr></table></figure><p><strong>v2ray关闭:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop v2ray</span><br></pre></td></tr></table></figure><p>每次修改完配置文件之后需要重启</p><h4 id="服务器1-1"><a href="#服务器1-1" class="headerlink" title="服务器1"></a>服务器1</h4><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;log&quot;: &#123;</span><br><span class="line">&quot;access&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;access.log&quot;,</span><br><span class="line">&quot;error&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;error.log&quot;,</span><br><span class="line">&quot;loglevel&quot;: &quot;warning&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">&quot;inbounds&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">      &quot;port&quot;: 端口号,</span><br><span class="line">      &quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      &quot;port&quot;: 端口号,</span><br><span class="line">      &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;outbounds&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">&quot;settings&quot;: &#123;&#125;,</span><br><span class="line">&quot;tag&quot;: &quot;direct&quot;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;routing&quot;: &#123;</span><br><span class="line">    &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;,</span><br><span class="line">    &quot;rules&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">        &quot;outboundTag&quot;: &quot;direct&quot;,</span><br><span class="line">        &quot;domain&quot;: [&quot;geosite:cn&quot;] </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">        &quot;outboundTag&quot;: &quot;direct&quot;,</span><br><span class="line">        &quot;ip&quot;: [</span><br><span class="line">          &quot;geoip:cn&quot;, </span><br><span class="line">          &quot;geoip:private&quot; </span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置文件实现了socks5和http的代理;</p><h4 id="服务器2-1"><a href="#服务器2-1" class="headerlink" title="服务器2"></a>服务器2</h4><p>我在.bashrc里面最后添加了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias setproxy&#x3D;&quot;export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;服务器1:端口号;echo &#39;You can use &#39;unset ALL_PROXY&#39; to unset it &#39;&quot;</span><br></pre></td></tr></table></figure><p>使用setproxy即可通过服务器1访问外网;通过unset ALL_PROXY来修改回默认设置;</p><p>于此同时该服务器也安装了v2ray；有需求的同学可以自行配置;</p><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget www.baidu.com</span><br></pre></td></tr></table></figure><p>来进行连通性的测试;（不知道什么原因ping不通baidu）</p><h4 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h4><p><a href="https://www.v2ray.com/" target="_blank" rel="noopener">https://www.v2ray.com/</a></p><p><a href="https://segmentfault.com/a/1190000039686752" target="_blank" rel="noopener">https://segmentfault.com/a/1190000039686752</a></p><p><a href="https://blog.csdn.net/yelllowcong/article/details/75949296" target="_blank" rel="noopener">https://blog.csdn.net/yelllowcong/article/details/75949296</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;访问外网的配置&quot;&gt;&lt;a href=&quot;#访问外网的配置&quot; class=&quot;headerlink&quot; title=&quot;访问外网的配置&quot;&gt;&lt;/a&gt;访问外网的配置&lt;/h1&gt;&lt;p&gt;服务器1命令行中使用:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-6:实现网络测量</title>
    <link href="http://Tyler-ytr.github.io/2021/04/20/p4%E5%AD%A6%E4%B9%A0-6/"/>
    <id>http://Tyler-ytr.github.io/2021/04/20/p4学习-6/</id>
    <published>2021-04-20T04:16:42.000Z</published>
    <updated>2021-04-27T16:17:31.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="p4学习-6-实现网络测量"><a href="#p4学习-6-实现网络测量" class="headerlink" title="p4学习-6:实现网络测量"></a>p4学习-6:实现网络测量</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><p>这个练习的目标是写一个P4程序允许一个主机区检测网络中所有链路的利用情况。这个练习是在基础的<a href="https://tyler-ytr.github.io/2021/02/21/p4%E5%AD%A6%E4%B9%A0-2/">IPV4 forwarding</a>练习上搭建的。具体来说，我们将修改基本的P4程序，以处理源路由探测包，使其能够在每一跳提取出口链路利用率，并将其交付给主机进行监控。</p><p>探测包由下面三种header types组成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe</span><br><span class="line">&#x2F;&#x2F; packet has traversed so far.</span><br><span class="line">&#x2F;&#x2F;顶层的探测header,指出这个探测包经过了多少跳</span><br><span class="line">header probe_t &#123;</span><br><span class="line">    bit&lt;8&gt; hop_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The data added to the probe by each switch at each hop.</span><br><span class="line">&#x2F;&#x2F;每一个交换机加到探测包上面的数据</span><br><span class="line">header probe_data_t &#123;</span><br><span class="line">    bit&lt;1&gt;    bos;&#x2F;&#x2F;bottom of stack</span><br><span class="line">    bit&lt;7&gt;    swid;&#x2F;&#x2F;switch ID</span><br><span class="line">    bit&lt;8&gt;    port;</span><br><span class="line">    bit&lt;32&gt;   byte_cnt;&#x2F;&#x2F;和下面的寄存器应该对应</span><br><span class="line">    time_t    last_time;&#x2F;&#x2F;和下面的寄存器应该对应</span><br><span class="line">    time_t    cur_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Indicates the egress port the switch should send this probe</span><br><span class="line">&#x2F;&#x2F; packet out of. There is one of these headers for each hop.</span><br><span class="line">&#x2F;&#x2F;指示交换机应该发送该探测报文的出口端口。每个跳跃都有一个这样的 header</span><br><span class="line">header probe_fwd_t &#123;</span><br><span class="line">    bit&lt;8&gt;   egress_spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/link-monitor-topo.png" alt="topology" title="">                </div>                <div class="image-caption">topology</div>            </figure><p>拓扑如上，包含了四个主机连接到四个交换机上面，连接方式好像他们在fat tree 的pod上一样。</p><p>为了监控链路利用率，交换机将维持两个寄存器数组：</p><ul><li><code>byte_cnt_reg</code> 自最后一个探测包从端口传输出去以来，每个端口传输出去的字节数。</li><li><code>last_time_reg</code>保存探测包最后一次从每个端口发送出去的时间。</li></ul><p>P4程序将被写成V1Model形式（bmv2交换机），V1model可以参考它的<a href="https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4" target="_blank" rel="noopener">官方源码</a></p><h5 id="补充：-FatTree胖树拓扑结构"><a href="#补充：-FatTree胖树拓扑结构" class="headerlink" title="补充： FatTree胖树拓扑结构"></a>补充： FatTree胖树拓扑结构</h5><p>传统结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210420125915925.png" alt="image-20210420125915925" title="">                </div>                <div class="image-caption">image-20210420125915925</div>            </figure><p>传统数据中心采用多层级的树形结构，这种结构针对客户端/服务器（C/S）模式能有较好的效果。树形结构包括单根树和多根树。多根数的根节点往往作为备份节点存在（我们以方格代表交换机）</p><blockquote><p>缺点：传统单根/多根拓扑结构有以下缺点：成本高，根部交换机必须要有足够大的带宽来满足下层服务器之间的通信；性能瓶颈，无法满足数据中心内部大规模的MapReduce和数据拷贝。</p></blockquote><p>FatTree 拓扑结构：</p><p>Fat-Tree是以交换机为中心的拓扑。支持在横向拓展的同时拓展路径数目；且所有交换机均为相同端口数量的普通设备，降低了网络建设成本。</p><p>整个拓扑网络分为三个层次：自上而下分别为边缘层（edge）、汇聚层（aggregate）和核心层（core），其中汇聚层交换机与边缘层交换机构成一个pod，交换设备均采用商用交换设备。</p><p>一个k元的Fat-Tree可以归纳为5个特征：</p><ul><li>每台交换机都有k个端口；</li><li>核心层为顶层，一共有(k/2)^2个交换机；</li><li>一共有k个pod，每个pod有k台交换机组成。其中汇聚层和接入层各占k/2台交换机；</li><li>接入层每个交换机可以容纳k/2台服务器，因此，k元Fat-Tree一共有k个pod，每个pod容纳$k<em>k/4$个服务器，所有pod共能容纳$k</em>k*k/4$台服务器；任意</li><li>两个pod之间存在k条路径。</li></ul><p>例子：</p><p>二叉FatTree</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/eY8DUtD.png" alt="二叉FatTree" title="">                </div>                <div class="image-caption">二叉FatTree</div>            </figure><p>四叉FatTree</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/Q8efPRm.png" alt="四叉FatTree" title="">                </div>                <div class="image-caption">四叉FatTree</div>            </figure><p>因此上面练习的拓扑就像四叉FatTree的一个pod</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>headers部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F;</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4  &#x3D; 0x800;</span><br><span class="line">const bit&lt;16&gt; TYPE_PROBE &#x3D; 0x812;</span><br><span class="line"></span><br><span class="line">#define MAX_HOPS 10</span><br><span class="line">#define MAX_PORTS 8</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;48&gt; time_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123;</span><br><span class="line">    macAddr_t dstAddr;</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe</span><br><span class="line">&#x2F;&#x2F; packet has traversed so far.</span><br><span class="line">header probe_t &#123;</span><br><span class="line">    bit&lt;8&gt; hop_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The data added to the probe by each switch at each hop.</span><br><span class="line">header probe_data_t &#123;</span><br><span class="line">    bit&lt;1&gt;    bos;</span><br><span class="line">    bit&lt;7&gt;    swid;</span><br><span class="line">    bit&lt;8&gt;    port;</span><br><span class="line">    bit&lt;32&gt;   byte_cnt;</span><br><span class="line">    time_t    last_time;</span><br><span class="line">    time_t    cur_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Indicates the egress port the switch should send this probe</span><br><span class="line">&#x2F;&#x2F; packet out of. There is one of these headers for each hop.</span><br><span class="line">header probe_fwd_t &#123;</span><br><span class="line">    bit&lt;8&gt;   egress_spec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct parser_metadata_t &#123;</span><br><span class="line">    bit&lt;8&gt;  remaining;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123;</span><br><span class="line">    bit&lt;8&gt; egress_spec;</span><br><span class="line">    parser_metadata_t parser_metadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t              ethernet;</span><br><span class="line">    ipv4_t                  ipv4;</span><br><span class="line">    probe_t                 probe;</span><br><span class="line">    probe_data_t[MAX_HOPS]  probe_data;</span><br><span class="line">    probe_fwd_t[MAX_HOPS]   probe_fwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比之前的<a href="https://tyler-ytr.github.io/2021/02/21/p4%E5%AD%A6%E4%B9%A0-2/">IPV4 forwarding</a>多了三个探测包的header</p><p><strong>Parser部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ethernet &#123;</span><br><span class="line">        packet.extract(hdr.ethernet);</span><br><span class="line">        transition select(hdr.ethernet.etherType) &#123;</span><br><span class="line">            TYPE_IPV4: parse_ipv4;</span><br><span class="line">            TYPE_PROBE: parse_probe;</span><br><span class="line">            default: accept;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ipv4 &#123;</span><br><span class="line">        packet.extract(hdr.ipv4);</span><br><span class="line">        transition accept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_probe &#123;</span><br><span class="line">        packet.extract(hdr.probe);</span><br><span class="line">        meta.parser_metadata.remaining &#x3D; hdr.probe.hop_cnt + 1;</span><br><span class="line">        transition select(hdr.probe.hop_cnt) &#123;</span><br><span class="line">            0: parse_probe_fwd;</span><br><span class="line">            default: parse_probe_data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_probe_data &#123;</span><br><span class="line">        packet.extract(hdr.probe_data.next);</span><br><span class="line">        transition select(hdr.probe_data.last.bos) &#123;</span><br><span class="line">            1: parse_probe_fwd;</span><br><span class="line">            default: parse_probe_data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_probe_fwd &#123;</span><br><span class="line">        packet.extract(hdr.probe_fwd.next);</span><br><span class="line">        meta.parser_metadata.remaining &#x3D; meta.parser_metadata.remaining - 1;</span><br><span class="line">        &#x2F;&#x2F; extract the forwarding data</span><br><span class="line">        meta.egress_spec &#x3D; hdr.probe_fwd.last.egress_spec;</span><br><span class="line">        transition select(meta.parser_metadata.remaining) &#123;</span><br><span class="line">            0: accept;</span><br><span class="line">            default: parse_probe_fwd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>流程是：先进入start状态，通过ethernet的etherType确定是    ipv4包还是探测包，如果是ipv4包，略；如果是探测包，那么看看是不是第一个跳，探测包经过第一跳的时候不会有其他信息，因此可以直接进入向前转发的状态；否则就更新matada里面的remaing，进入parse_probe_data状态解析probe_data.next的信息，知道解析到last.bos也就是栈底的时候再进入向前转发状态；向前转发状态(<code>parse_probe_fwd</code>)里面,使用<code>hdr.probe.hop_cnt</code>指出了哪一个<code>egress_spec</code>来处理向前转发，并且把这个端口号存在一个metadata的域里面；</p></blockquote><p><strong>Ingress Control 部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec &#x3D; port;</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr;</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (hdr.probe.isValid()) &#123;</span><br><span class="line">            standard_metadata.egress_spec &#x3D; (bit&lt;9&gt;)meta.egress_spec;</span><br><span class="line">            hdr.probe.hop_cnt &#x3D; hdr.probe.hop_cnt + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比basic那个实验多了一个如果hdr.probe.isValid()（也就是这个包是探测包），就记录 <code>egress_spec</code>并且更新<code>hdr.probe.hop_cnt</code> </p></blockquote><p><strong>Egress Control 部分</strong></p><p>这部分是状态处理发生的地方，使用<code>byte_cnt_regs</code>寄存器在计算自最后一个探测包通过该端口以来通过每个端口的字节数；</p><p>这部分增加了一个新的<code>probe_data</code>  ,并且填写了 <code>bos</code> (bottom of stack) 和 <code>swid</code> (switch ID)；</p><p>要做的部分是填写探测包字段的其余部分，以确保您可以正确地测量链路利用率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   ********************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; count the number of bytes seen since the last probe</span><br><span class="line">    register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg;</span><br><span class="line">    &#x2F;&#x2F; remember the time of the last probe</span><br><span class="line">    register&lt;time_t&gt;(MAX_PORTS) last_time_reg;</span><br><span class="line"></span><br><span class="line">    action set_swid(bit&lt;7&gt; swid) &#123;</span><br><span class="line">        hdr.probe_data[0].swid &#x3D; swid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table swid &#123;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            set_swid;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        bit&lt;32&gt; byte_cnt;</span><br><span class="line">        bit&lt;32&gt; new_byte_cnt;</span><br><span class="line">        time_t last_time;</span><br><span class="line">        time_t cur_time &#x3D; standard_metadata.egress_global_timestamp;</span><br><span class="line">        &#x2F;&#x2F; increment byte cnt for this packet&#39;s port</span><br><span class="line">        byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port);</span><br><span class="line">        byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length;</span><br><span class="line">        &#x2F;&#x2F; reset the byte count when a probe packet passes through</span><br><span class="line">        new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt;</span><br><span class="line">        byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt);</span><br><span class="line"></span><br><span class="line">        if (hdr.probe.isValid()) &#123;</span><br><span class="line">            &#x2F;&#x2F; fill out probe fields</span><br><span class="line">            hdr.probe_data.push_front(1);</span><br><span class="line">            hdr.probe_data[0].setValid();</span><br><span class="line">            if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; set switch ID field</span><br><span class="line">            swid.apply();</span><br><span class="line">            &#x2F;&#x2F; TODO: fill out the rest of the probe packet fields</span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].port &#x3D; ...</span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].byte_cnt &#x3D; ...</span><br><span class="line">            &#x2F;&#x2F; TODO: read &#x2F; update the last_time_reg</span><br><span class="line">            &#x2F;&#x2F; last_time_reg.read(&lt;val&gt;, &lt;index&gt;);</span><br><span class="line">            &#x2F;&#x2F; last_time_reg.write(&lt;index&gt;, &lt;val&gt;); </span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].last_time &#x3D; ...</span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].cur_time &#x3D; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   ********************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; count the number of bytes seen since the last probe</span><br><span class="line">    register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg;</span><br><span class="line">    &#x2F;&#x2F; remember the time of the last probe</span><br><span class="line">    register&lt;time_t&gt;(MAX_PORTS) last_time_reg;</span><br><span class="line"></span><br><span class="line">    action set_swid(bit&lt;7&gt; swid) &#123;</span><br><span class="line">        hdr.probe_data[0].swid &#x3D; swid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table swid &#123;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            set_swid;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        bit&lt;32&gt; byte_cnt;</span><br><span class="line">        bit&lt;32&gt; new_byte_cnt;</span><br><span class="line">        time_t last_time;</span><br><span class="line">        time_t cur_time &#x3D; standard_metadata.egress_global_timestamp;</span><br><span class="line">        &#x2F;&#x2F; increment byte cnt for this packet&#39;s port</span><br><span class="line">        byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port);</span><br><span class="line">        byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length;</span><br><span class="line">        &#x2F;&#x2F; reset the byte count when a probe packet passes through</span><br><span class="line">        new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt;</span><br><span class="line">        byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt);</span><br><span class="line"></span><br><span class="line">        if (hdr.probe.isValid()) &#123;</span><br><span class="line">            &#x2F;&#x2F; fill out probe fields</span><br><span class="line">            hdr.probe_data.push_front(1);</span><br><span class="line">            hdr.probe_data[0].setValid();</span><br><span class="line">            if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; set switch ID field</span><br><span class="line">            swid.apply();</span><br><span class="line">            hdr.probe_data[0].port &#x3D; (bit&lt;8&gt;)standard_metadata.egress_port;</span><br><span class="line">            hdr.probe_data[0].byte_cnt &#x3D; byte_cnt;</span><br><span class="line">            &#x2F;&#x2F; read &#x2F; update the last_time_reg</span><br><span class="line">            last_time_reg.read(last_time, (bit&lt;32&gt;)standard_metadata.egress_port);</span><br><span class="line">            last_time_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, cur_time);</span><br><span class="line">            hdr.probe_data[0].last_time &#x3D; last_time;</span><br><span class="line">            hdr.probe_data[0].cur_time &#x3D; cur_time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其余部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*************   C H E C K S U M    C O M P U T A T I O N   ***************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyComputeChecksum(inout headers  hdr, inout metadata meta) &#123;</span><br><span class="line">     apply &#123;</span><br><span class="line">update_checksum(</span><br><span class="line">    hdr.ipv4.isValid(),</span><br><span class="line">            &#123; hdr.ipv4.version,</span><br><span class="line">      hdr.ipv4.ihl,</span><br><span class="line">              hdr.ipv4.diffserv,</span><br><span class="line">              hdr.ipv4.totalLen,</span><br><span class="line">              hdr.ipv4.identification,</span><br><span class="line">              hdr.ipv4.flags,</span><br><span class="line">              hdr.ipv4.fragOffset,</span><br><span class="line">              hdr.ipv4.ttl,</span><br><span class="line">              hdr.ipv4.protocol,</span><br><span class="line">              hdr.ipv4.srcAddr,</span><br><span class="line">              hdr.ipv4.dstAddr &#125;,</span><br><span class="line">            hdr.ipv4.hdrChecksum,</span><br><span class="line">            HashAlgorithm.csum16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">        packet.emit(hdr.probe);</span><br><span class="line">        packet.emit(hdr.probe_data);</span><br><span class="line">        packet.emit(hdr.probe_fwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  S W I T C H  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">V1Switch(</span><br><span class="line">MyParser(),</span><br><span class="line">MyVerifyChecksum(),</span><br><span class="line">MyIngress(),</span><br><span class="line">MyEgress(),</span><br><span class="line">MyComputeChecksum(),</span><br><span class="line">MyDeparser()</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h4 id="probe-hdrs-py分析"><a href="#probe-hdrs-py分析" class="headerlink" title="probe_hdrs.py分析:"></a>probe_hdrs.py分析:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line">TYPE_PROBE &#x3D; 0x812</span><br><span class="line"></span><br><span class="line">class Probe(Packet):</span><br><span class="line">   fields_desc &#x3D; [ ByteField(&quot;hop_cnt&quot;, 0)]</span><br><span class="line"></span><br><span class="line">class ProbeData(Packet):</span><br><span class="line">   fields_desc &#x3D; [ BitField(&quot;bos&quot;, 0, 1),</span><br><span class="line">                   BitField(&quot;swid&quot;, 0, 7),</span><br><span class="line">                   ByteField(&quot;port&quot;, 0),</span><br><span class="line">                   IntField(&quot;byte_cnt&quot;, 0),</span><br><span class="line">                   BitField(&quot;last_time&quot;, 0, 48),</span><br><span class="line">                   BitField(&quot;cur_time&quot;, 0, 48)]</span><br><span class="line"></span><br><span class="line">class ProbeFwd(Packet):</span><br><span class="line">   fields_desc &#x3D; [ ByteField(&quot;egress_spec&quot;, 0)]</span><br><span class="line"></span><br><span class="line">bind_layers(Ether, Probe, type&#x3D;TYPE_PROBE)</span><br><span class="line">bind_layers(Probe, ProbeFwd, hop_cnt&#x3D;0)</span><br><span class="line">bind_layers(Probe, ProbeData)</span><br><span class="line">bind_layers(ProbeData, ProbeData, bos&#x3D;0)</span><br><span class="line">bind_layers(ProbeData, ProbeFwd, bos&#x3D;1)</span><br><span class="line">bind_layers(ProbeFwd, ProbeFwd)</span><br></pre></td></tr></table></figure><p>这部分是在控制平面用scapy定义了探测包的结构，从bind_layers可以看出，结构关系大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ethernet&#123;</span><br><span class="line">.....</span><br><span class="line">Probe&#123;</span><br><span class="line">ProbeFwd&#123;</span><br><span class="line">ProbeFwd&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ProbeData&#123;</span><br><span class="line">ProbeData&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样其中ProbeFwd以及ProbeData可以嵌套；具体的结构在class里面进行了定义</p><h4 id="send-py分析"><a href="#send-py分析" class="headerlink" title="send.py分析"></a>send.py分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">from probe_hdrs import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    probe_pkt &#x3D; Ether(dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;, src&#x3D;get_if_hwaddr(&#39;eth0&#39;)) &#x2F; \</span><br><span class="line">                Probe(hop_cnt&#x3D;0) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;4) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;1) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;4) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;1) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;3) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;2) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;3) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;2) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;1)# 根据拓扑也就是s1-s1的4端口出到s4,s41端口出到s2……</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            sendp(probe_pkt, iface&#x3D;&#39;eth0&#39;)# 每隔一秒发一个探测包</span><br><span class="line">            time.sleep(1)</span><br><span class="line">        except KeyboardInterrupt:</span><br><span class="line">            sys.exit()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这部分要结合拓扑图来看:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/link-monitor-topo.png" alt="topology" title="">                </div>                <div class="image-caption">topology</div>            </figure><p>这部分probe_pkt这个包其实仔细观察不难发现，它里面的ProbeFwd和拓扑图的路线完全一致，假设是s1进行了发包，那么就是从s1-s1的4端口出到s4,s4的1端口出到s2……然后完成了一个回路到了s1;下面的代码只是每隔一秒钟发一下罢了；</p><h4 id="receive-py分析"><a href="#receive-py分析" class="headerlink" title="receive.py分析"></a>receive.py分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from probe_hdrs import *</span><br><span class="line"></span><br><span class="line">def expand(x):</span><br><span class="line">    yield x</span><br><span class="line">    while x.payload:</span><br><span class="line">        x &#x3D; x.payload</span><br><span class="line">        yield x</span><br><span class="line"></span><br><span class="line">def handle_pkt(pkt):</span><br><span class="line">    if ProbeData in pkt:</span><br><span class="line">        data_layers &#x3D; [l for l in expand(pkt) if l.name&#x3D;&#x3D;&#39;ProbeData&#39;]</span><br><span class="line">        print &quot;&quot;</span><br><span class="line">        for sw in data_layers:</span><br><span class="line">            utilization &#x3D; 0 if sw.cur_time &#x3D;&#x3D; sw.last_time else 8.0*sw.byte_cnt&#x2F;(sw.cur_time - sw.last_time)</span><br><span class="line">            print &quot;Switch &#123;&#125; - Port &#123;&#125;: &#123;&#125; Mbps&quot;.format(sw.swid, sw.port, utilization)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    iface &#x3D; &#39;eth0&#39;</span><br><span class="line">    print &quot;sniffing on &#123;&#125;&quot;.format(iface)</span><br><span class="line">    sniff(iface &#x3D; iface,</span><br><span class="line">          prn &#x3D; lambda x: handle_pkt(x)) #prn指定回调函数，每当一个符合filter的报文被探测到时，就会执行回调函数，通常使用lambda表达式来写回调函数</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>expand 这个就是一个走yield的递归的函数；</p><p>handle_pkt这部分首先实会不停的往后整pkt得到ProbeData的部分然后存到data_layer里面，然后解析里面的内容，看utilization，计算公式就是以Bit为单位的数据除以时间；</p><p>main还是里面的sniff是一个过滤器，其实是iface为”eth0”的包就扔到handle_pkt里面去处理；</p><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><ol><li><p>跑:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br></pre></td></tr></table></figure><ul><li>编译link_monitor.p4</li><li>在mininet里面启动如上面图片的拓扑并且将所有的交换机都设置好p4程序和相应的table entries</li><li>根据topology.json设置所有的主机</li></ul></li><li><p>使用mininet打开h1端口，开两个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; xterm h1 h1</span><br></pre></td></tr></table></figure></li><li><p>在一个窗口里面跑send.py脚本可以开始每秒发送探测包。探测包的路线和拓扑图一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./send.py</span><br></pre></td></tr></table></figure></li><li><p>在另一个窗口跑receive.py可以开始接受并且接受这些探测包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./receive.py</span><br></pre></td></tr></table></figure><blockquote><p>报告的链路利用率和交换机端口号将始终为0，因为探测字段还没有填写。</p></blockquote></li><li><p>在h1和h4之间开一个iperf流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt;iperf h1 h4</span><br></pre></td></tr></table></figure></li><li><p>在所有窗口里面exit然后make stop</p></li></ol><blockquote><p>测量的链路利用率与iperf报告的不一致，因为探测包字段还没有填充。您的目标是填写探测包字段，以便两个测量结果一致。</p></blockquote><h6 id="控制平面的一些说明"><a href="#控制平面的一些说明" class="headerlink" title="控制平面的一些说明"></a>控制平面的一些说明</h6><p>P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。</p><p>在这个练习中，我们已经为您实现了控制平面逻辑。作为启动Mininet实例的一部分，<code>make run</code>命令将在每个交换机的表中安装包处理规则。这些是在<code>sX-runtime.json</code>中定义的，其中<code>X</code> 对应开关号。</p><p><strong>注意点：</strong>我们使用P4Runtime来安装控制平面规则。 <code>sX-runtime.json</code>文件的运行时的内容指的是表、键和动作的特定名称，如编译器生成的P4Info文件中定义的(在执行<code>make run</code>后查找 <code>build/link_monitor.p4.p4info.txt</code>文件)。P4程序中添加或重命名表、键或操作的任何更改都需要反映在这些 <code>sX-runtime.json</code>文件中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;p4学习-6-实现网络测量&quot;&gt;&lt;a href=&quot;#p4学习-6-实现网络测量&quot; class=&quot;headerlink&quot; title=&quot;p4学习-6:实现网络测量&quot;&gt;&lt;/a&gt;p4学习-6:实现网络测量&lt;/h2&gt;&lt;h4 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#实验目标&quot;
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>匈牙利算法</title>
    <link href="http://Tyler-ytr.github.io/2021/04/13/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://Tyler-ytr.github.io/2021/04/13/匈牙利算法/</id>
    <published>2021-04-13T07:12:02.000Z</published>
    <updated>2021-04-13T08:26:14.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>匈牙利算法适用于二分图匹配有关的问题</p><p><strong>二分图</strong>（<strong>Bipartite graph</strong>）是一类特殊的<strong>图</strong>，它可以被划分为两个部分，每个部分内的点互不相连。下图是典型的二分图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/v2-81f21981c992bc0b5b1acf04b37ff6c2_720w.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，在上面的二分图中，每条边的端点都分别处于点集X和Y中。匈牙利算法主要用来解决两个问题：求二分图的<strong>最大匹配数</strong>和<strong>最小点覆盖数</strong>。</p><p>在图论中，一个“匹配”（matching）是一个边的集合，其中任意两条边都没有公共顶点。</p><p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。<br>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。</p><p>交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p>增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。</p><hr><h4 id="邻接矩阵算法"><a href="#邻接矩阵算法" class="headerlink" title="邻接矩阵算法"></a>邻接矩阵算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//m代表右侧集合的元素数量,n代表左侧集合的元素数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];<span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="keyword">int</span> match[MAXN];<span class="comment">//记录当前右侧元素所对一个的左侧元素</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//记录右侧元素是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;<span class="comment">//右边并且i没有被访问</span></span><br><span class="line">            vis[i] = <span class="literal">true</span>;<span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || <span class="built_in">find</span>(match[i]))&#123;<span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">                match[i] = x;<span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接链表算法"><a href="#邻接链表算法" class="headerlink" title="邻接链表算法"></a>邻接链表算法</h4><h5 id="邻接链表数据结构"><a href="#邻接链表数据结构" class="headerlink" title="邻接链表数据结构"></a>邻接链表数据结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="comment">//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],tot;<span class="comment">//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;<span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to=v;<span class="comment">//对边进行编号</span></span><br><span class="line">    edge[tot].next=head[u];<span class="comment">//将U这个点上一次连接的点记录如果没有即为-1</span></span><br><span class="line">    head[u]=tot++;<span class="comment">//等于边的编号，之后edge[head[u]]即可调用这个边</span></span><br><span class="line">&#125;<span class="comment">//加边函数</span></span><br></pre></td></tr></table></figure><p>理解一下邻接链表：</p><p>邻接矩阵如下，但是它不适合稀疏图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/2019072120555471.png" alt="邻接矩阵" title="">                </div>                <div class="image-caption">邻接矩阵</div>            </figure><p>邻接链表适合稀疏图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/20190721205858715.png" alt="邻接链表" title="">                </div>                <div class="image-caption">邻接链表</div>            </figure><p>因此结合上面的代码，head数组相当于邻接链表的一个个头，head[a]可以得到a的第一个边，通过edge[head[a]]获得，然后edge[head[a]].next可以得到下一条边的编号……</p><h5 id="邻接链表匈牙利"><a href="#邻接链表匈牙利" class="headerlink" title="邻接链表匈牙利"></a>邻接链表匈牙利</h5> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200010</span>;<span class="comment">//边数的最大值</span></span><br><span class="line"><span class="comment">//参考资料https://zhuanlan.zhihu.com/p/96229700；</span></span><br><span class="line"><span class="comment">//整理的笔记:https://tyler-ytr.github.io/2021/04/13/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</span></span><br><span class="line"><span class="comment">//邻接链表定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="comment">//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],tot;<span class="comment">//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;<span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to=v;<span class="comment">//对边进行编号</span></span><br><span class="line">    edge[tot].next=head[u];<span class="comment">//将U这个点上一次连接的点记录如果没有即为-1</span></span><br><span class="line">    head[u]=tot++;<span class="comment">//等于边的编号，之后edge[head[u]]即可调用这个边</span></span><br><span class="line">&#125;<span class="comment">//加边函数</span></span><br><span class="line"><span class="comment">//匈牙利算法</span></span><br><span class="line"><span class="keyword">int</span> match[maxn];<span class="comment">//记录当前右侧元素所对一个的左侧元素</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];<span class="comment">//记录当前右侧元素有没有被访问过</span></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//左侧元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//dfs左侧元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;<span class="comment">//顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后</span></span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;<span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span>(match[v]==<span class="number">-1</span>||dfs(match[v]))&#123;<span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">                match[v]=u;<span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i))++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>问题 A: 二部图最大匹配</p><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个由X、Y两部分组成的二部图，试求图上最大匹配的规模（无需输出方案）</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第1行输入两个数，分别代表X和Y部的顶点数 第2行~第x+1行，第i行的第一个数k表示X部第(i-1)个与Y部的k个点之间有边。接下来k个数为Y部与其有边的顶点的标号。（点的标号从1开始） 输入保证X部、Y部顶点数量均不超过10^5，总边数不超过2*10^5。</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>输出1行，行内只有一个整数，为图上最大匹配的规模</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">2 3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h5><blockquote><p>样例解释：一个最大匹配是{(X1, Y3), (X2, Y2), (X4, Y1)} 。</p><p><strong>一个显而易见的事实是：你不应该尝试使用邻接矩阵存储图上的边。</strong></p><p>事实上，正确执行的算法并不需要每次遍历整个图（就像样例这样，除了X2以外的点搜索的第一条边就可以加入匹配）。我们提供的绝大部分数据是稀疏图，如果你的算法对此做了正确设计，使用C/C++实现的程序执行时间应该明显低于1秒。<br>如果你写出了时间复杂度Theta(V^2)的实现，那……也许你会在一部分数据上超时，也许不会</p></blockquote><p>代码:(耗时99)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn&#x3D;200010;&#x2F;&#x2F;边数的最大值</span><br><span class="line">&#x2F;&#x2F;参考资料https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;96229700；</span><br><span class="line">&#x2F;&#x2F;整理的笔记:https:&#x2F;&#x2F;tyler-ytr.github.io&#x2F;2021&#x2F;04&#x2F;13&#x2F;%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&#x2F;</span><br><span class="line">&#x2F;&#x2F;邻接链表定义</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">&#x2F;&#x2F;to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键</span><br><span class="line">int head[maxn],tot;&#x2F;&#x2F;tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    tot&#x3D;0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">&#125;&#x2F;&#x2F;初始化函数</span><br><span class="line">void addedge(int u,int v)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tot].to&#x3D;v;&#x2F;&#x2F;对边进行编号</span><br><span class="line">    edge[tot].next&#x3D;head[u];&#x2F;&#x2F;将U这个点上一次连接的点记录如果没有即为-1</span><br><span class="line">    head[u]&#x3D;tot++;&#x2F;&#x2F;等于边的编号，之后edge[head[u]]即可调用这个边</span><br><span class="line">&#125;&#x2F;&#x2F;加边函数</span><br><span class="line">&#x2F;&#x2F;匈牙利算法</span><br><span class="line">int match[maxn];&#x2F;&#x2F;记录当前右侧元素所对一个的左侧元素</span><br><span class="line">bool vis[maxn];&#x2F;&#x2F;记录当前右侧元素有没有被访问过</span><br><span class="line">int N;&#x2F;&#x2F;左侧元素的数量</span><br><span class="line">bool dfs(int u)&#123;&#x2F;&#x2F;dfs左侧元素</span><br><span class="line">    for (int i&#x3D;head[u];i!&#x3D;-1;i&#x3D;edge[i].next)&#123;&#x2F;&#x2F;顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后</span><br><span class="line">        int v&#x3D;edge[i].to;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v]&#x3D;true;&#x2F;&#x2F;记录状态为访问过</span><br><span class="line">            if(match[v]&#x3D;&#x3D;-1||dfs(match[v]))&#123;&#x2F;&#x2F;如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span><br><span class="line">                match[v]&#x3D;u;&#x2F;&#x2F;当前左侧元素成为当前右侧元素的新匹配</span><br><span class="line">                return true;&#x2F;&#x2F;返回匹配成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Hungarian()&#123;</span><br><span class="line">    int res&#x3D;0;</span><br><span class="line">    memset(match,-1,sizeof(match));</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;++i)&#123;</span><br><span class="line">        memset(vis,false,sizeof(vis));</span><br><span class="line">        if(dfs(i))++res;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">&#x2F;&#x2F;X为左侧，Y为右侧</span><br><span class="line">    int M;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    &#x2F;&#x2F;printf(&quot;%d\n&quot;,N);</span><br><span class="line">    int tempnum;</span><br><span class="line">    int tempy;</span><br><span class="line">    int j&#x3D;0;</span><br><span class="line">    init();</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;cin&gt;&gt;tempnum;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;tempnum);</span><br><span class="line">        &#x2F;&#x2F;printf(&quot;%d\n&quot;,tempnum);</span><br><span class="line">        for (j&#x3D;0;j&lt;tempnum;j++)&#123;</span><br><span class="line">            &#x2F;&#x2F;cin&gt;&gt;tempy;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tempy);</span><br><span class="line">            addedge(i,tempy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;建图完毕</span><br><span class="line">    int result &#x3D; Hungarian();</span><br><span class="line">    printf(&quot;%d\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;匈牙利算法&quot;&gt;&lt;a href=&quot;#匈牙利算法&quot; class=&quot;headerlink&quot; title=&quot;匈牙利算法&quot;&gt;&lt;/a&gt;匈牙利算法&lt;/h2&gt;&lt;p&gt;匈牙利算法适用于二分图匹配有关的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分图&lt;/strong&gt;（&lt;strong&gt;Bip
      
    
    </summary>
    
      <category term="算法模板" scheme="http://Tyler-ytr.github.io/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++预处理指令</title>
    <link href="http://Tyler-ytr.github.io/2021/04/13/C-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/"/>
    <id>http://Tyler-ytr.github.io/2021/04/13/C-预处理指令/</id>
    <published>2021-04-13T05:14:06.000Z</published>
    <updated>2021-04-13T06:53:16.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-翻译流程与预处理指令"><a href="#C-翻译流程与预处理指令" class="headerlink" title="C++翻译流程与预处理指令"></a>C++翻译流程与预处理指令</h2><p>参考了<a href="https://www.bookstack.cn/read/cppreference-language/85f4d80f537f13a4.md" target="_blank" rel="noopener">C++语言构造手册</a>,<a href="https://zh.cppreference.com/w/cpp/language/translation_phases" target="_blank" rel="noopener">cppreference</a></p><p>翻译阶段复制自cppreference</p><h1 id="翻译阶段"><a href="#翻译阶段" class="headerlink" title="翻译阶段"></a>翻译阶段</h1><p>编译器处理 C++ 源文件时，如同严格按照以下顺序进行各个阶段的处理：</p><h3 id="阶段-1"><a href="#阶段-1" class="headerlink" title="阶段 1"></a>阶段 1</h3><p>1) （以实现定义方式）将源文件的各个单独字节，映射为<em>基本源字符集</em>的字符。特别是，操作系统相关的行尾指示符均被替换为换行字符。<em>基本源字符集</em>由以下 96 个字符组成：</p><p>a) 5 个空白字符（空格 (space)、水平制表 (horizontal tab)、垂直制表 (vertical tab)、换页 (form feed)和 换行 (new-line)）</p><p>b) 10 个数字字符，从 ‘0’ 到 ‘9’</p><p>c) 52 个字母，从 ‘a’ 到 ‘z’ 以及从 ‘A’ 到 ‘Z’</p><p>d) 29 个标点字符：_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ “ ‘</p><p>2) 任何无法被映射到基本源字符集中的字符的源文件字符，均被替换为其<a href="https://zh.cppreference.com/w/cpp/language/escape" target="_blank" rel="noopener">通用字符名</a>（用 <code>\u</code> 或 <code>\U</code> 转义），或某种被等价处理的由实现定义的形式。</p><div class="table-container"><table><thead><tr><th>3) 将各个<a href="https://zh.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">三标符序列</a>替换为其对应的单字符表示。</th><th>(C++17 前)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h3 id="阶段-2"><a href="#阶段-2" class="headerlink" title="阶段 2"></a>阶段 2</h3><p>1) 当反斜杠出现于行尾（其后紧跟换行符）时，删除该反斜杠和换行符并将两个物理源码行组合成一个逻辑源码行。这是单趟操作：如果有一行以两个反斜杠结束且后随一个空行，这三行不会合为一行。若于此阶段组成了通用字符名（\uXXXX），则行为未定义。</p><p>2) 若此步骤后，非空源文件不以换行符结束（无论是原本就无换行，还是以反斜杠结束），则其行为未定义 (C++11 前)在最后添加一个换行符 (C++11 起)。</p><h3 id="阶段-3"><a href="#阶段-3" class="headerlink" title="阶段 3"></a>阶段 3</h3><p>1) 将源文件分解为<a href="https://zh.cppreference.com/w/cpp/comment" target="_blank" rel="noopener">注释</a>，空白字符（空格、水平制表、换行、垂直制表和换页）的序列，和下列各种<em>预处理记号</em>：</p><p>a) 头文件名，如 <iostream> 或 “myfile.h”</p><p>b) <a href="https://zh.cppreference.com/w/cpp/language/identifiers" target="_blank" rel="noopener">标识符</a></p><p>c) 预处理数字</p><p>d) ，包含<a href="https://zh.cppreference.com/w/cpp/language/user_literal" target="_blank" rel="noopener">用户定义</a>的 (C++11 起)<a href="https://zh.cppreference.com/w/cpp/language/character_literal" target="_blank" rel="noopener">字符</a>与<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串</a>字面量</p><p>e) 运算符与标点（包括<a href="https://zh.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">代用记号</a>），如 +、&lt;&lt;=、&lt;%、## 或 and</p><p>f) 不属于任何其他类别的单独非空白字符</p><div class="table-container"><table><thead><tr><th>2) 恢复在任何原始<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串字面量</a>的首尾双引号之间在阶段 1 和 2 期间进行的所有变换。</th><th>(C++11 起)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>3) 以一个空格字符替换每段注释。</p><p>保留换行符。未指明是否可将非换行空白字符序列缩减成单个空格字符。</p><p>若一个给定字符前的输入已被解析为预处理记号，下一个预处理记号通常会由能构成预处理记号的最长字符序列够成，即使这样处理会导致后续分析失败。这常被称为<em>最大吞噬</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo &#x3D; 1;</span><br><span class="line">int bar &#x3D; 0xE+foo;   &#x2F;&#x2F; 错误：非法的预处理数字 0xE+foo</span><br><span class="line">int baz &#x3D; 0xE + foo; &#x2F;&#x2F; OK</span><br><span class="line"> </span><br><span class="line">int quux &#x3D; bar+++++baz; &#x2F;&#x2F; 错误：bar++ ++ +baz，而非 bar++ + ++baz。</span><br></pre></td></tr></table></figure><p>最大吞噬规则仅有的例外是：</p><div class="table-container"><table><thead><tr><th>若以下一个字符开头的字符序列可作为<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">原始字符串字面量</a>的前缀和起始双引号，则下个预处理记号应当为原始字符串字面量。该字面量由匹配原始字符串模式的最短字符序列组成。<code>#define R &quot;x&quot; const char* s = R&quot;y&quot;; // 非良构的原始字符串字面量，而非 &quot;x&quot; &quot;y&quot; const char* s2 = R&quot;(a)&quot; &quot;b)&quot;; // 原始字符串字面量后随普通字符串字面量</code>若接下来三个字符是 <code>**&lt;::**</code>且后继字符不是 <code>**:**</code> 或者 <code>**&gt;**</code>，则把 <code>**&lt;**</code> 自身当做预处理记号（而非<a href="https://zh.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">代用记号</a> <code>&lt;:</code> 的首字符）。<code>struct Foo { static const int v = 1; }; std::vector&lt;::Foo&gt; x; // OK，&lt;: 未被当作 [ 的代用记号 extern int y&lt;::&gt;;     // OK，同 extern int y[]。 int z&lt;:::Foo::value:&gt;; // OK，int z[::Foo::value];</code></th><th>(C++11 起)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><ul><li>头文件名预处理记号仅在 <code>#include</code> 指令中形成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; x; &#x2F;&#x2F; OK，&lt;int&gt; 不是头文件名</span><br></pre></td></tr></table></figure><h3 id="阶段-4"><a href="#阶段-4" class="headerlink" title="阶段 4"></a>阶段 4</h3><p>1) 执行<a href="https://zh.cppreference.com/w/cpp/preprocessor" target="_blank" rel="noopener">预处理器</a>。</p><p>2) <a href="https://zh.cppreference.com/w/cpp/preprocessor/include" target="_blank" rel="noopener">#include</a> 指令所引入的每个文件都经历阶段 1 到 4 的处理，递归执行。</p><p>3) 此阶段结束时，所有预处理器指令都应从源（代码）移除。</p><h3 id="阶段-5"><a href="#阶段-5" class="headerlink" title="阶段 5"></a>阶段 5</h3><p>1) 将<a href="https://zh.cppreference.com/w/cpp/language/character_literal" target="_blank" rel="noopener">字符字面量</a>及<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串字面量</a>中的所有字符从源字符集转换到<em>执行字符集</em>（可以是 UTF-8 这样的多字节字符集，只要阶段 1 中所列的<em>基本源字符集</em>的 96 个字符都拥有单字节表示即可）。</p><p>2) 将字符字面量和非原始字符串字面量中的<a href="https://zh.cppreference.com/w/cpp/language/escape" target="_blank" rel="noopener">转义序列</a>和通用字符名展开，并转换到<em>执行字符集</em>。 若某个通用字符名所指定的字符不是执行字符集的成员，则结果是由实现定义的，但保证不是空（宽）字符。</p><p>注意：某些实现能以命令行选项控制此阶段所进行的转换：gcc 和 clang 用 -finput-charset 指定源字符集的编码，用 -fexec-charset 和 -fwide-exec-charset 指定无编码前缀的 (C++11 起)字符串和字符字面量中的执行字符集的编码，而 Visual Studio 2015 Update 2 及之后版本分别用 /source-charset 和 /execution-charset 指定源字符集和执行字符集。</p><h3 id="阶段-6"><a href="#阶段-6" class="headerlink" title="阶段 6"></a>阶段 6</h3><p>拼接相邻的<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串字面量</a>。</p><h3 id="阶段-7"><a href="#阶段-7" class="headerlink" title="阶段 7"></a>阶段 7</h3><p>进行编译：将各个预处理记号转换成记号。将所有记号当作一个翻译单元进行语法和语义分析并进行翻译。</p><h3 id="阶段-8"><a href="#阶段-8" class="headerlink" title="阶段 8"></a>阶段 8</h3><p>检验每个翻译单元，产生所要求的模板实例化的列表，其中包括<a href="https://zh.cppreference.com/w/cpp/language/class_template" target="_blank" rel="noopener">显式实例化</a>所要求的实例化。定位模板定义，并进行所要求的实例化，以产生<em>实例化单元</em>。</p><h3 id="阶段-9"><a href="#阶段-9" class="headerlink" title="阶段 9"></a>阶段 9</h3><p>将翻译单元、实例化单元和为满足外部引用所需的库组件汇集成一个程序映像，它含有在其执行环境中执行所需的信息。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>某些编译器不实现实例化单元（又称为<a href="http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc" target="_blank" rel="noopener">模板仓库</a>或<a href="http://www-01.ibm.com/support/knowledgecenter/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html?lang=en" target="_blank" rel="noopener">模板注册表</a>），而是简单地在阶段 7 编译每个模板实例化，存储代码于其所显式或隐式要求的对象文件中，然后由连接器于阶段 9 将这些编译后的实例化缩减到一个。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>C++11 standard (ISO/IEC 14882:2011):</li></ul><ul><li>C++98 standard (ISO/IEC 14882:1998):</li></ul><h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><h4 id="基本的预编译指令"><a href="#基本的预编译指令" class="headerlink" title="基本的预编译指令"></a>基本的预编译指令</h4><ul><li>$#$ 空指令</li><li>$#define$ 定义宏</li><li>$#include$ 包含一个源代码文件</li><li>$#undef$取消已经定义的宏</li><li>$#if$如果给定条件为真，则编译下面的代码</li><li>$#ifdef$如果宏已经定义就编译下面的代码</li><li>$#ifndef$如果宏没有定义，就编译下面的代码</li><li>$#elif$如果前面的$#if$给定条件不为真，当前条件为真，就编译下面的代码</li><li>$#endif$结束一个$#if….#else$条件编译块</li><li>$#error$停止编译并且显示错误信息</li></ul><h4 id="define-的一些使用"><a href="#define-的一些使用" class="headerlink" title="$# define$ 的一些使用"></a>$# define$ 的一些使用</h4><p>预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。记住仅仅是进行标识符的替换。</p><p>例子如下：</p><ul><li><p>用#define实现求最大值和最小值的宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) (((x)&gt;(y))?(x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(x,y) (((x)&lt;(y))?(x):(y))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAX    <span class="comment">//判断这个宏是否被定义</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3 and 5 the max is:%d\n"</span>,MAX(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIN</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3 and 5 the min is:%d\n"</span>,MIN(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)三元运算符要比if,else效率高</span></span><br><span class="line"><span class="comment"> * （2）宏的使用一定要细心，需要把参数小心的用括号括起来，</span></span><br><span class="line"><span class="comment"> * 因为宏只是简单的文本替换，不注意，容易引起歧义错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>宏定义错误使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR(x) (x*x)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SQR<span class="comment">//只需要宏名就可以了，不需要参数，有参数的话会警告</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,SQR(b+<span class="number">2</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *首先说明，这个宏的定义是错误的。并没有实现程序中的B+2的平方</span></span><br><span class="line"><span class="comment"> * 预处理的时候，替换成如下的结果：b+2*b+2</span></span><br><span class="line"><span class="comment"> * 正确的宏定义应该是：#define SQR(x) ((x)*(x))</span></span><br><span class="line"><span class="comment"> * 所以，尽量使用小括号，将参数括起来。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>宏参数的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONS(a,b) (int)(a##e##b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> STR</span></span><br><span class="line">    <span class="built_in">printf</span>(STR(VCK));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONS</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,CONS(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* （绝大多数是使用不到这些的，使用到的话，查看手册就可以了）</span></span><br><span class="line"><span class="comment"> * 第一个宏，用#把参数转化为一个字符串</span></span><br><span class="line"><span class="comment"> * 第二个宏，用##把2个宏参数粘合在一起，及aeb,2e3也就是2000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>用宏得到一个字的高位或低位的字节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_LO(xxx) ((byte)((word)(xxx) &amp; 255))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_HI(xxx) ((byte)((word)(xxx) &gt;&gt; 8))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个字2个字节，获得低字节（低8位），与255（0000,0000,1111,1111）按位相与</span></span><br><span class="line"><span class="comment"> * 获得高字节（高8位），右移8位即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>用宏定义得到一个数组所含元素的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE(a) (sizeof((a))/sizeof((a[0])))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ARR_SIZE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"array has %d items.\n"</span>,ARR_SIZE(<span class="built_in">array</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *总的大小除以每个类型的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="ifdef-ifndef-endif-…的使用"><a href="#ifdef-ifndef-endif-…的使用" class="headerlink" title="$#ifdef$,$#ifndef$,$#endif$…的使用"></a>$#ifdef$,$#ifndef$,$#endif$…的使用</h4><p>以上这些预编译指令，都是条件编译指令，也就是说，将决定那些代码被编译，而哪些不被编译</p><ul><li><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define DEBUG</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    char c;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        c &#x3D; getchar();</span><br><span class="line">        if(&#39;\n&#39; !&#x3D; c)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        if(&#39;q&#39; &#x3D;&#x3D; c || &#39;Q&#39; &#x3D;&#x3D; c)</span><br><span class="line">        &#123;</span><br><span class="line">#ifdef DEBUG&#x2F;&#x2F;判断DEBUG是否被定义了</span><br><span class="line">            printf(&quot;We get:%c,about to exit.\n&quot;,c);</span><br><span class="line">#endif</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;i &#x3D; %d&quot;,i);</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">            printf(&quot;,we get:%c&quot;,c);</span><br><span class="line">#endif</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*#endif用于终止#if预处理指令。*&#x2F;</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#error指令将使编译器显示一条错误信息，然后停止编译。</span><br><span class="line">#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。</span><br><span class="line">#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-翻译流程与预处理指令&quot;&gt;&lt;a href=&quot;#C-翻译流程与预处理指令&quot; class=&quot;headerlink&quot; title=&quot;C++翻译流程与预处理指令&quot;&gt;&lt;/a&gt;C++翻译流程与预处理指令&lt;/h2&gt;&lt;p&gt;参考了&lt;a href=&quot;https://www.book
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论-3</title>
    <link href="http://Tyler-ytr.github.io/2021/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA-3/"/>
    <id>http://Tyler-ytr.github.io/2021/03/22/机器学习导论-3/</id>
    <published>2021-03-22T03:14:15.000Z</published>
    <updated>2021-03-22T04:01:29.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><blockquote><p><a href="https://datawhalechina.github.io/pumpkin-book/#/chapter3/chapter3" target="_blank" rel="noopener">南瓜书本章连接</a></p></blockquote><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><ul><li>线性模型一般形式$f(x)=w_1x_1+w_2x_2+\cdots+w_dx_d+b$</li><li>向量形式$f(x)=w^{T}x+b$</li></ul><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><ul><li><p>单一属性</p><ul><li><p>基本目标:$f(x)=wx_{i}+b$使得$f(x_{i})\simeq y_{i}$</p><blockquote><p>目的是把离散的(比如身高的高中低)转换成连续的量(比如高1.0中0.5),这种情况主要考虑”序”，比如青绿，黑色，蓝色可能没有序，这个时候不妨把它变成[0,1,0]这种向量编码(几个维度整几维);</p></blockquote></li><li><p>回归:均方误差最小化</p><p>$(w^{<em>},b^{</em>})=arg\ min_{(w,b)}\sum_{i=1}^{m}(f(x_{i})-y_i)^2$</p><p>可以使用最小二乘参数估计（求偏导让导数为零，例子要求w,b），计算暂略</p><blockquote><p>偏导(w)整的主要是关于(w)的变化率，等于零的时候意味着到了极大/极小值;</p></blockquote></li></ul></li><li><p>多元属性</p><ul><li><p>基本目标:$f(x_i)=w^Tx_i+b$使得$f(x_{i})\simeq y_{i}$</p></li><li><p>回归:</p><p>$\hat{w}^*=\arg \min_{\hat{w}}(y-X\hat{w})^T(y-X\hat{w})$</p><p>如果满秩:$\hat{w}^*=(X^{T}X)^{-1}X^Ty$；$f(\hat{x_{i}})=\hat{x_{i}}^{T}(X^{T}X)^{-1}$</p><p>如果不满秩,求助于归纳偏好或者引入正则化(regularization)(也就是加入限制)</p></li></ul></li><li><p>求解非线性的模型——广义线性模型:</p><ul><li>比如$\ln y=w^Tx+b$,就可以用$e^{w^Tx+b}$来进行毕竟，称作对数线性回归;</li><li>$g(\cdot)$为联系函数(link function)，比如$g(\cdot)=\ln(\cdot)$</li></ul></li></ul><h3 id="二分类任务"><a href="#二分类任务" class="headerlink" title="二分类任务"></a>二分类任务</h3><ul><li><p>线性回归的实际输出:$z=w^{T}x+b$</p><p>期望输出 $y\in\{0,1\}$</p><p>这个二分类任务就是为了找到一个z,y的联系函数</p></li><li><p>理想模型：单位阶跃函数</p><blockquote><p>缺陷:数学性质很糟糕，不连续</p></blockquote></li><li><p>替代函数——对数几率函数（logistic function）属于sigmoid函数的一种:</p><blockquote><p>logistic 和逻辑没有关系,logistic源于logit 不是logic;</p></blockquote><ul><li><p><strong>$y=\frac{1}{1+e^{-z}}$</strong></p><p>可以表示成$y=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-(w^{T}x+b)}}$</p></li><li><p>两边取对数:</p><p>$\ln\frac{y}{1-y}=w^{T}x+b=\ln\frac{p(y=1|x)}{p(y=0|x)}$</p><blockquote><p>$\frac{y}{1-y}$称作几率(odds)，反映了x作为正例相对于负例的相对可能性;对数几率(log odds，亦称logit)</p></blockquote></li></ul><blockquote><p>不需要假设数据分布,可以得到“类别”的近似概率预测，并且可以直接应用现有的数值优化算法求最优解，这是分类学习算法</p></blockquote><p><img src="picture/image-20210322115345578.png" alt="image-20210322115345578"></p></li><li><p>使用极大似然法(maximum likelihood method)求解,给定数据集$\{(x_{i}, y_{i})\}^{m}_{i=1}$,对率回归模型最大化“对数似然”:</p><script type="math/tex; mode=display">l(w,b)=\sum_{i=1}^{m}\ln p (y_i|x_i;w,b)</script></li></ul><blockquote><p>似然:正例的可能性*正例+负例的可能性*负例</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线性模型&quot;&gt;&lt;a href=&quot;#线性模型&quot; class=&quot;headerlink&quot; title=&quot;线性模型&quot;&gt;&lt;/a&gt;线性模型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://datawhalechina.github.io/pumpkin
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论-2 模型评估与选择</title>
    <link href="http://Tyler-ytr.github.io/2021/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA-2/"/>
    <id>http://Tyler-ytr.github.io/2021/03/22/机器学习导论-2/</id>
    <published>2021-03-22T02:18:18.000Z</published>
    <updated>2021-03-22T03:26:07.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习导论-2-模型评估与选择"><a href="#机器学习导论-2-模型评估与选择" class="headerlink" title="机器学习导论-2 模型评估与选择"></a>机器学习导论-2 模型评估与选择</h2><blockquote><p><a href="https://datawhalechina.github.io/pumpkin-book/#/chapter2/chapter2" target="_blank" rel="noopener">南瓜书本章推理</a></p></blockquote><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><ul><li><p>假设空间</p><ul><li>假设满足XX条件的是好瓜</li></ul></li><li><p>版本空间</p><ul><li>有限训练集，已知XX是好瓜</li></ul></li><li><p>归纳偏好</p><ul><li>假设空间和训练集一致的假设</li><li>学习过程中对某种类型假设的偏好称为归纳偏好</li></ul></li><li>No Free Lunch<ul><li>奥卡姆剃刀：两个模型效果同样好，选择较为简单的</li></ul></li></ul><h3 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h3><ul><li><p>经验误差与过拟合</p><ul><li>错误率率&amp;误差<ul><li>错误率：错份样本的占$E=a/m$</li><li>误差：样本真实输出与预测输出之间的差异<ul><li>训练（经验）误差：训练集上</li><li>测试误差：测试集</li><li>泛化误差：初训练集外所有样本</li></ul></li></ul></li></ul></li><li><p>过拟合</p><ul><li>学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降</li><li>优化目标加正则项</li><li>Early stop</li></ul></li><li><p>欠拟合</p><ul><li>对训练样本的一般性质尚未学好</li><li>决策树：扩展分支</li><li>神经网络：增加训练层数</li></ul></li><li><p>评估方法</p><ul><li>留出法<ul><li>直接将数据集划分为两个互斥集合</li><li>训练/测试集划分要尽可能保持数据分布的一致性</li><li>一般若干次随机划分，重复实验取平均值</li><li>训练/测试样本比例通常为2:1～4:1</li></ul></li><li>交叉验证法<ul><li>将数据集分层采样划分为$k$个大小相似的互斥子集</li></ul></li><li>自助法<ul><li>以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\prime}$，$D\backslash D^{\prime}$用作测试集</li></ul></li></ul></li><li><p>性能度量</p><ul><li><p>性能度量是衡量模型泛化能力的评价标准，反映任务的需求</p><ul><li>回归任务最常用的是“均方误差”： <ul><li>$E(f:D)=\frac{1}{m}\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$</li></ul></li></ul></li><li><p>查准率 $P=\frac{TP}{TP+FP}$</p></li><li><p>查全率 $R=\frac{TP}{TP+FN}$</p></li><li><p>$P-R$曲线：根据学习器的预测结果对样例排序，“最可能”的正例的在前面，排在最后的是“最不可能”是正例的样本，按此顺序把样本作为整理进行预测，每一次计算出当前的P,R然后以P为纵轴，R为横轴作图</p></li><li><p>如何利用多次训练得到了多个混淆矩阵？</p><ul><li><p>macro-F1:</p><script type="math/tex; mode=display">macro-P=\frac{1}{n}\sum^{n}_{i=1}P_i\\macro-R=\frac{1}{n}\sum^{n}_{i=1}R_i\\macro-F_1=\frac{2\times macro-P\times macro-R}{macro-P+macro-R}</script><p>也就是平均P,R之后再算</p></li><li><p>micro-F1:</p><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}\\micro-R=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}\\micro-F1=\frac{2\times micro-P\times micro-R}{micro-P+micro-R}</script></li></ul></li></ul></li></ul><ul><li><p>$F1$ measure：$\frac{2\times TP}{N+TP-TN}$</p></li><li><p>AUC预测了排序质量,越高越好；</p><script type="math/tex; mode=display">AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\cdot(y_{i}+y_{i+1})</script><p>AUC与排序的密切关系:考虑每一个正反例，若正例的预测值小于反例，那么就计算一个“罚分”：</p><script type="math/tex; mode=display">\mathcal{l}_{tank}=\frac{1}{m^+m^-}\sum_{x^+\in D^+}\sum_{x^-\in D^-}(\mathbb{I}(f(x^+)<f(x^-))+\frac{1}{2}\mathbb{I}(f(x^+)=f(x^-)))</script><script type="math/tex; mode=display">AUC=1-\mathcal{l}_{tank}</script></li></ul><ul><li><p>代价敏感错误率:</p><p>损失是不一样大的一些任务里面，比如漏掉一个病人，放进去一个小偷等等，要考虑“非均等代价”</p><p>建立一个二分类代价矩阵里面有预测类别的cost,然后就就可以得到加权的代价敏感的错误率</p><blockquote><p>这部分的重点是用户到底想要什么？标准型是什么？优化目标是什么？</p></blockquote></li></ul><ul><li><p>性能评估</p><ul><li><p>关于性能比较:某种度量取得评估结果之后能不能直接评价优劣？</p><ul><li>测试性能并不等于泛化性能</li><li>测试性能随着测试集的变化而变化</li><li>很多机器学习算法本身有一定的随机性</li><li>直接选取相应评估方式在相应条件下评估并不可靠</li></ul></li><li><p>二项检验</p><ul><li>泛化错误率为$\epsilon$，测试错误率为$\hat{\epsilon}$，嘉定测试样本从样本总体分布中独立采样而来，我们可以使用“二项检验”，对于$\epsilon&lt;epsilon_{0}$进行假设检验。</li><li>假设$\epsilon\leq\epsilon_{0}$，若测试错误率小于</li></ul></li><li><p>$t$检验</p><blockquote><p>统计学的原来的方法：t检验中训练的数据可能不是那么独立，也许是一个“过高”的估计</p></blockquote></li><li><p>交叉验证$t$检验</p><blockquote><p>5*2交叉验证的含义：</p><p>两折：把数据分成两部分，一部分训练一部分测验；</p><p>五次：把数据洗五次，每次做两折；</p><p>目的：减小某一个数据集的误导</p></blockquote></li><li><p>McNemar检验:</p><blockquote><p>关注正确-正确，错误-错误</p></blockquote></li><li><p>多学习器比较:</p><p>使用Friedman+Nemenyi</p><blockquote><p>算法的好坏不具有传递性：算法A比算法B好；算法B比算法C好；不等于A比C好</p></blockquote></li></ul></li><li><p>偏差和方差</p><ul><li><p>对于测试样本$x$，令$y_{D}$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学的模型$f$在$x$上的预测输出。</p></li><li><p>以回归任务为例：</p><ul><li><p>期望预期为：$\bar{f}(x)=\mathbb{E}_{D}[f(x;D)]$；</p></li><li><p>使用样本数目相同的不同训练集产生的方差为$var(x)=\mathbb{E}_{D}[(f(x:D)-\bar{f}(x))^{2}]$；(每次做的浮动范围)</p></li><li><p>噪声为$\varepsilon^{2}=\mathbb{E}_{D}[(y_{D}-y)^{2}]$: 本真误差</p></li><li><p>偏差$bias^2(x)=(\overline{f}(x)-y)^2$ 期望输出和真实输出的差别</p><p>比较清晰的图示(周老师真nb):</p><p><img src="/picture/image-20210322111149303.png" alt="image-20210322111149303"></p></li></ul></li><li><p>$E(f;D)=bias^{2}(x)+var(x)+\varepsilon^2$</p><blockquote><p>一开始偏差(bias)起到主要的作用，后来是数据造成的扰动(方差)起到主要的作用，然后overfitting一般情况下是在后者气主要作用的时候产生的，因为其实学习的是数据本身的特征</p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;机器学习导论-2-模型评估与选择&quot;&gt;&lt;a href=&quot;#机器学习导论-2-模型评估与选择&quot; class=&quot;headerlink&quot; title=&quot;机器学习导论-2 模型评估与选择&quot;&gt;&lt;/a&gt;机器学习导论-2 模型评估与选择&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论-1 绪论与数学参考</title>
    <link href="http://Tyler-ytr.github.io/2021/03/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA-1/"/>
    <id>http://Tyler-ytr.github.io/2021/03/08/机器学习导论-1/</id>
    <published>2021-03-08T02:18:18.000Z</published>
    <updated>2021-04-13T07:54:18.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习导论-1-绪论与数学参考"><a href="#机器学习导论-1-绪论与数学参考" class="headerlink" title="机器学习导论-1 绪论与数学参考"></a>机器学习导论-1 绪论与数学参考</h2><blockquote><p>二刷机器学习导论</p><p>参考书: 统计机器学习 PRML(贝叶斯) ESL(统计学派) MLAPP UML </p></blockquote><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><ol><li><p>学习过程</p><ol><li>训练数据，经过</li><li>学习算法训练，得到</li><li>模型(决策树，射精网络，支持向量机，Boosting，贝叶斯网……)，可以判断</li><li>新数据样本，得到结论</li></ol></li><li><p>机器学习的局限性，失效条件:</p><ol><li>特征信息不充分</li><li>样本信息不充分</li></ol></li><li><p>机器学习的理论基础(计算学习理论),概率近似正确(PAC):</p><p>$P(|f(x)-y|\le \epsilon)\ge 1-\delta$</p><p>f(x)是预测值,y是真实值,目的是尽可能贴近真实值也就是$|f(x)-y|\le \epsilon$,然后这件事情有一个概率的保证，一定大于$1-\delta$的概率确保这件事情的完成。一句话总结就是很高的概率得到很好的结果的模型。</p><blockquote><p>如果你能确定百分百正确，就不用整机器学习了</p></blockquote></li></ol><h3 id="数学参考"><a href="#数学参考" class="headerlink" title="数学参考"></a>数学参考</h3><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><ul><li><p>在实数域中，数的大小和两个数之间的距离是通过绝对值来度量的。将数推广到向量就引入了范数。范数（Norm）是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。</p><blockquote><p>在算例子的时候我觉得其实是不同维度到0点的距离</p></blockquote></li></ul><h5 id="向量的范数"><a href="#向量的范数" class="headerlink" title="向量的范数"></a>向量的范数</h5><ul><li><p>范数标准定义:</p><ul><li><strong>正定性:</strong>$||x||\ge 0$,且$||x||= 0$当且仅当$x=0$;</li><li><strong>齐次性:</strong>对任意实数 $\alpha$ ，都有$||\alpha x||=|\alpha|\ ||x||$</li><li><strong>三角不等式:</strong> 对任意$x,y\in R^n$,都有$||x+y|| \le ||x|| + ||y||$</li></ul><p>则称$||x||$为$R^n$上的向量范数</p></li><li><p>范数表达式:</p><script type="math/tex; mode=display">\begin{align}\left| \left| x \right| \right|_{p}\; :=\; \left( \sum_{i=1}^{n}{\left| x_{i} \right|^{p} } \right)^{\frac{1}{p} }\tag{1}\end{align}</script></li><li><p>L1范数:</p><script type="math/tex; mode=display">||x||_1 = |x_1| + |x_2| + \dots + |x_n| = \sum_i^n |x_i|</script><p>向量元素绝对值之和</p><p>L2范数:</p><script type="math/tex; mode=display">||x||_2 = (|x_1|^2 + |x_2|^2+\dots+ |x_n|^2)^{\frac{1}{2} } =\sqrt{ \sum_i^n x_i^2}</script><p>Euclid范数(欧几里得范数，常用计算向量长度)</p><p>Lp范数:</p><script type="math/tex; mode=display">||x||_p = (|x_1|^p + |x_2|^p+\dots+ |x_n|^p)^{\frac{1}{p} } =\sqrt[p]{ \sum_i^n x_i^p}</script><p><img src="/picture/image-20210308113014539.png" alt="image-20210308113014539"></p><p>Lp的形状随p的变化的图</p><p>L$\infty $范数:</p><script type="math/tex; mode=display">||x||_{\infty} = \max\limits_{1\le i\le n} |x_i|</script></li></ul><p>  所有向量元素绝对值中的最大值</p><p>  L$-\infty$范数:</p><script type="math/tex; mode=display">  ||x||_{\infty} = \min\limits_{1\le i\le n} |x_i|</script><p>  所有向量元素绝对值中的最小值</p><p>  L0范数:</p><script type="math/tex; mode=display">  ||x||_0 = \sum_i^n I(x_i \ne 0)</script><p>  也就是非零元素的数量</p><ul><li><p>例子:$x=(1,4,3,0)^T$的常用范数:</p><p>$||x||_0=3$</p><p>$||x||_1=|1|+|4|+|3|+|0|=8$</p><p>$||x||_2=\sqrt{|1|^2+|4|^2+|3|^2+|0|^2}=\sqrt{26}$</p><p>$||x||_{\infty}=|4|=4$</p></li></ul><h5 id="矩阵的范数"><a href="#矩阵的范数" class="headerlink" title="矩阵的范数"></a>矩阵的范数</h5><ul><li><p>推广到矩阵，矩阵相容范数的定义:</p><ul><li><strong>正定性:</strong>$||A||\ge 0$,且$||A||= 0$当且仅当$A=0$;</li><li><strong>齐次性:</strong>对任意实数 $\alpha$ ，都有$||\alpha A||=|\alpha|\ ||A||$</li><li><strong>三角不等式:</strong> 对任意$A,B\in R^{n\times n}$,都有$||A+B|| \le ||A|| + ||B||$</li><li><strong>相容性:</strong>对任意$A,B\in R^{n\times n}$,都有$||AB|| \le ||A||\ ||B||$</li></ul><p>则称$||A||$为$R^{n\times n}$上的一个矩阵范数</p></li><li><p><strong>列范数:</strong></p><script type="math/tex; mode=display">||A||_1 = \max\limits_{1\le j\le n} \sum_i^n |a_{ij}|</script><p>$A$的每一列的绝对值的最大值，称作$A$的列范数</p></li><li><p><strong>行范数:</strong></p><script type="math/tex; mode=display">||A||_{\infty} = \max\limits_{1\le i\le n} \sum_j^n |a_{ij}|</script><p>$A$的每一行的绝对值的最大值，称作$A$的行范数</p></li><li><p><strong>L2范数:</strong></p><script type="math/tex; mode=display">||A||_2 = \sqrt{\lambda_{max} (A^T A)}</script><p>其中$\lambda_{max}$表示$A^TA$的特征值的绝对值的最大值</p></li><li><p><strong>F-范数(Frobenius):</strong></p><script type="math/tex; mode=display">||A||_F = (\sum_i^n \sum_j^n a_{ij}^2)^{\frac{1}{2} }=(tr(A^TA))^{1/2}</script><p>它相当于矩阵$A$各项元素的绝对值平方的总和,也就是矩阵张成向量之后的L2范数</p></li></ul><h4 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h4><ul><li><p>一阶导数：雅可比矩阵</p><p>假设函数$F:{R_n} \to {R_m}$是一个从欧式n维空间转换到欧式m维空间的函数.这个函数由m个实函数组成:$y1(x1,…,xn), …, ym(x1,…,xn)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵, 这就是所谓的雅可比矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix} \frac{\partial y_1}{\partial x_1} & \cdots & \frac{\partial y_1}{\partial x_n} \\ \vdots & \ddots & \vdots \\ \frac{\partial y_m}{\partial x_1} & \cdots & \frac{\partial y_m}{\partial x_n} \end{bmatrix}</script></li></ul><p>  此矩阵表示为: ${J_F}({x_1}, \ldots ,{x_n})$,或者$\frac{ {\partial {({y_1}, … ,{y_m})} }  } { {\partial {({x_1}, … ,{x_n})} } }$.</p><blockquote><p>hexo 两个{之间要加空格不然会报错: expected variable end</p></blockquote><p>  如果$p$是$R_n$中的一点，$F$在$p$点可微分，那么这一点的导数由$J_F(p)$给出.在此情况下, 由$F(p)$描述的线性算子即接近点$p$的$F$的最优线性逼近, $x$逼近于$p$:</p><script type="math/tex; mode=display">  F({\bf{x} }) \approx F({\bf{p} }) + {J_F}({\bf{p} }) \cdot ({\bf{x} } – {\bf{p} })</script><ul><li><p>二阶导数：海森矩阵</p><p>海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下：</p><script type="math/tex; mode=display">f({x_1},{x_2} \ldots ,{x_n})</script><p>如果$f$所有的二阶导都存在，那么有：</p><script type="math/tex; mode=display">H{(f)_{ij} }(x) = {D_i}{D_j}f(x)</script><p>也就是:</p><script type="math/tex; mode=display">\begin{bmatrix} \frac{\partial^2 f}{\partial x_1^2} & \frac{\partial^2 f}{\partial x_1\,\partial x_2} & \cdots & \frac{\partial^2 f}{\partial x_1\,\partial x_n} \\  \\ \frac{\partial^2 f}{\partial x_2\,\partial x_1} & \frac{\partial^2 f}{\partial x_2^2} & \cdots & \frac{\partial^2 f}{\partial x_2\,\partial x_n} \\  \\ \vdots & \vdots & \ddots & \vdots \\  \\ \frac{\partial^2 f}{\partial x_n\,\partial x_1} & \frac{\partial^2 f}{\partial x_n\,\partial x_2} & \cdots & \frac{\partial^2 f}{\partial x_n^2} \end{bmatrix}</script></li><li><p>链式法则的式子里面有转置的原因可以从维度的角度来思考;</p></li></ul><h4 id="奇异值"><a href="#奇异值" class="headerlink" title="奇异值"></a>奇异值</h4><ul><li><p>共轭:$z=a+bi$,z的共轭$\bar{z}=a-bi$;实数的共轭是他自身;</p></li><li><p>矩阵概念:</p><ul><li><p>对称矩阵:</p><p>$A^T=A$</p></li><li><p>Hermite矩阵，将实数范围讨论的对称矩阵延伸到复数范围:</p><p>其中，用$\bar{A}$表示以$A$的元素的共轭复数为元素构成的矩阵,那么$A^H=(\bar{A}^T)$，这个称作$A$的复共轭转置矩阵;</p><ul><li>特征值都是实数。</li><li>任意两个不同特征值所对应的特征向量正交。</li></ul></li><li><p>正交矩阵:</p><p> $A^TA=E$</p></li><li><p>酉矩阵:</p><p>$A^HA=E$</p><p>这玩意其实就是正交矩阵在复数范围的推广</p></li><li><p>奇异矩阵:</p><p>$|A|=0$称作奇异矩阵，否则称作非奇异矩阵;$A$是可逆矩阵的充要条件是$|A|\neq0$,因此可逆矩阵就是非奇异矩阵</p></li><li><p>正规矩阵:</p><p>$A^HA=AA^H$,如果都是实数矩阵，那么$A^T=A^H,A^TA=AA^T$</p></li><li><p>幂等矩阵:</p><p>$A^2=A$</p></li><li><p>正定矩阵:它是对称矩阵/Hermite矩阵的进一步延伸</p><p>设$A$为n阶Hermite矩阵，如果对任意n维复向量$x$都有$x^HAx\ge 0$,则称A是半正定矩阵;如果对任意n维复向量$x$都有$x^HAx&gt; 0$,则称A是正定矩阵。</p><ul><li>Hermite矩阵$A$为正定（半正定）矩阵 $\leftrightarrow$$A$的所有特征值是正数（非负数）。</li><li>Hermite矩阵$A$为正定矩阵 $\leftrightarrow$存在n阶非奇异矩阵$P$，使得$A=P^HP$</li><li>Hermite矩阵$A$为半正定矩阵$\leftrightarrow $存在n阶矩阵$P$，使得$A=P^HP$</li></ul></li></ul></li><li><p>特征值与特征分解:</p><p>特征值特征向量定义：$\lambda$是特征值,$x$是特征向量,A是方阵</p><script type="math/tex; mode=display">Ax=\lambda x</script><p>求解走:</p><p>$Ax=\lambda x\rightarrow Ax=\lambda E x\rightarrow (\lambda E-A)x=0\rightarrow|\lambda E-A|=0$解出特征值带入得到特征向量</p><p>特征分解:对于mxm的满秩对称矩阵A</p><script type="math/tex; mode=display">A=Q\Sigma Q^{-1}=Q\Sigma Q^T</script><p>其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。</p><p>特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。</p></li></ul><h5 id="奇异值与奇异值分解"><a href="#奇异值与奇异值分解" class="headerlink" title="奇异值与奇异值分解"></a>奇异值与奇异值分解</h5><ol><li><p>运用到的理论:</p><ol><li>对于n阶方阵，$Ax=\lambda x$;</li><li>如果$\vec{a}$与$\vec{b}$正交,那么有$\vec{a} \cdot \vec{b} = 0$</li><li>一个内积空间的正交基（orthogonal basis）是元素两两正交的基,基中的元素称为基向量。如果一个正交基的基向量的模长都是单位长度1，则称这正交基为标准正交基或”规范正交基”（Orthonormal basis）；</li><li>A与A的转置矩阵是有相同的特征值,但是他们各自的特征向量没有关系；</li></ol></li><li><p><strong>SVD推导之矩阵分解:</strong></p><p>对于矩阵$A$,有$A^TA = \lambda_{i} v_{i}$(因为$A^TA$肯定是方阵);$\lambda_i$是特征值,$v_i$是特征向量;假设$(v_{i}, v_{j})$是一组正交基，那么有$v_{i}^{T} \cdot v_{j} = 0$，那么:</p><script type="math/tex; mode=display">\begin{align} (Av_{i}, Av_{j}) &= (Av_{i})^{T} \cdot Av_{j} \\ &= v_{i}^{T} A^T Av_{j} \\ &= v_{i}^{T} \lambda_{j} v_{j} \\ &= \lambda_{j} \color{red}{v_{i}^{T} v_{j} } \\ &= 0 \end{align} \tag{1}</script><p>可以得到$Av_{i}, Av_{j}$;根据公式$(1)$可以推导得到$(Av_{i}, Av_{i}) = \lambda_{i} v_{i}^{T} v_{i}=\lambda_{i}$;又因为行列式的性质$|AB|=|A||B|\rightarrow|(Av_{i})^{T} \cdot Av_{i}|=|Av_{i}^{T} ||Av_{i}|=|Av_{i}|^2$,所以有:</p><script type="math/tex; mode=display">\begin{align} & |Av_{i}|^2 = \lambda_{i} \\ & |Av_{i}| = \sqrt{\lambda_{i} } \end{align} \tag{2}</script><p>根据公式(2),有$\frac{Av_{i} }{|Av_{i}|} = \frac{1}{\sqrt{\lambda_{i} } } Av_{i}$，令$\frac{1}{\sqrt{\lambda_{i} } } Av_{i}= u_{i}$,可以得到:</p><script type="math/tex; mode=display">Av_{i}= \sqrt{\lambda_{i} }u_{i}=\delta_{i}u_{i} \tag{3}</script><p>其中$\delta_{i} = \sqrt{\lambda_{i} }$（这个称作奇异值）,进一步推导成矩阵形式:</p><script type="math/tex; mode=display">\begin{align} AV &= A(v_{1}, v_{2}, \dots, v_{n} ) \\ &= (Av_{1}, Av_{2}, \dots, Av_{n} ) \\ &= (\delta_{1}u_{1}, \delta_{2}u_{2}, \dots, \delta_{n}u_{n} ) \\ &= U\Sigma \end{align} \tag{4}</script><p>从而得到:</p><script type="math/tex; mode=display">A = U\Sigma V^T \tag{5}</script></li><li><p><strong>SVD推导之矩阵计算:</strong></p><p>已知$A$怎么算$U$和$V$呢？</p><p>首先计算$A$的转置$A^T$,而$A^T$相当于:</p><script type="math/tex; mode=display">\begin{align} A^T =  V\Sigma^TU^T \end{align} \tag{6}</script><p>然后计算$A^TA$:</p><script type="math/tex; mode=display">\begin{align} A^TA &= V\Sigma^TU^T U\Sigma V^T \\ &= V\Sigma^2V^T \end{align} \tag{7}</script><p>通过公式(7),会发现这不就是特征值分解嘛！！！可以得到$A^TA v_{i} = \lambda_{i}v_{i}$,只需要求出$A^TA$的特征向量就可以得到$V$了</p><p>同理计算$AA^T:$</p><script type="math/tex; mode=display">\begin{align} A A^T &= U\Sigma V^T V\Sigma^TU^T \\ &= U\Sigma^2U^T \end{align} \tag{8}</script><p>通过公式(8),可以得到$AA^T u_{i} = \lambda_{i}u_{i}$,只需要求出$AA^T$的特征向量就可以得到$U$了</p><p>$\Sigma$是上面公式(7)或者公式(8)中求到的非零特征值从大到小排列后开根号的值</p></li><li><p>SVD计算例子:</p><p>假设有一个矩阵$A$:</p><script type="math/tex; mode=display">A=\begin{bmatrix} 1&1\\1&1\\0&0\end{bmatrix}</script><p>要计算:</p><script type="math/tex; mode=display">A_{3\times 2}=U_{3\times 3}\Sigma_{3\times2}V^T_{2\times 2}</script><p>中的$U,V,\Sigma$</p><ol><li><p>计算$U$  </p><p>$AA^T=\begin{bmatrix} 2&amp;2&amp;0\\2&amp;2&amp;0\\0&amp;0&amp;0\end{bmatrix}$,进行特征分解，得到特征值[4,0,0]以及对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T,[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T,[0,0,1]^T$,可以得到：</p><script type="math/tex; mode=display">U=\begin{bmatrix} \frac{1}{\sqrt{2}}&-\frac{1}{\sqrt{2}}&0 \\ \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}&0 \\ 0&0&1 \end{bmatrix}</script></li></ol></li><li><p>计算$V$  </p><p>$A^TA=\begin{bmatrix} 2&amp;2 \\ 2&amp;2 \end{bmatrix}$,进行特征分解,得到特征值[4,0]以及对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T,[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T$,可以得到:</p><script type="math/tex; mode=display">   V=\begin{bmatrix} \frac{1}{\sqrt{2}}&-\frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}\end{bmatrix}</script></li><li><p>计算$\Sigma$ </p><p>因为特征值是[4,0]，因此:</p><script type="math/tex; mode=display">   \Sigma=\begin{bmatrix} 2&0 \\ 0&0 \\ 0&0 \end{bmatrix}</script><p>   所以$A$的SVD分解是:</p><script type="math/tex; mode=display">   A=U \Sigma V^T= \begin{bmatrix} \frac{1}{\sqrt{2}}&-\frac{1}{\sqrt{2}}&0 \\ \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}&0 \\ 0&0&1 \end{bmatrix} \begin{bmatrix} 2&0 \\ 0&0 \\ 0&0 \end{bmatrix} {\begin{bmatrix} \frac{1}{\sqrt{2}}&-\frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}\end{bmatrix}}^T=\begin{bmatrix} 1&1\\1&1\\0&0\end{bmatrix}</script></li><li><p>代码求解方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A=np.array([<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">print(np.linalg.svd(A))</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>以下主要是优化的部分</p></blockquote><h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><blockquote><p>To be done</p></blockquote><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul><li><a href="https://ryannng.github.io/2016/12/23/%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/" target="_blank" rel="noopener">向量范数与矩阵范数</a></li><li><a href="http://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">雅可比矩阵和海森矩阵</a></li><li><a href="https://www.cnblogs.com/pinard/p/10825264.html" target="_blank" rel="noopener">链式法则</a></li><li><a href="https://zhuanlan.zhihu.com/p/120333258" target="_blank" rel="noopener">Hermite矩阵性质</a></li><li><a href="https://blog.csdn.net/Junerror/article/details/80222540" target="_blank" rel="noopener">矩阵特征值求解</a></li><li><a href="https://blog.csdn.net/qq_30232405/article/details/104588293" target="_blank" rel="noopener">矩阵的基本知识</a></li><li><a href="http://www.csuldw.com/2017/03/09/2017-03-09-svd/#mjx-eqn-1" target="_blank" rel="noopener">矩阵的奇异值推导</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;机器学习导论-1-绪论与数学参考&quot;&gt;&lt;a href=&quot;#机器学习导论-1-绪论与数学参考&quot; class=&quot;headerlink&quot; title=&quot;机器学习导论-1 绪论与数学参考&quot;&gt;&lt;/a&gt;机器学习导论-1 绪论与数学参考&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;二
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-5:完善MRI</title>
    <link href="http://Tyler-ytr.github.io/2021/03/06/p4%E5%AD%A6%E4%B9%A0-5/"/>
    <id>http://Tyler-ytr.github.io/2021/03/06/p4学习-5/</id>
    <published>2021-03-06T08:44:38.000Z</published>
    <updated>2021-03-09T06:42:38.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="p4学习-5-完善MRI"><a href="#p4学习-5-完善MRI" class="headerlink" title="p4学习-5:完善MRI"></a>p4学习-5:完善MRI</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><p>这次实验的目的是在基本的L3转发上面拓展一个带内遥测(INT)的阉割版本，这里称作多跳路由检查(Multi-Hop Route Inspection)(MRI)。</p><blockquote><p> 根据维基百科，多跳路由(Multi-hop routing)是无线电网络中的一种通信，其中网络覆盖区域大域单个节点的无线电范围，因此要到达某一个目的地的时候一个节点可以使用其他节点做中继。</p></blockquote><p>MRI允许使用者追踪每一个包经过的路线以及序列的长度，为了支持这个功能需要写一个P4程序，这个程序能够在每一个包的header stack上面附加一个ID以及队列的长度。在收包的目的地，交换机ID的顺序相当于这个包走的路径，每一个ID后面都跟着这个交换机的队列长度。</p><blockquote><p>控制平面已经事先设置好了</p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>mri里面包括了两个自定义的头:<code>mri_t</code>包含了<code>count</code>，用来指示交换机ID的数量;<code>switch_t</code>包含了数据包经过的每个交换机跳的交换机ID和队列深度字段；</p><p>主要挑战是处理用于解析两个headers的递归逻辑；这里使用<code>parser_metada</code>字段的<code>remaining</code>来追踪有多少<code>switch_t</code>头需要来解析;在<code>parse_mri</code>状态,这个字段设置为<code>hdr.mri.count</code>。在<code>parse_swtrace</code>状态将转换到其自身，直到剩余为0。</p><p>MRI自定义报头会携带在IP Options 头里面,其中IP Options头里面的<code>option</code>用于指示选项的类型。 我们将使用特殊的类型31来表示MRI标头的存在。</p><p>除了解析器逻辑外，您还将在sgress中添加一个表，在<code>swtrace</code>中存储交换机ID和队列深度，并执行增加<code>count</code>字段的操作，并附加一个<code>switch_t</code>标头。</p><p>一个完整的<code>mri.p4</code>包含如下组件:</p><ol><li>以太网（<code>ethernet_t</code>），IPv4（<code>ipv4_t</code>），IP选项（<code>ipv4_option_t</code>），MRI（<code>mri_t</code>）和交换机（<code>switch_t</code>）的<strong>header头部类型定义</strong>。</li><li>以太网，IPv4，IP选项，MRI和交换机的<strong>解析器Parsers</strong>，将填充<code>ethernet_t</code>，<code>ipv4_t</code>，<code>ipv4_option_t</code>，<code>mri_t</code>和<code>switch_t</code>。</li><li>使用<code>mark_to_drop()</code>丢弃数据包的<strong>动作action</strong>。</li><li>一个<strong>action动作</strong>（称为<code>ipv4_forward</code>），它将：<ol><li>设置下一跳的出口端口。</li><li>用下一跳的地址更新以太网目标地址。</li><li>用交换机的地址更新以太网源地址。</li><li>减少TTL</li></ol></li><li>一个ingress control:<ol><li>定义一个表，该表将读取IPv4目标地址，并调用<code>drop</code>或<code>ipv4_forward</code>。</li><li>一个应用表的<code>apply</code>模块</li></ol></li><li>在egress部分，将添加交换机ID和队列深度的action动作（<code>add_swtrace</code>）。</li><li>一个egress control,它应用表（<code>swtrace</code>）来存储交换机ID和队列深度并调用<code>add_swtrace</code></li><li>用于选择将字段插入传出数据包的顺序的<strong>deparser。</strong></li><li>实例化</li></ol><p><strong>headers部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F;</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">const bit&lt;8&gt;  UDP_PROTOCOL &#x3D; 0x11;</span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;</span><br><span class="line">const bit&lt;5&gt;  IPV4_OPTION_MRI &#x3D; 31;</span><br><span class="line"></span><br><span class="line">#define MAX_HOPS 9</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line">typedef bit&lt;32&gt; switchID_t;</span><br><span class="line">typedef bit&lt;32&gt; qdepth_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123;</span><br><span class="line">    macAddr_t dstAddr;</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_option_t &#123;</span><br><span class="line">    bit&lt;1&gt; copyFlag;</span><br><span class="line">    bit&lt;2&gt; optClass;</span><br><span class="line">    bit&lt;5&gt; option;</span><br><span class="line">    bit&lt;8&gt; optionLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mri头</span><br><span class="line"></span><br><span class="line">header mri_t &#123;</span><br><span class="line">    bit&lt;16&gt;  count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header switch_t &#123;</span><br><span class="line">    switchID_t  swid;</span><br><span class="line">    qdepth_t    qdepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ingress_metadata_t &#123;</span><br><span class="line">    bit&lt;16&gt;  count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct parser_metadata_t &#123;</span><br><span class="line">    bit&lt;16&gt;  remaining;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123;</span><br><span class="line">    ingress_metadata_t   ingress_metadata;</span><br><span class="line">    parser_metadata_t   parser_metadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t         ethernet;</span><br><span class="line">    ipv4_t             ipv4;</span><br><span class="line">    ipv4_option_t      ipv4_option;</span><br><span class="line">    mri_t              mri;</span><br><span class="line">    switch_t[MAX_HOPS] swtraces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error &#123; IPHeaderTooShort &#125;</span><br></pre></td></tr></table></figure><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="1-先跑不完整的初始版本代码"><a href="#1-先跑不完整的初始版本代码" class="headerlink" title="1 先跑不完整的初始版本代码"></a>1 先跑不完整的初始版本代码</h5><p>先跑一下初始代码看看啥样，以便和之后的做对比</p><ol><li><p>在shell上面跑:</p><blockquote><p>make</p></blockquote><p>这步会:</p><ul><li>编译<code>mri.p4</code></li><li>启动一个 Mininet 实例，其中三个交换机(<code>s1</code>,<code>s2</code>,<code>s3</code>)设置在三角形结构里面。有5个主机.具体见拓扑图部分</li><li>主机被指定成了<code>10.0.1.1</code>, <code>10.0.2.2</code>，其他的也都是(<code>10.0.&lt;Switchid&gt;.&lt;hostID&gt;</code>)这种格式</li><li>控制平面部分的规则是基于<code>sx-runtime.json</code></li></ul></li><li><p>准备做的事情是在<code>h1</code>和<code>h2</code>之间发送低速率的流, 在<code>h11</code>和<code>h22</code>之间发送搞俗的测试流。<code>s1</code>和<code>s2</code>之间会形成一个拥塞因为在<code>topology.json</code>里面把带宽削减到了512kbps。因此如果我们在<code>h2</code>收包胡发现连接里面有很长的队列等待长度。</p><p>拓扑如下:</p><p><img src="/picture/setup.png" alt="Setup"></p></li><li><p>在make打开的Mininet命令行界面开四个窗口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; xterm h1 h11 h2 h22</span><br></pre></td></tr></table></figure></li><li><p>在h2的xterm里面打开收包的服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;receive.py</span><br></pre></td></tr></table></figure></li><li><p>在h22的xterm里面打开iperf UDP 服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s -u</span><br></pre></td></tr></table></figure></li><li><p>在h1的xterm里面使用<code>send.py</code>给h2每秒发一个包，发30秒:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./send.py 10.0.2.2 <span class="string">"P4 is cool"</span> 30</span><br></pre></td></tr></table></figure><p>在h2的xterm里面会收到”P4 is cool “信息</p></li><li><p>在h11的xterm里面，启动iperf客户端发送15秒:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c 10.0.2.22 -t 15 -u</span><br></pre></td></tr></table></figure></li><li><p>在h2端,MRI header没有hop信息(count=0)</p></li><li><p>退出来</p><p> 这里h2虽然接到了信息，但是没有关于这条消息经过的路径的信息。完善的内容就是在<code>mri.p4</code>里面完善MRI逻辑来记录路径信息。</p><ol><li><p>到目前的实验结果如下:</p><p><img src="/picture/image-20210309103128712.png" alt="h2"></p><p>会发现h2收到的MRI信息里面的count=0;</p><p>h22中因为线路的带宽有限，几次实验发现15秒发不完:</p><p><img src="/picture/image-20210309103437274.png" alt="h22"></p><p>h1和h11里面是发包的提示信息:</p><p>h1如下:</p><p><img src="/picture/image-20210309103534773.png" alt="h1"></p><p>h11如下:</p><p><img src="/picture/image-20210309103620003.png" alt="h11"></p></li></ol></li></ol><h5 id="2-控制平面相关"><a href="#2-控制平面相关" class="headerlink" title="2 控制平面相关"></a>2 控制平面相关</h5><blockquote><p>控制平面相关:P4程序定义了一个数据包处理管道，但是控制数据包的规则是由控制平面插入到管道中的。 当规则与数据包匹配时，将使用控制平面提供的参数作为规则的一部分来调用其动作。在本练习中，控制平面逻辑已经实现。 作为启动Mininet实例的一部分，make脚本将在每个交换机的表中安装数据包处理规则。 这些定义在sX-runtime.json文件中，其中X对应于交换机号。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1-runtime.json部分代码</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"target"</span>: <span class="string">"bmv2"</span>,</span><br><span class="line">  <span class="attr">"p4info"</span>: <span class="string">"build/mri.p4.p4info.txt"</span>,</span><br><span class="line">  <span class="attr">"bmv2_json"</span>: <span class="string">"build/mri.json"</span>,</span><br><span class="line">  <span class="attr">"table_entries"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"table"</span>: <span class="string">"MyEgress.swtrace"</span>,</span><br><span class="line">      <span class="attr">"default_action"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"action_name"</span>: <span class="string">"MyEgress.add_swtrace"</span>,</span><br><span class="line">      <span class="attr">"action_params"</span>: &#123;</span><br><span class="line">         <span class="attr">"swid"</span>: <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"table"</span>: <span class="string">"MyIngress.ipv4_lpm"</span>,</span><br><span class="line">      <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"hdr.ipv4.dstAddr"</span>: [<span class="string">"10.0.1.1"</span>, <span class="number">32</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"action_name"</span>: <span class="string">"MyIngress.ipv4_forward"</span>,</span><br><span class="line">      <span class="attr">"action_params"</span>: &#123;</span><br><span class="line">        <span class="attr">"dstAddr"</span>: <span class="string">"08:00:00:00:01:01"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//..............还有一部分已经省略</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现这里的表项和拓扑图以及P4代码里面的table息息相关，写法也和之前的P4runtime里面的相似</p><h5 id="3-完善MRI"><a href="#3-完善MRI" class="headerlink" title="3 完善MRI"></a>3 完善MRI</h5><p>见前面的代码实现部分</p><h5 id="4-运行解决方案"><a href="#4-运行解决方案" class="headerlink" title="4 运行解决方案"></a>4 运行解决方案</h5><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;p4学习-5-完善MRI&quot;&gt;&lt;a href=&quot;#p4学习-5-完善MRI&quot; class=&quot;headerlink&quot; title=&quot;p4学习-5:完善MRI&quot;&gt;&lt;/a&gt;p4学习-5:完善MRI&lt;/h2&gt;&lt;h4 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#实验目标&quot; cla
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode300-m</title>
    <link href="http://Tyler-ytr.github.io/2021/03/04/leetcode300-m/"/>
    <id>http://Tyler-ytr.github.io/2021/03/04/leetcode300-m/</id>
    <published>2021-03-04T15:31:23.000Z</published>
    <updated>2021-03-06T02:47:10.658Z</updated>
    
    <content type="html"><![CDATA[<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h4><p>难度中等1422收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以设计时间复杂度为 <code>O(n2)</code> 的解决方案吗？</li><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><p><strong>解答 :</strong></p><ol><li><p>$O(n^2)$的方法：</p><p>使用dp[i]表示[0,i]之间的最大子序列长度，根据最大子序列的定义来思考状态转移方程:</p><p>dp[i]=max(dp[i],dp[j]+1 if j&lt;i and nums[j]&lt;nums[i])</p><p>也就是一个循环遍历i，然后里面的循环遍历j，找到一个nums[i]小的然后更新;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _length=len(nums)</span><br><span class="line">        <span class="keyword">if</span> _length &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> _length</span><br><span class="line">        dp=[<span class="number">1</span>]*(_length+<span class="number">1</span>)</span><br><span class="line">        res=dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,_length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            res=max(res,dp[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>$O(NlogN)$的方法:</p><p>贪心加二分，不是很好想;</p><p>这里找的状态时tail[i],表示长度为<code>i+1</code>的<strong>所有</strong>上升子序列的结尾最小值;这里的tail[i]时严格递增的，可以用反证法证明;</p><p>这题就变成了维护tail这个数组，这个数组的长度就是我们要求的结果的长度;如何维护分为以下两步:</p><ul><li><p>扩充数组元素:</p><p>如果遍历nums的时候这个 nums[i]&gt;*(tail.end()),那么就把nums[i]添加到tail数组后面，此时相当于tail数组变长了一位;</p></li><li><p>更新数组里面的元素：</p><p>如果遍历nums的时候这个nums[i]&lt;*(tail.end()),那么就要看tail数组里面第一个大于nums[i]的数，然后把它换成nums[i];</p></li></ul><p>例子解释:</p><blockquote><p>[9,2,3,6,7,4],初始化的时候表示长度的end=1,tail[end]=-1001,下面的[]表示tail数组</p><p>[9] 遍历到9,9&gt;tail[end],tail[end]=9</p><p>[2] 遍历到2,2&lt;tail[end],找到第一个大于2的,只有9,替换</p><p>[2,3] 遍历到3,3&gt;tail[end],添加进去</p><p>[2,3,6] 同理</p><p>[2,3,6,7] 同理</p><p>[2,3,4,7] 遍历到4,4&lt;tail[end],找到第一个大于4的,把它变小成4</p></blockquote><p>直观的来看,tail 数组越紧致,它越容易边长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _length=len(nums)</span><br><span class="line">        tail=[<span class="number">-1001</span>]*(_length+<span class="number">1</span>)</span><br><span class="line">        end=<span class="number">1</span></span><br><span class="line">        tail[end<span class="number">-1</span>]=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,_length):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;tail[end<span class="number">-1</span>]:</span><br><span class="line">                end=end+<span class="number">1</span></span><br><span class="line">                tail[end<span class="number">-1</span>]=nums[i]</span><br><span class="line">            <span class="keyword">elif</span> nums[i]&lt;tail[end<span class="number">-1</span>]:</span><br><span class="line">                left=<span class="number">0</span></span><br><span class="line">                right=end<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                    mid=(left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tail[mid]&lt;nums[i]:</span><br><span class="line">                        left=mid+<span class="number">1</span> <span class="comment"># 中位数不是要找的数</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right=mid</span><br><span class="line">                tail[left]=nums[i]</span><br><span class="line">        <span class="keyword">return</span> end</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;300-最长递增子序列&quot;&gt;&lt;a href=&quot;#300-最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;300. 最长递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-in
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库与泛型编程学习笔记</title>
    <link href="http://Tyler-ytr.github.io/2021/03/04/STL/"/>
    <id>http://Tyler-ytr.github.io/2021/03/04/STL/</id>
    <published>2021-03-04T13:25:17.000Z</published>
    <updated>2021-03-08T13:06:36.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-标准库与泛型编程学习笔记"><a href="#C-标准库与泛型编程学习笔记" class="headerlink" title="C++标准库与泛型编程学习笔记"></a>C++标准库与泛型编程学习笔记</h1><blockquote><p>感谢侯捷老师</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>六大部件</p><ul><li>容器(containers):数据存放在里面</li><li>分配器(Allocators):支持容器的内存管理</li><li>算法(Algorithms):一个个模板函数</li><li>迭代器(Iterators):泛化的指针</li><li>适配器(Adapters):有容器/迭代器/仿函数适配器，可以帮他们进行转换</li><li><p>仿函数(Functors):相似于函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">........</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">6</span>]=&#123;<span class="number">27</span>,<span class="number">210</span>,....&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,allocator&lt;<span class="keyword">int</span>&gt;&gt;vi(ia,ia+<span class="number">6</span>);<span class="comment">//分配器不写会默认帮你搞好;vi是iterator;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count_if(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),notl(bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>)));<span class="comment">//count_if 是算法,not1是function adapter(negator)，表示否定，大于等于40;bind2nd是function adapter(binder),绑定第二参数,这里的作用是有没有小于40;less是function object 仿函数;not1(....)这行称作predicate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>复杂度 略</p></li><li><p>“前闭后开”区间：标准库用 c.begin()指的是头,c.end()指向尾巴的后面一个,因此是[);所以*(c.end())是不行的;</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite=c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;ite!=c.<span class="built_in">end</span>();++ite)&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//range-based for statement C++11</span></span><br><span class="line"><span class="keyword">for</span>(decl:coll)&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子:</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem:vec)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;elem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem:vec)&#123;</span><br><span class="line">    elem*=<span class="number">3</span>;<span class="comment">//使用引用才能变;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//auto的使用;</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;c;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;</span><br><span class="line">ite=::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),target);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">auto</span> ite=::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),target);</span><br></pre></td></tr></table></figure></li></ol><h2 id="容器测试"><a href="#容器测试" class="headerlink" title="容器测试"></a>容器测试</h2><ol><li><p>分类:</p><ol><li><p>Sequence Containers(序列式):</p><p>Array:固定元素大小的数组</p><p>Vector:末端可以扩张的数组</p><p>Deque(/dek/):前后可以扩张的数组,双向队列</p><p>List:双链</p><p>Forward-List:单链,内存小于前者</p></li><li><p>Associative Containers(关联式):</p><p>适合查找</p><p>Set/Multiset:集合,底部用红黑树做;Multiset可以重复</p><p>Map/Multimap:有序的键/值对,后者的key可以重复,底部用红黑树做;</p></li><li><p>Unordered Containers(不定序的元素):</p><p>Unordered set/Multiset:集合,底部基于哈希-拉链法</p><p>Unordered Map/Multimap:有序的键/值对,底部基于哈希-拉链法</p></li></ol></li><li><p>容器速率直观比较:</p><p>(单位是毫秒)</p><ul><li><p>Array:47,187(项目:50万随机数for循环赋值时间和排序+二分查找时间)</p></li><li><p>Vector:3063,2765(项目:100万随机数for循环push_back和排序+二分查找时间）a.size()=1000000,a.capacity()=1048576,因为vector增加的时候会预留空间,长着长着开一个两倍的空间复制进去;这个例子里面用find找元素比排序+二分快,0毫秒</p></li><li><p>List:3265,2312,16(项目:100万随机数for循环push_back和排序+二分查找时间和find的时间),list自带sort</p></li><li><p>forward_list:3204,15,2656(项目:100万随机数,find的时间,sort的时间) ，它也自带sort</p></li><li><p>slist:非标准库里面,#include<ext\slist>里面有;和forward_list使用差不多;</p></li><li><p>deque:2704,15,3110(项目:100万随机数push_back,find函数,使用全局sort)deque的连续是一种假象;它是分段连续,分成一个个buffer,由指针指着;如果buffer用完了就再申请一块buffer;</p></li><li><p>stack: deque其实涵盖了stack和queue;它们两个的底层都是deque;812(项目:30万随机数push)</p></li><li><p>queue:890(项目:30万随机数push)</p><blockquote><p>因为stack,queue是由deque实现的,所以也被称为容器适配器</p></blockquote></li><li><p>multiset:6609,203,0(项目:100万随机数insert放进去和全局find和自己的find)关联式容器找东西非常快</p></li><li><p>multimap:4812,0(项目:<index,100万随机数> insert放进去和自己的find)</p></li><li><p>unordered_multiset:4406,109,0(项目:100万随机数insert进去和全局find和自带find) ;bucket_count()可以看出篮子的个数,篮子一定比元素多;load_factor()可以看出负载因子;</p></li><li><p>unordered_multimap:4313,0(项目:100万随机数insert进去和自带的find)</p></li><li><p>set:3922,0,0(项目:100万随机数insert进去和全局find和自带find)</p></li><li><p>map:4890,0(项目:100万放进去和自带的find)；multiset不能用<code>c[i]=string(buf)</code>只能用insert函数插入,但是map可以；</p></li><li><p>unordered_map,unordered_set:略</p></li><li><p>一些老版本的容器比如slist,hash_set,hash_map.hash_multiset,hash_multimap要另外include;</p></li></ul></li></ol><h2 id="分配器测试"><a href="#分配器测试" class="headerlink" title="分配器测试:"></a>分配器测试:</h2><p>下面都是GNU-C里面的:</p><ol><li><p>分类器使用示例: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typename_Tp,typename_Alloc=<span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;class <span class="built_in">vector</span>:protected_Vector_base&lt;_Tp,_Alloc&gt;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>不同分配器的使用示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用std::allocator意外的allocator需要自行#include&lt;ext\....&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\array_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\mt_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\debug_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\pool_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\bitmap_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\new_allocator.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,allocator&lt;<span class="built_in">string</span>&gt;&gt; c1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::malloc_allocator&lt;<span class="built_in">string</span>&gt;&gt; c2;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::new_allocator&lt;<span class="built_in">string</span>&gt;&gt; c3;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::__pool_allocator&lt;<span class="built_in">string</span>&gt;&gt; c4;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::__mt_allocator&lt;<span class="built_in">string</span>&gt;&gt; c5;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::bitmap_allocator&lt;<span class="built_in">string</span>&gt;&gt; c6;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>分配器可以分配内存，但是不如malloc/free;new/delete舒服，释放内存很麻烦;比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int*p;</span><br><span class="line">allocator&lt;int&gt;alloc1;</span><br><span class="line">p&#x3D;alloc1.allocate(1);</span><br><span class="line">alloc1.deallocate(p,1);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-标准库与泛型编程学习笔记&quot;&gt;&lt;a href=&quot;#C-标准库与泛型编程学习笔记&quot; class=&quot;headerlink&quot; title=&quot;C++标准库与泛型编程学习笔记&quot;&gt;&lt;/a&gt;C++标准库与泛型编程学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;感谢侯捷老师&lt;
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-4:P4runtime实验</title>
    <link href="http://Tyler-ytr.github.io/2021/03/02/p4%E5%AD%A6%E4%B9%A0-4/"/>
    <id>http://Tyler-ytr.github.io/2021/03/02/p4学习-4/</id>
    <published>2021-03-02T14:06:07.000Z</published>
    <updated>2021-03-05T08:44:52.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="p4学习-4-P4runtime实验"><a href="#p4学习-4-P4runtime实验" class="headerlink" title="p4学习-4:P4runtime实验"></a>p4学习-4:P4runtime实验</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><p>使用P4Runtime而不是来交换机的CLI发送flow entries;P4程序是在basic tunnel里面的程序的基础上写的，改名叫了 <code>advanced_tunnel.p4</code>，并且增加了两个counters(<code>ingressTunnelCounter</code>, <code>egressTunnelCounter</code>)和两个actions(<code>myTunnel_ingress</code>, <code>myTunnel_egress</code>)</p><p>使用启动程序<code>mycontroller.py</code>以及一些 <code>p4runtime_lib</code> 库里面的函数来创建主机1和主机2之间隧道通信所需的表项。</p><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><p>主要是<code>mycontroller.py</code>里面的<code>writeTunnelRules</code>函数的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import P4Runtime lib from parent utils dir</span></span><br><span class="line"><span class="comment"># Probably there's a better way of doing this.</span></span><br><span class="line">sys.path.append(</span><br><span class="line">    os.path.join(os.path.dirname(os.path.abspath(__file__)),</span><br><span class="line">                 <span class="string">'../../utils/'</span>))</span><br><span class="line"><span class="keyword">import</span> p4runtime_lib.bmv2</span><br><span class="line"><span class="keyword">from</span> p4runtime_lib.switch <span class="keyword">import</span> ShutdownAllSwitchConnections</span><br><span class="line"><span class="keyword">import</span> p4runtime_lib.helper</span><br><span class="line"></span><br><span class="line">SWITCH_TO_HOST_PORT = <span class="number">1</span></span><br><span class="line">SWITCH_TO_SWITCH_PORT = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeTunnelRules</span><span class="params">(p4info_helper, ingress_sw, egress_sw, tunnel_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                     dst_eth_addr, dst_ip_addr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Installs three rules:</span></span><br><span class="line"><span class="string">    1) An tunnel ingress rule on the ingress switch in the ipv4_lpm table that encapsulates traffic into a tunnel with the specified ID</span></span><br><span class="line"><span class="string">    ipv4_lpm表的入接口开关上的隧道入接口规则，该规则用指定的ID将流量封装到一个隧道中</span></span><br><span class="line"><span class="string">    2) A transit rule on the ingress switch that forwards traffic based on the specified ID</span></span><br><span class="line"><span class="string">    入口交换机上的一种传输规则，根据指定的ID转发流量</span></span><br><span class="line"><span class="string">    3) An tunnel egress rule on the egress switch that decapsulates traffic with the specified ID and sends it to the host</span></span><br><span class="line"><span class="string">    出口交换机上的一条隧道出口规则，将指定ID的流量解封装后发送给主机</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param p4info_helper: the P4Info helper</span></span><br><span class="line"><span class="string">    :param ingress_sw: the ingress switch connection</span></span><br><span class="line"><span class="string">    :param egress_sw: the egress switch connection</span></span><br><span class="line"><span class="string">    :param tunnel_id: the specified tunnel ID</span></span><br><span class="line"><span class="string">    :param dst_eth_addr: the destination IP to match in the ingress rule</span></span><br><span class="line"><span class="string">    :param dst_ip_addr: the destination Ethernet address to write in the egress rule</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1) Tunnel Ingress Rule</span></span><br><span class="line">    table_entry = p4info_helper.buildTableEntry(</span><br><span class="line">        table_name=<span class="string">"MyIngress.ipv4_lpm"</span>,</span><br><span class="line">        match_fields=&#123;</span><br><span class="line">            <span class="string">"hdr.ipv4.dstAddr"</span>: (dst_ip_addr, <span class="number">32</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        action_name=<span class="string">"MyIngress.myTunnel_ingress"</span>,</span><br><span class="line">        action_params=&#123;</span><br><span class="line">            <span class="string">"dst_id"</span>: tunnel_id,</span><br><span class="line">        &#125;)</span><br><span class="line">    ingress_sw.WriteTableEntry(table_entry)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Installed ingress tunnel rule on %s"</span> % ingress_sw.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2) Tunnel Transit Rule</span></span><br><span class="line">    <span class="comment"># The rule will need to be added to the myTunnel_exact table and match on the tunnel ID (hdr.myTunnel.dst_id). Traffic will need to be forwarded using the myTunnel_forward action on the port connected to the next switch.这条规则是添加到myTunnel_exact table上面的，match的部分是tunnel ID (hdr.myTunnel.dst_id)。流量将会使用myTunnel_forward action转发到连接下一个交换机的端口，这里要观察下面的拓扑图会发现连接交换机(h1,h2)的都是二号端口，文件里面用SWITCH_TO_SWITCH_PORT表示了2号端口</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># For our simple topology, switch 1 and switch 2 are connected using a link attached to port 2 on both switches. We have defined a variable at the top of the file, SWITCH_TO_SWITCH_PORT, that you can use as the output port for this action.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># We will only need a transit rule on the ingress switch because we are using a simple topology. In general, you'll need on transit rule for each switch in the path (except the last switch, which has the egress rule), and you will need to select the port dynamically for each switch based on your topology.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO build the transit rule</span></span><br><span class="line">    <span class="comment"># TODO install the transit rule on the ingress switch</span></span><br><span class="line">    <span class="comment">#print "TODO Install transit tunnel rule"</span></span><br><span class="line">table_entry=p4info_helper.buildTableEntry(</span><br><span class="line">    table_name=<span class="string">"MyIngress.myTunnel_exact"</span>,</span><br><span class="line">        match_fields=&#123;</span><br><span class="line">            <span class="string">"hdr.myTunnel.dst_id"</span>:tunnel_id</span><br><span class="line">        &#125;,</span><br><span class="line">        action_name=<span class="string">"MyIngress.myTunnel_forward"</span>,</span><br><span class="line">        action_params=&#123;</span><br><span class="line">            <span class="string">"port"</span>:SWITCH_TO_SWITCH_PORT</span><br><span class="line">        &#125;)</span><br><span class="line">    ingress_sw.WriteTableEntry(table_entry)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Installed transit tunnel rule on %s"</span> % ingress_sw.name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3) Tunnel Egress Rule</span></span><br><span class="line">    <span class="comment"># For our simple topology, the host will always be located on the SWITCH_TO_HOST_PORT (port 1).</span></span><br><span class="line">    <span class="comment"># In general, you will need to keep track of which port the host is connected to.</span></span><br><span class="line">    table_entry = p4info_helper.buildTableEntry(</span><br><span class="line">        table_name=<span class="string">"MyIngress.myTunnel_exact"</span>,</span><br><span class="line">        match_fields=&#123;</span><br><span class="line">            <span class="string">"hdr.myTunnel.dst_id"</span>: tunnel_id</span><br><span class="line">        &#125;,</span><br><span class="line">        action_name=<span class="string">"MyIngress.myTunnel_egress"</span>,</span><br><span class="line">        action_params=&#123;</span><br><span class="line">            <span class="string">"dstAddr"</span>: dst_eth_addr,</span><br><span class="line">            <span class="string">"port"</span>: SWITCH_TO_HOST_PORT</span><br><span class="line">        &#125;)</span><br><span class="line">    egress_sw.WriteTableEntry(table_entry)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Installed egress tunnel rule on %s"</span> % egress_sw.name</span><br><span class="line">    </span><br><span class="line"><span class="comment">#### 下面的函数省略不表</span></span><br></pre></td></tr></table></figure><p>实际写的时候主要依靠下面的Tunnel Egress Rule规则仿写,主要p4文件里面:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">**************  I N G R E S S   P R O C E S S I N G   *******************</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function">control <span class="title">MyIngress</span><span class="params">(inout headers hdr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  inout metadata meta,</span></span></span><br><span class="line"><span class="function"><span class="params">                  inout <span class="keyword">standard_metadata_t</span> standard_metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) ingressTunnelCounter;</span><br><span class="line">    counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) egressTunnelCounter;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">drop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">action <span class="title">ipv4_forward</span><span class="params">(macAddr_t dstAddr, egressSpec_t port)</span> </span>&#123;</span><br><span class="line">        standard_metadata.egress_spec = port;</span><br><span class="line">        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr = dstAddr;</span><br><span class="line">        hdr.ipv4.ttl = hdr.ipv4.ttl - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">myTunnel_ingress</span><span class="params">(<span class="built_in">bit</span>&lt;<span class="number">16</span>&gt; dst_id)</span> </span>&#123;</span><br><span class="line">        hdr.myTunnel.setValid();</span><br><span class="line">        hdr.myTunnel.dst_id = dst_id;</span><br><span class="line">        hdr.myTunnel.proto_id = hdr.ethernet.etherType;</span><br><span class="line">        hdr.ethernet.etherType = TYPE_MYTUNNEL;</span><br><span class="line">        ingressTunnelCounter.count((<span class="built_in">bit</span>&lt;<span class="number">32</span>&gt;) hdr.myTunnel.dst_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">myTunnel_forward</span><span class="params">(egressSpec_t port)</span> </span>&#123;</span><br><span class="line">        standard_metadata.egress_spec = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">myTunnel_egress</span><span class="params">(macAddr_t dstAddr, egressSpec_t port)</span> </span>&#123;</span><br><span class="line">        standard_metadata.egress_spec = port;</span><br><span class="line">        hdr.ethernet.dstAddr = dstAddr;</span><br><span class="line">        hdr.ethernet.etherType = hdr.myTunnel.proto_id;</span><br><span class="line">        hdr.myTunnel.setInvalid();</span><br><span class="line">        egressTunnelCounter.count((<span class="built_in">bit</span>&lt;<span class="number">32</span>&gt;) hdr.myTunnel.dst_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key = &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions = &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            myTunnel_ingress;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1024</span>;</span><br><span class="line">        default_action = NoAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table myTunnel_exact &#123;</span><br><span class="line">        key = &#123;</span><br><span class="line">            hdr.myTunnel.dst_id: exact;</span><br><span class="line">        &#125;</span><br><span class="line">        actions = &#123;</span><br><span class="line">            myTunnel_forward;</span><br><span class="line">            myTunnel_egress;</span><br><span class="line">            drop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1024</span>;</span><br><span class="line">        default_action = drop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        <span class="keyword">if</span> (hdr.ipv4.<span class="built_in">isValid</span>() &amp;&amp; !hdr.myTunnel.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">            <span class="comment">// Process only non-tunneled IPv4 packets.</span></span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hdr.myTunnel.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">            <span class="comment">// Process all tunneled packets.</span></span><br><span class="line">            myTunnel_exact.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match_field里面相当于action里面的key部分,具体的值由控制平面也就是函数里面的<code>tunnel_id</code>确定;action_name里面相当于调用了<code>action myTunnel_forward</code>,这个action的参数只有<code>port</code>,又因为题目里面的提示要求port是<code>SWITCH_TO_SWITCH_PORT</code>因此填进去就行了;</p><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="1-跑未完成的代码"><a href="#1-跑未完成的代码" class="headerlink" title="1 跑未完成的代码"></a>1 跑未完成的代码</h5><ol><li><p><code>mycontroller.py</code>里面包含了一些隧道通信需要的规则，在没有完成的情况下先跑p4看看啥样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>这步编译了 <code>advanced_tunnel.p4</code>,</li><li>启动一个Mininet实例，其中三个交换机(<code>s1</code>, <code>s2</code>, <code>s3</code>)配置在一个三角形中，每个交换机连接到一个主机(<code>h1</code>, <code>h2</code>, <code>h3</code>)，并且把<code>10.0.1.1</code>, <code>10.0.2.2</code>, <code>10.0.3.3</code>这些IP配置到对应的主机上</li></ul></li><li><p>现在会看到mininet命令窗口，ping h1 和 h2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; h1 ping h2</span><br></pre></td></tr></table></figure><p>因为交换机上面没有规则，现在还没法接受回应，然后如果ctrl+C就如下图各种丢包；</p><p><img src="/picture/image-20210303234909688.png" alt="image-20210303234909688"></p><p>现在把这个ping留着继续跑然后开另一个shell</p></li><li><p>在另一个shell里面跑:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/tutorials/exercises/p4runtime</span><br><span class="line">./mycontroller.py</span><br></pre></td></tr></table></figure><p>这会安装<code>advanced_tunnel.p4</code>程序到switch上面并且把tunnel ingress规则推进去；这个程序每两秒打印ingress和egress的counters</p><p><img src="/picture/image-20210304163414071.png" alt="image-20210304163414071"></p><p>因为目前没有完成还有一些TODO的部分，所以下面可以看到这些包经过s1的ingress并且让计数器增加；</p></li><li><p>Ctrl-c退出</p><p>目前的交换机是根据目的IP地址将流量映射到隧道(ID)上面，要做的工作是写规则，从而让交换机能够基于隧道(tunnel) ID来转发流量 </p></li></ol><blockquote><p>和前面的对比：之前的都是依靠一些json文件静态的设置表项，这里是动态的；要注意到p4 程序仅仅定义了一个包处理的管道，但是是不包含具体的规则的；</p><p>P4程序定义了包处理管道（规则由控制平面插入），同时定义了交互机的pipeline和控制平面的接口（这部分在advanced_tunnel.p4info）里面；在mycontroller. py里面构建的表项(table entries)会根据名称引用特定的表、键和actions；使用p4info会将名字转换程P4runtime所需要的ID。在P4程序中添加或者重命名的表、键、actions都要反映在 py程序的表项(table entries)里面</p></blockquote><h5 id="2-完善隧道转发"><a href="#2-完善隧道转发" class="headerlink" title="2 完善隧道转发"></a>2 完善隧道转发</h5><ol><li><p>p4runtime_lib库里面的总结,这部分代码在tutorials/utils/p4runtime_lib里面:</p><ul><li><p><code>p4runtime_lib.helper</code></p><ul><li>包含了<code>P4InfoHelper</code> 类能够解析<code>P4Info</code>文件，包括了name,id,alias,match_field(本身/id/name/pb/value)，action_param(本身/id/name/pb)</li><li>提供了实体的名字到ID数字转换的方法(buildTableEnrty函数)</li><li>构建P4Runtime表项的P4依赖于程序的部分。</li></ul></li><li><p><code>p4runtime_lib.switch.py</code></p><ul><li>包括了<code>SwitchConnection</code>类，会获取gRPC的client stub以及给交换机建立连接</li><li>提供了helper方法，能够构建P4Runtime协议的buffer信息以及制作P4Runtime gRPC service calls</li></ul></li><li><p><code>p4runtime_lib.bmv2.py</code></p><ul><li><p>包含了 <code>Bmv2SwitchConnection</code> 类，它拓展了<code>SwitchConnections</code>并且提供了BMv2-specific 设备载荷来装载P4程序</p><blockquote><p> PS:实际上是重载了SwitchConnection 然后多了一个buildDeviceConfig函数能够根据bmv2_json_file来返回设备的配置</p></blockquote></li></ul></li><li><p><code>p4runtime_lib.convert.py</code></p><ul><li>由<code>helper.py</code>调用</li><li>主要提供了一些把数字/字符串编码协议buffer信息需要的格式的方法以及相应的解码方法</li></ul></li></ul></li><li><p><code>mycontroller.py</code>是一个结能的控制平面做了以下的事情</p><ol><li>为P4Runtime服务构建了一个到交换机的 gRPC连接</li><li>把P4程序push给各个交换机</li><li>在h1,h2之间的两个隧道编写了ingress/egress规则</li><li>每两秒读隧道的ingress/egress计数器</li></ol></li><li><p>代码部分主要要做的事情是在 <code>writeTunnelRules</code>函数里面写隧道转发规则，它对应于隧道ID并且能够把包转发到下一跳</p></li><li><p>拓扑图如下:</p><p><img src="/picture/topo_basic_tunnel-1614931073774.png" alt="topology"></p></li></ol><h5 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3 实验结果"></a>3 实验结果</h5><p>先<code>make clean</code>再<code>make</code>，然后<code>h1 ping h2</code>，然后开一个新端口<code>./mycontroller.py</code>，这个时候可以看见ingress,egress的计数都上涨了:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210305163701102.png" alt="py_info" title="">                </div>                <div class="image-caption">py_info</div>            </figure><p>另外ping也能够成功的收到了:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210305163722778.png" alt="mini_info" title="">                </div>                <div class="image-caption">mini_info</div>            </figure><h4 id="额外参考——rpc-grpc学习"><a href="#额外参考——rpc-grpc学习" class="headerlink" title="额外参考——rpc,grpc学习"></a>额外参考——rpc,grpc学习</h4><p>左转参考博客</p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul><li><a href="https://www.cnblogs.com/duanxz/p/3769872.html" target="_blank" rel="noopener">rpc介绍</a></li><li><a href="https://www.shuzhiduo.com/A/n2d9O7yQJD/" target="_blank" rel="noopener">P4 runtime 和 p4 info</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;p4学习-4-P4runtime实验&quot;&gt;&lt;a href=&quot;#p4学习-4-P4runtime实验&quot; class=&quot;headerlink&quot; title=&quot;p4学习-4:P4runtime实验&quot;&gt;&lt;/a&gt;p4学习-4:P4runtime实验&lt;/h2&gt;&lt;h4 id=&quot;实
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode303-s</title>
    <link href="http://Tyler-ytr.github.io/2021/03/01/leetcode303-s/"/>
    <id>http://Tyler-ytr.github.io/2021/03/01/leetcode303-s/</id>
    <published>2021-03-01T12:18:36.000Z</published>
    <updated>2021-03-01T12:36:04.639Z</updated>
    
    <content type="html"><![CDATA[<h4 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></h4><p>难度简单283收藏分享切换为英文接收动态反馈</p><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>104</code> 次 <code>sumRange</code> 方法</li></ul><p><strong>解答：</strong></p><p>使用前缀和方法，前缀和表示的是[0,i)之间的和，比如对于数组 [1,2,3,4,5],presum[0]=0,presum[1]=0+1=1……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)+<span class="number">1</span>):</span><br><span class="line">presum[i+<span class="number">1</span>]=presum[i]+nums[i]</span><br></pre></td></tr></table></figure><p>因此本题解法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        _length=len(nums)</span><br><span class="line">        self.presum=[<span class="number">0</span>]*(_length+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,_length):</span><br><span class="line">            self.presum[i+<span class="number">1</span>]=self.presum[i]+nums[i]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i: int, j: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.presum[j+<span class="number">1</span>]-self.presum[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(i,j)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;303. 区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/probl
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="前缀和" scheme="http://Tyler-ytr.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1176-h</title>
    <link href="http://Tyler-ytr.github.io/2021/02/26/leetcode1176-h/"/>
    <id>http://Tyler-ytr.github.io/2021/02/26/leetcode1176-h/</id>
    <published>2021-02-26T09:05:15.000Z</published>
    <updated>2021-02-26T09:14:39.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1178-猜字谜"><a href="#1178-猜字谜" class="headerlink" title="1178. 猜字谜"></a><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/" target="_blank" rel="noopener">1178. 猜字谜</a></h4><p>难度困难149</p><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li><li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）都不能作为谜底。</li></ul><p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words &#x3D; [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], </span><br><span class="line">puzzles &#x3D; [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]</span><br><span class="line">输出：[1,1,3,2,4,0]</span><br><span class="line">解释：</span><br><span class="line">1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; </span><br><span class="line">1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;</span><br><span class="line">3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;</span><br><span class="line">2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;</span><br><span class="line">4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;</span><br><span class="line">没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#39;g&#39;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^5</code></li><li><code>4 &lt;= words[i].length &lt;= 50</code></li><li><code>1 &lt;= puzzles.length &lt;= 10^4</code></li><li><code>puzzles[i].length == 7</code></li><li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li><li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li></ul><p><strong>解答：</strong></p><p>这题有两个要思考的点，第一个是怎么压缩状态，非常自然的想到二进制，英文字母一共26位，用int完全可以表示，通过这一点可以想到一个朴素的方法（TLE）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int 二进制有32位 英文字母一共26位 出现一次该位为1</span></span><br><span class="line">        <span class="comment">//a最小,z最大</span></span><br><span class="line">        <span class="comment">//如果字谜A包含了wordB,首先A&amp;B==1，判断A中的第一个字母有没有包含在B里面 假设该字母是00010,取反是11101，(11101|B)&amp;(00010)表示有</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result(puzzles.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;wordmap(words.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;puzzlemap(puzzles.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                temp=<span class="number">1</span>&lt;&lt;(<span class="keyword">int</span>)(words[i][j]-<span class="string">'a'</span>);</span><br><span class="line">                wordmap[i]|=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;puzzles.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;puzzles[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                temp=<span class="number">1</span>&lt;&lt;(<span class="keyword">int</span>)(puzzles[i][j]-<span class="string">'a'</span>);</span><br><span class="line">                puzzlemap[i]|=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;puzzles.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="number">1</span>&lt;&lt;(<span class="keyword">int</span>)(puzzles[i][<span class="number">0</span>]-<span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">if</span>((~temp|wordmap[j])&amp;temp)&#123;</span><br><span class="line">                    <span class="keyword">int</span> a=puzzlemap[i];</span><br><span class="line">                    <span class="keyword">int</span> b=wordmap[j];</span><br><span class="line">                    <span class="keyword">if</span>((a&amp;b)==b)&#123;</span><br><span class="line">                        result[i]+=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法就是先将words,puzzles都压缩成二进制串然后一对一比较，后面比较是一个O($N^2$),并且没有利用<code>puzzles[i].length == 7</code>这个条件，因此会TLE；（这是TLE的<a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/xiang-jin-zhu-shi-xiang-jie-po-su-wei-yu-3cr2/" target="_blank" rel="noopener">分析</a>）</p><p>根据<code>puzzles[i].length == 7</code>，然后可以联想到优化的方法，因为长度是固定的，所以它的子集数目也是比较小的，因此可以将words做一个unorderer_map，然后对于pussles压缩之后的每一个子集进行查询即可。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算</span></span><br><span class="line">        <span class="comment">//int 二进制有32位 英文字母一共26位 出现一次该位为1</span></span><br><span class="line">        <span class="comment">//a最小,z最大</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何枚举一个二进制数的子集：</span></span><br><span class="line">        <span class="comment">//也就是10101的子集是10101,10100,10001,10000,00101,00100,00001,00000;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int sub = k;</span></span><br><span class="line"><span class="comment">        do &#123;</span></span><br><span class="line"><span class="comment">            sub = (sub - 1) &amp; k;</span></span><br><span class="line"><span class="comment">        &#125; while(sub != k);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count; </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> &amp;<span class="keyword">word</span>: words) &#123;<span class="comment">//注意</span></span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : <span class="keyword">word</span>)</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>));</span><br><span class="line">            count[mask]+=<span class="number">1</span>;<span class="comment">//如果出现了那么对应的count那么这个count应该为1</span></span><br><span class="line">           <span class="comment">// cout&lt;&lt;count[mask];</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=puzzles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            <span class="built_in">string</span>&amp;puzzle=puzzles[i];</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch:puzzle)&#123;</span><br><span class="line">                k|=(<span class="number">1</span>&lt;&lt;(ch-<span class="string">'a'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sub = k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                sub = (sub - <span class="number">1</span>) &amp; k;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">'a'</span>)) &amp; sub)</span><br><span class="line">                    result[i] += count[sub];</span><br><span class="line">            &#125; <span class="keyword">while</span>(sub != k);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1178-猜字谜&quot;&gt;&lt;a href=&quot;#1178-猜字谜&quot; class=&quot;headerlink&quot; title=&quot;1178. 猜字谜&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-valid-wor
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="位运算" scheme="http://Tyler-ytr.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读一篇论文阅读笔记</title>
    <link href="http://Tyler-ytr.github.io/2021/02/25/how-to-read-a-paper-notes/"/>
    <id>http://Tyler-ytr.github.io/2021/02/25/how-to-read-a-paper-notes/</id>
    <published>2021-02-25T08:59:25.000Z</published>
    <updated>2021-03-01T11:32:18.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="How-to-read-a-paper-阅读笔记"><a href="#How-to-read-a-paper-阅读笔记" class="headerlink" title="How to read a paper 阅读笔记"></a>How to read a paper 阅读笔记</h2><blockquote><p>原文链接:<a href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf" target="_blank" rel="noopener">https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf</a></p><p>由刘恩萌启发</p></blockquote><p><strong>3段方法</strong></p><ol><li><p>1st pass</p><ol><li>仔细阅读标题，abstract和intruduction，结论；浏览section &amp; subsection的标题、数学内容；reference；其他部分一概忽略</li><li>能够回答下面的五个C:<ol><li>Category:(类型：测量/分析/描述……)</li><li>Context:(有关论文？理论基础？…… )</li><li>Correctness:（假设看上去正确吗？……）</li><li>Contributions</li><li>Clarity:（写的咋样……）</li></ol></li><li>通过这些内容决定是否进一步阅读</li></ol></li><li><p>2nd pass</p><ol><li>比第一遍更认真的看，可以记一些笔记在空白处，划重点；看完之后应该能够把握论文内容</li><li>认真看图表，看看有没有错</li><li>标注没读过的相关文献以便进一步了解背景</li><li>如果看完还是懵逼，以下三选一：<ol><li>扔一边不看了</li><li>过一会/看完背景材料再看</li><li>坚持不懈并且进入步骤3</li></ol></li></ol></li><li><p>3rd pass</p><ol><li><p>virtually re-implement:</p><p>标注作者的假设，然后在这些假设基础(虚拟)上重新实现这个工作，通过将重新实现和作者文章的比较，很容易发现它的创新点以及隐藏的错误/假设</p></li><li><p>重点是关注细节，积累对未来工作的想法</p></li><li><p>在这一阶段结束时，能够根据记忆重建整篇文章的结构，并且能够识别出它的优缺点。</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;How-to-read-a-paper-阅读笔记&quot;&gt;&lt;a href=&quot;#How-to-read-a-paper-阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;How to read a paper 阅读笔记&quot;&gt;&lt;/a&gt;How to read a 
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>p4学习-3:P4 basic tunnel实验</title>
    <link href="http://Tyler-ytr.github.io/2021/02/24/p4%E5%AD%A6%E4%B9%A0-3/"/>
    <id>http://Tyler-ytr.github.io/2021/02/24/p4学习-3/</id>
    <published>2021-02-24T08:52:17.000Z</published>
    <updated>2021-03-05T08:01:47.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-3：P4-basic-tunnel实验"><a href="#P4学习-3：P4-basic-tunnel实验" class="headerlink" title="P4学习-3：P4 basic tunnel实验"></a>P4学习-3：P4 basic tunnel实验</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><ol><li><p>在本练习中，我们将向IP添加对基本隧道协议的支持</p><p>你在上一个作业中完成的路由器。基本交换机根据目的IP地址进行转发。您的工作是定义一个新的头类型来封装IP包并修改交换代码，这样它就可以使用一个新的隧道头来决定目的端口。</p><p>新的头类型将包含协议ID，它指示被封装的包的类型，以及用于路由的目的地ID。</p></li><li><p>P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。</p><p>对于本练习，我们已经添加了必要的静态控制平面条目。作为启动Mininet实例的一部分，<code>make run</code>命令将在每个交换机的表中安装包处理规则。这些是在<code>sX-runtime</code>中定义的<code>json files</code>，其中<code>X</code>对应开关号。</p><p>因为控制平面试图访问<code>myTunnel_exact</code>表，而这个表还不存在，所以<code>make run</code>命令不能与启动器代码一起工作。</p><p>PS：这里使用P4Runtime来安装规则，文件内容在<code>sX-runtime.json</code>里面</p></li><li><p>拓扑如下:</p><p><img src="/picture/topo_basic_tunnel.png" alt="pod-topo"></p></li><li><p><code>basic_tunnel.p4</code>文件包含了一个基本的IP路由器的实现，完整的实现版本将能够转发基于自定义封装头的内容，以及如果封装头在数据包中不存在，那么将执行正常的IP转发。工作有以下几个部分:</p><ol><li><strong>NOTE:</strong>添加了一个新的头类型称作<code>myTunnel_t</code> ,包含了<code>proto_id</code> and <code>dst_id</code></li><li><strong>NOTE:</strong><code>myTunnel_t</code> 已经加入了<code>myTunnel_t</code> header</li><li><strong>TODO:</strong>更新解析器，根据以太网头中的<code>etherType</code>字段提取<code>myTunnel</code>头或<code>ipv4</code>头。myTunnel报头对应的etherType是’ 0x1212 ‘。如果<code>proto_id</code> == <code>TYPE_IPV4 &#39;</code>即0x0800)，解析器还应该在<code>myTunnel 头</code>之后提取<code>ipv4</code>头。</li><li><strong>TODO:</strong> 定义了一个新的action称作 <code>myTunnel_forward</code> ，它设置出口端口(即<code>standard_metadata</code>总线的<code>egress_spec</code>字段)到控制平面提供的端口号。</li><li><strong>TODO:</strong>定义一个名为<code>myTunnel_exact</code>的新表，它对<code>myTunnel</code>报头的<code>dst_id</code>字段执行精确匹配。如果表中有匹配项，该表应该调用<code>myTunnel_forward</code>操作，否则它应该调用<code>drop</code>操作。</li><li><strong>TODO:</strong>如果<code>myTunnel</code>报头有效，更新<code>MyIngress</code>控制块中的<code>apply</code>语句，以应用新定义的<code>myTunnel_exact</code>表。否则，如果<code>ipv4</code>报头有效，则调用<code>ipv4_lpm</code>表。</li><li>更新deparser以发出’ ethernet ‘，然后是’ myTunnel ‘，然后是’ ipv4 ‘头。请记住，deparser只会在消息头有效时发出消息头。头的隐式有效性位由解析器在提取时设置。这里不需要检查头的有效性。</li><li>为新定义的表添加静态规则，以便交换机能够正确转发’ dst_id ‘的每个可能值。请参阅下面的图，了解拓扑的端口配置以及我们将如何为主机分配id。在此步骤中，您需要将转发规则添加到“sX-runtime”中。json文件。</li></ol></li></ol><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><p><strong>headers部分：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F;</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NOTE: new type added here</span><br><span class="line">const bit&lt;16&gt; TYPE_MYTUNNEL &#x3D; 0x1212;</span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123;</span><br><span class="line">    macAddr_t dstAddr;</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NOTE: added new header type</span><br><span class="line">header myTunnel_t &#123;&#x2F;&#x2F;新的header type</span><br><span class="line">    bit&lt;16&gt; proto_id; &#x2F;&#x2F;包含了proto_id以及dst_id</span><br><span class="line">    bit&lt;16&gt; dst_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123;</span><br><span class="line">    &#x2F;* empty *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NOTE: Added new header type to headers struct</span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t   ethernet;</span><br><span class="line">    myTunnel_t   myTunnel; &#x2F;&#x2F;新添加的字段</span><br><span class="line">    ipv4_t       ipv4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Parser部分："><a href="#Parser部分：" class="headerlink" title="Parser部分："></a><strong>Parser部分：</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as well</span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ethernet &#123;</span><br><span class="line">        packet.extract(hdr.ethernet);</span><br><span class="line">        transition select(hdr.ethernet.etherType) &#123;</span><br><span class="line">            TYPE_IPV4 : parse_ipv4;</span><br><span class="line">            default : accept;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ipv4 &#123;</span><br><span class="line">        packet.extract(hdr.ipv4);</span><br><span class="line">        transition accept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as well</span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ethernet &#123;</span><br><span class="line">        packet.extract(hdr.ethernet);</span><br><span class="line">        transition select(hdr.ethernet.etherType) &#123;</span><br><span class="line">            TYPE_IPV4 : parse_ipv4;</span><br><span class="line">            TYPE_MYTUNNEL : parse_mytunnel;</span><br><span class="line">            default : accept;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ipv4 &#123;</span><br><span class="line">        packet.extract(hdr.ipv4);</span><br><span class="line">        transition accept;</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_mytunnel&#123;</span><br><span class="line">    packet.extract(hdr.myTunnel);</span><br><span class="line">    transition select(hdr.myTunnel.proto_id)&#123; &#x2F;&#x2F;满足需求：如果&#96;proto_id &#96; &#x3D;&#x3D; &#96; TYPE_IPV4 &#39;&#96;即0x0800)，解析器还应该在&#96;myTunnel 头&#96;之后提取&#96;ipv4 &#96;头。</span><br><span class="line">    TYPE_IPV4 : parse_ipv4;</span><br><span class="line">    default : accept;</span><br><span class="line">    &#125;</span><br><span class="line">    transition accept;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Ingress部分（以及checksum部分）："><a href="#Ingress部分（以及checksum部分）：" class="headerlink" title="Ingress部分（以及checksum部分）："></a><strong>Ingress部分（以及checksum部分）：</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec &#x3D; port;</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr;</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact</span><br><span class="line">    &#x2F;&#x2F; TODO: also remember to add table entries!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Update control flow</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec &#x3D; port;</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr;</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;&#x2F;&#x2F;最长前缀匹配</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port)</span><br><span class="line">action myTunnel_ford(egressSpec_t port)&#123;</span><br><span class="line">standard_metadata.egress_spec &#x3D; port;&#x2F;&#x2F;设置端口号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact</span><br><span class="line">    table myTunnel_exact&#123;</span><br><span class="line">    key&#x3D;&#123;</span><br><span class="line">    hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配</span><br><span class="line">    &#125;</span><br><span class="line">    actions&#x3D;&#123;</span><br><span class="line">    myTunnel_ford;</span><br><span class="line">    drop;&#x2F;&#x2F;如果表中有匹配项，该表应该调用&#96; myTunnel_forward &#96;操作，否则它应该调用&#96; drop &#96;操作。</span><br><span class="line">    &#125;</span><br><span class="line">    size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; TODO: also remember to add table entries!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Update control flow</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">        if(hdr.myTunnel.isValid())&#123;&#x2F;&#x2F;模仿ipv4写的</span><br><span class="line">        myTunnel_exact.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: match_kind： 这是match_action table里面的一种类型，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key&#x3D;&#123;</span><br><span class="line">hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的exact就是一种match_kind，<a href="https://github.com/p4lang/p4c" target="_blank" rel="noopener">p4c</a>/<a href="https://github.com/p4lang/p4c/tree/master/p4include" target="_blank" rel="noopener">p4include</a>/core.p4有三种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match_kind &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Match bits exactly.精准匹配</span><br><span class="line">    exact,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Ternary match, using a mask. 把值和一个 mask 比较，比如 0x01020304 符合 mask 0x0F0F0F0F</span><br><span class="line">    ternary,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Longest-prefix match.最长前缀匹配</span><br><span class="line">    lpm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/p4lang/p4c" target="_blank" rel="noopener">p4c</a>/<a href="https://github.com/p4lang/p4c/tree/master/p4include" target="_blank" rel="noopener">p4include</a>/<strong>v1model.p4</strong>里面有一下几种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match_kind &#123;</span><br><span class="line">    &#x2F;&#x2F;检查是否值在一个范围里，比如取 0x01020304 - 0x010203FF 之间的值</span><br><span class="line">    range,</span><br><span class="line">    &#x2F;&#x2F; Either an exact match, or a wildcard (matching any value).精准匹配或者通配</span><br><span class="line">    optional,</span><br><span class="line">    &#x2F;&#x2F; Used for implementing dynamic_action_selection 用于实现dynamic_action_selection</span><br><span class="line">    selector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在include上述两个文件的情况下一共有六种</p><h5 id="Egress部分（以及checksum部分）："><a href="#Egress部分（以及checksum部分）：" class="headerlink" title="Egress部分（以及checksum部分）："></a>Egress部分（以及checksum部分）：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*************   C H E C K S U M    C O M P U T A T I O N   **************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyComputeChecksum(inout headers  hdr, inout metadata meta) &#123;</span><br><span class="line">     apply &#123;</span><br><span class="line">update_checksum(</span><br><span class="line">    hdr.ipv4.isValid(),</span><br><span class="line">            &#123; hdr.ipv4.version,</span><br><span class="line">      hdr.ipv4.ihl,</span><br><span class="line">              hdr.ipv4.diffserv,</span><br><span class="line">              hdr.ipv4.totalLen,</span><br><span class="line">              hdr.ipv4.identification,</span><br><span class="line">              hdr.ipv4.flags,</span><br><span class="line">              hdr.ipv4.fragOffset,</span><br><span class="line">              hdr.ipv4.ttl,</span><br><span class="line">              hdr.ipv4.protocol,</span><br><span class="line">              hdr.ipv4.srcAddr,</span><br><span class="line">              hdr.ipv4.dstAddr &#125;,</span><br><span class="line">            hdr.ipv4.hdrChecksum,</span><br><span class="line">            HashAlgorithm.csum16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Deparser部分:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);</span><br><span class="line">        &#x2F;&#x2F; TODO: emit myTunnel header as well</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);</span><br><span class="line">        &#x2F;&#x2F; TODO: emit myTunnel header as well</span><br><span class="line">        packet.emit(hdr.myTunnel);</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例化部分：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  S W I T C H  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">V1Switch(</span><br><span class="line">MyParser(),</span><br><span class="line">MyVerifyChecksum(),</span><br><span class="line">MyIngress(),</span><br><span class="line">MyEgress(),</span><br><span class="line">MyComputeChecksum(),</span><br><span class="line">MyDeparser()</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><ol><li><p>make run</p><p>这会进行以下几步:</p><ol><li>编译basic_tunnel.p4</li><li>启动一个Mininet实例，其中三个交换机(<code>s1</code>、<code>s2</code>、<code>s3</code>)配置在一个三角形中，每个交换机连接到一个主机(<code>h1</code>、<code>h2</code>和<code>h3</code>)。</li><li>这些主机的ip地址设置为<code>10.0.1.1</code>, <code>10.0.2.2</code>, and <code>10.0.3.3</code>.</li></ol><p>然后进入mininet界面</p></li><li><p>使用mininet的xterm功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; xterm h1 h2</span><br></pre></td></tr></table></figure></li><li><p>在h2的界面输入 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;receive.py</span><br></pre></td></tr></table></figure><p>在h1的界面输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot;</span><br></pre></td></tr></table></figure><p>这是不经过my_tunnel的测试；</p><p>如果您检查接收到的数据包，您应该会看到它由一个以太网报头、一个IP报头、一个TCP报头和消息组成。如果您更改了目的IP地址(例如试图发送到’ 10.0.3.3 ‘)，则该消息不应该被’ h2 ‘接收，而将被’ h3 ‘接收。</p><p>结果如下图:</p><p><img src="/picture/image-20210228215634236.png" alt="image-20210228215634236"></p><p>发给10.0.3.3之后:</p><p>h1有相似的显示，h2没有变化</p></li><li><p>下面测试my_tunnel</p><p>在h1的界面输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot; --dst_id 2</span><br></pre></td></tr></table></figure></li></ol><p>   结果如下图:</p><p>   <img src="/picture/image-20210228215915163.png" alt="image-20210228215915163"></p><p>   数据包在<code>h2</code>处接收。它由一个以太网报头、一个隧道报头、一个IP报头、一个TCP报头和消息组成。隧道报头就是那个###[MyTunnel]在IP报头上面;</p><ol><li><p>在h1的界面输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;send.py 10.0.3.3 &quot;P4 is cool&quot; --dst_id 2</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="/picture/image-20210228220230000.png" alt="image-20210228220230000"></p><p>即使IP地址是<code>h3</code>的地址，数据包也应该在<code>h2</code>处接收。这是因为当<code>MyTunnel</code>头在包中时，交换机不再使用IP头进行路由。</p><p>一开始我也不理解上面这句话，后来我看了s1-runtime文件，这个文件规定了交换机的静态规则，将这个文件和basic里面的同名文件比较会发现里面多了:</p><p><img src="/picture/image-20210228221250171.png" alt="image-20210228221250171"></p><p>这部分内容结合刚刚./receive代码里面的—dst 2后缀可以得知刚刚那个包在进入交换机s1之后会因为p4的解包触发走myTunnel_forward的规则然后发给S1的2端口，结合拓扑图可以看出确实是发给h2的</p></li></ol><h4 id="解析其他内容"><a href="#解析其他内容" class="headerlink" title="解析其他内容"></a>解析其他内容</h4><h5 id="my-tunnel-py"><a href="#my-tunnel-py" class="headerlink" title="my_tunnel.py"></a>my_tunnel.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">TYPE_MYTUNNEL = <span class="number">0x1212</span></span><br><span class="line">TYPE_IPV4 = <span class="number">0x0800</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTunnel</span><span class="params">(Packet)</span>:</span></span><br><span class="line">    name = <span class="string">"MyTunnel"</span></span><br><span class="line">    fields_desc = [</span><br><span class="line">        ShortField(<span class="string">"pid"</span>, <span class="number">0</span>),</span><br><span class="line">        ShortField(<span class="string">"dst_id"</span>, <span class="number">0</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mysummary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.sprintf(<span class="string">"pid=%pid%, dst_id=%dst_id%"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bind_layers(Ether, MyTunnel, type=TYPE_MYTUNNEL)</span><br><span class="line">bind_layers(MyTunnel, IP, pid=TYPE_IPV4)</span><br></pre></td></tr></table></figure><p>因为原来的scapy只支持ipv4，不支持我们的myTunnel协议，因此需要重新定义，上面的文件就重新定义了MyTunnel；</p><blockquote><p>每一个协议层都是Packet类的子类。协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。一个简单的协议层是被一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为fields_desc的属性中。每一个字段都是一个field类的实例：</p></blockquote><p>上面MyTunnel的协议层有两个字段分别是pid和dst_id，默认值都是0；</p><p>UDP的协议层定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UDP(Packet):</span><br><span class="line">    name &#x3D; &quot;UDP&quot;</span><br><span class="line">    fields_desc &#x3D; [ ShortEnumField(&quot;sport&quot;, 53, UDP_SERVICES),</span><br><span class="line">                    ShortEnumField(&quot;dport&quot;, 53, UDP_SERVICES),</span><br><span class="line">                    ShortField(&quot;len&quot;, None),</span><br><span class="line">                    XShortField(&quot;chksum&quot;, None), ]</span><br></pre></td></tr></table></figure><p>最后两句是绑定协议层;</p><blockquote><p>Scapy在解析协议层时一个很酷的特性是他试图猜测下一层协议是什么。连接两个协议层官方的方法是bind_layers():</p></blockquote><h5 id="send-py"><a href="#send-py" class="headerlink" title="send.py"></a>send.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> sendp, send, get_if_list, get_if_hwaddr, hexdump</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Packet</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Ether, IP, UDP, TCP</span><br><span class="line"><span class="keyword">from</span> myTunnel_header <span class="keyword">import</span> MyTunnel</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_if</span><span class="params">()</span>:</span></span><br><span class="line">    ifs=get_if_list() <span class="comment">#    # type: () -&gt; List[str] """Return a list of interface names""",返回接口(网卡)名字</span></span><br><span class="line">    iface=<span class="literal">None</span> <span class="comment"># "h1-eth0"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> get_if_list():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"eth0"</span> <span class="keyword">in</span> i:</span><br><span class="line">            iface=i</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> iface:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Cannot find eth0 interface"</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> iface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser()<span class="comment">#argsparse是python的命令行解析的标准模块，相当于就是解析./send.py后面的参数</span></span><br><span class="line">    parser.add_argument(<span class="string">'ip_addr'</span>, type=str, help=<span class="string">"The destination IP address to use"</span>)<span class="comment">#type是要传入的参数的数据类型  help是该参数的提示信息,使用python send.py -h可以看到</span></span><br><span class="line">    parser.add_argument(<span class="string">'message'</span>, type=str, help=<span class="string">"The message to include in packet"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--dst_id'</span>, type=int, default=<span class="literal">None</span>, help=<span class="string">'The myTunnel dst_id to use, if unspecified then myTunnel header will not be included in packet'</span>)</span><br><span class="line">    args = parser.parse_args()<span class="comment">##获得传入的参数</span></span><br><span class="line"></span><br><span class="line">    addr = socket.gethostbyname(args.ip_addr)<span class="comment">## 获取ip_addr的主机名</span></span><br><span class="line">    dst_id = args.dst_id<span class="comment">#获得dst_id</span></span><br><span class="line">    iface = get_if()<span class="comment">#获取网卡的名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dst_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):<span class="comment">#包装</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"sending on interface &#123;&#125; to dst_id &#123;&#125;"</span>.format(iface, str(dst_id))</span><br><span class="line">        pkt =  Ether(src=get_if_hwaddr(iface), dst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>)</span><br><span class="line">        pkt = pkt / MyTunnel(dst_id=dst_id) / IP(dst=addr) / args.message</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"sending on interface &#123;&#125; to IP addr &#123;&#125;"</span>.format(iface, str(addr))</span><br><span class="line">        pkt =  Ether(src=get_if_hwaddr(iface), dst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>)</span><br><span class="line">        pkt = pkt / IP(dst=addr) / TCP(dport=<span class="number">1234</span>, sport=random.randint(<span class="number">49152</span>,<span class="number">65535</span>)) / args.message</span><br><span class="line"></span><br><span class="line">    pkt.show2()</span><br><span class="line"><span class="comment">#    hexdump(pkt)</span></span><br><span class="line"><span class="comment">#    print "len(pkt) = ", len(pkt)</span></span><br><span class="line">    sendp(pkt, iface=iface, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>大概流程就是，先分析参数，然后包装成Ether的格式然后用scapy发包;</p><h5 id="receive-py"><a href="#receive-py" class="headerlink" title="receive.py"></a>receive.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> sniff, sendp, hexdump, get_if_list, get_if_hwaddr</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Packet, IPOption</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> ShortField, IntField, LongField, BitField, FieldListField, FieldLenField</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> IP, TCP, UDP, Raw</span><br><span class="line"><span class="keyword">from</span> scapy.layers.inet <span class="keyword">import</span> _IPOption_HDR</span><br><span class="line"><span class="keyword">from</span> myTunnel_header <span class="keyword">import</span> MyTunnel</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_if</span><span class="params">()</span>:</span> <span class="comment"># 获得网卡接口</span></span><br><span class="line">    ifs=get_if_list()</span><br><span class="line">    iface=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> get_if_list():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"eth0"</span> <span class="keyword">in</span> i:</span><br><span class="line">            iface=i</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> iface:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Cannot find eth0 interface"</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> iface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_pkt</span><span class="params">(pkt)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> MyTunnel <span class="keyword">in</span> pkt <span class="keyword">or</span> (TCP <span class="keyword">in</span> pkt <span class="keyword">and</span> pkt[TCP].dport == <span class="number">1234</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"got a packet"</span></span><br><span class="line">        pkt.show2()</span><br><span class="line"><span class="comment">#        hexdump(pkt)</span></span><br><span class="line"><span class="comment">#        print "len(pkt) = ", len(pkt)</span></span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ifaces = filter(<span class="keyword">lambda</span> i: <span class="string">'eth'</span> <span class="keyword">in</span> i, os.listdir(<span class="string">'/sys/class/net/'</span>))</span><br><span class="line">    iface = ifaces[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"sniffing on %s"</span> % iface</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    sniff(iface = iface,</span><br><span class="line">          prn = <span class="keyword">lambda</span> x: handle_pkt(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>首先获得网卡，发出“sniffing on….”信息，并且立刻打出来，然后把收到的包里面的东西立刻打印出来</p><h4 id="原文部分"><a href="#原文部分" class="headerlink" title="原文部分"></a>原文部分</h4><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this exercise, we will add support for a basic tunneling protocol to the IP<br>router that you completed in the previous assignment.  The basic switch<br>forwards based on the destination IP address.  Your jobs is to define a new<br>header type to encapsulate the IP packet and modify the switch code, so that it<br>instead decides the destination port using a new tunnel header.</p><p>The new header type will contain a protocol ID, which indicates the type of<br>packet being encapsulated, along with a destination ID to be used for routing.</p><blockquote><p><strong>Spoiler alert:</strong> There is a reference solution in the <code>solution</code><br>sub-directory. Feel free to compare your implementation to the reference.</p></blockquote><p>The starter code for this assignment is in a file called <code>basic_tunnel.p4</code> and<br>is simply the solution to the IP router from the previous exercise.</p><h3 id="A-note-about-the-control-plane"><a href="#A-note-about-the-control-plane" class="headerlink" title="A note about the control plane"></a>A note about the control plane</h3><p>A P4 program defines a packet-processing pipeline, but the rules within each<br>table are inserted by the control plane. When a rule matches a packet, its<br>action is invoked with parameters supplied by the control plane as part of the<br>rule.</p><p>For this exercise, we have already added the necessary static control plane<br>entries. As part of bringing up the Mininet instance, the <code>make run</code> command<br>will install packet-processing rules in the tables of each switch. These are<br>defined in the <code>sX-runtime.json</code> files, where <code>X</code> corresponds to the switch<br>number.</p><p>Since the control plane tries to access the <code>myTunnel_exact</code> table, and that<br>table does not yet exist, the <code>make run</code> command will not work with the starter<br>code.</p><p><strong>Important:</strong> We use P4Runtime to install the control plane rules. The content<br>of files <code>sX-runtime.json</code> refer to specific names of tables, keys, and<br>actions, as defined in the P4Info file produced by the compiler (look for the<br>file <code>build/basic.p4info</code> after executing <code>make run</code>). Any changes in the P4<br>program that add or rename tables, keys, or actions will need to be reflected<br>in these <code>sX-runtime.json</code> files.</p><h4 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h4><ul><li><a href="https://www.zhihu.com/column/c_1336207793033015296" target="_blank" rel="noopener">P4学习笔记专栏</a></li><li><a href="https://github.com/p4lang/p4c/blob/master/p4include/core.p4" target="_blank" rel="noopener">core.p4库</a></li><li><a href="https://wizardforcel.gitbooks.io/scapy-docs/content/3.html" target="_blank" rel="noopener">scapy中文文档</a></li><li><a href="https://blog.csdn.net/dj1174232716/article/details/49046409" target="_blank" rel="noopener">scapy添加新的协议</a></li><li><a href="https://github.com/secdev/scapy" target="_blank" rel="noopener">scapy源码</a></li><li><a href="https://zhuanlan.zhihu.com/p/56922793" target="_blank" rel="noopener">argparse使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-3：P4-basic-tunnel实验&quot;&gt;&lt;a href=&quot;#P4学习-3：P4-basic-tunnel实验&quot; class=&quot;headerlink&quot; title=&quot;P4学习-3：P4 basic tunnel实验&quot;&gt;&lt;/a&gt;P4学习-3：P4 basi
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode24-m</title>
    <link href="http://Tyler-ytr.github.io/2021/02/24/leetcode24-m/"/>
    <id>http://Tyler-ytr.github.io/2021/02/24/leetcode24-m/</id>
    <published>2021-02-24T08:37:35.000Z</published>
    <updated>2021-02-25T08:18:30.262Z</updated>
    
    <content type="html"><![CDATA[<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><p>难度中等827</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/swap_ex1.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p><ol><li><p>迭代解法：开了一个虚拟节点，然后pid的next是将要交换的第一个节点,pid.next.next是第二个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        temphead=ListNode(<span class="number">0</span>)</span><br><span class="line">        temphead.next=head</span><br><span class="line">        pid=temphead</span><br><span class="line">        <span class="keyword">while</span> pid.next <span class="keyword">and</span> pid.next.next:</span><br><span class="line">            node1=pid.next</span><br><span class="line">            node2=pid.next.next</span><br><span class="line">            </span><br><span class="line">            pid.next=node2</span><br><span class="line">            node1.next=node2.next</span><br><span class="line">            node2.next=node1</span><br><span class="line">            pid=node2.next</span><br><span class="line">        <span class="keyword">return</span> temphead.next</span><br></pre></td></tr></table></figure></li><li><p>递归解法：见里面的注释</p><p>首先思考递归终止条件，然后思考里面的递归过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val&#x3D;0, next&#x3D;None):</span><br><span class="line">#         self.val &#x3D; val</span><br><span class="line">#         self.next &#x3D; next</span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        # 终止条件：head是空或者head.next是空 比如[],[1]</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line">        </span><br><span class="line">        #1,2,3,4</span><br><span class="line">        temp&#x3D;head.next #因为马上要修改</span><br><span class="line">        #1-&gt;2-&gt;3-&gt;4</span><br><span class="line">        #修改好了4-&gt;3</span><br><span class="line">        #所以1-&gt;4-&gt;3</span><br><span class="line">        head.next&#x3D;self.swapPairs(temp.next)</span><br><span class="line">        #temp相当于2,2-&gt;1</span><br><span class="line">        temp.next&#x3D;head</span><br><span class="line">        return temp</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="递归" scheme="http://Tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="链表" scheme="http://Tyler-ytr.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode23-h</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/leetcode23-h/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/leetcode23-h/</id>
    <published>2021-02-23T12:08:25.000Z</published>
    <updated>2021-02-23T14:21:35.442Z</updated>
    
    <content type="html"><![CDATA[<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表</a></h4><p>难度困难1151</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p><strong>解答：</strong></p><ol><li><p>优先队列</p><p><code>heapq</code>是二叉堆，通常用普通列表实现。</p><p><code>heapq</code>模块是在Python中不错的优先级队列实现。由于heapq在技术上只提供最小堆实现，因此必须添加额外步骤来确保排序稳定性，以此来获得“实际”的优先级队列中所含有的预期特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line"></span><br><span class="line">q &#x3D; []</span><br><span class="line"></span><br><span class="line">heapq.heappush(q, (2, &#39;code&#39;))</span><br><span class="line">heapq.heappush(q, (1, &#39;eat&#39;))</span><br><span class="line">heapq.heappush(q, (3, &#39;sleep&#39;))</span><br><span class="line"></span><br><span class="line">while q:</span><br><span class="line">    next_item &#x3D; heapq.heappop(q)</span><br><span class="line">    print(next_item)</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line">#   (1, &#39;eat&#39;)</span><br><span class="line">#   (2, &#39;code&#39;)</span><br><span class="line">#   (3, &#39;sleep&#39;)</span><br></pre></td></tr></table></figure><p><code>queue.PriorityQueue</code>这个优先级队列的实现在内部使用了<code>heapq</code>，时间和空间复杂度与<code>heapq</code>相同。</p><p>区别在于<code>PriorityQueue</code>是同步的，提供了锁语义来支持多个并发的生产者和消费者。</p><p>在不同情况下，锁语义可能会带来帮助，也可能会导致不必要的开销。不管哪种情况，你都可能更喜欢<code>PriorityQueue</code>提供的基于类的接口，而不是使用<code>heapq</code>提供的基于函数的接口。</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from queue import PriorityQueue</span><br><span class="line"></span><br><span class="line">q &#x3D; PriorityQueue()</span><br><span class="line"></span><br><span class="line">q.put((2, &#39;code&#39;))</span><br><span class="line">q.put((1, &#39;eat&#39;))</span><br><span class="line">q.put((3, &#39;sleep&#39;))</span><br><span class="line"></span><br><span class="line">while not q.empty():</span><br><span class="line">    next_item &#x3D; q.get()</span><br><span class="line">    print(next_item)</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line">#   (1, &#39;eat&#39;)</span><br><span class="line">#   (2, &#39;code&#39;)</span><br><span class="line">#   (3, &#39;sleep&#39;)</span><br></pre></td></tr></table></figure><p>   其中PriorityQueue可以自定义比较函数:</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from queue import PriorityQueue</span><br><span class="line">class Job(object):</span><br><span class="line">    def __init__(self, priority, description):</span><br><span class="line">        self.priority &#x3D; priority</span><br><span class="line">        self.description &#x3D; description</span><br><span class="line">        print(&#39;New job:&#39;, description)</span><br><span class="line">        return</span><br><span class="line"> </span><br><span class="line">    def __lt__(self, other):</span><br><span class="line">        return self.priority &lt; other.priority</span><br><span class="line"> &#39;&#39;&#39; 或者使用__cmp__函数</span><br><span class="line">    def __cmp__(self, other):</span><br><span class="line">        if self.priority &lt; other.priority:</span><br><span class="line">            return -1</span><br><span class="line">        elif self.priority &#x3D;&#x3D; other.priority:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            return 1</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">q2 &#x3D; PriorityQueue()</span><br><span class="line"> </span><br><span class="line">q2.put(Job(5, &#39;Mid-level job&#39;))</span><br><span class="line">q2.put(Job(10, &#39;Low-level job&#39;))</span><br><span class="line">q2.put(Job(1, &#39;Important job&#39;)) #数字越小，优先级越高</span><br><span class="line"> </span><br><span class="line">while not q2.empty():</span><br><span class="line">    next_job &#x3D; q2.get() #可根据优先级取序列</span><br><span class="line">    print(&#39;Processing job&#39;, next_job.description)</span><br></pre></td></tr></table></figure><p>   题解:</p><p>   使用heapq解决该问题，每一个链表的第一个节点进入堆进行比较，然后最小的那个取出来扔进新链表，然后最小的那个向后移动一位（80ms）</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        minheap=[]</span><br><span class="line">        <span class="keyword">for</span> index,node <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="keyword">if</span> node!=<span class="literal">None</span>:</span><br><span class="line">                heapq.heappush(minheap,(node.val,index)) <span class="comment">#第几个链表的节点的值</span></span><br><span class="line"></span><br><span class="line">        head=ListNode(<span class="number">-1</span>)</span><br><span class="line">        tail=head</span><br><span class="line">        <span class="keyword">while</span> minheap:</span><br><span class="line">            nodeval,index=heapq.heappop(minheap)</span><br><span class="line">            tail.next=lists[index]</span><br><span class="line">            tail=tail.next</span><br><span class="line">            lists[index]=lists[index].next</span><br><span class="line">            <span class="keyword">if</span> lists[index]!=<span class="literal">None</span>:</span><br><span class="line">                heapq.heappush(minheap,(lists[index].val,index))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>   使用PriorityQueue解决问题，速度慢于heapq(144ms)：</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line">        minheap=PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> index,node <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="keyword">if</span> node!=<span class="literal">None</span>:</span><br><span class="line">               minheap.put((node.val,index)) <span class="comment">#第几个链表的节点的值</span></span><br><span class="line">        head=ListNode(<span class="number">-1</span>)</span><br><span class="line">        tail=head</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> minheap.empty():</span><br><span class="line">            nodeval,index=minheap.get()</span><br><span class="line">            tail.next=lists[index]</span><br><span class="line">            tail=tail.next</span><br><span class="line">            lists[index]=lists[index].next</span><br><span class="line">            <span class="keyword">if</span> lists[index]!=<span class="literal">None</span>:</span><br><span class="line">                minheap.put((lists[index].val,index))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><ol><li><p>分治</p><p>首先实现合并两个链表，然后分治：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 合并两个链表的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                l1,l2=l2,l1</span><br><span class="line">            l1.next=self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">    <span class="comment">#调用上面的代码合并两个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergetwonode</span><span class="params">(self,node1:ListNode,node2:ListNode)</span>-&gt;ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(node1,node2)</span><br><span class="line">    <span class="comment">#分治</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self,left:int,right:int,lists:List[ListNode])</span>-&gt;ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> left==right:</span><br><span class="line">            <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="keyword">if</span> left&gt;right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid=left+((right-left)//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> self.mergetwonode(self.merge(left,mid,lists),self.merge(mid+<span class="number">1</span>,right,lists))        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(<span class="number">0</span>,len(lists)<span class="number">-1</span>,lists)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;23-合并K个升序链表&quot;&gt;&lt;a href=&quot;#23-合并K个升序链表&quot; class=&quot;headerlink&quot; title=&quot;23. 合并K个升序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-k-so
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="递归" scheme="http://Tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="优先队列" scheme="http://Tyler-ytr.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1052-m</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/leetcode1052-m/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/leetcode1052-m/</id>
    <published>2021-02-23T09:54:13.000Z</published>
    <updated>2021-02-23T09:57:28.305Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">1052. 爱生气的书店老板</a></h4><p>难度中等106</p><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</code></li><li><code>0 &lt;= customers[i] &lt;= 1000</code></li><li><code>0 &lt;= grumpy[i] &lt;= 1</code></li></ul><p><strong>解答:</strong></p><p>分为两部分，第一部分是不用秘密方法得到的满意度，第二部分是使用秘密方法得到的满意度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        base=<span class="number">0</span></span><br><span class="line">        increase=<span class="number">0</span></span><br><span class="line">        maxincrease=<span class="number">0</span></span><br><span class="line">        length=len(customers)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            base=base+customers[i]*(<span class="number">1</span>-grumpy[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,X):</span><br><span class="line">            increase=increase+customers[i]*grumpy[i]</span><br><span class="line">        maxincrease=increase</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X,length):</span><br><span class="line">            increase=increase+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X]</span><br><span class="line">            maxincrease=max(increase,maxincrease)</span><br><span class="line">        <span class="keyword">return</span> maxincrease+base</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1052-爱生气的书店老板&quot;&gt;&lt;a href=&quot;#1052-爱生气的书店老板&quot; class=&quot;headerlink&quot; title=&quot;1052. 爱生气的书店老板&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/grum
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="滑动窗口" scheme="http://Tyler-ytr.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="贪心" scheme="http://Tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论笔记</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/机器学习/</id>
    <published>2021-02-23T09:26:04.000Z</published>
    <updated>2021-03-22T02:14:34.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记"><a href="#机器学习笔记" class="headerlink" title="机器学习笔记"></a>机器学习笔记</h1><p>感谢毕秋宇同学！！</p><h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><ul><li><p>假设空间</p><ul><li>假设满足XX条件的是好瓜</li></ul></li><li><p>版本空间</p><ul><li>有限训练集，已知XX是好瓜</li></ul></li><li><p>归纳偏好</p><ul><li>假设空间和训练集一致的假设</li><li>学习过程中对某种类型假设的偏好称为归纳偏好</li></ul></li><li>No Free Lunch<ul><li>奥卡姆剃刀：两个模型效果同样好，选择较为简单的</li></ul></li></ul><h2 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h2><ul><li>经验误差与过拟合<ul><li>错误率率&amp;误差<ul><li>错误率：错份样本的占$E=a/m$</li><li>误差：样本真实输出与预测输出之间的差异<ul><li>训练（经验）误差：训练集上</li><li>测试误差：测试集</li><li>泛化误差：初训练集外所有样本</li></ul></li></ul></li></ul></li><li>过拟合<ul><li>学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降</li><li>优化目标加正则项</li><li>Early stop</li></ul></li><li>欠拟合<ul><li>对训练样本的一般性质尚未学好</li><li>决策树：扩展分支</li><li>神经网络：增加训练层数</li></ul></li><li>评估方法<ul><li>留出法<ul><li>直接将数据集划分为两个互斥集合</li><li>训练/测试集划分要尽可能保持数据分布的一致性</li><li>一般若干次随机划分，重复实验取平均值</li><li>训练/测试样本比例通常为2:1～4:1</li></ul></li><li>交叉验证法<ul><li>将数据集分层采样划分为$k$个大小相似的互斥子集</li></ul></li><li>自助法<ul><li>以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\prime}$，$D\backslash D^{\prime}$用作测试集</li></ul></li></ul></li><li>性能度量<ul><li>性能度量是衡量模型泛化能力的评价标准，反映任务的需求<ul><li>回归任务最常用的是“均方误差”：<ul><li>$E(f:D)=\frac{1}{m}\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$</li></ul></li></ul></li><li>查准率 $P=\frac{TP}{TP+FP}$</li><li>查全率 $R=\frac{TP}{TP+FN}$</li><li>$P-R$曲线</li><li>$F1$ measure：$\frac{2\times TP}{N+TP-TN}$</li><li>$AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\cdot(y_{i}+y_{i+1})$，预测了排序质量</li><li>代价敏感错误率</li></ul></li><li>性能评估<ul><li>关于性能比较<ul><li>测试性能并不等于泛化性能</li><li>测试性能随着测试集的变化而变化</li><li>很多机器学习算法本身有一定的随机性</li><li>直接选取相应评估方式在相应条件下评估并不可靠</li></ul></li><li>二项检验<ul><li>泛化错误率为$\epsilon$，测试错误率为$\hat{\epsilon}$，嘉定测试样本从样本总体分布中独立采样而来，我们可以使用“二项检验”，对于$\epsilon&lt;epsilon_{0}$进行假设检验。</li><li>假设$\epsilon\leq\epsilon_{0}$，若测试错误率小于</li></ul></li><li>$t$检验</li><li>交叉验证$t$检验</li></ul></li><li>偏差和方差<ul><li>对于测试样本$x$，令$y_{D}$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学的模型$f$在$x$上的预测输出。</li><li>以回归任务为例：<ul><li>期望预期为：$\bar{f}(x)=\mathbb{E}_{D}[f(x;D)]$；</li><li>使用样本数目相同的不同训练集产生的方差为$var(x)=\mathbb{E}_{D}[(f(x:D)-\bar{f}(x))^{2}]$；</li><li>噪声为$\varepsilon^{2}=\mathbb{E}_{D}[(y_{D}-y)^{2}]$</li></ul></li><li>$E(f;D)=bias^{2}(x)+var(x)+\varepsilon^2$</li></ul></li></ul><h1 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><ul><li>线性模型一般形式$f(x)=w_1x_1+w_2x_2+\cdots+w_dx_d+b$</li><li><p>向量形式$f(x)=w^{T}x+b$</p></li><li><p>区分猫狗的例子</p><ul><li>按照像素行堆叠或列堆叠，成为一个向量</li><li>乘以单位，对于二分类问题，单位就是一个向量</li></ul></li><li>Perceptron感知机<ul><li>对于线性分类器，误分类则$-y_{1}(w\cdot x_i)+b&gt;0$</li><li>定义损失函数$L(w,b)=-\sum_{x_{i}\in M}y_{i}(w\cdot x_{i}+b)$</li><li>梯度$\bigtriangledown_{w}L(w,b)=-\sum_{x_{i}\in M}y_{i}x_{i}$</li><li>$\bigtriangledown_{b}L(w,b)=-\sum_{x_{i}\in M}y_{i}$</li></ul></li><li>梯度下降法<ul><li>一阶方法</li><li>考虑无约束优化$min_{x}f(x)$，$f(x+\Delta x)\approx f(x)+\Delta x^{T}\bigtriangledown f(x)$</li><li>$\Delta x^{T}\bigtriangledown f(x)&lt;0$</li><li>$\Delta x=-\gamma \bigtriangledown f(x)$</li><li>$\gamma$使用二分查找法进行查找</li></ul></li><li>优点<ul><li>形式简单，易于建模</li><li>可解释性</li><li>非线性模型的基础<ul><li>引入层级结构或高维映射</li></ul></li></ul></li><li>缺陷<ul><li>解决不了$x^{2}$问题</li></ul></li></ul><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><ul><li><p>目的：学得一个线性模型以尽可能准确地预测实值输出标记</p></li><li><p>离散属性处理</p><ul><li>有“序”关系<ul><li>连续化为连续值</li></ul></li><li>无“序”关系</li></ul></li><li>单一属性的线性回归目标<ul><li>$f(x)=wx_{i}+b$使得$f(x_{i})\simeq y_{i}$</li></ul></li><li><p>参数/模型估计：最小二乘法（Least square method）</p><ul><li>$(w^{<em>},b^{</em>})=arg\ min_{(w,b)}\sum_{i=1}^{m}(f(x_{i})-y_i)^2$</li><li>最小化均方误差$E_{(w,b)}$</li></ul></li><li><p>多元线性回归</p><ul><li>$f(\hat{x_{i}})=\hat{x_{i}}^{T}(X^{T}X)^{-1}$</li><li>$X^{T}X$不满秩，进行正则化</li></ul></li><li>广义线性模型<ul><li>一般形式：$y=g^{-1}(w^{T}x+b)$<ul><li>$g$为联系函数(link function)</li></ul></li></ul></li></ul><h2 id="二分类问题"><a href="#二分类问题" class="headerlink" title="二分类问题"></a>二分类问题</h2><ul><li>预测值与输出标记$z=w^{T}x+b$</li><li>寻找函数将分类标记与线性回归模型输出联系起来</li><li>最理想的模型——单位阶跃函数</li><li><p>替代函数——对数几率函数（logistic function）</p><ul><li><strong>$y=\frac{1}{1+e^{-z}}$</strong></li><li>运行对数几率函数$y=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-(w^{T}x+b)}}$</li><li>对数几率</li></ul></li><li><p>样本作为正例的相对可能性的对数$\ln\frac{y}{1-y}=\ln\frac{p(y=1|x)}{p(y=0|x)}=w^{T}x+b$</p></li><li><p>极大似然法</p></li><li><p>给定数据集$\{(x_{i}, y_{i})\}^{m}_{i=1}$</p></li><li><p>最大化样本属于其真实标记的概率</p></li><li><p>线性判别分析（Linear Discriminant Analysis）</p><ul><li>最大化目标$J=\frac{|w^{T}\mu_{0}-w^{T}\mu_{1}|^{2}_{2}}{w^{T}\sum_{0}w+w^{T}\sum_{1}w}=\frac{w^{T}(\mu_{0}-\mu_{1})(\mu_{0}-\mu_{1})^{T}w}{w^{T}(\sum_{0}+\sum_{1})w}$</li><li>类间散度矩阵，类内散度矩阵</li><li>广义瑞丽商$J=\frac{w^{T}S_{b}w}{w^{T}S_{w}w}$</li><li>拉格朗日乘子法<ul><li>$\bigtriangledown f(x^{<em>})+\lambda \Delta g(x^{</em>})=0$</li><li>$L(x,\lambda)=f(x)+\lambda g(x)$.</li></ul></li></ul></li></ul><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><ul><li>多分类学习方法<ul><li>二分类学习方法推广到多类</li><li>利用二分类学习器解决多分类问题<ul><li>对问题进行拆分，为拆出的每个二分类任务训练一个分类器</li><li>对于每个分类器的预测结果进行集成以获得最终的多分类结果</li></ul></li><li>拆分策略<ul><li>一对一（OVO）<ul><li>$N$个类别两两配对，$N(N-1)/2$个二类任务</li><li>各个二类任务学习分类器，$N(N-1)/2$个二类分类器</li></ul></li><li>一对其余（OVR）</li><li>多对多（MVM）<ul><li>若干类作为正类，若干类作为反类</li><li>输出纠错码（Error Correcting Output Code, ECOC）</li></ul></li></ul></li><li>类别不平衡问题$(class\ imbalance)$<ul><li>不同类别训练样例数相差很大情况（正类为小类）</li><li>类别平衡正例预测$\frac{y}{1-y}&gt;1\Rightarrow \frac{y}{1-y}&gt;\frac{m^{+}}{m^{-}}$正负类比例</li></ul></li><li>再缩放<ul><li>欠采样$(undersampling)$<ul><li>去除一些反例使正反例数目接近</li></ul></li><li>过采样$(oversampling)$<ul><li>增加一些正例使正反例数目接近</li></ul></li><li>阈值移动$(threshold-moving)$</li></ul></li></ul></li></ul><h1 id="Chapter4-决策树"><a href="#Chapter4-决策树" class="headerlink" title="Chapter4 决策树"></a>Chapter4 决策树</h1><h2 id="4-1-基本流程"><a href="#4-1-基本流程" class="headerlink" title="4.1 基本流程"></a>4.1 基本流程</h2><h4 id="决策树基于树结构来进行预测"><a href="#决策树基于树结构来进行预测" class="headerlink" title="决策树基于树结构来进行预测"></a>决策树基于树结构来进行预测</h4><ul><li><p>如果用决策树来进行分来,起码该模型一定意义上是可以理解的</p><h4 id="树结构的return"><a href="#树结构的return" class="headerlink" title="树结构的return"></a>树结构的return</h4><h5 id="1-当前节点包含的样本全部属于同一类别-没必要分类"><a href="#1-当前节点包含的样本全部属于同一类别-没必要分类" class="headerlink" title="(1)当前节点包含的样本全部属于同一类别(没必要分类)"></a>(1)当前节点包含的样本全部属于同一类别(没必要分类)</h5><h5 id="2-当前的属性集为空-或所有样本所有属性上取值相同-没法分类"><a href="#2-当前的属性集为空-或所有样本所有属性上取值相同-没法分类" class="headerlink" title="(2)当前的属性集为空,或所有样本所有属性上取值相同(没法分类)"></a>(2)当前的属性集为空,或所有样本所有属性上取值相同(没法分类)</h5><h5 id="3-当前节点包含的样本集合为空-emptyset"><a href="#3-当前节点包含的样本集合为空-emptyset" class="headerlink" title="(3)当前节点包含的样本集合为空($ \emptyset $)"></a>(3)当前节点包含的样本集合为空($ \emptyset $)</h5><h2 id="4-2划分选择"><a href="#4-2划分选择" class="headerlink" title="4.2划分选择"></a>4.2划分选择</h2></li><li><p>希望决策树的分支节点包含的样本尽可能属于同一类别,即节点的”纯度”(purity)越来越高</p></li><li><p>经典的属性划分方法:<br>1)信息增益,<br>2)增益率,<br>3)基尼指数</p><h5 id="划分选择-信息增益"><a href="#划分选择-信息增益" class="headerlink" title="划分选择-信息增益"></a>划分选择-信息增益</h5></li><li><p>“信息熵”是度量样本集合纯度最常用的一种指标</p><h6 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h6></li><li><script type="math/tex; mode=display">Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k</script></li><li><p>推导:<script type="math/tex">\int P(x)f(x)dx\rightarrow E_{x - p}(f(x))\rightarrow E_{x-p} (log_2 \frac{1}{p_k})</script></p><ul><li><p>(log2可以表示用二进制表示,$\frac{1}{p_k}$可以显示信息(概率越低越刺激))</p></li><li><p>计算信息熵的约定:若p=0,则Ent=0</p></li><li><p>Ent(D)的值越小,纯度越大</p><h6 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h6></li></ul></li><li><script type="math/tex; mode=display">Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^{v}|}{|D|}Ent(D^{v})</script></li><li><p>算出信息增益之后,可以确定树的每一层应该对应哪些划分属性</p><h6 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h6></li><li><p>信息增益对可取值数目较多的属性有所偏好</p><h5 id="划分选择-增益率"><a href="#划分选择-增益率" class="headerlink" title="划分选择-增益率"></a>划分选择-增益率</h5></li><li><p>增益率：<script type="math/tex">Gain\_ ratio (D,a)=\frac{Gain(D,a)}{IV(a)}</script><br>其中    <script type="math/tex">IV(a)=-\sum _{v=1}^{V}\frac{D^v}{D}log_2 \frac{D^v}{D}</script></p><h6 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h6></li><li><p>增益率准则对可取值数目较少的属性有所偏好</p><h5 id="划分选择-基尼指数"><a href="#划分选择-基尼指数" class="headerlink" title="划分选择-基尼指数"></a>划分选择-基尼指数</h5><script type="math/tex; mode=display">Gini(D)=\sum_{k=1}^{|y|}\sum _{k'\neq k}p_kp_{k'}=1-\sum_{k=1}^{|y|}p_k^{2}</script></li><li><p>Gini越小纯度越高</p></li></ul><h2 id="4-3剪枝处理"><a href="#4-3剪枝处理" class="headerlink" title="4.3剪枝处理"></a>4.3剪枝处理</h2><ul><li><p>为了对抗过拟合</p></li><li><p>基本策略</p><ul><li>预剪枝</li><li>后剪枝</li></ul></li><li><p>判断决策树泛化性能是否提升的办法</p><ul><li>留出法<h5 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h5></li></ul></li><li><p>优点</p><ul><li>降低过拟合风险</li><li>显著减少训练时间和测试时间开销</li></ul></li><li><p>缺点</p><ul><li>欠拟合风险<h5 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h5></li></ul></li><li><p>优点</p><ul><li>比预剪枝保留了更多的分支,欠拟合风险小,泛化性能往往由于预剪枝决策树</li></ul></li><li><p>缺点</p><ul><li>时间开销<h2 id="4-4连续与缺失值"><a href="#4-4连续与缺失值" class="headerlink" title="4.4连续与缺失值"></a>4.4连续与缺失值</h2><h5 id="连续与缺失值-连续值处理"><a href="#连续与缺失值-连续值处理" class="headerlink" title="连续与缺失值-连续值处理"></a>连续与缺失值-连续值处理</h5></li></ul></li><li><p>连续属性离散化(二分法)</p></li><li><p>缺失值处理</p><ul><li>面临两个问题 如何划分,如何测试</li></ul></li></ul><h2 id="4-5多变量决策树"><a href="#4-5多变量决策树" class="headerlink" title="4.5多变量决策树"></a>4.5多变量决策树</h2><h1 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h1><h2 id="5-1-神经网络模型与发展史"><a href="#5-1-神经网络模型与发展史" class="headerlink" title="5.1 神经网络模型与发展史"></a>5.1 神经网络模型与发展史</h2><ul><li>第一阶段<ul><li>M-P模型</li><li>Hebb学习规则:类似于巴普洛夫,if input and output 同时激活或者失活, 那么这两个神经元的链接应该被加强,else 应该减弱</li><li>感知机网络</li><li>自适应神经元,最小均方学习算法</li><li>GG 1: 单层的神经网络不能解决非线性问题,多层神经网络算力不足的时候就输了</li></ul></li><li>第二阶段<ul><li>Hopfield 网络</li><li>反向传播算法</li><li>SVM与统计学习理论</li></ul></li><li>第三阶段<ul><li>DBN深度信念网络</li></ul></li><li>神经元模型<ul><li>M-P神经元模型<ul><li>输入:来自其他n个神经元传递过来的输入信号</li><li>处理:输入信号通过带权重的连接进行传递,神经元接收到的总输入值将与神经元的阈值进行比较</li><li>输出:通过激活函数的处理以得到输出:$y=f(\sum _{i=1}^{n}w_ix_i-<br>\theta)$</li><li>扯一点signmoid(x)=$\frac{1}{1+e^{-x}}$<br>$y’=\frac{1}{1+e^{-x}}’=\frac{1}{1+e^{-x}}\times \frac{e^{-x}}{1+e^{-x}}=y(1-y)$</li></ul></li></ul></li></ul><h2 id="5-2-感知机与多层网络"><a href="#5-2-感知机与多层网络" class="headerlink" title="5.2 感知机与多层网络"></a>5.2 感知机与多层网络</h2><ul><li>感知机<ul><li>由两层神经元组成,输入层接受外界输入信号传递个输出层,输出层是M-神经元</li><li>与或非</li><li>多层感知机</li><li>多层前馈神经网络<ul><li>定义:每层神经元与下一层神经元全互联</li><li>前馈:输入层接受外界输入,隐含层与输出层神经元对信号进行加工,最终结果由输出层神经元输出</li></ul></li></ul></li></ul><h2 id="5-3-误差逆传播算法"><a href="#5-3-误差逆传播算法" class="headerlink" title="5.3 误差逆传播算法"></a>5.3 误差逆传播算法</h2><ul><li>误差逆传播算法(BP)<ul><li>前向计算:<ul><li>$b_h=f(\beta _h -y_h ),\beta _h=\sum_{i=1}^{d}v_{ih}x_i$</li><li>$\hat{y}_i^{k}=f(a_j-\theta _j),\alpha_h=\sum_{i=1}^{d} w_{hj}b_{h}$ </li><li>$E_k=\frac{1}{2}\sum_{j=1}^{l}(\hat{y}_{j}^{k}-\hat{y}_{j}^{k})^{2}$</li></ul></li><li>参数数目<ul><li>权重:$v_{ih},w_{hj}$, 阈值:$\theta _{j}$,$y_{h}$ (i=1,…,d,h=1,…,q,j=1,…,l)<br>因此网络中需要(d+l+1)q+l个参数需要优化</li></ul></li><li>参数优化<ul><li>BP是迭代学习算法,在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计,任意的参数v的更新估计式为<script type="math/tex; mode=display">v\leftarrow v+\Delta v</script></li><li>梯度咋整? 梯度消失咋整?</li><li>因为本质上还是函数的复合,因此不能用线性函数做传递函数</li></ul></li></ul></li><li>一些BP算法<ul><li>标准BP算法:每来一个样本,就扔到bp网络中,然后前馈得到误差,得到误差之后就逆传递回来更新网络……</li><li>累计BP算法:用平均误差更新权值,一定意义上可以减少震荡</li><li>实际应用: Mini BP 一块一块更新</li></ul></li><li>多层前馈网络:<ul><li>局限:<ul><li>可能遭遇过拟合</li><li>到底搞几层？</li></ul></li><li>解决过拟合策略：<ul><li>正则化</li><li>早停</li></ul></li></ul></li></ul><h2 id="5-4-全局最小与局部极小"><a href="#5-4-全局最小与局部极小" class="headerlink" title="5.4 全局最小与局部极小"></a>5.4 全局最小与局部极小</h2><ul><li>策略<ul><li>使用”模拟退火”</li><li>随机梯度下降</li><li>遗传算法 </li></ul></li></ul><h2 id="5-5-其他常见神经网络"><a href="#5-5-其他常见神经网络" class="headerlink" title="5.5 其他常见神经网络"></a>5.5 其他常见神经网络</h2><ul><li>RBF网络:单隐层,激活函数与输入向量有关:<script type="math/tex; mode=display">\phi(x)=\sum^{q}_{i=1}w_i\rho(x,c_i)</script>$\rho(x,c_i)$是径向基函数：<script type="math/tex; mode=display">\rho(x,c_i)=e^{-\beta_i ||x-c_i||^{2}}</script></li><li>ART网络：自适应谐振理论<br>竞争性学习网络,输出神经元互相竞争,遵循胜者通吃原则<br>比较层,识别层(???)</li><li>SOM网络：获取数据内在的结构</li><li>级联相关,或则隐层节点的构造</li><li>Elman网络：递归神经网络 </li></ul><h1 id="Chapter-6-支持向量机"><a href="#Chapter-6-支持向量机" class="headerlink" title="Chapter 6: 支持向量机"></a>Chapter 6: 支持向量机</h1><h1 id="传奇——一刀999"><a href="#传奇——一刀999" class="headerlink" title="传奇——一刀999"></a>传奇——一刀999</h1><p>神经网络(1989-1994)(BP算法)—————-&gt;支持向量机 (1995-2005)(核方法,统计学习)(Vapnik)————-&gt; 神经网络(2006-今)(深度学习)</p><div class="table-container"><table><thead><tr><th>支持向量机</th><th style="text-align:left">灵活（核方法）</th><th>能力很强</th><th>数学理论坚实</th><th>全局最优解</th><th>不需要人工调参</th></tr></thead><tbody><tr><td>神经网络</td><td style="text-align:left">更灵活</td><td>能力很强</td><td>理论不清,来自认知</td><td>局部最优解</td><td>非常依赖人工调参</td></tr><tr><td>支持向量机(SVM)</td><td style="text-align:left">计算开销大</td><td>领域知识嵌入困难(对现象的认识)</td><td>服务于科学界</td><td></td><td></td></tr><tr><td>神经网络(NN)</td><td style="text-align:left">可大可小</td><td>领域知识无处不在</td><td>服务于工业界</td><td></td></tr></tbody></table></div><h2 id="6-1-间隔与支持向量"><a href="#6-1-间隔与支持向量" class="headerlink" title="6.1 间隔与支持向量"></a>6.1 间隔与支持向量</h2><ul><li><p>最大间隔: 寻找参数$w$,b,使得$\nu=\frac{2}{||w||}$ 最大 </p><ul><li><script type="math/tex; mode=display">arg~max_{w,b}~\frac{2}{||w||}</script><p>s.t. $y_i(w^{T}x_i+b)\geq 1,i=1,2,…,m$</p></li><li><script type="math/tex; mode=display">arg~min~\frac{1}{2}||w||^{2}</script><p>s.t. $y_i(w^{T}x_i+b) \geq 1,i=1,2,…,m$</p></li></ul></li></ul><h2 id="6-2-对偶问题"><a href="#6-2-对偶问题" class="headerlink" title="6.2 对偶问题"></a>6.2 对偶问题</h2><ul><li><p>拉格朗日乘子法</p><ul><li>三步</li></ul></li><li><p>解的稀疏性</p><ul><li><p>最终模型:$f(x)=w^Tx+b=\sum_{i=1}^{m}a_iy_ix_{i}^{T}x+b$</p></li><li><p>KKT条件:</p><script type="math/tex; mode=display">{\begin{cases}a_i\geq 0\\y_if(x_i)\geq 1\\a_i(y_if(x_i)-1)=0\end{cases}}</script></li></ul></li><li><p>SMO-求解方法,选两个固定搞，因为两个有闭式解；</p></li></ul><h2 id="6-3-核函数"><a href="#6-3-核函数" class="headerlink" title="6.3 核函数"></a>6.3 核函数</h2><ul><li><p>从低维映射到高维可以用线性的方式进行分类，只要维数足够高，高维的空间总可以线性的来分类；</p></li><li><p>将x映射到$\phi(x)$转换前面的最终模型为:$f(x)=w^Tx+b=\sum_{i=1}^{m}a_iy_i\phi(x)_{i}^{T}\phi(x)+b$</p><p>定义核函数:$k(x_i,x_j)=\phi(x_i)^{T}\phi(x_j)$</p><p>定义核矩阵:<script type="math/tex">K= {\left[  \begin{matrix}    k(x_1,x_1) & k(x_1,x_2) & ... & k(x_1,x_n)\\  k(x_2,x_1) & k(x_2,x_2) & ... & k(x_2,y_n) \\   ...&... & ... & ..  \\   k(x_n,x_1) & k(x_n,x_2) & ... & k(x_n,y_n)  \end{matrix}  \right]}</script></p></li></ul><h2 id="6-4-软间隔与正则化"><a href="#6-4-软间隔与正则化" class="headerlink" title="6.4 软间隔与正则化"></a>6.4 软间隔与正则化</h2><ul><li>黑人问号，谜の调参(C)</li></ul><h2 id="6-5-支持向量回归"><a href="#6-5-支持向量回归" class="headerlink" title="6.5 支持向量回归"></a>6.5 支持向量回归</h2><ul><li>因为听不懂所以自闭了 感觉大概推了一个神奇的二次回归吧</li></ul><h2 id="6-6-核方法"><a href="#6-6-核方法" class="headerlink" title="6.6 核方法"></a>6.6 核方法</h2><ul><li>表示定理：对于任意单调增函数$\Omega$和任意非负损失函数l,优化问题……</li></ul><h1 id="Chapter-7-贝叶斯"><a href="#Chapter-7-贝叶斯" class="headerlink" title="Chapter 7 :贝叶斯"></a>Chapter 7 :贝叶斯</h1><h2 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a>7.1 贝叶斯决策论</h2><p>概率框架下实施决策的基本理论：</p><ul><li><p>条件风险</p><ul><li>$R(c_i|x)=\sum_{j=1}^{N}\lambda _{ij}P(c_j|x)$</li></ul></li><li><p>贝叶斯判定准则</p><ul><li>$h^{*}(x)=argmin_{c\in \gamma} ~R(c|x)$</li><li>$h^*(x)$:贝叶斯最优分类器,</li><li>反应了机器学习所能产生的模型精度的理论上限</li></ul></li><li><p>P(c|x)在现实中通常难以直接获得</p></li><li><p>两种基本策略：</p><ul><li>判别式模型：直接对P(c|x)建模<ul><li>决策树</li><li>BP神经网络</li><li>SVM</li></ul></li><li>生成式模型：先对联合概率分布P(x,c)建模,再由此获得P(c|x)<ul><li>$P(c|x)=\frac{P(x.c)}{P(x)}$</li></ul></li></ul></li><li><p>贝叶斯定理</p><ul><li><p>后验概率与联合概率分布的关系：</p><p>$P(c|x)=\frac{P=(x,c)}{P(x)}$</p></li><li><p>$P(c|x)=\frac{P(c)P(x|c)}{P(x)}=\frac{P(c)P(x|c)}{\int P(c)P(x|c)~dc}$</p><p>P(c):先验概率(人群中得病概率为1/1000000)</p><p>P(x):证据</p><p>P(c|x):后验概率(医院看到了症状之后判断的概率)  </p><p>P(x|c): likehood 似然(重点在另外的变量$\theta$上) ,likehood function目的是求$\theta$ </p><p>Prob(重点在变量上面) </p></li></ul></li></ul><h2 id="7-2极大似然估计"><a href="#7-2极大似然估计" class="headerlink" title="7.2极大似然估计"></a>7.2极大似然估计</h2><p>fenleiqifenleiqi（不太懂 <a href="https://blog.csdn.net/chenjianbo88/article/details/52398181" target="_blank" rel="noopener">https://blog.csdn.net/chenjianbo88/article/details/52398181</a></p><h2 id="7-3-朴素贝叶斯分类器-naive-Bayes-classifier"><a href="#7-3-朴素贝叶斯分类器-naive-Bayes-classifier" class="headerlink" title="7.3 朴素贝叶斯分类器(naive Bayes classifier)"></a>7.3 朴素贝叶斯分类器(naive Bayes classifier)</h2><p>假定属性独立地对分类结果发生影响</p><script type="math/tex; mode=display">P(c|x)=\frac{P(c)P(x|c)}{P(x)}=\frac{P(c)}{P(x)}\Pi^{d}_{i=1}P(x_i|c)</script><ul><li>P(c)=$\frac{D_c}{D}$</li><li>$P(x_i|c)=\frac{D_{c,x_i}}{D_c}$</li><li>拉普拉斯修正(为了解决某一个属性值在训练集中没有与某个类同时出现过就凉了 所以要假设出现了一次)<ul><li>$\hat{P(c)}=\frac{|D_c|+1}{|D|+N}$</li><li>$\hat{P(x_i|c)}=\frac{|D+{c_i,x_i}|+1}{|D_c|+N_i}$</li></ul></li><li>hint: 连续的分布用概率密度来代替,(一般用高斯分布)</li></ul><h2 id="7-4-半朴素贝叶斯分类器"><a href="#7-4-半朴素贝叶斯分类器" class="headerlink" title="7.4 半朴素贝叶斯分类器"></a>7.4 半朴素贝叶斯分类器</h2><p>One - Dependent Esitimator</p><ul><li><p>SPODE</p><p>超父带你飞</p></li><li><p>TAN</p><ul><li><p>计算条件互信息</p><p>$I(x_i,x_j|y)=\sum _{x_i,x_j;c\in \gamma}P(x_i,x_j|c)log\frac{P(x_i,x_j|c)}{P(x_i|c)P(x_j|c)}$</p></li><li><p>建完全图,权重设为上面的I</p></li><li><p>构建最大带权生成树,挑选根变量,将变置为有向</p></li><li><p>加入类别节点y,增加从y到每一个属性的有向边</p></li></ul></li><li><p>AODE</p></li></ul><h2 id="7-5-贝叶斯网"><a href="#7-5-贝叶斯网" class="headerlink" title="7.5 贝叶斯网"></a>7.5 贝叶斯网</h2><p>（概率论知识反应不能,To be continued</p><ul><li>V型例子:各位的智商x1 考试难度x2  最后的考试成绩x4,考完结果出来x1,x2就不独立了</li><li>道德图(从marriage的梗里面获得)</li><li></li></ul><h1 id="Chap-8-集成学习"><a href="#Chap-8-集成学习" class="headerlink" title="Chap 8 集成学习"></a>Chap 8 集成学习</h1><p>​    </p><p>​    </p><blockquote><p>PS：使用<a href="https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</a> 里面的方法解决了博客的数学公式显示问题</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习笔记&quot;&gt;&lt;a href=&quot;#机器学习笔记&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记&quot;&gt;&lt;/a&gt;机器学习笔记&lt;/h1&gt;&lt;p&gt;感谢毕秋宇同学！！&lt;/p&gt;
&lt;h1 id=&quot;Chapter-2&quot;&gt;&lt;a href=&quot;#Chapter-2&quot; 
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>数学期望</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/数学期望/</id>
    <published>2021-02-23T09:24:41.000Z</published>
    <updated>2021-02-23T09:26:15.447Z</updated>
    
    <content type="html"><![CDATA[<ul><li>离散型:$\sum _{k=1}^{\infty}x_kp_k$,需要它绝对收敛;</li><li>连续型:$\int_{-\infty}^{\infty}xp(x)dx$,同样需要它绝对收敛,如果$\int_{-\infty}^{\infty}|x|p(x)dx$发散,则X的数学期望不存在</li><li>Gamma函数:<script type="math/tex; mode=display">\Gamma(x)=\int_{0}^{+\infty}t^{x-1}e^{-t}</script><ul><li>$\Gamma(1)=1$</li><li>$\Gamma(x+1)=x\Gamma(x)$</li><li>$\Gamma(n)=(n-1)!$</li></ul></li><li>高斯积分:<ul><li>$\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}$</li></ul></li><li>$C_{n}^{k}=\frac{n!}{k!(n-k)!}$</li><li>$\int \frac{1}{1+x^2}=arctanx$</li></ul><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><ul><li>概率与数学期望及方差:<ul><li>0-1分布:$X~B(1,p)$,$0&lt;p&lt;1$:<ul><li>E(x)=0<em>(1-p)+1</em>p=p</li><li>D(X)=pq</li></ul></li><li>二项分布:$X~B(n,p)$,$0&lt;p&lt;1$<ul><li>$P\{X=k\}=C_{n}^kp^k(1-p)^{n-k},(k=0,1,…,n)$</li><li>$E(X)=np$<ul><li>$E(X)$的证明注意$\sum^{n-1}_{s=0}C^{s}_{n-1}p^s(1-p)^{n-1-s}=1$</li></ul></li><li>$D(x)=npq$</li></ul></li><li>几何分布:<ul><li>P(X=k)=$p(1-p)^{k-1}$</li><li>E(x)=</li></ul></li><li>泊松分布:X~$P(\lambda),\lambda&gt;0$<ul><li>$P\{X=k\}=\frac{\lambda^{k}}{k!}e^{-\lambda}$</li><li>E(X)=$\lambda$<ul><li>$E(x)$的证明注意$\sum_{m=0}^{\infty}\frac{\lambda^m}{m!}e^{-\lambda}=1$(这是因为泊松分布概率的加和为1)</li><li>D(X)=$\lambda$</li></ul></li></ul></li><li>均匀分布:X~$U(a,b)$<ul><li>$\begin{aligned}p(x)&amp;=\frac{1}{b-a},a&lt;x&lt;b;\\&amp;=0,<del>~</del>~~~others;\end{aligned}$</li><li>E(x)=$\frac{a+b}{2}$</li></ul></li><li>指数分布:X~E($\lambda$)$\lambda&gt;0$,<ul><li>p(x)=$\lambda e^{-\lambda x}$,x&gt;0;</li><li>E(x)=$\frac{1}{\lambda}$</li></ul></li><li>正态分布:X~N($\mu,\sigma^2$)<ul><li>p(x)=$\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;\infty$</li><li>E(x)=$\mu$</li><li>$\mu$:平均值;$\sigma^2$:X取值的离散程度</li></ul></li><li>代换:<ul><li>一维<ul><li>E(Y)=E[g(X)]=$\sum_{k=1}^{\infty}g(x_k)p_k$(离散)</li><li>E(Y)=E[g(X)]=$\int_{-\infty}^{+\infty}g(x)p(x)dx$</li></ul></li><li>二维<ul><li>E(Z)=E[g(X,Y)]=$\sum_{j=1}^{\infty}\sum_{i=1}^{\infty}g(x_i,y_i)p_{ij}$(离散型)</li><li>E(Z)=E[g(X,Y)]=$\int_{j=1}^{\infty}\int_{i=1}^{\infty}g(x,y)p_{x,y}dxdy$(连续型)</li></ul></li><li>边缘密度:E(g(X,Y)),g(X,Y)=x,E(x)=$\int_{j=1}^{\infty}\int_{i=1}^{\infty}xp_{x,y}dxdy$</li><li>性质:<ul><li>E(X+Y)=E(X)+E(Y)</li><li>if X,Y互相独立:E(XY)=E(X)E(Y)</li><li>设C是常数:E(C)=C</li><li>设k是常数:E(kx)=kE(x)</li></ul></li></ul></li></ul></li></ul><h1 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h1><ul><li>D(X)=E{[X-E(X)]$^2$}<ul><li>D(X)=$\sum_{k=1}^{+\infty}[x_k-E(X)]^2p_k$</li><li>D(X)=$\int_{-infty}^{+\infty}[x_k-E(X)]^2p_k$</li><li>D(x)=E($X^2$)-$[E(x)]^2$</li></ul></li><li>性质:<ul><li>D(C)=0;</li><li>C是常数<ul><li>D(CX)=$C^2$D(X)</li><li>D(X+C)=D(X)</li></ul></li><li>D(X),D(Y)存在:<ul><li>if 不独立:D($X\pm Y$)=$D(X)\pm +D(y)\pm 2E\{(X-E(X))(Y-E(Y))\}$</li><li>else:D($X\pm Y$)=$D(X)\pm +D(y)$</li></ul></li><li>切比雪夫不等式:<ul><li>$P{|X-E(X)|\geq \varepsilon }\leq \frac{D(X)}{\varepsilon ^2 }$</li><li>$P{|X-E(X)|&lt;&gt; \varepsilon }\geq 1- \frac{D(X)}{\varepsilon ^2 }$</li></ul></li><li>D(X)=0  $\Leftrightarrow $ P{X=C}=1</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;离散型:$\sum _{k=1}^{\infty}x_kp_k$,需要它绝对收敛;&lt;/li&gt;
&lt;li&gt;连续型:$\int_{-\infty}^{\infty}xp(x)dx$,同样需要它绝对收敛,如果$\int_{-\infty}^{\infty}|x|p(x)
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="概率论" scheme="http://Tyler-ytr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-2:P4 basic实验</title>
    <link href="http://Tyler-ytr.github.io/2021/02/21/p4%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://Tyler-ytr.github.io/2021/02/21/p4学习-2/</id>
    <published>2021-02-21T09:12:26.000Z</published>
    <updated>2021-02-25T08:18:32.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-2：P4-basic实验"><a href="#P4学习-2：P4-basic实验" class="headerlink" title="P4学习-2：P4 basic实验"></a>P4学习-2：P4 basic实验</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><ol><li><p>写一个P4程序完成基本的IPV4转发，也就是交换机需要:1.更新源和目的MAC地址 2. 在IP报头中减少 time-to-live(TTL)  3.将数据包转发到适当的端口</p><p>交换机有一个简单的table,控制平面将根据基本的规则更新它。每个规则将一个IP地址映射到下一跳的MAC地址和输出端口。我们已经定义了控制平面规则，所以你只需要实现你的P4程序的数据平面逻辑。</p></li><li><p>拓扑如下:</p><p><img src="/picture/pod-topo.png" alt="pod-topo"></p></li><li><p>实验basic.p4给了一个p4程序，关键部分被TODO代替，这个程序主要由以下部分组成:</p><ol><li><p>Ethernet (<code>ethernet_t</code>) and IPv4 (<code>ipv4_t</code>)两个header type的类型定义</p></li><li><p><strong>TODO</strong>：用于以太网和IPv4的Parser,它通过解析数据包填充了上述两个header;</p></li><li><p>一个丢包的动作，用了<code>mark_to_drop()</code></p></li><li><p><strong>TODO</strong>：一个动作（<code>ipv4_forward</code>）：</p><ol><li>设置下一跳的出口端口。</li><li>更新以太网目的地址为下一跳地址。</li><li>将以太网源地址更新为交换机地址。</li><li>TTL衰减。</li></ol></li><li><p><strong>TODO:</strong> 一个control:</p><ol><li>定义一个表，该表将读取IPv4目的地址，并调用<code>drop</code> 或者<code>ipv4_forward</code></li><li>应用这个表的一个 <code>apply</code>  block </li></ol></li><li><p>选择字段插入出数据包的顺序的Deparser。</p></li><li><p>实例化部分</p><blockquote><p>通常，包还需要校验和验证和重新计算控件的实例。这些对于本教程来说不是必需的，它们将被空控件的实例化所取代。</p></blockquote></li></ol></li></ol><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><p>本部分根据上面对程序的描述一一进行分析：</p><h5 id="headers部分"><a href="#headers部分" class="headerlink" title="headers部分:"></a>headers部分:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F; # 声明语言是p4-16</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123; # header数据结构相当于c语言里面的 packed struct,它有一个隐藏的参数validity，如果解析正确那么是true，可以通过isValid()获得，比如hdr.ipv4.isValid();</span><br><span class="line">    macAddr_t dstAddr;# macAddr_t是typedef bit&lt;48&gt; 的自定义类型</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;#4bit的数据</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123; #struct数据结构相当于python里面的 dictionary</span><br><span class="line">    &#x2F;* empty *&#x2F; #这个实验用不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t   ethernet;</span><br><span class="line">    ipv4_t       ipv4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中V1model的结构如下图所示:</p><p> <img src="/picture/image-20210222224801495.png" alt="image-20210222224801495"></p><p> 总的来说这是一个模板，大致由下图组成:</p><p> <img src="/picture/image-20210222224659076.png" alt="image-20210222224659076"></p><p> 主要由HEADERS,PARSER,CHECKSUMVERFICATION,INGRESSPROCESSING,EGRESSPROCESSING,CHECKSUM UPDATE,DEPARSER,SWITCH组成;大概实例化的解释如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">V1Switch(</span><br><span class="line">MyParser(),    &#x2F;&#x2F; 解析数据包，提取包头 </span><br><span class="line">MyVerifyChecksum(),  &#x2F;&#x2F; 校验和验证</span><br><span class="line">MyIngress(),   &#x2F;&#x2F; 输入处理</span><br><span class="line">MyEgress(),    &#x2F;&#x2F; 输出处理</span><br><span class="line">MyComputeChecksum(),  &#x2F;&#x2F; 计算新的校验和</span><br><span class="line">MyDeparser()   &#x2F;&#x2F; 逆解析器</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h5 id="Parser部分"><a href="#Parser部分" class="headerlink" title="Parser部分"></a>Parser部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        &#x2F;* TODO: add parser logic *&#x2F;</span><br><span class="line">        transition accept;#表示接受，也就是程序终止</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr, #out相当于输出的数据,然后它的type是headers</span><br><span class="line">                inout metadata meta, #inout同时作为输入和输出值，类似 c++ 里面的引用</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;#转移到解析以太包头阶段</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_ethernet&#123;</span><br><span class="line">    packet.extract(hdr.ethernet); #把packet提取到hdr的ethernet里面，这里的过程可以理解为根据ethernet的长度截取一段数据</span><br><span class="line">    transition select(hdr.ethernet.etherType)&#123;#根据etherType的值选择进入的状态</span><br><span class="line">    TYPE_IPV4: parse_ipv4;#是IPV4包，进入解析ipv4的状态</span><br><span class="line">    default: accept;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_ipv4&#123;</span><br><span class="line">    packet.extract(hdr.ipv4); #接着解析ipv4部分，这里可以理解为指针又往前移动了</span><br><span class="line">    transition accept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Ingress部分"><a href="#Ingress部分" class="headerlink" title="Ingress部分"></a>Ingress部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        &#x2F;* TODO: fill out code in action body *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;* TODO: fix ingress control logic</span><br><span class="line">         *  - ipv4_lpm should be applied only when IPv4 header is valid</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ipv4_lpm.apply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec&#x3D;port; #egress_spec可以在输入代码中指定一个值来控制数据包将去哪个输出端口</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;  #原数据包的源地址改为目的地址</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr; #目的地址改为控制面传入的新的地址</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;       #ttl要减去1</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;# 隐藏的参数，判断解析是否成功</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:standard_metadata是<a href="https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4" target="_blank" rel="noopener">v1model.p4</a>里面定义的数据结构，在<a href="https://github.com/p4lang/behavioral-model/blob/main/docs/simple_switch.md" target="_blank" rel="noopener">simple_switch</a>的README里面进行了详细的解释,simple_switch是p4语言的一种架构，它大概的定义如下,其中v1m表示v1model,p4-16的一种模型，sm14是p4-14里面定义的模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ingress_port (sm14, v1m) - For new packets, the number of the ingress port on which the packet arrived to the device. Read only.</span><br><span class="line">packet_length (sm14, v1m) - For new packets from a port, or recirculated packets, the length of the packet in bytes. For cloned or resubmitted packets, you may need to include this in a list of fields to preserve, otherwise its value will become 0.</span><br><span class="line">egress_spec (sm14, v1m) - Can be assigned a value in ingress code to control which output port a packet will go to. The P4_14 primitive drop, and the v1model primitive action mark_to_drop, have the side effect of assigning an implementation specific value DROP_PORT to this field (511 decimal for simple_switch by default, but can be changed through the --drop-port target-specific command-line option), such that if egress_spec has that value at the end of ingress processing, the packet will be dropped and not stored in the packet buffer, nor sent to egress processing. See the &quot;after-ingress pseudocode&quot; for relative priority of this vs. other possible packet operations at end of ingress. If your P4 program assigns a value of DROP_PORT to egress_spec, it will still behave according to the &quot;after-ingress pseudocode&quot;, even if you never call mark_to_drop (P4_16) or drop (P4_14).</span><br><span class="line">egress_port (sm14, v1m) - Only intended to be accessed during egress processing, read only. The output port this packet is destined to.</span><br><span class="line">egress_instance (sm14) - Renamed egress_rid in simple_switch. See egress_rid below.</span><br><span class="line">instance_type (sm14, v1m) - Contains a value that can be read by your P4 code. In ingress code, the value can be used to distinguish whether the packet is newly arrived from a port (NORMAL), it was the result of a resubmit primitive action (RESUBMIT), or it was the result of a recirculate primitive action (RECIRC). In egress processing, can be used to determine whether the packet was produced as the result of an ingress-to-egress clone primitive action (INGRESS_CLONE), egress-to-egress clone primitive action (EGRESS_CLONE), multicast replication specified during ingress processing (REPLICATION), or none of those, so a normal unicast packet from ingress (NORMAL). Until such time as similar constants are pre-defined for you, you may copy this list of constants into your code.</span><br><span class="line">parser_status (sm14) or parser_error (v1m) - parser_status is the name in the P4_14 language specification. It has been renamed to parser_error in v1model. The value 0 (sm14) or error.NoError (P4_16 + v1model) means no error. Otherwise, the value indicates what error occurred during parsing.</span><br><span class="line">parser_error_location (sm14) - Not present in v1model.p4, and not implemented in simple_switch.</span><br><span class="line">checksum_error (v1m) - Read only. 1 if a call to the verify_checksum primitive action finds a checksum error, otherwise 0. Calls to verify_checksum should be in the VerifyChecksum control in v1model, which is executed after the parser and before ingress.</span><br></pre></td></tr></table></figure><h5 id="Egress部分"><a href="#Egress部分" class="headerlink" title="Egress部分"></a>Egress部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Checksum-部分"><a href="#Checksum-部分" class="headerlink" title="Checksum 部分"></a>Checksum 部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*************   C H E C K S U M    C O M P U T A T I O N   **************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123;</span><br><span class="line">     apply &#123;</span><br><span class="line">update_checksum(</span><br><span class="line">    hdr.ipv4.isValid(),</span><br><span class="line">            &#123; hdr.ipv4.version,</span><br><span class="line">      hdr.ipv4.ihl,</span><br><span class="line">              hdr.ipv4.diffserv,</span><br><span class="line">              hdr.ipv4.totalLen,</span><br><span class="line">              hdr.ipv4.identification,</span><br><span class="line">              hdr.ipv4.flags,</span><br><span class="line">              hdr.ipv4.fragOffset,</span><br><span class="line">              hdr.ipv4.ttl,</span><br><span class="line">              hdr.ipv4.protocol,</span><br><span class="line">              hdr.ipv4.srcAddr,</span><br><span class="line">              hdr.ipv4.dstAddr &#125;,</span><br><span class="line">            hdr.ipv4.hdrChecksum,</span><br><span class="line">            HashAlgorithm.csum16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;# 内置函数</span><br></pre></td></tr></table></figure><h5 id="Deparser部分"><a href="#Deparser部分" class="headerlink" title="Deparser部分"></a>Deparser部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;* TODO: add deparser logic *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);#按照顺序封装,emit的含义是发射</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例化部分"><a href="#实例化部分" class="headerlink" title="实例化部分"></a>实例化部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  S W I T C H  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">V1Switch(</span><br><span class="line">MyParser(),</span><br><span class="line">MyVerifyChecksum(),</span><br><span class="line">MyIngress(),</span><br><span class="line">MyEgress(),</span><br><span class="line">MyComputeChecksum(),</span><br><span class="line">MyDeparser()</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果:"></a>实验结果:</h4><p>pingall测试:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210223225105957.png" alt="image-20210223225105957" title="">                </div>                <div class="image-caption">image-20210223225105957</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-2：P4-basic实验&quot;&gt;&lt;a href=&quot;#P4学习-2：P4-basic实验&quot; class=&quot;headerlink&quot; title=&quot;P4学习-2：P4 basic实验&quot;&gt;&lt;/a&gt;P4学习-2：P4 basic实验&lt;/h2&gt;&lt;h4 id=&quot;实验目标&quot;
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-1:介绍与参考资料</title>
    <link href="http://Tyler-ytr.github.io/2021/02/18/p4%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://Tyler-ytr.github.io/2021/02/18/p4学习-1/</id>
    <published>2021-02-18T03:08:37.000Z</published>
    <updated>2021-03-13T03:37:30.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-1：介绍与参考资料"><a href="#P4学习-1：介绍与参考资料" class="headerlink" title="P4学习-1：介绍与参考资料"></a>P4学习-1：介绍与参考资料</h2><h4 id="实验前"><a href="#实验前" class="headerlink" title="实验前"></a>实验前</h4><ol><li><p>P4的PISA(Protocol-Independent Switch Architecture)结构：</p><p>Programmable  Parser—-&gt;Programmable Match-Action Pipeline—-&gt; Programmable Deparser；</p><p>Parser作用:程序员声明应该被识别的头和它们在包中的顺序</p><p>Match-Action作用:程序员定义表和精确的处理算法</p><p>Deparser作用:程序员声明输出的包怎样输出到总线上</p><p><img src="/picture/image-20210220162023603.png" alt="image-20210220162023603"></p><p>整个结构都是流水线架构，一个来自外部的网络数据包经过层层流程首先被Parser解析出headers,然后进入Match-Action Table进行匹配和操作，这些headsers可以被添加/修改/删除；然后进入Deparser组装好流入外部网络，因为是流水线，所以Match-Action部分是不可以回头的 ；</p></li><li><p>实验部分——文件结构:(主要参考博客)</p><p> tutorials的文件结构:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tutorials&#x2F;</span><br><span class="line">├── exercises   # 存放各种练习</span><br><span class="line">├── utils       # 工具脚本目录</span><br><span class="line">└── vm          # 用于vagrant构建虚拟机的目录，可以无视</span><br></pre></td></tr></table></figure><p> 例子的文件结构:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 我们切换进入 exercises&#x2F;basic_tunnel 这个例子</span><br><span class="line">basic</span><br><span class="line">├── basic_tunnel.p4   # 要编写的p4代码</span><br><span class="line">├── build      # 生成文件的目录</span><br><span class="line">├── logs       # 日志文件， 在调试的时候真的非常重要！</span><br><span class="line">├── Makefile   ### 通过Makefile 来调用utils下的脚本!</span><br><span class="line">├── pcaps      # 生成的pcap包，可以使用wireshark等工具来分析</span><br><span class="line">├── README.md  # 详细的指导</span><br><span class="line">├── receive.py ## 利用scapy写的抓取和分析数据包的工具</span><br><span class="line">├── s1-runtime.json  #</span><br><span class="line">├── s2-runtime.json  # 在运行同时加载入交换机的控制面代码，这里有争议，稍后再谈</span><br><span class="line">├── s3-runtime.json  #</span><br><span class="line">├── send.py    ## 利用scapy写的构建和发送数据包的工具</span><br><span class="line">├── solution   # 这里有这个例子的示例代码（答案）</span><br><span class="line">└── topology.json  # 描述拓扑的json文件</span><br></pre></td></tr></table></figure><blockquote><p>这部分摘自参考资料的博客，实际情况有所不同</p></blockquote><p> Makefile会调用前面提到的utils下面的Makefile脚本，运行P4代码;</p><p> 使用make run 启动;</p><p> 调用<code>make run</code>，我们可以运行当前目录下（以basic目录为例）的代码，它将执行以下几个步骤:</p><ul><li>编译basic.p4 代码，生成basic.json</li><li>解析topology.json， 并且构建相应的mininet仿真拓扑，按照该拓扑启动一台或者多台BMv2交换机，以及一些host</li><li>启动BMv2的同时会将p4代码编译产生的json文件导入</li><li>启动BMv2后会解析 sN-runtime.json 文件(s1,s2,s3……)，将其载入 交换机sN流表之中</li><li>进入mininet命令行，同时开始记录log以及搜集pcap文件</li></ul></li><li><p>P4的参考手册:<a href="https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html" target="_blank" rel="noopener">https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html</a></p></li></ol><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://www.sdnlab.com/22512.html" target="_blank" rel="noopener">https://www.sdnlab.com/22512.html</a></li><li>P4官方tutorial(<a href="https://github.com/p4lang/tutorials" target="_blank" rel="noopener">https://github.com/p4lang/tutorials</a>)</li><li><a href="https://www.zhihu.com/column/c_1336207793033015296" target="_blank" rel="noopener">P4学习笔记专栏</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-1：介绍与参考资料&quot;&gt;&lt;a href=&quot;#P4学习-1：介绍与参考资料&quot; class=&quot;headerlink&quot; title=&quot;P4学习-1：介绍与参考资料&quot;&gt;&lt;/a&gt;P4学习-1：介绍与参考资料&lt;/h2&gt;&lt;h4 id=&quot;实验前&quot;&gt;&lt;a href=&quot;#实验
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode21-s</title>
    <link href="http://Tyler-ytr.github.io/2021/02/14/leetcode21-s/"/>
    <id>http://Tyler-ytr.github.io/2021/02/14/leetcode21-s/</id>
    <published>2021-02-14T09:46:54.000Z</published>
    <updated>2021-02-14T09:51:48.658Z</updated>
    
    <content type="html"><![CDATA[<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><p>难度简单1530</p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/merge_ex1.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                l1,l2=l2,l1</span><br><span class="line">            l1.next=self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21. 合并两个有序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="递归" scheme="http://Tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>p4安装</title>
    <link href="http://Tyler-ytr.github.io/2021/02/07/p4%E5%AE%89%E8%A3%85/"/>
    <id>http://Tyler-ytr.github.io/2021/02/07/p4安装/</id>
    <published>2021-02-07T08:25:10.000Z</published>
    <updated>2021-03-04T01:28:45.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="P4环境配置"><a href="#P4环境配置" class="headerlink" title="P4环境配置"></a>P4环境配置</h4><blockquote><p>因为之后使用的时候PI那块还是有问题，建议谨做参考，安装还是最好用一用官方的tuorials里面的虚拟机脚本</p></blockquote><h5 id="0-准备"><a href="#0-准备" class="headerlink" title="0.准备"></a>0.准备</h5><ul><li><p>基础环境ubuntu 18.04 LTS</p></li><li><p>使用trojan终端代理，不然一些下载太慢了</p></li><li><p>ubuntu换源到阿里云</p></li><li><p>在~目录新建P4目录并且加入环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir P4</span><br><span class="line">cd P4</span><br><span class="line">echo&quot;P4_HOME&#x3D;$(pwd)&quot;&gt;&gt; ~&#x2F;.bashrc</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y cmake g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev libboost-graph-dev llvm pkg-config python python-scapy python-ipaddr python-ply tcpdump doxygen graphviz texlive</span><br><span class="line">sudo apt-get install g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev pkg-config python python-scapy python-ipaddr tcpdump cmake## 两个参考里面的可能有重复</span><br></pre></td></tr></table></figure><p>下面都是在P4文件夹进行的工作</p><blockquote><p>所有的make都巨慢，合理安排好时间</p></blockquote></li></ul><h5 id="1-安装依赖库protocol"><a href="#1-安装依赖库protocol" class="headerlink" title="1. 安装依赖库protocol"></a>1. 安装依赖库protocol</h5><ul><li><p>参考了这个依赖库github的C++环境的<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/README.md" target="_blank" rel="noopener">README</a>;</p></li><li><p>安装依赖并且git clone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf.git</span><br><span class="line">cd protobuf</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">.&#x2F;autogen.sh</span><br></pre></td></tr></table></figure><blockquote><p>其中 git submodule update —init —recursive 必做，这会下载好相应的googletest文件，忽略这一步会在make check报错</p></blockquote></li><li><p>然后build以及安装，下面步骤耗时较长:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig # refresh shared library cache.更新共享库</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-安装PI以及它的依赖"><a href="#2-安装PI以及它的依赖" class="headerlink" title="2. 安装PI以及它的依赖"></a>2. 安装PI以及它的依赖</h5><ul><li><p>参考PI的 github网站<a href="https://github.com/p4lang/PI" target="_blank" rel="noopener">https://github.com/p4lang/PI</a> 安装</p></li><li><p>首先安装gRPC V1.17.2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;grpc.git</span><br><span class="line">cd grpc&#x2F;</span><br><span class="line">git checkout tags&#x2F;v1.17.2</span><br><span class="line">git submodule update --init --recursive # 这步耗时较长，一定要代理</span><br><span class="line">make #也可以make -j4 表示用四个核make,j后面这个数量可以自己设定</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br><span class="line"># Install gRPC Python Package 这步安装挺慢的</span><br><span class="line">sudo pip install grpcio</span><br></pre></td></tr></table></figure></li><li><p>然后安装PI —with-proto,（To include <code>p4runtime.proto</code> in the build, please run <code>configure</code> with <code>--with-proto</code>.）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --with-proto</span><br><span class="line">make </span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-安装bmv2"><a href="#3-安装bmv2" class="headerlink" title="3. 安装bmv2"></a>3. 安装bmv2</h5><ul><li><p>建议先阅读原来的github库(<a href="https://github.com/p4lang/behavioral-model" target="_blank" rel="noopener">https://github.com/p4lang/behavioral-model</a>)</p></li><li><p>安装操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;P4</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;behavioral-model.git</span><br><span class="line">cd behavioral-model</span><br><span class="line">sudo .&#x2F;install_deps.sh #脚本安装依赖库</span><br></pre></td></tr></table></figure><blockquote><p>终端代理的好处在于这些脚本如果不是终端代理下载会异常慢以至于不得不手动转换到gitee安装</p><p>安装依赖库因为要编译其他第三方库也异常的慢</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  .&#x2F;autogen.sh</span><br><span class="line">  .&#x2F;configure --enable-debugger --with-pi</span><br><span class="line">  make</span><br><span class="line">  sudo make install</span><br><span class="line">  sudo sudo ldconfig</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-安装p4c"><a href="#4-安装p4c" class="headerlink" title="4. 安装p4c"></a>4. 安装p4c</h5><ul><li><p>下载库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;P4</span><br><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;p4c.git</span><br><span class="line">cd p4c</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make -j4 #4线程编译</span><br><span class="line">sudo make install</span><br><span class="line">cd ..&#x2F;..</span><br></pre></td></tr></table></figure><blockquote><p>这步如果make -j4后面make check 会花很多时间然后有可能报错</p></blockquote></li></ul><h5 id="5-下载p4-tutorials"><a href="#5-下载p4-tutorials" class="headerlink" title="5. 下载p4 tutorials"></a>5. 下载p4 tutorials</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;tutorials</span><br></pre></td></tr></table></figure><p>目前的目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P4</span><br><span class="line">|——behavioral-model # BMv2 软件交换机</span><br><span class="line">|——grpc  # 作为BMv2的依赖</span><br><span class="line">|——mininet # 网络仿真</span><br><span class="line">|——p4c #p4c编译器</span><br><span class="line">|——PI # PI P4 runtime库</span><br><span class="line">|——protobuf # 依赖</span><br><span class="line">|——tutorials #教程</span><br></pre></td></tr></table></figure><h5 id="6-解决实验出现的bug"><a href="#6-解决实验出现的bug" class="headerlink" title="6. 解决实验出现的bug"></a>6. 解决实验出现的bug</h5><p>在做实验的时候出现了陆陆续续的bug，还需要:</p><ol><li><p>No module named psutil</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;p&#x2F;psutil&#x2F;psutil-2.1.3.tar.gz </span><br><span class="line">    tar -zxvf psutil-2.1.3.tar.gz</span><br><span class="line">    cd psutil-2.1.3</span><br><span class="line">    python setup.py install</span><br></pre></td></tr></table></figure></li><li><p>No module named google.protobuf.internal</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install protobuf</span><br></pre></td></tr></table></figure></li><li><p>根据<a href="https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc" target="_blank" rel="noopener">https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc</a> 安装simple_switch_grpc</p></li><li><p>安装之后还是P4 switch s1 did not start correctly，根据issue<a href="https://github.com/p4lang/tutorials/issues/107" target="_blank" rel="noopener">https://github.com/p4lang/tutorials/issues/107</a> ，还需要：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p> 至此可以编译basic实验</p></li><li><p>安装之后进行P4runtime的时候出现报错 ：No module named rpc 尚未解决 因此建议还是使用官方的vagrant</p></li></ol><blockquote><p> PS: 最后发现其实最标准的安装操作是根据tutorials（<a href="https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢" target="_blank" rel="noopener">https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢</a></p></blockquote><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><ul><li><a href="https://p4.org/p4/getting-started-with-p4.html" target="_blank" rel="noopener">https://p4.org/p4/getting-started-with-p4.html</a></li><li><a href="https://www.jianshu.com/p/2878192ba3f7" target="_blank" rel="noopener">https://www.jianshu.com/p/2878192ba3f7</a></li><li><a href="https://www.sdnlab.com/22512.html" target="_blank" rel="noopener">https://www.sdnlab.com/22512.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;P4环境配置&quot;&gt;&lt;a href=&quot;#P4环境配置&quot; class=&quot;headerlink&quot; title=&quot;P4环境配置&quot;&gt;&lt;/a&gt;P4环境配置&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;因为之后使用的时候PI那块还是有问题，建议谨做参考，安装还是最好用一用官方的tuo
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型2</title>
    <link href="http://Tyler-ytr.github.io/2020/10/09/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B2/"/>
    <id>http://Tyler-ytr.github.io/2020/10/09/深度探索C-对象模型2/</id>
    <published>2020-10-09T03:13:38.000Z</published>
    <updated>2020-10-09T03:15:26.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度探索c-对象模型2"><a href="#深度探索c-对象模型2" class="headerlink" title="深度探索c++对象模型2"></a>深度探索c++对象模型2</h2><p>这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”和“程序效率”的冲击</p><h4 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h4><ul><li><p>带有默认构造函数的Member Class Object</p><p>总结而言就是，如果对象a中依次有对象b，c，d，如果程序员仅仅初始化了c（10），那么编译器会调用b，d的默认构造函数，顺序是b，c（10），d；另外，对于对象g，假设里面只有int c;string d;编译器的隐式默认构造函数是不会帮忙解决这两者的初始化问题的，也就是这个构造函数是trivial的</p></li><li><p>带有默认构造函数的Base Class</p><p>一个类的构造函数，需要调用一些基类的构造函数（必要之默认构造函数），你自定义的构造函数，编译器会帮你补上调用那些构造函数的部分；先调用基类的默认构造函数然后调用成员类的默认构造函数</p></li><li><p>带有一个Virtual Function 的 Class</p><p>以下两种情况，需要编译器合成出default constructor</p><ul><li>class声明（或者继承）一个virtual constructor</li><li>class派生自一个继承串链，其中有一个或者更多的virtual base classes<br>以上两种情况如果缺乏用户声明的constructor，那么编译器会详细记录合成一个default constructor 的必要信息。主要有以下两种扩张行动：</li><li>一个虚函数表会被编译器产生出来，存放着类的虚函数地址</li><li>一个vptr会被编译器合成出来，包含着虚函数表的地址</li></ul></li><li><p>带有一个Virtual Base Class 的 Class</p><p>C继承A、B，A虚继承X，B虚继承X；根据不同编译器，在构造这些对象的时候会有类似指针的东西指向虚继承的类里面的成员，这些都是编译器在类对象构造期间完成的；对于这样的类所定义的每一个构造函数，编译器会安插那些“允许每一个virtual base class的执行期存取操作”的代码。如果class没有声明任何的constructors,编译器必须为它合成一个default constructor。；</p></li><li><p>总结：</p><p>上面四种情况，会造成：编译器必须为没有声明构造函数的类合成一个默认构造函数“，这些合成物被称为隐式非平凡默认构造函数(implicit nontrivial default constructors)。除此之外都是隐式平凡构造函数，实际上不会被合成出来。</p><p>在合成出来的这些构造函数里面，只有base class subobjects和member class objects会被初始化，其他的都不会。</p></li></ul><h4 id="Copy-Constructor-的构造操作"><a href="#Copy-Constructor-的构造操作" class="headerlink" title="Copy Constructor 的构造操作"></a>Copy Constructor 的构造操作</h4><ul><li><p>下面三种情况，会以一个object的内容作为另一个class object的初值</p><ul><li><p>显式地以一个对象的内容作为另一个类对象的初值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">X xx&#x3D;x;</span><br></pre></td></tr></table></figure></li><li><p>当对象被当做参数交给某一个函数的时候</p></li><li><p>当函数传回一个类对象的时候</p></li></ul><p>如果类的设计者显式定义了一个拷贝构造函数，就会调用它</p></li><li><p>默认的拷贝构造函数</p><p>当类没有提供一个显示的拷贝构造函数时候使用，用递归的方式实行member initialization，比每一个内建的活着派生的data member的值从一个object拷贝到另一个上面。</p><p>下面讨论的是隐式的拷贝构造函数编译器是否会合成一个default copy constructor的问题。根据C++标准，决定一个copy constructor 是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。（只有nontrivial的实例才会被合成于程序里面。）</p></li><li><p>bitwise copy semantics（位逐次拷贝）</p><p>什么时候一个class不展现出所谓的位逐次拷贝呢？</p><ul><li>一个class中有一个成员变量的class里面声明了一个copy constructor</li><li>这个class继承自一个基类，然后这个基类里面有一个copy constructor</li><li>当class声明了一个或者多个virtual functions（考虑vptr的拷贝问题）</li><li>当class派生自一个继承串链，其中有一个或者多个virtual base classes（发生在一个class object 以其derived classes的某一个对象作为初值的时候，编译器需要安插一些代码来设定virtual base class pointer/offset 的初值）</li></ul></li></ul><h4 id="程序转化语义学（Program-Transformation-Semantics）"><a href="#程序转化语义学（Program-Transformation-Semantics）" class="headerlink" title="程序转化语义学（Program Transformation Semantics）"></a>程序转化语义学（Program Transformation Semantics）</h4><ul><li><p>主要从初始化，参数初始化，返回值初始化三个角度探讨了拷贝构造函数的应用及应用的伪码；</p></li><li><p>显示初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo_bar()&#123;</span><br><span class="line">X x1(x0);</span><br><span class="line">X x2&#x3D;x0;</span><br><span class="line">X x3&#x3D;X(x0);</span><br></pre></td></tr></table></figure></li></ul><p>转换成的可能的伪码：<br>    <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/Pwv3q8xTrLdlOkE.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><br>    其中：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1.X::X(x0);</span><br></pre></td></tr></table></figure></code></pre><p>//表现为对一下copy constructor 的调用：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X::x(const X&amp; xx);</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>参数初始化：<br>对于一下子调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(X x0);</span><br><span class="line">X xx;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">foo(xx)</span><br></pre></td></tr></table></figure><p>可能的伪码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">__temp0.X::X(xx);</span><br><span class="line">foo(__temp0);</span><br></pre></td></tr></table></figure></li><li><p>返回值的初始化：<br>对于以下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X bar()&#123;</span><br><span class="line">x xx;</span><br><span class="line">&#x2F;&#x2F;....</span><br><span class="line">return xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为如下伪码：<br><img src="/picture/9afNxvP82DGHIso.jpg" alt="Alt"></p></li><li><p>NRV优化：</p><p>NRV(name returned value)优化大致如下，我觉得是通过把返回的临时变量变成一个引用形参来实现的；</p><p><img src="/picture/972snfWXvIZRYDM.jpg" alt="Alt"></p><p>NRV优化需要一个copy constructor,（最好是内联的提高效率)</p></li><li><p>最后探讨了copy constructor 要还是不要的问题，我觉得它的含义是，从速度角度来看，如果存在NRV优化的可能性，以及传值的要求，那么实现拷贝构造函数可以帮助实现这一点；</p></li></ul><p>同时实现拷贝构造函数准备使用memcpy，memset的时候要注意是否有虚函数或者含有虚基类，防止错误的改变内部的vtpr;</p><p>比如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/grnbpALH8OlUXVj.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/kgviWzxyEhc314V.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><h4 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h4><ul><li><p>必须使用成员初始化表的四种情况：</p><ol><li>当初始化一个reference member</li><li>当初始化一个const member;</li><li>当调用一个base class 的constructor，而它拥有一组参数的时候;</li><li>当调用一个member class的constructor，而它拥有一组参数的时候；</li></ol></li><li><p>使用的注意点：</p><ol><li>顺序问题，成员初始化表的初始化顺序是声明的顺序，因此如下代码会有bug:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">public:</span><br><span class="line">X(int val):j(val),i(j)&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实际执行的时候是先i(j)然后j(val)的；</p><p>另外成员初始化表在显式代码的前面，因此</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">public:</span><br><span class="line">X(int val):j(val)&#123;</span><br><span class="line">i&#x3D;j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  是合法的；</p><ul><li>本书不太建议在成员初始化表里面调用一个member function进行初始化，主要因为不清楚具体的依赖关系的问题；当然如下图的伪代码，这是合法的：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/ShYNvKdqGUbQTPt.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><p>- </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深度探索c-对象模型2&quot;&gt;&lt;a href=&quot;#深度探索c-对象模型2&quot; class=&quot;headerlink&quot; title=&quot;深度探索c++对象模型2&quot;&gt;&lt;/a&gt;深度探索c++对象模型2&lt;/h2&gt;&lt;p&gt;这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
      <category term="深度探索C++对象模型" scheme="http://Tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_478_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/25/leetcode478-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/25/leetcode478-m/</id>
    <published>2020-09-25T09:13:45.000Z</published>
    <updated>2020-09-25T09:20:28.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="478-在圆内随机生成点"><a href="#478-在圆内随机生成点" class="headerlink" title="478. 在圆内随机生成点"></a><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/" target="_blank" rel="noopener">478. 在圆内随机生成点</a></h4><p>难度中等37</p><p>给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 <code>randPoint</code> 。</p><p>说明:</p><ol><li>输入值和输出值都将是<a href="https://baike.baidu.com/item/浮点数/6162520" target="_blank" rel="noopener">浮点数</a>。</li><li>圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。</li><li>圆周上的点也认为是在圆中。</li><li><code>randPoint</code> 返回一个包含随机点的x坐标和y坐标的大小为2的数组。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[1,0,0],[],[],[]]</span><br><span class="line">输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[10,5,-7.5],[],[],[]]</span><br><span class="line">输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span><br></pre></td></tr></table></figure><p><strong>输入语法说明：</strong></p><p>输入是两个列表：调用成员函数名和调用的参数。<code>Solution</code> 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。<code>randPoint</code> 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。</p><p>C++11新特性,随机数库,不香嘛？</p><p><a href="https://blog.csdn.net/qq_23225317/article/details/79787543" target="_blank" rel="noopener">https://blog.csdn.net/qq_23225317/article/details/79787543</a></p><p>基本语法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::random_device rd;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line"><span class="comment">//e.seed(time(0));</span></span><br><span class="line"><span class="comment">//随机整数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="comment">//随机实数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">u2</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;u2(e)&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line"><span class="comment">//正态分布</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test normal distribution:\n"</span>;</span><br><span class="line">e.seed(time(<span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="built_in">std</span>::normal_distribution&lt;&gt; <span class="title">n</span><span class="params">(<span class="number">4</span>, <span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">vals</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">250</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v = lround(n(e));</span><br><span class="line">    <span class="keyword">if</span>(v &lt; vals.<span class="built_in">size</span>()) vals[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vals.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">string</span>(vals[i], <span class="string">'*'</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test normal distribution done.\n"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//伯努利分布</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test bernoulli distribution:\n"</span>;</span><br><span class="line">e.seed(time(<span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="built_in">std</span>::bernoulli_distribution <span class="title">b</span><span class="params">(<span class="number">0.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">bers</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b(e)) bers[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">else</span> bers[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"True: "</span>&lt;&lt;bers[<span class="number">1</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"False: "</span>&lt;&lt;bers[<span class="number">0</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test bernoulli distribution done.\n"</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/solution/zai-yuan-nei-sui-ji-sheng-cheng-dian-by-617076674/" target="_blank" rel="noopener">某一个题解</a>:</p><p>相信大部分人都没有看懂，我就来通俗地解释一下吧。</p><p>确定圆内一点，需要有相对于圆心的距离r，以及相对于圆心的角度angle。</p><p>一开始的想法，我们在[0, radius]中等概率取r，在[0, 2π)中等概率取angle即可实现圆内的随机分布。</p><p>事实上，这是不对的。</p><p>在[0, 2π)中等概率取angle，相对于把一个圆分成了无数个扇形，点落在每个扇形上的概率均相等。</p><p>假设某个扇形的圆心角是theta，那么该扇形的面积是0.5 <em> theta </em> radius ^ 2，分布在该扇形区域上的概率是theta / 2π，只要每个扇形的圆心角相等，扇形面积就是相等的，点在扇形中也是等概率的。</p><p>在[0, radius]中等概率取r，相当于把一个圆分成了无数个环形，点落在每个环形上的概率均相等。</p><p>假设某个环形的内径是r1，外径是r2，那么该环形的面积是π * (r2 ^ 2 - r1 ^ 2)。可见每个环形的面积是不一样的，显然每个环形上的点密度是不一样的。这样做会造成靠近圆心的点分布比较密集，远离圆心的点分布比较稀疏。</p><p>那么，如何取r使得点落在圆内任意区域的概率均相等呢？这样做显然会使得落在每个环形上的概率均不同，且环形面积较大的概率高，环形面积较小的概率小。</p><p>根据环形面积的计算公式：π * (r2 ^ 2 - r1 ^ 2)，落在该环形面积上的概率应为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)。</p><p>在[0, radius]中如何分布概率密度函数f(x)，可以使得f(x)其在[r1, r2]上的积分值为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)呢？</p><p>取f(x) = 2x / (radius ^ 2)可以满足上述条件，即半径r在[0, radius]上的概率密度函数应为f(x) = 2x / (radius ^ 2)，故只需要在[0, radius ^ 2]范围内等概率取r ^ 2，再开根号即得r值。（求一下导数即可，x ^ 2的导数是2x）</p><p>时间复杂度是和空间复杂度均是O(1)。</p><p><img src="/picture/image-jizuobiao.png" alt="image-20200925171304597"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">double</span> x_center,y_center;</span><br><span class="line">    <span class="keyword">double</span> _2pi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//极坐标:x=rcos(\theta),y=rsin(\theta)</span></span><br><span class="line">    Solution(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;radius=radius;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x_center=x_center;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y_center=y_center;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_2pi=<span class="built_in">acos</span>(<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(radius&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            random_device rd;</span><br><span class="line">            <span class="function">default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line">            uniform_real_distribution&lt;<span class="keyword">double</span>&gt;u1(<span class="number">0</span>,radius*radius);</span><br><span class="line">            uniform_real_distribution&lt;<span class="keyword">double</span>&gt;u2(<span class="number">0</span>,_2pi);<span class="comment">//acos(-1)*2=2\pi</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> r=<span class="built_in">sqrt</span>(u1(e));</span><br><span class="line">            <span class="keyword">double</span> theta=u2(e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> x=x_center+r*<span class="built_in">cos</span>(theta);</span><br><span class="line">            <span class="keyword">double</span> y=y_center+r*<span class="built_in">sin</span>(theta);</span><br><span class="line">            result.push_back(x);</span><br><span class="line">            result.push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * vector&lt;double&gt; param_1 = obj-&gt;randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;478-在圆内随机生成点&quot;&gt;&lt;a href=&quot;#478-在圆内随机生成点&quot; class=&quot;headerlink&quot; title=&quot;478. 在圆内随机生成点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generat
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
      <category term="随机采样" scheme="http://Tyler-ytr.github.io/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_18_m 四数之和</title>
    <link href="http://Tyler-ytr.github.io/2020/09/25/leetcode18-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/25/leetcode18-m/</id>
    <published>2020-09-25T08:19:56.000Z</published>
    <updated>2020-09-25T08:20:46.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><p>难度中等572</p><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数109,251</p><p>提交次数284,303</p><p>双指针法;主要要注意的是几个边界以及怎么去重的方法;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针法;</span></span><br><span class="line">        <span class="comment">//比O(n^4)的暴力减少了一些重复的内容;</span></span><br><span class="line">        <span class="comment">//算法是:固定a,b=a+1,然后c,d双指针遍历;然后b++……;然后b结束外层循环a++;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>&lt;<span class="number">4</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=<span class="built_in">size</span><span class="number">-4</span>;++a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;nums[a]==nums[a<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=a+<span class="number">1</span>;b&lt;=<span class="built_in">size</span><span class="number">-3</span>;++b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b&gt;a+<span class="number">1</span>&amp;&amp;nums[b]==nums[b<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                c=b+<span class="number">1</span>;</span><br><span class="line">                d=<span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(c&lt;d)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[a]+nums[b]+nums[c]+nums[d]&lt;target)&#123;</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[a]+nums[b]+nums[c]+nums[d]&gt;target)&#123;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.push_back(&#123;nums[a],nums[b],nums[c],nums[d]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c+<span class="number">1</span>])&#123;</span><br><span class="line">                            c++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d<span class="number">-1</span>])&#123;</span><br><span class="line">                            d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;18-四数之和&quot;&gt;&lt;a href=&quot;#18-四数之和&quot; class=&quot;headerlink&quot; title=&quot;18. 四数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic_knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>HDU_4734 F(x)</title>
    <link href="http://Tyler-ytr.github.io/2020/09/20/HDU-4734/"/>
    <id>http://Tyler-ytr.github.io/2020/09/20/HDU-4734/</id>
    <published>2020-09-20T12:19:26.000Z</published>
    <updated>2020-09-20T12:20:13.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-x"><a href="#F-x" class="headerlink" title="F(x)"></a><a href="https://vjudge.net/problem/HDU-4734" target="_blank" rel="noopener">F(x)</a></h2><p>For a decimal number x with n digits (AnAn-1An-2 … A2A1), we define its weight as F(x) = An <em> 2n-1 + An-1 </em> 2n-2 + … + A2 <em> 2 + A1 </em> 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A).</p><p>Input</p><p>The first line has a number T (T &lt;= 10000) , indicating the number of test cases.<br>For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109)</p><p>Output</p><p>For every case,you should output “Case #t: “ at first, without quotes. The <em>t</em> is the case number starting from 1. Then output the answer.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 100</span><br><span class="line">1 10</span><br><span class="line">5 100</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 2</span><br><span class="line">Case #3: 13</span><br></pre></td></tr></table></figure><p>最开始的思路肯定是搜索</p><p>首先是对数位的搜索</p><p>然后开始思考另外有什么状态是需要往下面传的，那么就只有前面数的和了，因此是二维的，第一维度是数位，第二个维度是sum;</p><p>然后思考记忆化,最直观的就是第二维度就是sum,但是这样子的话每一次都需要根据all进行修改;比较特别的是dp里面的sum记录的是all-sum的值,这样做可以有效的利用memset优化;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">12</span>][<span class="number">5005</span>];<span class="comment">//dp[pos][sum]:对于位置pos的数位,这里的sum存储的是all-当前pos前缀和的差;</span></span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> all;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">//计算F(a)的值</span></span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> able[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">while</span>(a)&#123;</span><br><span class="line">able[pos++]=a%<span class="number">10</span>;</span><br><span class="line">a/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//int now=1;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">result+=(able[i]&lt;&lt;i);</span><br><span class="line"><span class="comment">//now*=2;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"result:"&lt;&lt;result&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pos:当前的数位,sum 当前的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(pos&lt;0)return 1;合法;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sum,<span class="keyword">bool</span> limit)</span></span>&#123;<span class="comment">//这里的sum表示的是到目前数位的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>)<span class="keyword">return</span> sum&lt;=all;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;all)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!limit&amp;&amp;dp[pos][all-sum]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][all-sum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up=limit?cur[pos]:<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;++i)&#123;</span><br><span class="line"></span><br><span class="line">ans+=dfs(pos<span class="number">-1</span>,sum+i*(<span class="number">1</span>&lt;&lt;pos),limit&amp;&amp;cur[pos]==i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit)dp[pos][all-sum]=ans;</span><br><span class="line"><span class="comment">//cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;sum&lt;&lt;" "&lt;&lt;limit&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">//memset(cur,0,sizeof(cur));</span></span><br><span class="line"> all=f(a);</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line">cur[pos++]=b%<span class="number">10</span>;</span><br><span class="line">b/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i=pos-1;i&gt;=0;--i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;cur[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">int</span> result=dfs(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="comment">//cin&gt;&gt;a&gt;&gt;b;</span></span><br><span class="line"><span class="keyword">int</span> result=solve(a,b);</span><br><span class="line"><span class="comment">//printf("Case #%d: %d",i+1,result);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,i+<span class="number">1</span>,result);</span><br><span class="line"><span class="comment">//cout&lt;&lt;"Case #"&lt;&lt;i+1&lt;&lt;": "&lt;&lt;result&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;F-x&quot;&gt;&lt;a href=&quot;#F-x&quot; class=&quot;headerlink&quot; title=&quot;F(x)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-4734&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>HDU_2089 不要62</title>
    <link href="http://Tyler-ytr.github.io/2020/09/19/HDU-2089/"/>
    <id>http://Tyler-ytr.github.io/2020/09/19/HDU-2089/</id>
    <published>2020-09-19T12:40:05.000Z</published>
    <updated>2020-09-19T12:41:16.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a><a href="https://vjudge.net/problem/HDU-2089" target="_blank" rel="noopener">不要62</a></h2><p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p><p>Input</p><p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p><p>Output</p><p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 100</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80</span><br></pre></td></tr></table></figure><p>经典的数位dp题目,数位dp我参考了<a href="https://blog.csdn.net/wust_zzwh/article/details/52100392" target="_blank" rel="noopener">数位dp总结 之 从入门到模板</a>进行学习;总的来说的思想是对每一个数位进行枚举,然后辅之以记忆化搜索,以下是我根据板子做出来的结果;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos:数位,pre:前一位什么数,state:前一位是不是6,如果是6那么就是1,否则是0;limit:防止超过最大数;为true的时候表示上一个到顶了;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> state,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//枚举合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!limit&amp;&amp;dp[pos][state]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][state];<span class="comment">//记忆化;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up=limit?a[pos]:<span class="number">9</span>;<span class="comment">//如果limit成功,那么前面的没有到顶,因此可以到9,否则只能到这个数位的值,比如231,前面枚举到3的时候,最后一位只有1可以;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//计数;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">4</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(pre==<span class="number">6</span>&amp;&amp;i==<span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">ans+=dfs(pos<span class="number">-1</span>,i,i==<span class="number">6</span>,i==up&amp;&amp;limit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit)dp[pos][state]=ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//分解数位</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">a[pos]=n%<span class="number">10</span>;</span><br><span class="line">n/=<span class="number">10</span>;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result=dfs(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r &amp;&amp;(l!=<span class="number">0</span>||r!=<span class="number">0</span>))&#123;</span><br><span class="line"><span class="keyword">int</span> result=solve(r)-solve(l<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不要62&quot;&gt;&lt;a href=&quot;#不要62&quot; class=&quot;headerlink&quot; title=&quot;不要62&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-2089&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型1</title>
    <link href="http://Tyler-ytr.github.io/2020/09/10/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B1/"/>
    <id>http://Tyler-ytr.github.io/2020/09/10/深度探索C-对象模型1/</id>
    <published>2020-09-10T02:08:08.000Z</published>
    <updated>2020-09-10T02:30:37.240Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深度探索c-对象模型1"><a href="#深度探索c-对象模型1" class="headerlink" title="深度探索c++对象模型1"></a>深度探索c++对象模型1</h4><ul><li>C++的主要额外负担：<ul><li>virtual function 机制</li><li>virtual base class 用以实现“多次出现在继承体系中的base class，又一个单一而被共享的实例”</li><li>多重继承下的额外负担</li></ul></li></ul><h5 id="1-1-C-对象模式"><a href="#1-1-C-对象模式" class="headerlink" title="1.1 C++对象模式"></a>1.1 C++对象模式</h5><ul><li><p>C++对象模型</p><ul><li>非静态成员变量存放在每一个class object里面，静态成员变量存放在个别的class object 之外；静态函数，非静态函数成员放在个别的class object之外，虚函数特殊对待：<ul><li>每一个class 产生出一堆指向virtual function 的指针，放在表格中，这个表格称之为虚函数表（virtual table）</li><li>每一个class object被安插一个指针，指向相关的virtual table。通常这个指针称为$vtpr$.$vtpr$的设定由每一个class的constructor，destructor和copy assignment运算符自动完成。每一个class所关联的$tyle_info$ object(用来支持runtime type identification)也经由虚函数表纸出来，通常放在表格的第一个slot里面。<br>例子如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/nGapT7QCPUdiFhS.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></li></ul></li></ul></li><li><p>C++继承</p><ul><li>使用所谓的base table 模型。每一个class object内涵一个bptr,被初始化，指向它的base class table，然后这个表就如同虚函数表一样指向继承的类的对象，如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/u4XH1PLQEbrGwfv.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></li></ul></li><li><p>什么时候一个人应该使用struct 取代class？当它让一个人感觉比较好的时候（狗头）<br>聚合（composition）而非继承才是把C++和C结合起来的好方法。<br>struct在C++中的一个合理用途，是当你要传递一个“复杂的class object的全部或者部分”到某一个C函数去的时候，struct声明可以将数据封装起来，并且保证拥有与C兼容的空间布局，然而这种保证只在聚合（composition）的情况下存在。如果是继承的话，可能会因为内存布局原因无法实现想要的结果。</p></li><li><p>C++以下列方法支持多态：</p><ul><li>经过一组隐式的转化操作，比如把一个派生类的指针转化为一个指向它的public base type的指针：<br>shape *ps=new circle ();</li><li>经由virtual function机制：<br>ps-&gt;rotate（）</li><li>经由$dynamic_cast$和typeid运算符：<br>$if(circle <em>pc=dynami_cast &lt; circle</em>&gt;(ps))$</li></ul></li><li><p>需要多少内存才能够表现一个class object：</p><ul><li>非静态成员变量的总和大小</li><li>加上任何由于alignment（对齐）的需求而填补（padding）上去的空间</li><li>加上为了支持virtual而内部产生的任何额外负担</li></ul></li><li><p>关于指针：<br>不同类型的指针从内存需求的观点来看没有什么不同，“指向不同类型之各指针‘间的差异，既不在其指针表示法的不同，也不再其内容的不同，而是在其所寻址出来的object类型不同。也就是说，“指针类型”会教导编译器如何解释某一个特定地址的内存内容及其大小。</p></li><li><p>最后一部分内容讨论了多态发生的条件，我认为总结下来就是引用和指针可能触发多态，通过虚函数来实现。然后将子对象赋值给父类对象一般会导致切割，来放置数据溢出。</p></li><li><p>具体问题：</p><ul><li><p>一个Bear指针和一个ZooAnimal指针有什么不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal *pz&#x3D;&amp;b;</span><br><span class="line">Bear *pb&#x3D;&amp;;</span><br></pre></td></tr></table></figure><p>它们每一个都指向Bear object 的第一个type，它们的区别是：pb所涵盖的地址包含整个 Bear object但是pz所涵盖的地址之包含Bear object中的ZooAnimal subobject.<br>内存布局如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/hozFU6gL9ubjs54.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;深度探索c-对象模型1&quot;&gt;&lt;a href=&quot;#深度探索c-对象模型1&quot; class=&quot;headerlink&quot; title=&quot;深度探索c++对象模型1&quot;&gt;&lt;/a&gt;深度探索c++对象模型1&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++的主要额外负担：&lt;ul&gt;
&lt;li&gt;virtua
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
      <category term="深度探索C++对象模型" scheme="http://Tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode22-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode22-m/</id>
    <published>2020-09-07T01:28:58.000Z</published>
    <updated>2020-09-07T01:33:35.089Z</updated>
    
    <content type="html"><![CDATA[<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h4><p>难度中等1252收藏分享切换为英文关注反馈</p><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><p>通过次数166,462</p><p>提交次数218,996</p><p>一道经典的回溯算法的题目,lcnit表示左边括号的数目,rcnt表示右括号的数目;结束的条件是temp.size()==2*n,也就是满足长度;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="built_in">string</span> temp,<span class="keyword">int</span> lcnt,<span class="keyword">int</span> rcnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==maxn*<span class="number">2</span>)&#123;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lcnt&lt;maxn)&#123;</span><br><span class="line">            temp.push_back(<span class="string">'('</span>);</span><br><span class="line">            back_track(temp,lcnt+<span class="number">1</span>,rcnt);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rcnt&lt;lcnt)&#123;</span><br><span class="line">            temp.push_back(<span class="string">')'</span>);</span><br><span class="line">            back_track(temp,lcnt,rcnt+<span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        maxn=n;</span><br><span class="line">        back_track(temp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;22-括号生成&quot;&gt;&lt;a href=&quot;#22-括号生成&quot; class=&quot;headerlink&quot; title=&quot;22. 括号生成&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="栈" scheme="http://Tyler-ytr.github.io/tags/%E6%A0%88/"/>
    
      <category term="数据结构" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode134_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode134-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode134-m/</id>
    <published>2020-09-07T01:26:14.000Z</published>
    <updated>2020-09-07T01:28:25.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h4><p>难度中等243</p><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong> </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><hr><p>参考了一个数形结合的<a href="https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/" target="_blank" rel="noopener">题解</a></p><p>注意最小值的初始化问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> success=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tempsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tempsum=tempsum+gas[i]-cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tempsum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            success=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在起码可以环绕一圈，开始找起始点</span></span><br><span class="line">       <span class="comment">//我觉得如果可以跑的话就是一个逃税过程，如何逃掉更多的税呢？因为起始点起始相当于少交一次前面的税</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> gassum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> costsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_result=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           gassum+=gas[i];</span><br><span class="line">           costsum+=cost[i];</span><br><span class="line">            temp=gassum-costsum;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;min_result)&#123;</span><br><span class="line">                min_result=temp;</span><br><span class="line">                min_ans=i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (min_ans+<span class="number">1</span>)%n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;134-加油站&quot;&gt;&lt;a href=&quot;#134-加油站&quot; class=&quot;headerlink&quot; title=&quot;134. 加油站&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/gas-station/&quot; target=&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="贪心" scheme="http://Tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>poj2386</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/poj2386/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/poj2386/</id>
    <published>2020-09-07T01:24:14.000Z</published>
    <updated>2020-09-07T01:25:41.937Z</updated>
    
    <content type="html"><![CDATA[<p>Lake Counting</p><div class="table-container"><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 65536K</th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 59523</td><td></td><td><strong>Accepted:</strong> 28958</td></tr></tbody></table></div><p>Description</p><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.</p><p>Given a diagram of Farmer John’s field, determine how many ponds he has.</p><p>Input</p><p>* Line 1: Two space-separated integers: N and M</p><p>* Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.</p><p>Output</p><p>* Line 1: The number of ponds in Farmer John’s field.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>Hint</p><p>OUTPUT DETAILS:</p><p>There are three ponds: one in the upper left, one in the lower left,and one along the right side.</p><p>Source</p><p><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2004+November" target="_blank" rel="noopener">USACO 2004 November</a></p><p>题目大意: 计算出相连的’W’有多少块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> mapa[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    mapa[x][y]=<span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">int</span> tempx;</span><br><span class="line">    <span class="keyword">int</span> tempy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">            tempx=x+i;</span><br><span class="line">            tempy=y+j;</span><br><span class="line">            <span class="keyword">if</span>(tempx&gt;=<span class="number">0</span>&amp;&amp;tempx&lt;N&amp;&amp;tempy&gt;=<span class="number">0</span>&amp;&amp;tempy&lt;M&amp;&amp;mapa[tempx][tempy]==<span class="string">'W'</span>)&#123;</span><br><span class="line">                dfs(tempx,tempy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">  <span class="comment">// vector&lt;vector&lt;char&gt; &gt; map(N,(vector&lt;char&gt; (M)));</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">           <span class="keyword">char</span> temp;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">           mapa[i][j]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"here"&lt;&lt;endl;</span></span><br><span class="line">   <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(mapa[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">               dfs(i,j);</span><br><span class="line"><span class="comment">//               cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//               for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line"><span class="comment">//                   for(int j=0;j&lt;M;j++)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                       cout&lt;&lt;mapa[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//                   &#125;</span></span><br><span class="line"><span class="comment">//                   cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//               &#125;</span></span><br><span class="line">               cnt+=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lake Counting&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000MS&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;M
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>poj1321 棋盘问题</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/poj1321/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/poj1321/</id>
    <published>2020-09-07T01:22:23.000Z</published>
    <updated>2020-09-07T01:23:35.759Z</updated>
    
    <content type="html"><![CDATA[<h4 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h4><div class="table-container"><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 10000K</th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 96005</td><td></td><td><strong>Accepted:</strong> 43758</td></tr></tbody></table></div><p>Description</p><p>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><p>Input</p><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p><p>Output</p><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Source</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;<span class="built_in">map</span>;</span><br><span class="line"><span class="comment">//vector&lt;bool&gt;line;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">clear</span>();</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> K;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;<span class="built_in">line</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == K) &#123;<span class="comment">//注意出递归的条件是cnt==K也就是找到这么多个</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=N)&#123;<span class="comment">//这里是为了防止遍历的行数超过边界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">line</span>[i]&amp;&amp;<span class="built_in">map</span>[j][i]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">true</span>;</span><br><span class="line">                cnt+=<span class="number">1</span>;</span><br><span class="line">                backtrace(j+<span class="number">1</span>,<span class="built_in">line</span>);</span><br><span class="line">                cnt-=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrace(j+<span class="number">1</span>,<span class="built_in">line</span>);<span class="comment">//遍历下一行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//vector&lt;string&gt;map;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;<span class="built_in">line</span>(<span class="number">9</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;<span class="built_in">cin</span>&gt;&gt;t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;t==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            N=n;</span><br><span class="line">            K=t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> a;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">                <span class="built_in">map</span>.push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtrace(<span class="number">0</span>,<span class="built_in">line</span>);</span><br><span class="line">           <span class="comment">// N=n;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">//                for(int j=0;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">//                cout&lt;&lt;map[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//cout结果;</span></span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:leetcode刷题表示所有的OJ题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;棋盘问题&quot;&gt;&lt;a href=&quot;#棋盘问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘问题&quot;&gt;&lt;/a&gt;棋盘问题&lt;/h4&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Ti
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode491_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode491-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode491-m/</id>
    <published>2020-09-07T01:18:16.000Z</published>
    <updated>2020-09-07T01:19:09.615Z</updated>
    
    <content type="html"><![CDATA[<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/" target="_blank" rel="noopener">491. 递增子序列</a></h4><p>难度中等88</p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p>通过次数7,099</p><p>提交次数14,688</p><p>使用回溯算法进行dfs;主要要和那道全排列进行比较和区分;</p><p>使用set可以减少重复(我感觉剪枝更快但是不好写)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            temp.push_back(nums[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+pos&gt;nums.<span class="built_in">size</span>()<span class="number">-1</span>||nums[i+pos]&lt;temp.back())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[pos+i]);</span><br><span class="line">                result.insert(temp);</span><br><span class="line">                dfs(nums,temp,pos+i);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//感觉是回溯算法做的;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">            dfs(nums,temp,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it=result.<span class="built_in">begin</span>();it!=result.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            ans.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;491-递增子序列&quot;&gt;&lt;a href=&quot;#491-递增子序列&quot; class=&quot;headerlink&quot; title=&quot;491. 递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-subse
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode386_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode386-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode386-m/</id>
    <published>2020-09-07T01:14:51.000Z</published>
    <updated>2020-09-07T01:15:17.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://leetcode-cn.com/problems/lexicographical-numbers/" target="_blank" rel="noopener">386. 字典序排数</a></h4><p>难度中等74</p><p>给定一个整数 <em>n</em>, 返回从 <em>1</em> 到 <em>n</em> 的字典顺序。</p><p>例如，</p><p>给定 <em>n</em> =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p><p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 <em>n</em> 小于等于 5,000,000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur*<span class="number">10</span>+i&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dfs(cur*<span class="number">10</span>+i,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;++i)</span><br><span class="line">        dfs(i,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;386-字典序排数&quot;&gt;&lt;a href=&quot;#386-字典序排数&quot; class=&quot;headerlink&quot; title=&quot;386. 字典序排数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lexicographical-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode133_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode133-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode133-m/</id>
    <published>2020-09-07T01:12:57.000Z</published>
    <updated>2020-09-10T02:39:57.631Z</updated>
    
    <content type="html"><![CDATA[<h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><p>难度中等155</p><p>给你无向 <strong><a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/133_clone_graph_question-1599441241258.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/graph-1599441241260.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/graph-1-1599441241260.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<a href="https://baike.baidu.com/item/简单图/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><p>使用dfs+字典/哈希表 即可;重点需要学会的是C++map/unorder_map的使用count查询的操作,count返回0表示没有,1表示有;</p><p>递归+数组版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node*used[<span class="number">101</span>];</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素;</span></span><br><span class="line">        <span class="comment">//也可以不用Map 用一个Node*数组来表示;</span></span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(used[node-&gt;val])<span class="keyword">return</span> used[node-&gt;val];</span><br><span class="line">        Node*p=<span class="keyword">new</span> Node(node-&gt;val);<span class="comment">//创建拷贝结点;</span></span><br><span class="line">        used[node-&gt;val]=p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt;tp=node-&gt;neighbors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            p-&gt;neighbors.push_back(cloneGraph(tp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归+unorder_map版本;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;used;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素;</span></span><br><span class="line">        <span class="comment">//也可以不用Map 用一个Node*数组来表示;</span></span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(used.count(node))<span class="keyword">return</span> used[node];</span><br><span class="line">        Node*p=<span class="keyword">new</span> Node(node-&gt;val);<span class="comment">//创建拷贝结点;</span></span><br><span class="line">        used[node]=p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt;tp=node-&gt;neighbors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            p-&gt;neighbors.push_back(cloneGraph(tp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>map版本用map替换unorder_map即可;</p><p>其中速度:map慢于unorder_map慢于数组;</p><p>原因:(摘自一个<a href="https://leetcode-cn.com/problems/clone-graph/solution/dfsjie-ti-by-xiao-luo-ai-xue-xi/" target="_blank" rel="noopener">题解</a>):</p><p>map：</p><p>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高<br>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p><p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p><p>unordered_map：</p><p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><p>深度优先遍历的递归写法<br>1.发现新节点<br>1.如果没有操作该节点，就操作该节点，并将该节点的visit置1<br>1.1接着对该节点的neibor挨个遍历dfs函数<br>2.如果有操作就返回该节点或者pass</p><p>非递归版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;unordered_map&lt;Node*, Node*&gt;used;</span><br><span class="line">    Node* cloneGraph(Node* node) &#123;</span><br><span class="line">        if(!node)return node;</span><br><span class="line">        stack&lt;Node*&gt;S;</span><br><span class="line">        S.push(node);&#x2F;&#x2F;等同于 stack &lt;Node*&gt;S(&#123;node&#125;);</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt;used;</span><br><span class="line">        used[node] &#x3D; new Node(node-&gt;val);</span><br><span class="line">        Node* tmp;</span><br><span class="line">        while(!S.empty())&#123;</span><br><span class="line">            tmp &#x3D; S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            Node* r &#x3D; used[tmp];</span><br><span class="line">            vector&lt;Node*&gt;n&#x3D;tmp-&gt;neighbors;</span><br><span class="line">            for(int i&#x3D;0;i&lt;n.size();++i)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果这个节点之前已经遍历到，就把他的复制加到链表中</span><br><span class="line">            &#x2F;&#x2F;没有遍历过就复刻该节点，加入map，加入neighbor</span><br><span class="line">                Node*cur&#x3D;n[i];</span><br><span class="line">                if(!used.count(cur))&#123;</span><br><span class="line">                    Node*t&#x3D;new Node(cur-&gt;val);</span><br><span class="line">                    used[cur]&#x3D;t;</span><br><span class="line">                    S.push(cur);</span><br><span class="line">                &#125;</span><br><span class="line">                r-&gt;neighbors.push_back(used[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return used[node];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;133-克隆图&quot;&gt;&lt;a href=&quot;#133-克隆图&quot; class=&quot;headerlink&quot; title=&quot;133. 克隆图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/clone-graph/&quot; target=&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode131_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode131-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode131-m/</id>
    <published>2020-09-07T01:10:18.000Z</published>
    <updated>2020-09-07T01:10:48.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><p>难度中等471</p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><p>dfs 递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> higher)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> temp=root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;=lower||temp&gt;=higher)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,LONG_MIN,LONG_MAX);</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;98. 验证二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-bina
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode98_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode98-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode98-m/</id>
    <published>2020-09-07T01:05:19.000Z</published>
    <updated>2020-09-07T01:05:49.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><p>难度中等471</p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><p>dfs 递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> higher)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> temp=root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;=lower||temp&gt;=higher)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,LONG_MIN,LONG_MAX);</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;98. 验证二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-bina
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode51_h</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode51-h/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode51-h/</id>
    <published>2020-09-07T01:00:57.000Z</published>
    <updated>2020-09-10T02:41:34.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></h4><p>难度困难377</p><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/8-queens-1599440478541.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//行列; 本质上还是回溯法</span></span><br><span class="line">    <span class="comment">//逐个行来扫描,这一行确定了之后就删除一些状态</span></span><br><span class="line">   <span class="comment">//三个需要验证的合法性:</span></span><br><span class="line">   <span class="comment">//列,两个对角线:</span></span><br><span class="line">   <span class="comment">//line,incline1,incline2</span></span><br><span class="line">   <span class="comment">//按行遍历,如果这列ok 就line[i]=1</span></span><br><span class="line">   <span class="comment">//0x0x</span></span><br><span class="line">   <span class="comment">//x1xx (1,1)(0,0)(2,2)(3,3) 发现abs(j-i)是相同的;因此j-i+N 相同(这样确保大于0))</span></span><br><span class="line">   <span class="comment">//0x0x (1,1)(0,2)(3,0) 发现对角线上面i+j是相同的</span></span><br><span class="line">   <span class="comment">//xxx0</span></span><br><span class="line">   <span class="comment">//所以每次更新的时候都是line[i]=true,incline[i+j]=true,incline[j-i+N]=true;</span></span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;result;<span class="comment">//用来保存;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp;track,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;<span class="built_in">line</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;incline1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;incline2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==N)&#123;</span><br><span class="line">            <span class="comment">//递归结束</span></span><br><span class="line">            <span class="built_in">string</span> a=<span class="string">""</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;N;p++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(track[p][k])&#123;</span><br><span class="line">                        a.push_back(<span class="string">'Q'</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        a.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                b.push_back(a);</span><br><span class="line">                a.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">line</span>[i]&amp;&amp;!incline1[i+j]&amp;&amp;!incline2[j-i+N])&#123;</span><br><span class="line">                    <span class="built_in">line</span>[i]=<span class="literal">true</span>;</span><br><span class="line">                    incline1[i+j]=<span class="literal">true</span>;</span><br><span class="line">                    incline2[j-i+N]=<span class="literal">true</span>;</span><br><span class="line">                    track[j][i]=<span class="literal">true</span>;</span><br><span class="line">                    place(j+<span class="number">1</span>,track,<span class="built_in">line</span>,incline1,incline2);</span><br><span class="line">                    <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">                    incline1[i+j]=<span class="literal">false</span>;</span><br><span class="line">                    incline2[j-i+N]=<span class="literal">false</span>;</span><br><span class="line">                    track[j][i]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;incline1(<span class="number">2</span>*n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;incline2(<span class="number">2</span>*n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;<span class="built_in">line</span>(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">track</span><span class="params">(n,<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        N=n;</span><br><span class="line">        place(<span class="number">0</span>,track,<span class="built_in">line</span>,incline1,incline2);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;51-N皇后&quot;&gt;&lt;a href=&quot;#51-N皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N皇后&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="回溯法" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode46_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode46-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode46-m/</id>
    <published>2020-09-07T00:59:34.000Z</published>
    <updated>2020-09-07T01:00:11.014Z</updated>
    
    <content type="html"><![CDATA[<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46 Permutations"></a>46 Permutations</h4><p>Medium</p><p>333697Add to ListShare</p><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;<span class="comment">//表示这个解遇到过了;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;track,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//index记录vis的编号;</span></span><br><span class="line">        <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.push_back(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没有访问过;</span></span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                track.push_back(nums[i]);</span><br><span class="line">                backtrace(nums,track,index+<span class="number">1</span>);</span><br><span class="line">                track.pop_back();</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        backtrace(nums,track,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;46-Permutations&quot;&gt;&lt;a href=&quot;#46-Permutations&quot; class=&quot;headerlink&quot; title=&quot;46 Permutations&quot;&gt;&lt;/a&gt;46 Permutations&lt;/h4&gt;&lt;p&gt;Medium&lt;/p&gt;
&lt;p&gt;3336
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="回溯法" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124_h</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode124-h/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode124-h/</id>
    <published>2020-09-07T00:58:16.000Z</published>
    <updated>2020-09-07T00:59:07.992Z</updated>
    
    <content type="html"><![CDATA[<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h4><p>难度困难510</p><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//用一个maxm来缓存对于某一个根节点的状态;</span></span><br><span class="line"> <span class="comment">//dfs过程中返回给上层应该是最大的一边;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxm=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="built_in">max</span>(<span class="number">0</span>,dfs(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right=<span class="built_in">max</span>(<span class="number">0</span>,dfs(root-&gt;right));</span><br><span class="line">        maxm=<span class="built_in">max</span>(maxm,root-&gt;val+left+right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left+root-&gt;val,right+root-&gt;val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs解决该题,使用maxm缓存最大的结点处于的状态;dfs到某一个结点的时候,该节点返回给上一层:该节点值,该结点值+左值,该节点的值+右值的最大值;</p><p>对于空节点,返回0,表示对原来的结点没有贡献;</p><p>对于负值,和0比较取max的步骤表示如果有一边是负的那么就不做贡献,和空节点没有区别;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;124-二叉树中的最大路径和&quot;&gt;&lt;a href=&quot;#124-二叉树中的最大路径和&quot; class=&quot;headerlink&quot; title=&quot;124. 二叉树中的最大路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/b
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode690_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode690-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode690-s/</id>
    <published>2020-09-07T00:56:33.000Z</published>
    <updated>2020-09-07T00:57:39.829Z</updated>
    
    <content type="html"><![CDATA[<h4 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">690. 员工的重要性</a></h4><p>难度简单88</p><p>给定一个保存员工信息的数据结构，它包含了员工<strong>唯一的id</strong>，<strong>重要度</strong> 和 <strong>直系下属的id</strong>。</p><p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于<strong>并不是直系</strong>下属，因此没有体现在员工1的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出: 11</span><br><span class="line">解释:</span><br><span class="line">员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 &#x3D; 11。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>一个员工最多有一个<strong>直系</strong>领导，但是可以有多个<strong>直系</strong>下属</li><li>员工数量不超过2000。</li></ol><p>通过次数13,683</p><p>提交次数23,456</p><p>重要的是先进行的hash操作,运用了unorder_map结构体,极大的简化了dfs的操作;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> importance;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Employee*&gt;mp;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        result+=mp[id]-&gt;importance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp[id]-&gt;subordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            dfs(mp[id]-&gt;subordinates[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希:</span></span><br><span class="line">        <span class="keyword">for</span>(Employee* tmp:employees)&#123;</span><br><span class="line">            mp[tmp-&gt;id]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行dfs;</span></span><br><span class="line">        dfs(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BFS版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    int importance;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//     unordered_map&lt;int, Employee*&gt; mp;</span></span><br><span class="line"><span class="comment">//     int ans = 0;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span></span><br><span class="line"><span class="comment">//         for (auto&amp; e : employees) </span></span><br><span class="line"><span class="comment">//             mp[e-&gt;id] = e;</span></span><br><span class="line"><span class="comment">//         dfs(id);</span></span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     void dfs(int id) &#123;</span></span><br><span class="line"><span class="comment">//         ans += mp[id]-&gt;importance;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; mp[id]-&gt;subordinates.size(); ++i) </span></span><br><span class="line"><span class="comment">//             dfs(mp[id]-&gt;subordinates[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Employee*&gt;mp;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希:</span></span><br><span class="line">        <span class="keyword">for</span>(Employee* tmp:employees)&#123;</span><br><span class="line">            mp[tmp-&gt;id]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行bfs</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(id);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            result+=mp[temp]-&gt;importance;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp[temp]-&gt;subordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">                q.push(mp[temp]-&gt;subordinates[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;690-员工的重要性&quot;&gt;&lt;a href=&quot;#690-员工的重要性&quot; class=&quot;headerlink&quot; title=&quot;690. 员工的重要性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/employee-impo
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode199-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode199-m/</id>
    <published>2020-09-07T00:53:29.000Z</published>
    <updated>2020-09-07T00:54:31.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h4><p>难度中等186</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><p>通过次数29,576</p><p>提交次数46,105</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="comment">//    1</span></span><br><span class="line">        <span class="comment">//2        3</span></span><br><span class="line">        <span class="comment">//   5         4</span></span><br><span class="line">        <span class="comment">//广度优先搜索，当q里面只有最右边一个元素的时候把这个元素加入到输出的队列里面;</span></span><br><span class="line">       <span class="comment">// if(root==nullptr)&#123;return NULL&#125;;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> result;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;<span class="comment">//先进先出</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">           <span class="comment">// TreeNode*temp=q.front();</span></span><br><span class="line">        <span class="comment">//关键点: 用len记录q的size;通过这个来获得最右侧的点;</span></span><br><span class="line">            <span class="keyword">int</span> len=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode*temp=q.front();</span><br><span class="line">                <span class="keyword">if</span>(i==len<span class="number">-1</span>)&#123;</span><br><span class="line">                    result.push_back(temp-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;199-二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199. 二叉树的右视图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tre
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode101_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode101-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode101-s/</id>
    <published>2020-09-07T00:51:12.000Z</published>
    <updated>2020-09-07T00:53:08.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h4><p>难度简单 </p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><p>BFS的板子题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">                root = q.front(); q.pop();</span><br><span class="line">                v[i] = root ? root-&gt;val : INT_MIN;</span><br><span class="line">                <span class="keyword">if</span>(root) &#123; q.push(root-&gt;left); q.push(root-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否回文</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="built_in">size</span>/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i] != v[<span class="built_in">size</span><span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;101-对称二叉树&quot;&gt;&lt;a href=&quot;#101-对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;101. 对称二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/symmetric-tree/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode200_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode200-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode200-m/</id>
    <published>2020-09-07T00:49:14.000Z</published>
    <updated>2020-09-07T00:50:53.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>难度中等515</p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><p>解法1:BFS 遍历每一个点,遇到1就bfs并且把bfs到的1变成0;记录bfs的次数即可：</p><p>测试数据竟然有空集，这样会导致int maxn=map[0].size();//列数; 出现runtime error神必报错我tm……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//感觉可以bfs</span></span><br><span class="line">        <span class="comment">//遍历map的每一个点,如果map[i][j]是1,进行bfs,遇到1的变成0;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;<span class="built_in">map</span>(grid);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//m*n;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxm=<span class="built_in">map</span>.<span class="built_in">size</span>();<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">if</span>(maxm==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//对付空集的神必特判</span></span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="built_in">map</span>[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列数;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxm;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    cnt+=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">                    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp;</span><br><span class="line">                    temp.first=i;</span><br><span class="line">                    temp.second=j;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                    <span class="built_in">map</span>[i][j]=<span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;cur=q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        <span class="keyword">int</span> tempi=cur.first;</span><br><span class="line">                        <span class="keyword">int</span> tempj=cur.second;</span><br><span class="line">                        <span class="keyword">if</span>(tempi<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">map</span>[tempi<span class="number">-1</span>][tempj]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi<span class="number">-1</span>;</span><br><span class="line">                            temp2.second=tempj;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi<span class="number">-1</span>][tempj]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempi+<span class="number">1</span>&lt;maxm&amp;&amp;<span class="built_in">map</span>[tempi+<span class="number">1</span>][tempj]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi+<span class="number">1</span>;</span><br><span class="line">                            temp2.second=tempj;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi+<span class="number">1</span>][tempj]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempj<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">map</span>[tempi][tempj<span class="number">-1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi;</span><br><span class="line">                            temp2.second=tempj<span class="number">-1</span>;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi][tempj<span class="number">-1</span>]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempj+<span class="number">1</span>&lt;maxn&amp;&amp;<span class="built_in">map</span>[tempi][tempj+<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi;</span><br><span class="line">                            temp2.second=tempj+<span class="number">1</span>;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi][tempj+<span class="number">1</span>]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;200-岛屿数量&quot;&gt;&lt;a href=&quot;#200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;200. 岛屿数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode705_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode705-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode705-s/</id>
    <published>2020-09-06T08:26:54.000Z</published>
    <updated>2020-09-06T08:27:25.744Z</updated>
    
    <content type="html"><![CDATA[<h4 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705. 设计哈希集合"></a><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></h4><p>难度简单40</p><p>不使用任何内建的哈希表库设计一个哈希集合</p><p>具体地说，你的设计应该包含以下的功能</p><ul><li><code>add(value)</code>：向哈希集合中插入一个值。</li><li><code>contains(value)</code> ：返回哈希集合中是否存在这个值。</li><li><code>remove(value)</code>：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);         </span><br><span class="line">hashSet.add(2);         </span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; 返回 true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; 返回 false (未找到)</span><br><span class="line">hashSet.add(2);          </span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; 返回 true</span><br><span class="line">hashSet.remove(2);          </span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; 返回  false (已经被删除)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>所有的值都在 <code>[0, 1000000]</code>的范围内。</li><li>操作的总数目在<code>[1, 10000]</code>范围内。</li><li>不要使用内建的哈希集合库。</li></ul><p>通过次数11,949</p><p>提交次数21,319</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node* next;</span><br><span class="line">        Node(<span class="keyword">int</span> val):val(val),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; arr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">101</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet() &#123;</span><br><span class="line">        arr=<span class="built_in">vector</span>&lt;Node*&gt;(len,<span class="keyword">new</span> Node(<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">        Node*temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)<span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span>(!(temp-&gt;next))&#123;</span><br><span class="line">                    Node*node=<span class="keyword">new</span> Node(key);</span><br><span class="line">                    temp-&gt;next=node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 temp = temp -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp-&gt;val=key;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         int haval = key % len;</span></span><br><span class="line"><span class="comment">//         Node* temp = arr[haval];</span></span><br><span class="line"><span class="comment">//         if(temp -&gt; val != -1)&#123;</span></span><br><span class="line"><span class="comment">//             while(temp)&#123;</span></span><br><span class="line"><span class="comment">//                 if(temp -&gt; val == key)&#123;</span></span><br><span class="line"><span class="comment">//                     temp -&gt; val = -1;</span></span><br><span class="line"><span class="comment">//                     return;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 temp = temp -&gt; next;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">        Node*temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)&#123;</span><br><span class="line">                    temp-&gt;val=<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">       Node* temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;705-设计哈希集合&quot;&gt;&lt;a href=&quot;#705-设计哈希集合&quot; class=&quot;headerlink&quot; title=&quot;705. 设计哈希集合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/design-hashse
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://Tyler-ytr.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode67_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode67-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode67-s/</id>
    <published>2020-09-06T08:25:13.000Z</published>
    <updated>2020-09-06T08:25:28.838Z</updated>
    
    <content type="html"><![CDATA[<h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></h4><p>难度简单398</p><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li></ul><p>模拟题,用j来从后往前遍历;</p><p>一开始搞错的原因是因为忘记在result.push_back之后加上temp=0了,佛佛佛</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m=b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="built_in">max</span>(n,m);</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;<span class="comment">//处理进位</span></span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n-j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp+=(<span class="keyword">int</span>)(a[n-j<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m-j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp+=(<span class="keyword">int</span>)(b[m-j<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        temp+=out;</span><br><span class="line">        out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            temp-=<span class="number">2</span>;</span><br><span class="line">            out=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        temp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(out==<span class="number">1</span>)&#123;</span><br><span class="line">        result.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=result.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            res=res+<span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;res=res+<span class="string">'0'</span>;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;67-二进制求和&quot;&gt;&lt;a href=&quot;#67-二进制求和&quot; class=&quot;headerlink&quot; title=&quot;67. 二进制求和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-binary/&quot; target
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode14_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode14-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode14-s/</id>
    <published>2020-09-06T07:58:44.000Z</published>
    <updated>2020-09-06T08:24:53.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h4><p>难度简单1079</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p>模拟题实锤,纵向比较,重点是要掌握string的substr方法;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//纵向扫描;</span></span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length=strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i]!=c||i==strs[j].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,cnt); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;14-最长公共前缀&quot;&gt;&lt;a href=&quot;#14-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;14. 最长公共前缀&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-p
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode892_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode892-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode892-s/</id>
    <published>2020-09-06T07:56:59.000Z</published>
    <updated>2020-09-06T07:58:20.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a><a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">892. 三维形体的表面积</a></h4><p>难度简单90</p><p>在 <code>N * N</code> 的网格上，我们放置一些 <code>1 * 1 * 1</code> 的立方体。</p><p>每个值 <code>v = grid[i][j]</code> 表示 <code>v</code> 个正方体叠放在对应单元格 <code>(i, j)</code> 上。</p><p>请你返回最终形体的表面积。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= N &lt;= 50</code></li><li><code>0 &lt;= grid[i][j] &lt;= 50</code></li></ul><hr><p>一道模拟题，题目意思很难懂</p><p>第一个示例的意思是 0,0这个位置有一个高度为2的立方体；</p><p>第二个示例的意思是 0,0 高度为1;0,1 高度为2…………</p><p>主要解法是找到一个求解表面积的公式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    result+=<span class="number">2</span>+<span class="number">4</span>*grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i<span class="number">-1</span>][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result-=<span class="built_in">min</span>(grid[i<span class="number">-1</span>][j],grid[i][j])*<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(grid[i][j<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result-=<span class="built_in">min</span>(grid[i][j<span class="number">-1</span>],grid[i][j])*<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;892-三维形体的表面积&quot;&gt;&lt;a href=&quot;#892-三维形体的表面积&quot; class=&quot;headerlink&quot; title=&quot;892. 三维形体的表面积&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/surface
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>DNS刷新</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/DNS%E5%88%B7%E6%96%B0/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/DNS刷新/</id>
    <published>2020-09-04T06:56:33.000Z</published>
    <updated>2020-09-10T02:36:02.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS刷新"><a href="#DNS刷新" class="headerlink" title="DNS刷新"></a>DNS刷新</h2><p>垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中心的工程师打完电话之后发现是自己电脑DNS的问题，因此bing搜索，发现了如下的方法进行DNS的刷新:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netsh int ip reset </span><br><span class="line">netsh winsock reset</span><br><span class="line">ipconfig&#x2F;flushdns </span><br><span class="line">重启</span><br></pre></td></tr></table></figure><p>然后报错从dns probe finished no Internet变成了<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200904150200196.png" alt="image-20200904150200196" title="">                </div>                <div class="image-caption">image-20200904150200196</div>            </figure></p><p>佛了</p><p>面对不知道咋整的东西，那就选择重装系列：</p><p>右击<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200904184552395.png" alt="image-20200904184552395" title="">                </div>                <div class="image-caption">image-20200904184552395</div>            </figure>然后点击网络重置 好像就行了？！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DNS刷新&quot;&gt;&lt;a href=&quot;#DNS刷新&quot; class=&quot;headerlink&quot; title=&quot;DNS刷新&quot;&gt;&lt;/a&gt;DNS刷新&lt;/h2&gt;&lt;p&gt;垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows配置" scheme="http://Tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于windows密钥登录服务器</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/cmd_vs_rsa/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/cmd_vs_rsa/</id>
    <published>2020-09-04T06:56:33.000Z</published>
    <updated>2020-09-04T07:05:55.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于windows密钥登录服务器"><a href="#关于windows密钥登录服务器" class="headerlink" title="关于windows密钥登录服务器"></a>关于windows密钥登录服务器</h2><p>前言:windows的权限管理太屑了</p><p>参考<a href="https://blog.csdn.net/joshua2011/article/details/90208741" target="_blank" rel="noopener">https://blog.csdn.net/joshua2011/article/details/90208741</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于windows密钥登录服务器&quot;&gt;&lt;a href=&quot;#关于windows密钥登录服务器&quot; class=&quot;headerlink&quot; title=&quot;关于windows密钥登录服务器&quot;&gt;&lt;/a&gt;关于windows密钥登录服务器&lt;/h2&gt;&lt;p&gt;前言:windows的权限管
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows配置" scheme="http://Tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>wishlist_together</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/wishlist-together/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/wishlist-together/</id>
    <published>2020-09-04T02:18:35.000Z</published>
    <updated>2020-09-04T02:19:22.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-wishlist"><a href="#2020-wishlist" class="headerlink" title="2020 wishlist"></a>2020 wishlist</h2><ul><li>一起去鬼屋</li><li>一起去迪士尼</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2020-wishlist&quot;&gt;&lt;a href=&quot;#2020-wishlist&quot; class=&quot;headerlink&quot; title=&quot;2020 wishlist&quot;&gt;&lt;/a&gt;2020 wishlist&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一起去鬼屋&lt;/li&gt;
&lt;li&gt;一起去迪士
      
    
    </summary>
    
      <category term="wishlist" scheme="http://Tyler-ytr.github.io/categories/wishlist/"/>
    
    
      <category term="wishlist" scheme="http://Tyler-ytr.github.io/tags/wishlist/"/>
    
  </entry>
  
  <entry>
    <title>leetcode4_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/</id>
    <published>2020-08-31T14:55:42.000Z</published>
    <updated>2020-08-31T14:58:35.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>难度困难2695</p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    #二分法,对于arr1,arr2,k:令x=k<span class="comment">//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小;</span></span><br><span class="line">    #注意处理边界</span><br><span class="line">    def findkthelement(self,arr1:List[<span class="keyword">int</span>],arr2:List[<span class="keyword">int</span>],k)-&gt;<span class="keyword">float</span>:</span><br><span class="line">        len1=len(arr1)</span><br><span class="line">        len2=len(arr2)</span><br><span class="line">        <span class="keyword">if</span> len1&gt;len2:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr2,arr1,k)</span><br><span class="line">            ##确保arr1是短的一边;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr1:</span><br><span class="line">            #arr1为空,递归结束</span><br><span class="line">            <span class="keyword">return</span> arr2[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            #返回最小的元素</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(arr1[<span class="number">0</span>],arr2[<span class="number">0</span>])</span><br><span class="line">        x=k<span class="comment">//2</span></span><br><span class="line">        i=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len1)<span class="number">-1</span>) #arr1的边界;因为是数组所以要减一,代表有i+<span class="number">1</span>个元素</span><br><span class="line">        j=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len2)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr1[i]&lt;arr2[j]:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1[i+<span class="number">1</span>:],arr2,k-i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1,arr2[j+<span class="number">1</span>:],k-j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    def findMedianSortedArrays(self, nums1: List[<span class="keyword">int</span>], nums2: List[<span class="keyword">int</span>]) -&gt; <span class="keyword">float</span>:</span><br><span class="line">        len1=len(nums1)</span><br><span class="line">        len2=len(nums2)</span><br><span class="line">        #考虑中位数的奇偶问题</span><br><span class="line">        mid1=(len1+len2+<span class="number">1</span>)<span class="comment">//2</span></span><br><span class="line">        mid2=(len1+len2+<span class="number">2</span>)<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span>(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;4. 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/m
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="二分" scheme="http://Tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode990_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/</id>
    <published>2020-08-31T14:28:06.000Z</published>
    <updated>2020-08-31T14:28:32.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></h4><p>难度中等73</p><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li><li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">            p[x]=find_set(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//图的连通性问题---并查集</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//==就合并;</span></span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1!=fx2)&#123;</span><br><span class="line">                    p[fx1]=p[fx2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1==fx2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        parent.resize(26);</span><br><span class="line">        iota(parent.begin(), parent.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int index) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; parent[index]) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[index] &#x3D; find(parent[index]);</span><br><span class="line">        return parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int index1, int index2) &#123;</span><br><span class="line">        parent[find(index1)] &#x3D; find(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        UnionFind uf;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                uf.unite(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;990-等式方程的可满足性&quot;&gt;&lt;a href=&quot;#990-等式方程的可满足性&quot; class=&quot;headerlink&quot; title=&quot;990. 等式方程的可满足性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sati
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode547_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/</id>
    <published>2020-08-31T14:23:59.000Z</published>
    <updated>2020-09-10T02:42:05.980Z</updated>
    
    <content type="html"><![CDATA[<h4 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></h4><p>难度中等255</p><p>班上有 <strong>N</strong> 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 <strong>N * N</strong> 的矩阵 <strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>N 在[1,200]的范围内。</li><li>对于所有学生，有M[i][i] = 1。</li><li>如果有M[i][j] = 1，则有M[j][i] = 1。</li></ol><p>通过次数47,496</p><p>提交次数83,180</p><p><strong>并查集版本</strong></p><p>改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前;</p><p>还有就是find函数的条件是$x==f[x]$ 别搞错了;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dis_set</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">//int f[205];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f;</span><br><span class="line">        dis_set(<span class="keyword">int</span> x)&#123;</span><br><span class="line">           <span class="comment">// this-&gt;n=205;</span></span><br><span class="line">            <span class="comment">//f.resize(this-&gt;n);</span></span><br><span class="line">            <span class="comment">//iota(f.begin(),f.end(),0);</span></span><br><span class="line">            n=x;</span><br><span class="line">            f.resize(x+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;n;i++)&#123;</span><br><span class="line">                f[i]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==f[x])&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">                f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">                <span class="keyword">return</span> f[x];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> roota=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> rootb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(roota==rootb)<span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">this</span>-&gt;n--;</span><br><span class="line">            f[roota]=rootb;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">struct dis_set <span class="title">cur</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[<span class="number">0</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    cur.unite(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.count();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[id]==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vis[id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M[id].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[id][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                dfs(i,M);               </span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        vis.resize(n);</span><br><span class="line">       <span class="comment">// iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i,M);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> bfs 版本的解法:</p><p>注意vis[j]=1那句,很重要;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200617203349985-1598883847362.png" alt="image-20200617203349985" title="">                </div>                <div class="image-caption">image-20200617203349985</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line">        <span class="comment">//还可以用bfs做;同样用vis记录没有访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">                Q.push(i);</span><br><span class="line">                <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> top=Q.front();</span><br><span class="line">                    Q.pop();</span><br><span class="line">                    vis[top]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[top].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[top][j]==<span class="number">1</span>&amp;&amp;vis[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                            Q.push(j);</span><br><span class="line">                             vis[j]=<span class="number">1</span>;<span class="comment">//这句很重要,如果没有这句会慢很多;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;547-朋友圈&quot;&gt;&lt;a href=&quot;#547-朋友圈&quot; class=&quot;headerlink&quot; title=&quot;547. 朋友圈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/friend-circles/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode94_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/</id>
    <published>2020-08-31T14:11:42.000Z</published>
    <updated>2020-09-10T02:42:55.622Z</updated>
    
    <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>难度中等614</p><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>通过次数210,162</p><p>提交次数290,172</p><p>递归版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sol(root-&gt;left,nums);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        sol(root-&gt;right,nums);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        sol(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代版本如下:</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt;S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line"></span><br><span class="line">    TreeNode*cur=root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!S.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            S.push(cur);</span><br><span class="line">            cur=cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=S.top();</span><br><span class="line">        result.push_back(cur-&gt;val);</span><br><span class="line">        S.pop();</span><br><span class="line">        cur=cur-&gt;right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。</span></span><br><span class="line"><span class="comment">        # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。</span></span><br><span class="line"><span class="comment">        # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200809090152414-1598883215929.png" alt="image-20200809090152414" title="">                </div>                <div class="image-caption">image-20200809090152414</div>            </figure><p>以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tre
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="树" scheme="http://Tyler-ytr.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题51_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9851-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题51-h/</id>
    <published>2020-08-31T14:10:23.000Z</published>
    <updated>2020-09-10T02:43:42.369Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></h4><p>难度困难90</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure><p>当然二重for循环暴力可以解决，但是会超时；</p><p>实际上是一道二分思想的归并排序题目</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200424130136282-1598883032345.png" alt="image-20200424130136282" title="">                </div>                <div class="image-caption">image-20200424130136282</div>            </figure><p>对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;temp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> tempresult=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int mid=(l+r)/2;</span></span><br><span class="line">        <span class="keyword">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);<span class="comment">//防止l,r过大的时候溢出</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)&gt;&gt;1; 最快</span></span><br><span class="line">        tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">                tempresult+=mid-i+<span class="number">1</span>;<span class="comment">//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line">        <span class="keyword">return</span> tempresult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//居然是归并排序</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">            temp.resize((<span class="keyword">int</span>)nums.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            result=mergesort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题51-数组中的逆序对&quot;&gt;&lt;a href=&quot;#面试题51-数组中的逆序对&quot; class=&quot;headerlink&quot; title=&quot;面试题51. 数组中的逆序对&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode912_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/</id>
    <published>2020-08-31T13:27:52.000Z</published>
    <updated>2020-08-31T13:28:22.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></h4><p>难度中等98</p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p>排序算法复习题</p><p>归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;//左指针偶遇右指针</span><br><span class="line">        int mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(nums,l,mid);</span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        // 现在l-mid mid+<span class="number">1</span>-r是有序的</span><br><span class="line">        //考虑合并的情况</span><br><span class="line">        int i=l;</span><br><span class="line">        int j=mid+<span class="number">1</span>;</span><br><span class="line">        int cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        temp.resize((int)nums.size(), <span class="number">0</span>);</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, (int)nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=nums[r];</span><br><span class="line">        <span class="keyword">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=pivot)&#123;</span><br><span class="line">                i=i+<span class="number">1</span>;<span class="comment">//扩展比pivot小的边界;</span></span><br><span class="line">                swap(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i+<span class="number">1</span>],nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomized_partiton</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        swap(nums[r],nums[i]);<span class="comment">//选择pivot然后存放到最右端;</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=randomized_partiton(nums,l,r);</span><br><span class="line">            quicksort(nums,l,pos<span class="number">-1</span>);</span><br><span class="line">            quicksort(nums,pos+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆排序（不稳定排序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxheapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;<span class="comment">//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1)</span></span><br><span class="line">       <span class="keyword">for</span>(;(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>&lt;=len;)&#123;       </span><br><span class="line">            <span class="keyword">int</span> lson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> largest;</span><br><span class="line">            <span class="keyword">if</span>(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123;</span><br><span class="line">                largest=lson;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                largest=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123;</span><br><span class="line">                largest=rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=largest)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">                nums[i]=nums[largest];</span><br><span class="line">                nums[largest]=temp;</span><br><span class="line">                i=largest;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildmaxheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            maxheapify(nums,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        buildmaxheap(nums,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">            len-=<span class="number">1</span>;</span><br><span class="line">            maxheapify(nums,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        heapsort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//另外关于排序算法</p><p>线性时间但是有限制的有:</p><p>计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\Theta(n+k)$</p><p>基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort</p><p>桶排序:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;912-排序数组&quot;&gt;&lt;a href=&quot;#912-排序数组&quot; class=&quot;headerlink&quot; title=&quot;912. 排序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot; tar
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/</id>
    <published>2020-08-31T13:26:51.000Z</published>
    <updated>2020-08-31T13:27:18.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>难度中等365</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><p>通过次数85,540</p><p>提交次数241,065</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">long</span> <span class="keyword">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>) &#123;<span class="comment">//此处等价于if(power%2==1)</span></span><br><span class="line">            result = result * base;</span><br><span class="line">        &#125;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;<span class="comment">//此处等价于power=power/2</span></span><br><span class="line">        base = (base * base) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp=n;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> fastPower(x,temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/fastPower(x,-temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;50-Pow-x-n&quot;&gt;&lt;a href=&quot;#50-Pow-x-n&quot; class=&quot;headerlink&quot; title=&quot;50. Pow(x, n)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/&quot; ta
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode914_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/</id>
    <published>2020-08-31T13:25:40.000Z</published>
    <updated>2020-08-31T13:26:10.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">914. 卡牌分组</a></h4><p>难度简单100</p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= deck.length &lt;= 10000</code></li><li><code>0 &lt;= deck[i] &lt; 10000</code></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10002</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">10002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD1</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num1%num2==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next1=num2;</span><br><span class="line"> <span class="keyword">int</span> next2=num1%num2;</span><br><span class="line"><span class="keyword">return</span> GCD1(next1,next2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deck.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt[deck[i]]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> g=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g==<span class="number">-1</span>)&#123;</span><br><span class="line">                    g=cnt[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    g=GCD1(g,cnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g&gt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;914-卡牌分组&quot;&gt;&lt;a href=&quot;#914-卡牌分组&quot; class=&quot;headerlink&quot; title=&quot;914. 卡牌分组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/x-of-a-kind-in-a-de
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode312_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/</id>
    <published>2020-08-31T13:23:43.000Z</published>
    <updated>2020-09-10T02:41:12.851Z</updated>
    
    <content type="html"><![CDATA[<h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h4><p>难度困难318</p><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 <code>i</code> 时，你可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>说明:</strong></p><ul><li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><p>这题需要考虑的有两点:</p><p>第一点是状态的寻找和转移</p><p>第二点是如何进行递推;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200620172037074-1598880235219.png" alt="image-20200620172037074" title="">                </div>                <div class="image-caption">image-20200620172037074</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \in [i+1,j-1] 这里k表示最后一次戳哪一个气球;</span></span><br><span class="line">        <span class="comment">//注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历;</span></span><br><span class="line">        <span class="comment">//另外还需要在左端和右端都添加虚假的气球;</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;points(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        points[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        points[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            points[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n + <span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n+<span class="number">2</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)&#123;</span><br><span class="line">                    maxn=<span class="built_in">max</span>(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                dp[i][j]=maxn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;312-戳气球&quot;&gt;&lt;a href=&quot;#312-戳气球&quot; class=&quot;headerlink&quot; title=&quot;312. 戳气球&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/burst-balloons/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU2513 切蛋糕</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU2513/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU2513/</id>
    <published>2020-08-31T13:21:36.000Z</published>
    <updated>2020-09-21T05:43:43.149Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th></th></tr></thead><tbody><tr><td><strong><a href="http://acm.hdu.edu.cn/discuss/public/post/reply.php?postid=40764&amp;messageid=1&amp;deep=0" target="_blank" rel="noopener">多校联合训练的常见问题回答（FAQ）</a></strong></td></tr><tr><td>Cake slicing<strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583  Accepted Submission(s): 305 **</strong>  Problem DescriptionA rectangular cake with a grid of m<em>n unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts  For example, assume that the cake has a grid of 3</em>4 unit squares on its top, and there are three cherries on the top, as shown in the figure below. <img src="/picture/C150-1009-1.jpg" alt="img"> One allowable slicing is as follows. <img src="/picture/C150-1009-2.jpg" alt="img"> For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is <img src="/picture/C150-1009-3.jpg" alt="img"> In this case, the total length of the cutting edges is 3+2=5.  Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges.   InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks.   OutputOutput an integer indicating the least total length of the cutting edges.                                                       Sample Input<code>3 4 3 1 2 2 3 3 2</code>                                                                                                                        Sample Output<code>Case 1: 5</code>  Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ECJTU+2008+Autumn+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ECJTU 2008 Autumn Contest</a></td></tr></tbody></table></div><p>【题意】</p><p>有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底)</p><p>我参考了网上的博客,思路如下:</p><p>这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200620162927557.png" alt="image-20200620162927557" title="">                </div>                <div class="image-caption">image-20200620162927557</div>            </figure></p><p>因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> MAXN=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y,x,sum;<span class="comment">//y*x矩阵；sum个樱桃;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,<span class="keyword">int</span> l)</span></span>&#123;<span class="comment">//以i,j为左上角,k,l为右下角</span></span><br><span class="line">    <span class="keyword">if</span>(dp[i][j][k][l]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line">    &#125;<span class="comment">//如果之前计算过了,直接返回;</span></span><br><span class="line">    <span class="comment">//统计区域里面的樱桃数量;</span></span><br><span class="line">    <span class="keyword">int</span> cherry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;=k;++a)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;=l;++b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[a][b]==<span class="number">1</span>)&#123;</span><br><span class="line">                cherry+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果樱桃数量==1,那么不需要切割,返回0;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">1</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是0,那么这是一个不应该取得解,返回INF;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=MAXN;</span><br><span class="line">        <span class="keyword">return</span> MAXN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则需要切割;横着切或者纵着切;</span></span><br><span class="line">    <span class="keyword">int</span> minn=MAXN;</span><br><span class="line">    <span class="comment">//横着切:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;k;++a)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,a,l)+Dp(a+<span class="number">1</span>,j,k,l)+l-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纵着切割:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;l;++b)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,k,b)+Dp(i,b+<span class="number">1</span>,k,l)+k-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][j][k][l]=minn;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;y,&amp;x,&amp;sum))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p,q;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;q);</span><br><span class="line">            m[p][q]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dp(<span class="number">1</span>,<span class="number">1</span>,y,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cnt,dp[<span class="number">1</span>][<span class="number">1</span>][y][x]);</span><br><span class="line">        cnt+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/discuss/
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>面试题08_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9808-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题08-m/</id>
    <published>2020-08-31T13:20:30.000Z</published>
    <updated>2020-08-31T13:20:49.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h4><p>难度中等82</p><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//没有优化的版本:</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(val.<span class="built_in">size</span>(),temp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//不管用几种硬币组成0元只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;<span class="comment">//只用一种硬币(1)当然只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>+dp[i][j-val[i]]% <span class="number">1000000007</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n]% <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//降维到一维的版本:</span></span><br><span class="line">        <span class="comment">//dp[j]=dp[j]+dp[j-val[i]];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[j]=dp[j]%<span class="number">1000000007</span>+dp[j-val[i]]%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题-08-11-硬币&quot;&gt;&lt;a href=&quot;#面试题-08-11-硬币&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.11. 硬币&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-lc
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1014_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/</id>
    <published>2020-08-31T13:19:15.000Z</published>
    <updated>2020-08-31T13:19:39.158Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">1014. 最佳观光组合</a></h4><p>难度中等124</p><p>给定正整数数组 <code>A</code>，<code>A[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的距离为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 50000</code></li><li><code>1 &lt;= A[i] &lt;= 1000</code></li></ol><p>通过次数17,154</p><p>提交次数32,791</p><p>主要注意优化的这种思路,真的挺妙的;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//A[i]+i+A[j]-j</span></span><br><span class="line">        <span class="comment">//原始解法:</span></span><br><span class="line">        <span class="comment">//对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2)</span></span><br><span class="line">        <span class="comment">//优化:</span></span><br><span class="line">        <span class="comment">//tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp=A[<span class="number">0</span>]+<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxn=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(tmp+A[i]-i,maxn);</span><br><span class="line">            tmp=<span class="built_in">max</span>(tmp,A[i]+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1014-最佳观光组合&quot;&gt;&lt;a href=&quot;#1014-最佳观光组合&quot; class=&quot;headerlink&quot; title=&quot;1014. 最佳观光组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-sight
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode837_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/</id>
    <published>2020-08-31T13:18:28.000Z</published>
    <updated>2020-08-31T13:18:44.193Z</updated>
    
    <content type="html"><![CDATA[<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p>难度中等190</p><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>K</code> 分时抽取数字。 抽取时，她从 <code>[1, W]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>W</code> 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 <code>K</code> 分时，她就停止抽取数字。 爱丽丝的分数不超过 <code>N</code> 的概率是多少？</p><p><strong>示例</strong> <strong>1**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>2**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>3**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li><li><code>1 &lt;= W &lt;= 10000</code></li><li>如果答案与正确答案的误差不超过 <code>10^-5</code>，则该答案将被视为正确答案通过。</li><li>此问题的判断限制时间已经减少。</li></ol><p>这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[x]: 得到x分之后继续游戏,成功的概率;</span></span><br><span class="line">        <span class="comment">//dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W</span></span><br><span class="line">        <span class="comment">//初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1</span></span><br><span class="line">        <span class="comment">//结果:dp[0]</span></span><br><span class="line">        <span class="comment">//优化:发现 dp[x]和dp[x-1]之间的关系:</span></span><br><span class="line">        <span class="comment">//Wdp[x-1]=dp[x]+...+dp[x+w-1]</span></span><br><span class="line">        <span class="comment">//Wdp[x]=dp[x+1].....dp[x+w]</span></span><br><span class="line">        <span class="comment">//W (dp[x]-dp[x-1])=-dp[x]+dp[x+w]</span></span><br><span class="line">        <span class="comment">//(W+1)dp[x]-dp[x+w]=Wdp[x-1]</span></span><br><span class="line">        <span class="comment">//dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k</span></span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="built_in">max</span>(N,K+W+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;dp(maxn,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=W;i++)&#123;</span><br><span class="line">            dp[K<span class="number">-1</span>]+=dp[i+K<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[K<span class="number">-1</span>]/=W;</span><br><span class="line">        <span class="comment">//dp[K - 1] = 1.0 * min(N - K + 1, W) / W;</span></span><br><span class="line">        <span class="comment">//dp[K-1]=((W+1)*dp[K]-dp[K+W])/W;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=((W+<span class="number">1</span>)*dp[i+<span class="number">1</span>]-dp[i+W+<span class="number">1</span>])/W;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;837-新21点&quot;&gt;&lt;a href=&quot;#837-新21点&quot; class=&quot;headerlink&quot; title=&quot;837. 新21点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/new-21-game/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode416_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/</id>
    <published>2020-08-31T13:17:48.000Z</published>
    <updated>2020-08-31T13:18:02.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h4><p>难度中等218</p><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure><hr><p>01背包问题 具体解体思路见注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//背包问题</span></span><br><span class="line">        <span class="comment">//背包的容量是总和的一半</span></span><br><span class="line">        <span class="comment">//dp[i][j] 表示取了前i个数剩余容积为j时候的最大值</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> V=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只取0号数字的时候的初始化：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums[<span class="number">0</span>];i&lt;=V;i++)&#123;<span class="comment">//注意越界问题</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=nums[<span class="number">0</span>];<span class="comment">//因为只能取一次nums[0];</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//dp状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[n<span class="number">-1</span>][V]!=V)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;416-分割等和子集&quot;&gt;&lt;a href=&quot;#416-分割等和子集&quot; class=&quot;headerlink&quot; title=&quot;416. 分割等和子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode221_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/</id>
    <published>2020-08-31T13:16:52.000Z</published>
    <updated>2020-09-10T02:40:38.559Z</updated>
    
    <content type="html"><![CDATA[<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h4><p>难度中等428</p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>神必的dp</p><p>主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度;</p><p>状态转移方程比较难像:</p><p>$dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$</p><p>解释如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200531160513652.png" alt="image-20200531160513652" title="">                </div>                <div class="image-caption">image-20200531160513652</div>            </figure><p>为了代码的美观减少一次特判,应该要在左边和上边多加一列:</p><p>0 0 0 …..</p><p>0  matrix</p><p>0 </p><p>…</p><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#重点是神必的状态转移方程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        height=len(matrix)</span><br><span class="line">        width=len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(width+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(height+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#dp初始化,并且在外面多套了一层;</span></span><br><span class="line">        <span class="comment">#dp[i,j]表示以i,j为右下角的矩形的最大宽度;</span></span><br><span class="line">        <span class="comment"># 0 0 0 0 ....</span></span><br><span class="line">        <span class="comment"># 0 matrix</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment">#转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1</span></span><br><span class="line">        maxedge=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(dp[i][j],dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">                maxedge=max(maxedge,dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> maxedge*maxedge</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;221-最大正方形&quot;&gt;&lt;a href=&quot;#221-最大正方形&quot; class=&quot;headerlink&quot; title=&quot;221. 最大正方形&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximal-square/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode213_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/</id>
    <published>2020-08-31T13:16:12.000Z</published>
    <updated>2020-08-31T13:16:24.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>难度中等284</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;dp1(nums.size(),0);</span><br><span class="line">        vector&lt;int&gt;dp2(nums.size(),0);</span><br><span class="line">        dp1[0]&#x3D;nums[0];</span><br><span class="line"></span><br><span class="line">        dp1[1]&#x3D;max(nums[0],nums[1]);</span><br><span class="line">        </span><br><span class="line">        if(nums.size()&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(nums.size()&#x3D;&#x3D;3)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123;</span><br><span class="line">            dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int result1&#x3D;dp1[nums.size()-2];</span><br><span class="line"></span><br><span class="line">        dp2[1]&#x3D;nums[1];</span><br><span class="line">        dp2[2]&#x3D;max(nums[1],nums[2]);</span><br><span class="line">        for(int i&#x3D;3;i&lt;nums.size();i++)&#123;</span><br><span class="line">            dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int result2&#x3D;dp2[nums.size()-1];</span><br><span class="line">        return max(result1,result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;213-打家劫舍-II&quot;&gt;&lt;a href=&quot;#213-打家劫舍-II&quot; class=&quot;headerlink&quot; title=&quot;213. 打家劫舍 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robb
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode198_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/</id>
    <published>2020-08-31T13:15:12.000Z</published>
    <updated>2020-08-31T13:15:36.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>难度简单875</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p>原始版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:第0间-第i间房子偷窃的最高金额;</span></span><br><span class="line">        <span class="comment">//dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        <span class="comment">//dp[0]=nums[0]</span></span><br><span class="line">        <span class="comment">//dp[1]=max(nums[0],nums[1])</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(len,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;++i)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//滚动数组优化;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>滚动数组优化版本;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额;</span><br><span class="line">        &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span><br><span class="line">        &#x2F;&#x2F;初始化:</span><br><span class="line">        &#x2F;&#x2F;dp[0]&#x3D;nums[0]</span><br><span class="line">        &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1])</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int len&#x3D;nums.size();</span><br><span class="line">        int first&#x3D;nums[0];</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return first;</span><br><span class="line">            &#x2F;&#x2F;return dp[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int sec&#x3D;max(nums[1],nums[0]);</span><br><span class="line">        int result&#x3D;sec;</span><br><span class="line">        for(int i&#x3D;2;i&lt;len;i++)&#123;</span><br><span class="line">            result&#x3D;max(sec,first+nums[i]);</span><br><span class="line">            first&#x3D;sec;</span><br><span class="line">            sec&#x3D;result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;198-打家劫舍&quot;&gt;&lt;a href=&quot;#198-打家劫舍&quot; class=&quot;headerlink&quot; title=&quot;198. 打家劫舍&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot; targ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/</id>
    <published>2020-08-31T13:10:02.000Z</published>
    <updated>2020-08-31T13:13:23.891Z</updated>
    
    <content type="html"><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>难度中等537</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:i个结点的时候二叉搜索树的个数</span></span><br><span class="line">        <span class="comment">//空树只有一种情况:dp[0]=1</span></span><br><span class="line">        <span class="comment">//dp[1]=1</span></span><br><span class="line">        <span class="comment">//dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-bin
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode64_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/</id>
    <published>2020-08-31T13:09:13.000Z</published>
    <updated>2020-08-31T13:09:41.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>难度中等486</p><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]:到i,j 的最小路径和;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(grid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m=dp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n=dp[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/</id>
    <published>2020-08-31T13:04:05.000Z</published>
    <updated>2020-09-10T02:42:28.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>难度中等560</p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/robot_maze.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#x2F;&#x2F;dp[0][0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;dp[0][1]&#x3D;1&#39;</span><br><span class="line">        &#x2F;&#x2F;dp[1][0]&#x3D;1;</span><br><span class="line">        if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt;tmp(m,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n,tmp);</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            dp[0][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][0]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;m;j++)&#123;</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode53_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/</id>
    <published>2020-08-31T13:03:25.000Z</published>
    <updated>2020-08-31T13:03:46.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><p>水题:</p><p>dp[i]表示第i个之前的连续子数组的最大和</p><p>dp[i]=max(dp[i],dp[i-1]+dp[i]) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnum;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums)</span></span>;</span><br><span class="line">        maxnum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;53-最大子序和&quot;&gt;&lt;a href=&quot;#53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. 最大子序和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode32_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/</id>
    <published>2020-08-31T13:01:40.000Z</published>
    <updated>2020-08-31T13:02:23.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><p>难度困难784</p><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>通过次数74,856</p><p>提交次数233,569</p><p>题解见注释:主要是要两两字符判断;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度;</span></span><br><span class="line">        <span class="comment">//对于...............():</span></span><br><span class="line">        <span class="comment">//dp[i]=dp[i-2]+2;</span></span><br><span class="line">        <span class="comment">//对于...............)):</span></span><br><span class="line">        <span class="comment">//dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) </span></span><br><span class="line">        <span class="comment">//判断s[i-dp[i-1]-1],如果是(:</span></span><br><span class="line">        <span class="comment">//dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.length();;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i]=<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                        dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>+dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]; </span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;32-最长有效括号&quot;&gt;&lt;a href=&quot;#32-最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32. 最长有效括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-pa
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/</id>
    <published>2020-08-31T13:00:48.000Z</published>
    <updated>2020-08-31T13:01:10.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>难度中等</p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><p>这题目可以使用动态规划</p><p>我觉得很棒的一个<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> len=s.length();</span><br><span class="line">       <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[j][i]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][i]=dp[j+<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=i-j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;maxl)&#123;</span><br><span class="line">                        maxl=temp;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5. 最长回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HDU_1284</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU-1284/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU-1284/</id>
    <published>2020-08-31T12:58:32.000Z</published>
    <updated>2020-08-31T12:59:37.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 15976  Accepted Submission(s): 9546<br>**</strong></p><p>Problem Description</p><p>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。</p><p>Input</p><p>每行只有一个正整数N，N小于32768。</p><p>Output</p><p>对应每个输入，输出兑换方法数。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2934</span><br><span class="line">12553</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">718831</span><br><span class="line">13137761</span><br></pre></td></tr></table></figure><p>Author</p><p>SmallBeer(CML)</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%BA%BC%B5%E7ACM%BC%AF%D1%B5%B6%D3%D1%B5%C1%B7%C8%FC%A3%A8VII%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">杭电ACM集训队训练赛（VII）</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//相当于3件物品，容量为N的背包，第i件物品的重量是i</span></span><br><span class="line"><span class="comment">//初始化: dp[0][0]=1</span></span><br><span class="line"><span class="comment">//dp[i][j]表示用前i件物品组成j的方案数量</span></span><br><span class="line"><span class="comment">//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;</span></span><br><span class="line"><span class="comment">//滚动数组优化：</span></span><br><span class="line"><span class="comment">//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">33000</span>;<span class="comment">//32468</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;maxn;j++)&#123;</span><br><span class="line">            dp[j]+=dp[j-i];</span><br><span class="line">          <span class="comment">//  printf("%lld\n",dp[j]);</span></span><br><span class="line">           <span class="comment">// dp[j]+=max(dp[j],dp[j-i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf("here");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    scanf("%d",&amp;temp);</span></span><br><span class="line"><span class="comment">//        printf("%lld",dp[temp]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,dp[temp]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;钱币兑换问题&quot;&gt;&lt;a href=&quot;#钱币兑换问题&quot; class=&quot;headerlink&quot; title=&quot;钱币兑换问题&quot;&gt;&lt;/a&gt;钱币兑换问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Time Limit: 2000/1000 MS (Java/Other
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode19_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/</id>
    <published>2020-08-31T03:12:38.000Z</published>
    <updated>2020-08-31T12:50:14.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h4><p>难度中等947收藏分享切换为英文关注反馈</p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗</p><p>快慢指针的想法来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* l;</span><br><span class="line">        ListNode*r;</span><br><span class="line">        l=head;</span><br><span class="line">        r=head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(cnt=<span class="number">0</span>;cnt&lt;n;cnt++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;r-&gt;val&lt;&lt;endl;      </span></span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;l-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        l-&gt;next=l-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;19-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode16_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/</id>
    <published>2020-08-31T03:11:14.000Z</published>
    <updated>2020-08-31T12:50:07.255Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><p>难度中等530</p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p>通过次数141,122</p><p>提交次数308,415</p><p>和leetcode15相似,主要思路还是排序+双指针</p><p>我使用了minA维护了当前的最小值,然后使用res记录和;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#排序: -4 -1 1 2</span></span><br><span class="line">        <span class="comment">#minA 对于遍历到的每一个i,维护minA;</span></span><br><span class="line">        <span class="comment">#每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回;</span></span><br><span class="line"></span><br><span class="line">        n=len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> NULL</span><br><span class="line">        minA=sys.maxsize <span class="comment"># INT最大值</span></span><br><span class="line">        res=minA</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-2</span>):</span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                cur=nums[i]+nums[L]+nums[R]</span><br><span class="line">                <span class="keyword">if</span> cur==target:</span><br><span class="line">                    minA=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> cur</span><br><span class="line">                <span class="keyword">elif</span> cur&lt;target:</span><br><span class="line">                    tempres=target-cur</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tempres=cur-target</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur        </span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-close
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode15_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/</id>
    <published>2020-08-31T03:06:50.000Z</published>
    <updated>2020-08-31T12:50:01.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>难度中等2455</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数293,697</p><p>提交次数1,016,765</p><p>还是看了题解,排序太香了！</p><p>主要操作是排序使用双指针进行检查;同时记得去重;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#从i遍历到n-2,使用双指针维护和探查;</span></span><br><span class="line">        <span class="comment">#记得去重,也就是对于相同的找最后的;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#去重</span></span><br><span class="line">            </span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="number">0</span>):</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]):</span><br><span class="line">                        L=L+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L&lt; R <span class="keyword">and</span> nums[R]==nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R=R<span class="number">-1</span></span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R]&lt;<span class="number">0</span>:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      咸鱼leetcode刷题ing
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Winter plan</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/</id>
    <published>2020-01-22T09:17:23.000Z</published>
    <updated>2020-01-22T09:23:27.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>需要完成的目标:</p><ul><li>线性代数复习</li><li>学习cs224n</li><li>刷leetcode</li><li>算法竞赛入门经典</li></ul></li><li><p>目前进度:</p><ul><li>线性代数: <ul><li>1.22 </li></ul></li><li>cs224n<ul><li>1.22 </li></ul></li><li>leetcode<ul><li>1.22 </li></ul></li><li>算法竞赛入门经典</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要完成的目标:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性代数复习&lt;/li&gt;
&lt;li&gt;学习cs224n&lt;/li&gt;
&lt;li&gt;刷leetcode&lt;/li&gt;
&lt;li&gt;算法竞赛入门经典&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前进度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线
      
    
    </summary>
    
      <category term="个人计划" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="flag" scheme="http://Tyler-ytr.github.io/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu教程</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/</id>
    <published>2020-01-22T08:28:15.000Z</published>
    <updated>2021-02-25T08:13:34.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;</li><li>重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜</li></ul><h2 id="复活操作"><a href="#复活操作" class="headerlink" title="复活操作"></a>复活操作</h2><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><ul><li>管理员权限,换源,安装vim  <pre><code>  sudo passwd(修改sudo密码)  sudo apt-get update  sudo apt-get install vim  </code></pre></li><li>更换国内源,这里我选择的是<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华源</a>用下面的命令打开文件,并且注释里面的所有内容,<br> <pre><code> sudo vim /etc/apt/sources.list</code></pre> <ul><li>然后粘贴下面的内容到打开的文件里面<br><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</code></pre><br>如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下;</li></ul></li><li>安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇<a href="https://blog.csdn.net/qq_33159059/article/details/85019467" target="_blank" rel="noopener">博客</a></li><li>然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义<pre><code>suapt-get install build-essentialapt-get install man                # on-line reference manualapt-get install gcc-doc            # manual for GCCapt-get install gdb                # GNU debuggerapt-get install git                # reversion control systemapt-get install libreadline-dev    # a library to use compile the project laterapt-get install libsdl2-dev        # a library to use compile the project laterapt-get install qemu-system-x86    # QEMU</code></pre></li><li>安装chrome:请使用bing搜索;用gmail同步很香;</li></ul><h4 id="科学的看世界"><a href="#科学的看世界" class="headerlink" title="科学的看世界"></a>科学的看世界</h4><ul><li>我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) <pre><code> mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json </code></pre></li><li>将下面的内容根据自己的配置放进去:<pre><code>{  "server":"my_server_ip",  "server_port":53450,  "local_address": "127.0.0.1",  "local_port":1080,  "password":"密码",  "timeout":300,  "method":"aes-256-gcm",  "fast_open": false}</code></pre></li><li>然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;<br>自己测试一下有没有问题;</li><li>感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)：<ul><li>先写一个自启动脚本：<pre><code> touch ~/.ssstart.shvim ~/.ssstart.sh</code></pre>内容是:<pre><code>#!/bin/bashss-local -c ~/shadowsocks/shadowsocks.json </code></pre></li><li>然后在终端里面起别名:<br><pre><code>vim ~/.bashrc在末尾添加:alias ss='. ~/.ssstart.sh':wq 保存,退出在终端里面: source ~/.bashrc(如果是zsh:source ~/.zshrc)</code></pre><br>尝试一下在终端输入ss,它lei了;</li></ul></li><li><p>因为后面的netdata需要<strong>终端</strong>翻墙,我也就尝试了一下,如果没有需求可以跳过这一步:</p><ul><li>主要参考的是谷歌出来的<a href="http://www.totorocyx.me/2018/10/02/ubuntu_shadowsocks/" target="_blank" rel="noopener">网站</a></li><li>首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装</li><li><p>下面尝试全局代理(我也不确定能不能成功)：</p><ul><li>sudo pip install genpac</li><li>选择安装配置文件的目录,我选择的是:<pre><code>/home/larryytr/shadowsocks</code></pre></li><li>然后执行以下命令:<pre><code>sudo genpac --proxy="SOCKS5 127.0.0.1:1080" --gfwlist-proxy="SOCKS5 127.0.0.1:1080" -o autoproxy.pac --gfwlist-url="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt"</code></pre></li><li>下面是一句搬运,我没有遇到过:<pre><code>注意：如果报错“fetch gfwlist fail.online: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt local:None”，可以使用后面的语句：sudo genpac --proxy="SOCKS5 127.0.0.1:1080" -o autoproxy.pac --gfwlist-url="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt"</pre>&lt;/code&gt;</li><li>执行完之后,目录下面会有一个autoproxy.pac文件。</li><li><p>然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写：</p><pre><code>file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改)</code></pre></li></ul></li><li><p>然后使得终端也能使用代理。我们需要<strong>privoxy</strong>代理工具:</p><ul><li><p>安装很自然:sudo apt-get install privoxy</p></li><li><p>然后编辑配置文件<pre><code>sudo vim /etc/privoxy/config </pre>&lt;/code&gt;</p></li><li><p>在文档中搜索(vim 使用/搜索)“<strong>listen-address</strong>”（即监听地址），找到如下一行：<strong>listen-address localhost:8118</strong> 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“<strong>forward-socks5t</strong>”，找到如下一行：<strong>forward-socks5t / 127.0.0.1:1080</strong> . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure></li><li><p>最后，再配置/etc/profile：<pre><code></p><pre><code># 先进入编辑模式</code></pre><p>sudo vim /etc/profile</p><pre><code> # 在末尾添加以下三行：</code></pre><p>export http_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export https_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export ftp_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a></p><pre><code># 退出之后记得执行source /etc/profile</code></pre><p>&lt;/code&gt;&lt;/pre&gt;</p></li><li><p>验证是否成功:curl www.google.com或wget www.google.com判断是否可以访问</p></li><li><p>HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！</p></li></ul></li></ul></li></ul><h4 id="优化美化"><a href="#优化美化" class="headerlink" title="优化美化"></a>优化美化</h4><ul><li>官网安装网易云</li><li>官网安装vscode</li><li>配置zsh,tmux,vim:</li></ul><h5 id="zsh安装与美化"><a href="#zsh安装与美化" class="headerlink" title="zsh安装与美化"></a>zsh安装与美化</h5><ul><li>学习了:<a href="https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/" target="_blank" rel="noopener">https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/</a><br><a href="https://segmentfault.com/a/1190000013612471这两篇教程" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013612471这两篇教程</a>;</li><li>感谢何伟的配置文件;</li><li>相应的setting请参考我的github<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>.</li><li>安装zsh:<pre><code>sudo apt-get updatesudo apt-get install zshchsh -s /bin/zsh (设置zsh为默认)</code></pre></li><li>重启你的ubuntu</li><li>安装oh-my-zsh插件:<pre><code> wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre></li><li>不改theme一无所有</li><li>准备使用powerline主题  </li><li>首先安装powerline字体：<pre><code>git clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts</code></pre></li><li>安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久)</li><li>安装powerline: sudo apt install powerline </li><li>我的配置见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting .zshrc</li><li>颜色选择困难请: <pre><code>for code ({000..255}) print -P -- "$code: %F{$code}This is how your text would look like%f"</code></pre></li><li>改完请source ~/.zshrc</li></ul><h5 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h5><ul><li>tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程;</li><li>我使用了何伟的配置,具体见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting</li><li>我又加了一个插件使得tmux在重启之后状态可以恢复:<ul><li>主要参考这个<a href="https://zhuanlan.zhihu.com/p/24660412" target="_blank" rel="noopener">知乎教程</a></li><li><pre><code>git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp</code></pre></li><li>在~/.tmux.conf.local里面加上:<pre><code>run-shell ~/tmux_tmp/resurrect.tmux</code></pre></li><li>最后载入这个配置：<pre><code>tmux source-file ~/.tmux.conf</code></pre></li></ul></li></ul><h5 id="vim的美化"><a href="#vim的美化" class="headerlink" title="vim的美化"></a>vim的美化</h5><ul><li>使用啦懒人vim: spf13-vim美化</li><li>请看<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh</li><li>我的配置同样在<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting里面;</li><li>这个时候的vim没有办法和系统剪切版交互,我根据<a href="https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html" target="_blank" rel="noopener">https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html</a> 下载了其他一些插件:<br><pre><code>sudo apt-get install vim-scripts vim-gtk vim-gnome</pre>&lt;/code&gt;<br>这样 vim —version|grep “cliboard” 会看到 +clipboard;<br>然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！</li></ul><h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容:"></a>其他内容:</h4><ul><li>OSlab还需要:<ul><li>sudo apt-get install curl</li><li>sudo apt-get install gcc-multilib</li></ul></li><li>git 配置请搜索廖雪峰</li><li>ctags 可以参考Mengzelev的<a href="https://mengzelev.github.io/2018/10/04/pa-inspirations/" target="_blank" rel="noopener">博客</a></li><li>感谢xnr给我推荐的network来查看linux的运行情况<ul><li>这是netdata的官方网站:<a href="https://github.com/netdata/netdata#user-base" target="_blank" rel="noopener">https://github.com/netdata/netdata#user-base</a></li><li>但是由于GFW,安装会出现报错,事实上需要终端翻墙才行</li><li>可以通过这篇<a href="https://blog.csdn.net/zhangvalue/article/details/80270169" target="_blank" rel="noopener">教程</a><br><pre><code> sudo apt-get install net-tools  ifconfig</code></pre><br>查看inet 之后的内容来得知自己的server_ip</li><li>成功之后,进入 <a href="http://127.0.0.1:19999/" target="_blank" rel="noopener">http://127.0.0.1:19999/</a> (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验</li><li>相应配置可以参考这篇<a href="https://cloud.tencent.com/developer/article/1181577" target="_blank" rel="noopener">博客</a>或者自己搜索</li></ul></li><li>OSlab的kvm bug处理方法：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1479558" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=1479558</a><pre><code>chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content:KERNEL=="kvm", GROUP="kvm", MODE="0666"</code></pre></li><li>texlive 安装<pre><code>sudo apt install texlive-full</code></pre>相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting)vscode的保存即编译请<pre><code>Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾；</code></pre></li><li>ubuntu的截图:我参考了这篇<a href="https://blog.csdn.net/qq_17448289/article/details/56480805" target="_blank" rel="noopener">博客</a><ul><li>打开右上角的设置—&gt;设备—&gt;键盘—&gt;快捷键,点击+</li><li>显然的配置好按键,然后在命令里面写<pre><code>gnome-screenshot -a</code></pre></li><li>hint:上面的命令终端输入也有效<br>截屏的图在文件夹的图片(picture)里面;</li></ul></li></ul><h4 id="ubuntu-jupyter-lab配置"><a href="#ubuntu-jupyter-lab配置" class="headerlink" title="ubuntu jupyter lab配置"></a>ubuntu jupyter lab配置</h4><p>在服务器上面配置了jupyter lab;</p><p>主要借鉴了:<a href="https://cloud.tencent.com/developer/article/1769288?from=information.detail.jupyter%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1769288?from=information.detail.jupyter%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8</a></p><ul><li><p>安装anaconda</p></li><li><p>使用python生成密钥;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from notebook.auth import passwd                                        </span><br><span class="line"></span><br><span class="line">In [2]: passwd()                                                                </span><br><span class="line">Enter password: </span><br><span class="line">Verify password: </span><br><span class="line">Out[2]: &#39;sha1:salt:hashed-password&#39;#这里输出的东西就是密钥，复制好之后填</span><br><span class="line"></span><br><span class="line">In [3]: exit()</span><br></pre></td></tr></table></figure></li><li><p>生成配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure></li><li><p>修改它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~<span class="regexp">/.jupyter/</span>jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>在末尾加上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.allow_remote_access &#x3D; True   # 允许外部访问</span><br><span class="line">c.NotebookApp.ip&#x3D;&#39;*&#39;                       # 设置所有ip皆可访问</span><br><span class="line">c.NotebookApp.password &#x3D; u&#39;sha1:salt:hashed-password&#39;  # 使用刚才生成的密钥</span><br><span class="line">c.NotebookApp.open_browser &#x3D; False       # 禁止自动打开浏览器</span><br><span class="line">c.NotebookApp.port &#x3D; 2021                # 任意指定一个不冲突的端口，</span><br><span class="line">c.NotebookApp.notebook_dir &#x3D; &#39;&#x2F;home&#x2F;ubuntu&#x2F;JupyterProject&#x2F;&#39; #默认文件路径,这里用户名要改成自己的</span><br><span class="line">c.NotebookApp.allow_root &#x3D; True          # 允许root身份运行jupyter notebook</span><br></pre></td></tr></table></figure></li><li><p>记得在安全组里面打开这个</p></li><li><p>在服务器端输入jupyter notebook, 然后本地浏览器输入 服务器地址:2021就行啦(比如 122.52.187.69:2021)(这个服务器是随意打的)</p></li></ul><h4 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h4><ul><li>有空再研究怎么换主题;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;&lt;/li&gt;
&lt;li&gt;重装很多次的原因是因为
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Tyler-ytr.github.io/2020/01/21/hello-world/"/>
    <id>http://Tyler-ytr.github.io/2020/01/21/hello-world/</id>
    <published>2020-01-20T19:20:25.723Z</published>
    <updated>2020-01-20T19:20:25.723Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
