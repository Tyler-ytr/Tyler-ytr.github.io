<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tyler-yin&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/9cf7a8e81293a5a77561848afbba692b</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Tyler-ytr.github.io/"/>
  <updated>2020-08-31T14:58:35.460Z</updated>
  <id>http://Tyler-ytr.github.io/</id>
  
  <author>
    <name>Tyler-yin</name>
    <email>ytrpossible@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode4_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/</id>
    <published>2020-08-31T14:55:42.000Z</published>
    <updated>2020-08-31T14:58:35.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>难度困难2695</p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    #二分法,对于arr1,arr2,k:令x=k<span class="comment">//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小;</span></span><br><span class="line">    #注意处理边界</span><br><span class="line">    def findkthelement(self,arr1:List[<span class="keyword">int</span>],arr2:List[<span class="keyword">int</span>],k)-&gt;<span class="keyword">float</span>:</span><br><span class="line">        len1=len(arr1)</span><br><span class="line">        len2=len(arr2)</span><br><span class="line">        <span class="keyword">if</span> len1&gt;len2:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr2,arr1,k)</span><br><span class="line">            ##确保arr1是短的一边;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr1:</span><br><span class="line">            #arr1为空,递归结束</span><br><span class="line">            <span class="keyword">return</span> arr2[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            #返回最小的元素</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(arr1[<span class="number">0</span>],arr2[<span class="number">0</span>])</span><br><span class="line">        x=k<span class="comment">//2</span></span><br><span class="line">        i=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len1)<span class="number">-1</span>) #arr1的边界;因为是数组所以要减一,代表有i+<span class="number">1</span>个元素</span><br><span class="line">        j=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len2)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr1[i]&lt;arr2[j]:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1[i+<span class="number">1</span>:],arr2,k-i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1,arr2[j+<span class="number">1</span>:],k-j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    def findMedianSortedArrays(self, nums1: List[<span class="keyword">int</span>], nums2: List[<span class="keyword">int</span>]) -&gt; <span class="keyword">float</span>:</span><br><span class="line">        len1=len(nums1)</span><br><span class="line">        len2=len(nums2)</span><br><span class="line">        #考虑中位数的奇偶问题</span><br><span class="line">        mid1=(len1+len2+<span class="number">1</span>)<span class="comment">//2</span></span><br><span class="line">        mid2=(len1+len2+<span class="number">2</span>)<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span>(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;4. 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/m
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="二分" scheme="http://Tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode990_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/</id>
    <published>2020-08-31T14:28:06.000Z</published>
    <updated>2020-08-31T14:28:32.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></h4><p>难度中等73</p><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li><li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">            p[x]=find_set(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//图的连通性问题---并查集</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//==就合并;</span></span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1!=fx2)&#123;</span><br><span class="line">                    p[fx1]=p[fx2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1==fx2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        parent.resize(26);</span><br><span class="line">        iota(parent.begin(), parent.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int index) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; parent[index]) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[index] &#x3D; find(parent[index]);</span><br><span class="line">        return parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int index1, int index2) &#123;</span><br><span class="line">        parent[find(index1)] &#x3D; find(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        UnionFind uf;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                uf.unite(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;990-等式方程的可满足性&quot;&gt;&lt;a href=&quot;#990-等式方程的可满足性&quot; class=&quot;headerlink&quot; title=&quot;990. 等式方程的可满足性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sati
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode547_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/</id>
    <published>2020-08-31T14:23:59.000Z</published>
    <updated>2020-08-31T14:24:24.922Z</updated>
    
    <content type="html"><![CDATA[<h4 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></h4><p>难度中等255</p><p>班上有 <strong>N</strong> 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 <strong>N * N</strong> 的矩阵 <strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>N 在[1,200]的范围内。</li><li>对于所有学生，有M[i][i] = 1。</li><li>如果有M[i][j] = 1，则有M[j][i] = 1。</li></ol><p>通过次数47,496</p><p>提交次数83,180</p><p><strong>并查集版本</strong></p><p>改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前;</p><p>还有就是find函数的条件是$x==f[x]$ 别搞错了;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dis_set</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">//int f[205];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f;</span><br><span class="line">        dis_set(<span class="keyword">int</span> x)&#123;</span><br><span class="line">           <span class="comment">// this-&gt;n=205;</span></span><br><span class="line">            <span class="comment">//f.resize(this-&gt;n);</span></span><br><span class="line">            <span class="comment">//iota(f.begin(),f.end(),0);</span></span><br><span class="line">            n=x;</span><br><span class="line">            f.resize(x+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;n;i++)&#123;</span><br><span class="line">                f[i]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==f[x])&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">                f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">                <span class="keyword">return</span> f[x];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> roota=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> rootb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(roota==rootb)<span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">this</span>-&gt;n--;</span><br><span class="line">            f[roota]=rootb;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">struct dis_set <span class="title">cur</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[<span class="number">0</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    cur.unite(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.count();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[id]==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vis[id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M[id].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[id][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                dfs(i,M);               </span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        vis.resize(n);</span><br><span class="line">       <span class="comment">// iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i,M);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> bfs 版本的解法:</p><p>注意vis[j]=1那句,很重要;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20200617203349985-1598883847362.png" alt="image-20200617203349985" title="">                </div>                <div class="image-caption">image-20200617203349985</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line">        <span class="comment">//还可以用bfs做;同样用vis记录没有访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">                Q.push(i);</span><br><span class="line">                <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> top=Q.front();</span><br><span class="line">                    Q.pop();</span><br><span class="line">                    vis[top]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[top].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[top][j]==<span class="number">1</span>&amp;&amp;vis[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                            Q.push(j);</span><br><span class="line">                             vis[j]=<span class="number">1</span>;<span class="comment">//这句很重要,如果没有这句会慢很多;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;547-朋友圈&quot;&gt;&lt;a href=&quot;#547-朋友圈&quot; class=&quot;headerlink&quot; title=&quot;547. 朋友圈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/friend-circles/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode94_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/</id>
    <published>2020-08-31T14:11:42.000Z</published>
    <updated>2020-08-31T14:14:14.812Z</updated>
    
    <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>难度中等614</p><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>通过次数210,162</p><p>提交次数290,172</p><p>递归版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sol(root-&gt;left,nums);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        sol(root-&gt;right,nums);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        sol(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代版本如下:</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt;S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line"></span><br><span class="line">    TreeNode*cur=root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!S.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            S.push(cur);</span><br><span class="line">            cur=cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=S.top();</span><br><span class="line">        result.push_back(cur-&gt;val);</span><br><span class="line">        S.pop();</span><br><span class="line">        cur=cur-&gt;right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。</span></span><br><span class="line"><span class="comment">        # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。</span></span><br><span class="line"><span class="comment">        # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20200809090152414-1598883215929.png" alt="image-20200809090152414" title="">                </div>                <div class="image-caption">image-20200809090152414</div>            </figure><p>以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tre
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="树" scheme="http://Tyler-ytr.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题51_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9851-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题51-h/</id>
    <published>2020-08-31T14:10:23.000Z</published>
    <updated>2020-08-31T14:10:48.359Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></h4><p>难度困难90</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure><p>当然二重for循环暴力可以解决，但是会超时；</p><p>实际上是一道二分思想的归并排序题目</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20200424130136282-1598883032345.png" alt="image-20200424130136282" title="">                </div>                <div class="image-caption">image-20200424130136282</div>            </figure><p>对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;temp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> tempresult=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int mid=(l+r)/2;</span></span><br><span class="line">        <span class="keyword">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);<span class="comment">//防止l,r过大的时候溢出</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)&gt;&gt;1; 最快</span></span><br><span class="line">        tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">                tempresult+=mid-i+<span class="number">1</span>;<span class="comment">//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line">        <span class="keyword">return</span> tempresult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//居然是归并排序</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">            temp.resize((<span class="keyword">int</span>)nums.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            result=mergesort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题51-数组中的逆序对&quot;&gt;&lt;a href=&quot;#面试题51-数组中的逆序对&quot; class=&quot;headerlink&quot; title=&quot;面试题51. 数组中的逆序对&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode912_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/</id>
    <published>2020-08-31T13:27:52.000Z</published>
    <updated>2020-08-31T13:28:22.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></h4><p>难度中等98</p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p>排序算法复习题</p><p>归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;//左指针偶遇右指针</span><br><span class="line">        int mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(nums,l,mid);</span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        // 现在l-mid mid+<span class="number">1</span>-r是有序的</span><br><span class="line">        //考虑合并的情况</span><br><span class="line">        int i=l;</span><br><span class="line">        int j=mid+<span class="number">1</span>;</span><br><span class="line">        int cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        temp.resize((int)nums.size(), <span class="number">0</span>);</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, (int)nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=nums[r];</span><br><span class="line">        <span class="keyword">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=pivot)&#123;</span><br><span class="line">                i=i+<span class="number">1</span>;<span class="comment">//扩展比pivot小的边界;</span></span><br><span class="line">                swap(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i+<span class="number">1</span>],nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomized_partiton</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        swap(nums[r],nums[i]);<span class="comment">//选择pivot然后存放到最右端;</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=randomized_partiton(nums,l,r);</span><br><span class="line">            quicksort(nums,l,pos<span class="number">-1</span>);</span><br><span class="line">            quicksort(nums,pos+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆排序（不稳定排序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxheapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;<span class="comment">//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1)</span></span><br><span class="line">       <span class="keyword">for</span>(;(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>&lt;=len;)&#123;       </span><br><span class="line">            <span class="keyword">int</span> lson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> largest;</span><br><span class="line">            <span class="keyword">if</span>(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123;</span><br><span class="line">                largest=lson;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                largest=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123;</span><br><span class="line">                largest=rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=largest)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">                nums[i]=nums[largest];</span><br><span class="line">                nums[largest]=temp;</span><br><span class="line">                i=largest;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildmaxheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            maxheapify(nums,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        buildmaxheap(nums,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">            len-=<span class="number">1</span>;</span><br><span class="line">            maxheapify(nums,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        heapsort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//另外关于排序算法</p><p>线性时间但是有限制的有:</p><p>计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\Theta(n+k)$</p><p>基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort</p><p>桶排序:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;912-排序数组&quot;&gt;&lt;a href=&quot;#912-排序数组&quot; class=&quot;headerlink&quot; title=&quot;912. 排序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot; tar
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/</id>
    <published>2020-08-31T13:26:51.000Z</published>
    <updated>2020-08-31T13:27:18.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>难度中等365</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><p>通过次数85,540</p><p>提交次数241,065</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">long</span> <span class="keyword">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>) &#123;<span class="comment">//此处等价于if(power%2==1)</span></span><br><span class="line">            result = result * base;</span><br><span class="line">        &#125;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;<span class="comment">//此处等价于power=power/2</span></span><br><span class="line">        base = (base * base) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp=n;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> fastPower(x,temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/fastPower(x,-temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;50-Pow-x-n&quot;&gt;&lt;a href=&quot;#50-Pow-x-n&quot; class=&quot;headerlink&quot; title=&quot;50. Pow(x, n)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/&quot; ta
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode914_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/</id>
    <published>2020-08-31T13:25:40.000Z</published>
    <updated>2020-08-31T13:26:10.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">914. 卡牌分组</a></h4><p>难度简单100</p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= deck.length &lt;= 10000</code></li><li><code>0 &lt;= deck[i] &lt; 10000</code></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10002</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">10002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD1</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num1%num2==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next1=num2;</span><br><span class="line"> <span class="keyword">int</span> next2=num1%num2;</span><br><span class="line"><span class="keyword">return</span> GCD1(next1,next2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deck.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt[deck[i]]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> g=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g==<span class="number">-1</span>)&#123;</span><br><span class="line">                    g=cnt[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    g=GCD1(g,cnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g&gt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;914-卡牌分组&quot;&gt;&lt;a href=&quot;#914-卡牌分组&quot; class=&quot;headerlink&quot; title=&quot;914. 卡牌分组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/x-of-a-kind-in-a-de
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode312_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/</id>
    <published>2020-08-31T13:23:43.000Z</published>
    <updated>2020-08-31T13:23:55.555Z</updated>
    
    <content type="html"><![CDATA[<h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h4><p>难度困难318</p><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 <code>i</code> 时，你可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>说明:</strong></p><ul><li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><p>这题需要考虑的有两点:</p><p>第一点是状态的寻找和转移</p><p>第二点是如何进行递推;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20200620172037074-1598880235219.png" alt="image-20200620172037074" title="">                </div>                <div class="image-caption">image-20200620172037074</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \in [i+1,j-1] 这里k表示最后一次戳哪一个气球;</span></span><br><span class="line">        <span class="comment">//注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历;</span></span><br><span class="line">        <span class="comment">//另外还需要在左端和右端都添加虚假的气球;</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;points(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        points[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        points[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            points[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n + <span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n+<span class="number">2</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)&#123;</span><br><span class="line">                    maxn=<span class="built_in">max</span>(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                dp[i][j]=maxn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;312-戳气球&quot;&gt;&lt;a href=&quot;#312-戳气球&quot; class=&quot;headerlink&quot; title=&quot;312. 戳气球&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/burst-balloons/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU2513</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU2513/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU2513/</id>
    <published>2020-08-31T13:21:36.000Z</published>
    <updated>2020-08-31T13:23:08.859Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th></tr></thead><tbody><tr><td><strong><a href="http://acm.hdu.edu.cn/discuss/public/post/reply.php?postid=40764&amp;messageid=1&amp;deep=0" target="_blank" rel="noopener">多校联合训练的常见问题回答（FAQ）</a></strong></td></tr><tr><td>Cake slicing<strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583  Accepted Submission(s): 305 **</strong>  Problem DescriptionA rectangular cake with a grid of m<em>n unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts  For example, assume that the cake has a grid of 3</em>4 unit squares on its top, and there are three cherries on the top, as shown in the figure below. <img src="picture/C150-1009-1.jpg" alt="img"> One allowable slicing is as follows. <img src="picture/C150-1009-2.jpg" alt="img"> For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is <img src="picture/C150-1009-3.jpg" alt="img"> In this case, the total length of the cutting edges is 3+2=5.  Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges.   InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks.   OutputOutput an integer indicating the least total length of the cutting edges.                                                       Sample Input<code>3 4 3 1 2 2 3 3 2</code>                                                                                                                        Sample Output<code>Case 1: 5</code>  Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ECJTU+2008+Autumn+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ECJTU 2008 Autumn Contest</a></td></tr></tbody></table><p>【题意】</p><p>有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底)</p><p>我参考了网上的博客,思路如下:</p><p>这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20200620162927557.png" alt="image-20200620162927557" title="">                </div>                <div class="image-caption">image-20200620162927557</div>            </figure></p><p>因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> MAXN=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y,x,sum;<span class="comment">//y*x矩阵；sum个樱桃;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,<span class="keyword">int</span> l)</span></span>&#123;<span class="comment">//以i,j为左上角,k,l为右下角</span></span><br><span class="line">    <span class="keyword">if</span>(dp[i][j][k][l]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line">    &#125;<span class="comment">//如果之前计算过了,直接返回;</span></span><br><span class="line">    <span class="comment">//统计区域里面的樱桃数量;</span></span><br><span class="line">    <span class="keyword">int</span> cherry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;=k;++a)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;=l;++b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[a][b]==<span class="number">1</span>)&#123;</span><br><span class="line">                cherry+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果樱桃数量==1,那么不需要切割,返回0;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">1</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是0,那么这是一个不应该取得解,返回INF;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=MAXN;</span><br><span class="line">        <span class="keyword">return</span> MAXN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则需要切割;横着切或者纵着切;</span></span><br><span class="line">    <span class="keyword">int</span> minn=MAXN;</span><br><span class="line">    <span class="comment">//横着切:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;k;++a)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,a,l)+Dp(a+<span class="number">1</span>,j,k,l)+l-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纵着切割:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;l;++b)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,k,b)+Dp(i,b+<span class="number">1</span>,k,l)+k-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][j][k][l]=minn;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;y,&amp;x,&amp;sum))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p,q;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;q);</span><br><span class="line">            m[p][q]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dp(<span class="number">1</span>,<span class="number">1</span>,y,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cnt,dp[<span class="number">1</span>][<span class="number">1</span>][y][x]);</span><br><span class="line">        cnt+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/discuss/public/post/reply.php?postid=4
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>面试题08_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9808-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题08-m/</id>
    <published>2020-08-31T13:20:30.000Z</published>
    <updated>2020-08-31T13:20:49.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h4><p>难度中等82</p><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//没有优化的版本:</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(val.<span class="built_in">size</span>(),temp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//不管用几种硬币组成0元只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;<span class="comment">//只用一种硬币(1)当然只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>+dp[i][j-val[i]]% <span class="number">1000000007</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n]% <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//降维到一维的版本:</span></span><br><span class="line">        <span class="comment">//dp[j]=dp[j]+dp[j-val[i]];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[j]=dp[j]%<span class="number">1000000007</span>+dp[j-val[i]]%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题-08-11-硬币&quot;&gt;&lt;a href=&quot;#面试题-08-11-硬币&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.11. 硬币&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-lc
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1014_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/</id>
    <published>2020-08-31T13:19:15.000Z</published>
    <updated>2020-08-31T13:19:39.158Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">1014. 最佳观光组合</a></h4><p>难度中等124</p><p>给定正整数数组 <code>A</code>，<code>A[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的距离为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 50000</code></li><li><code>1 &lt;= A[i] &lt;= 1000</code></li></ol><p>通过次数17,154</p><p>提交次数32,791</p><p>主要注意优化的这种思路,真的挺妙的;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//A[i]+i+A[j]-j</span></span><br><span class="line">        <span class="comment">//原始解法:</span></span><br><span class="line">        <span class="comment">//对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2)</span></span><br><span class="line">        <span class="comment">//优化:</span></span><br><span class="line">        <span class="comment">//tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp=A[<span class="number">0</span>]+<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxn=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(tmp+A[i]-i,maxn);</span><br><span class="line">            tmp=<span class="built_in">max</span>(tmp,A[i]+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1014-最佳观光组合&quot;&gt;&lt;a href=&quot;#1014-最佳观光组合&quot; class=&quot;headerlink&quot; title=&quot;1014. 最佳观光组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-sight
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode837_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/</id>
    <published>2020-08-31T13:18:28.000Z</published>
    <updated>2020-08-31T13:18:44.193Z</updated>
    
    <content type="html"><![CDATA[<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p>难度中等190</p><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>K</code> 分时抽取数字。 抽取时，她从 <code>[1, W]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>W</code> 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 <code>K</code> 分时，她就停止抽取数字。 爱丽丝的分数不超过 <code>N</code> 的概率是多少？</p><p><strong>示例</strong> <strong>1**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>2**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>3**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li><li><code>1 &lt;= W &lt;= 10000</code></li><li>如果答案与正确答案的误差不超过 <code>10^-5</code>，则该答案将被视为正确答案通过。</li><li>此问题的判断限制时间已经减少。</li></ol><p>这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[x]: 得到x分之后继续游戏,成功的概率;</span></span><br><span class="line">        <span class="comment">//dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W</span></span><br><span class="line">        <span class="comment">//初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1</span></span><br><span class="line">        <span class="comment">//结果:dp[0]</span></span><br><span class="line">        <span class="comment">//优化:发现 dp[x]和dp[x-1]之间的关系:</span></span><br><span class="line">        <span class="comment">//Wdp[x-1]=dp[x]+...+dp[x+w-1]</span></span><br><span class="line">        <span class="comment">//Wdp[x]=dp[x+1].....dp[x+w]</span></span><br><span class="line">        <span class="comment">//W (dp[x]-dp[x-1])=-dp[x]+dp[x+w]</span></span><br><span class="line">        <span class="comment">//(W+1)dp[x]-dp[x+w]=Wdp[x-1]</span></span><br><span class="line">        <span class="comment">//dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k</span></span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="built_in">max</span>(N,K+W+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;dp(maxn,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=W;i++)&#123;</span><br><span class="line">            dp[K<span class="number">-1</span>]+=dp[i+K<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[K<span class="number">-1</span>]/=W;</span><br><span class="line">        <span class="comment">//dp[K - 1] = 1.0 * min(N - K + 1, W) / W;</span></span><br><span class="line">        <span class="comment">//dp[K-1]=((W+1)*dp[K]-dp[K+W])/W;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=((W+<span class="number">1</span>)*dp[i+<span class="number">1</span>]-dp[i+W+<span class="number">1</span>])/W;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;837-新21点&quot;&gt;&lt;a href=&quot;#837-新21点&quot; class=&quot;headerlink&quot; title=&quot;837. 新21点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/new-21-game/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode416_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/</id>
    <published>2020-08-31T13:17:48.000Z</published>
    <updated>2020-08-31T13:18:02.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h4><p>难度中等218</p><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure><hr><p>01背包问题 具体解体思路见注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//背包问题</span></span><br><span class="line">        <span class="comment">//背包的容量是总和的一半</span></span><br><span class="line">        <span class="comment">//dp[i][j] 表示取了前i个数剩余容积为j时候的最大值</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> V=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只取0号数字的时候的初始化：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums[<span class="number">0</span>];i&lt;=V;i++)&#123;<span class="comment">//注意越界问题</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=nums[<span class="number">0</span>];<span class="comment">//因为只能取一次nums[0];</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//dp状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[n<span class="number">-1</span>][V]!=V)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;416-分割等和子集&quot;&gt;&lt;a href=&quot;#416-分割等和子集&quot; class=&quot;headerlink&quot; title=&quot;416. 分割等和子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode221_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/</id>
    <published>2020-08-31T13:16:52.000Z</published>
    <updated>2020-08-31T13:17:27.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h4><p>难度中等428</p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>神必的dp</p><p>主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度;</p><p>状态转移方程比较难像:</p><p>$dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$</p><p>解释如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20200531160513652.png" alt="image-20200531160513652" title="">                </div>                <div class="image-caption">image-20200531160513652</div>            </figure><p>为了代码的美观减少一次特判,应该要在左边和上边多加一列:</p><p>0 0 0 …..</p><p>0  matrix</p><p>0 </p><p>…</p><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#重点是神必的状态转移方程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        height=len(matrix)</span><br><span class="line">        width=len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(width+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(height+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#dp初始化,并且在外面多套了一层;</span></span><br><span class="line">        <span class="comment">#dp[i,j]表示以i,j为右下角的矩形的最大宽度;</span></span><br><span class="line">        <span class="comment"># 0 0 0 0 ....</span></span><br><span class="line">        <span class="comment"># 0 matrix</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment">#转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1</span></span><br><span class="line">        maxedge=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(dp[i][j],dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">                maxedge=max(maxedge,dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> maxedge*maxedge</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;221-最大正方形&quot;&gt;&lt;a href=&quot;#221-最大正方形&quot; class=&quot;headerlink&quot; title=&quot;221. 最大正方形&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximal-square/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode213_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/</id>
    <published>2020-08-31T13:16:12.000Z</published>
    <updated>2020-08-31T13:16:24.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>难度中等284</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;dp1(nums.size(),0);</span><br><span class="line">        vector&lt;int&gt;dp2(nums.size(),0);</span><br><span class="line">        dp1[0]&#x3D;nums[0];</span><br><span class="line"></span><br><span class="line">        dp1[1]&#x3D;max(nums[0],nums[1]);</span><br><span class="line">        </span><br><span class="line">        if(nums.size()&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(nums.size()&#x3D;&#x3D;3)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123;</span><br><span class="line">            dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int result1&#x3D;dp1[nums.size()-2];</span><br><span class="line"></span><br><span class="line">        dp2[1]&#x3D;nums[1];</span><br><span class="line">        dp2[2]&#x3D;max(nums[1],nums[2]);</span><br><span class="line">        for(int i&#x3D;3;i&lt;nums.size();i++)&#123;</span><br><span class="line">            dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int result2&#x3D;dp2[nums.size()-1];</span><br><span class="line">        return max(result1,result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;213-打家劫舍-II&quot;&gt;&lt;a href=&quot;#213-打家劫舍-II&quot; class=&quot;headerlink&quot; title=&quot;213. 打家劫舍 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robb
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode198_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/</id>
    <published>2020-08-31T13:15:12.000Z</published>
    <updated>2020-08-31T13:15:36.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>难度简单875</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p>原始版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:第0间-第i间房子偷窃的最高金额;</span></span><br><span class="line">        <span class="comment">//dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        <span class="comment">//dp[0]=nums[0]</span></span><br><span class="line">        <span class="comment">//dp[1]=max(nums[0],nums[1])</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(len,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;++i)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//滚动数组优化;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>滚动数组优化版本;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额;</span><br><span class="line">        &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span><br><span class="line">        &#x2F;&#x2F;初始化:</span><br><span class="line">        &#x2F;&#x2F;dp[0]&#x3D;nums[0]</span><br><span class="line">        &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1])</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int len&#x3D;nums.size();</span><br><span class="line">        int first&#x3D;nums[0];</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return first;</span><br><span class="line">            &#x2F;&#x2F;return dp[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int sec&#x3D;max(nums[1],nums[0]);</span><br><span class="line">        int result&#x3D;sec;</span><br><span class="line">        for(int i&#x3D;2;i&lt;len;i++)&#123;</span><br><span class="line">            result&#x3D;max(sec,first+nums[i]);</span><br><span class="line">            first&#x3D;sec;</span><br><span class="line">            sec&#x3D;result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;198-打家劫舍&quot;&gt;&lt;a href=&quot;#198-打家劫舍&quot; class=&quot;headerlink&quot; title=&quot;198. 打家劫舍&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot; targ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/</id>
    <published>2020-08-31T13:10:02.000Z</published>
    <updated>2020-08-31T13:13:23.891Z</updated>
    
    <content type="html"><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>难度中等537</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:i个结点的时候二叉搜索树的个数</span></span><br><span class="line">        <span class="comment">//空树只有一种情况:dp[0]=1</span></span><br><span class="line">        <span class="comment">//dp[1]=1</span></span><br><span class="line">        <span class="comment">//dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-bin
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode64_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/</id>
    <published>2020-08-31T13:09:13.000Z</published>
    <updated>2020-08-31T13:09:41.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>难度中等486</p><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]:到i,j 的最小路径和;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(grid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m=dp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n=dp[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/</id>
    <published>2020-08-31T13:04:05.000Z</published>
    <updated>2020-08-31T13:07:52.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>难度中等560</p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/robot_maze.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#x2F;&#x2F;dp[0][0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;dp[0][1]&#x3D;1&#39;</span><br><span class="line">        &#x2F;&#x2F;dp[1][0]&#x3D;1;</span><br><span class="line">        if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt;tmp(m,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n,tmp);</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            dp[0][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][0]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;m;j++)&#123;</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode53_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/</id>
    <published>2020-08-31T13:03:25.000Z</published>
    <updated>2020-08-31T13:03:46.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><p>水题:</p><p>dp[i]表示第i个之前的连续子数组的最大和</p><p>dp[i]=max(dp[i],dp[i-1]+dp[i]) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnum;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums)</span></span>;</span><br><span class="line">        maxnum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;53-最大子序和&quot;&gt;&lt;a href=&quot;#53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. 最大子序和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode32_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/</id>
    <published>2020-08-31T13:01:40.000Z</published>
    <updated>2020-08-31T13:02:23.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><p>难度困难784</p><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>通过次数74,856</p><p>提交次数233,569</p><p>题解见注释:主要是要两两字符判断;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度;</span></span><br><span class="line">        <span class="comment">//对于...............():</span></span><br><span class="line">        <span class="comment">//dp[i]=dp[i-2]+2;</span></span><br><span class="line">        <span class="comment">//对于...............)):</span></span><br><span class="line">        <span class="comment">//dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) </span></span><br><span class="line">        <span class="comment">//判断s[i-dp[i-1]-1],如果是(:</span></span><br><span class="line">        <span class="comment">//dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.length();;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i]=<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                        dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>+dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]; </span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;32-最长有效括号&quot;&gt;&lt;a href=&quot;#32-最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32. 最长有效括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-pa
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/</id>
    <published>2020-08-31T13:00:48.000Z</published>
    <updated>2020-08-31T13:01:10.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>难度中等</p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><p>这题目可以使用动态规划</p><p>我觉得很棒的一个<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> len=s.length();</span><br><span class="line">       <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[j][i]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][i]=dp[j+<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=i-j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;maxl)&#123;</span><br><span class="line">                        maxl=temp;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5. 最长回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HDU_1284</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU-1284/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU-1284/</id>
    <published>2020-08-31T12:58:32.000Z</published>
    <updated>2020-08-31T12:59:37.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 15976  Accepted Submission(s): 9546<br>**</strong></p><p>Problem Description</p><p>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。</p><p>Input</p><p>每行只有一个正整数N，N小于32768。</p><p>Output</p><p>对应每个输入，输出兑换方法数。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2934</span><br><span class="line">12553</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">718831</span><br><span class="line">13137761</span><br></pre></td></tr></table></figure><p>Author</p><p>SmallBeer(CML)</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%BA%BC%B5%E7ACM%BC%AF%D1%B5%B6%D3%D1%B5%C1%B7%C8%FC%A3%A8VII%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">杭电ACM集训队训练赛（VII）</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//相当于3件物品，容量为N的背包，第i件物品的重量是i</span></span><br><span class="line"><span class="comment">//初始化: dp[0][0]=1</span></span><br><span class="line"><span class="comment">//dp[i][j]表示用前i件物品组成j的方案数量</span></span><br><span class="line"><span class="comment">//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;</span></span><br><span class="line"><span class="comment">//滚动数组优化：</span></span><br><span class="line"><span class="comment">//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">33000</span>;<span class="comment">//32468</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;maxn;j++)&#123;</span><br><span class="line">            dp[j]+=dp[j-i];</span><br><span class="line">          <span class="comment">//  printf("%lld\n",dp[j]);</span></span><br><span class="line">           <span class="comment">// dp[j]+=max(dp[j],dp[j-i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf("here");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    scanf("%d",&amp;temp);</span></span><br><span class="line"><span class="comment">//        printf("%lld",dp[temp]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,dp[temp]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;钱币兑换问题&quot;&gt;&lt;a href=&quot;#钱币兑换问题&quot; class=&quot;headerlink&quot; title=&quot;钱币兑换问题&quot;&gt;&lt;/a&gt;钱币兑换问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Time Limit: 2000/1000 MS (Java/Other
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode19_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/</id>
    <published>2020-08-31T03:12:38.000Z</published>
    <updated>2020-08-31T12:50:14.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h4><p>难度中等947收藏分享切换为英文关注反馈</p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗</p><p>快慢指针的想法来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* l;</span><br><span class="line">        ListNode*r;</span><br><span class="line">        l=head;</span><br><span class="line">        r=head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(cnt=<span class="number">0</span>;cnt&lt;n;cnt++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;r-&gt;val&lt;&lt;endl;      </span></span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;l-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        l-&gt;next=l-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;19-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode16_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/</id>
    <published>2020-08-31T03:11:14.000Z</published>
    <updated>2020-08-31T12:50:07.255Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><p>难度中等530</p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p>通过次数141,122</p><p>提交次数308,415</p><p>和leetcode15相似,主要思路还是排序+双指针</p><p>我使用了minA维护了当前的最小值,然后使用res记录和;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#排序: -4 -1 1 2</span></span><br><span class="line">        <span class="comment">#minA 对于遍历到的每一个i,维护minA;</span></span><br><span class="line">        <span class="comment">#每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回;</span></span><br><span class="line"></span><br><span class="line">        n=len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> NULL</span><br><span class="line">        minA=sys.maxsize <span class="comment"># INT最大值</span></span><br><span class="line">        res=minA</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-2</span>):</span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                cur=nums[i]+nums[L]+nums[R]</span><br><span class="line">                <span class="keyword">if</span> cur==target:</span><br><span class="line">                    minA=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> cur</span><br><span class="line">                <span class="keyword">elif</span> cur&lt;target:</span><br><span class="line">                    tempres=target-cur</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tempres=cur-target</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur        </span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-close
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode15_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/</id>
    <published>2020-08-31T03:06:50.000Z</published>
    <updated>2020-08-31T12:50:01.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>难度中等2455</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数293,697</p><p>提交次数1,016,765</p><p>还是看了题解,排序太香了！</p><p>主要操作是排序使用双指针进行检查;同时记得去重;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#从i遍历到n-2,使用双指针维护和探查;</span></span><br><span class="line">        <span class="comment">#记得去重,也就是对于相同的找最后的;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#去重</span></span><br><span class="line">            </span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="number">0</span>):</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]):</span><br><span class="line">                        L=L+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L&lt; R <span class="keyword">and</span> nums[R]==nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R=R<span class="number">-1</span></span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R]&lt;<span class="number">0</span>:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      咸鱼leetcode刷题ing
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>cmd_vs_rsa</title>
    <link href="http://Tyler-ytr.github.io/2020/08/10/cmd_vs_rsa/"/>
    <id>http://Tyler-ytr.github.io/2020/08/10/cmd_vs_rsa/</id>
    <published>2020-08-10T12:30:55.848Z</published>
    <updated>2020-08-10T12:31:48.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于windows密钥登录服务器"><a href="#关于windows密钥登录服务器" class="headerlink" title="关于windows密钥登录服务器"></a>关于windows密钥登录服务器</h2><p>前言:windows的权限管理太屑了</p><p>参考<a href="https://blog.csdn.net/joshua2011/article/details/90208741" target="_blank" rel="noopener">https://blog.csdn.net/joshua2011/article/details/90208741</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于windows密钥登录服务器&quot;&gt;&lt;a href=&quot;#关于windows密钥登录服务器&quot; class=&quot;headerlink&quot; title=&quot;关于windows密钥登录服务器&quot;&gt;&lt;/a&gt;关于windows密钥登录服务器&lt;/h2&gt;&lt;p&gt;前言:windows的权限管
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Winter plan</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/</id>
    <published>2020-01-22T09:17:23.000Z</published>
    <updated>2020-01-22T09:23:27.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>需要完成的目标:</p><ul><li>线性代数复习</li><li>学习cs224n</li><li>刷leetcode</li><li>算法竞赛入门经典</li></ul></li><li><p>目前进度:</p><ul><li>线性代数: <ul><li>1.22 </li></ul></li><li>cs224n<ul><li>1.22 </li></ul></li><li>leetcode<ul><li>1.22 </li></ul></li><li>算法竞赛入门经典</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要完成的目标:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性代数复习&lt;/li&gt;
&lt;li&gt;学习cs224n&lt;/li&gt;
&lt;li&gt;刷leetcode&lt;/li&gt;
&lt;li&gt;算法竞赛入门经典&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前进度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线
      
    
    </summary>
    
      <category term="个人计划" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="flag" scheme="http://Tyler-ytr.github.io/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu教程</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/</id>
    <published>2020-01-22T08:28:15.000Z</published>
    <updated>2020-01-24T07:42:44.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;</li><li>重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜</li></ul><h2 id="复活操作"><a href="#复活操作" class="headerlink" title="复活操作"></a>复活操作</h2><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><ul><li>管理员权限,换源,安装vim  <pre><code>  sudo passwd(修改sudo密码)  sudo apt-get update  sudo apt-get install vim  </code></pre></li><li>更换国内源,这里我选择的是<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华源</a>用下面的命令打开文件,并且注释里面的所有内容,<br> <pre><code> sudo vim /etc/apt/sources.list<br></code></pre> <ul><li>然后粘贴下面的内容到打开的文件里面<br><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br></code></pre><br>如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下;</li></ul></li><li>安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇<a href="https://blog.csdn.net/qq_33159059/article/details/85019467" target="_blank" rel="noopener">博客</a></li><li>然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义<pre><code>suapt-get install build-essentialapt-get install man                # on-line reference manualapt-get install gcc-doc            # manual for GCCapt-get install gdb                # GNU debuggerapt-get install git                # reversion control systemapt-get install libreadline-dev    # a library to use compile the project laterapt-get install libsdl2-dev        # a library to use compile the project laterapt-get install qemu-system-x86    # QEMU</code></pre></li><li>安装chrome:请使用bing搜索;用gmail同步很香;</li></ul><h4 id="科学的看世界"><a href="#科学的看世界" class="headerlink" title="科学的看世界"></a>科学的看世界</h4><ul><li>我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) <pre><code> mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json </code></pre></li><li>将下面的内容根据自己的配置放进去:<pre><code>{  "server":"my_server_ip",  "server_port":53450,  "local_address": "127.0.0.1",  "local_port":1080,  "password":"密码",  "timeout":300,  "method":"aes-256-gcm",  "fast_open": false}</code></pre></li><li>然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;<br>自己测试一下有没有问题;</li><li>感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)：<ul><li>先写一个自启动脚本：<pre><code> touch ~/.ssstart.shvim ~/.ssstart.sh</code></pre>内容是:<pre><code>#!/bin/bashss-local -c ~/shadowsocks/shadowsocks.json </code></pre></li><li>然后在终端里面起别名:<br><pre><code>vim ~/.bashrc<br>在末尾添加:<br>alias ss=’. ~/.ssstart.sh’<br>:wq 保存,退出<br>在终端里面:<br>source ~/.bashrc<br>(如果是zsh:source ~/.zshrc)<br></code></pre><br>尝试一下在终端输入ss,它lei了;</li></ul></li><li><p>因为后面的netdata需要<strong>终端</strong>翻墙,我也就尝试了一下,如果没有需求可以跳过这一步:</p><ul><li>主要参考的是谷歌出来的<a href="http://www.totorocyx.me/2018/10/02/ubuntu_shadowsocks/" target="_blank" rel="noopener">网站</a></li><li>首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装</li><li><p>下面尝试全局代理(我也不确定能不能成功)：</p><ul><li>sudo pip install genpac</li><li>选择安装配置文件的目录,我选择的是:<pre><code>/home/larryytr/shadowsocks</code></pre></li><li>然后执行以下命令:<pre><code>sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a></code></pre></li><li>下面是一句搬运,我没有遇到过:<pre><code>注意：如果报错“fetch gfwlist fail.online: <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a><br></pre></code></li><li>执行完之后,目录下面会有一个autoproxy.pac文件。</li><li><p>然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写：</p><pre><code>file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改)</code></pre></li></ul></li><li><p>然后使得终端也能使用代理。我们需要<strong>privoxy</strong>代理工具:</p><ul><li><p>安装很自然:sudo apt-get install privoxy</p></li><li><p>然后编辑配置文件<pre><code>sudo vim /etc/privoxy/config </pre></code></p></li><li><p>在文档中搜索(vim 使用/搜索)“<strong>listen-address</strong>”（即监听地址），找到如下一行：<strong>listen-address localhost:8118</strong> 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“<strong>forward-socks5t</strong>”，找到如下一行：<strong>forward-socks5t / 127.0.0.1:1080</strong> . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure></li><li><p>最后，再配置/etc/profile：<pre><code></p><pre><code># 先进入编辑模式</code></pre><p>sudo vim /etc/profile</p><pre><code># 在末尾添加以下三行：</code></pre><p>export http_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export https_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export ftp_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a></p><pre><code># 退出之后记得执行source /etc/profile</code></pre><p></code></pre></p></li><li><p>验证是否成功:curl <a href="http://www.google.com或wget" target="_blank" rel="noopener">www.google.com或wget</a> <a href="http://www.google.com判断是否可以访问" target="_blank" rel="noopener">www.google.com判断是否可以访问</a></p></li><li><p>HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！</p></li></ul></li></ul></li></ul><h4 id="优化美化"><a href="#优化美化" class="headerlink" title="优化美化"></a>优化美化</h4><ul><li>官网安装网易云</li><li>官网安装vscode</li><li>配置zsh,tmux,vim:</li></ul><h5 id="zsh安装与美化"><a href="#zsh安装与美化" class="headerlink" title="zsh安装与美化"></a>zsh安装与美化</h5><ul><li>学习了:<a href="https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/" target="_blank" rel="noopener">https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/</a><br><a href="https://segmentfault.com/a/1190000013612471这两篇教程" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013612471这两篇教程</a>;</li><li>感谢何伟的配置文件;</li><li>相应的setting请参考我的github<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>.</li><li>安装zsh:<pre><code>sudo apt-get updatesudo apt-get install zshchsh -s /bin/zsh (设置zsh为默认)</code></pre></li><li>重启你的ubuntu</li><li>安装oh-my-zsh插件:<pre><code> wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre></li><li>不改theme一无所有</li><li>准备使用powerline主题  </li><li>首先安装powerline字体：<pre><code>git clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts</code></pre></li><li>安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久)</li><li>安装powerline: sudo apt install powerline </li><li>我的配置见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting .zshrc</li><li>颜色选择困难请: <pre><code>for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f”</code></pre></li><li>改完请source ~/.zshrc</li></ul><h5 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h5><ul><li>tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程;</li><li>我使用了何伟的配置,具体见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting</li><li>我又加了一个插件使得tmux在重启之后状态可以恢复:<ul><li>主要参考这个<a href="https://zhuanlan.zhihu.com/p/24660412" target="_blank" rel="noopener">知乎教程</a></li><li><pre><code>git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp</code></pre></li><li>在~/.tmux.conf.local里面加上:<pre><code>run-shell ~/tmux_tmp/resurrect.tmux</code></pre></li><li>最后载入这个配置：<pre><code>tmux source-file ~/.tmux.conf<br></code></pre></li></ul></li></ul><h5 id="vim的美化"><a href="#vim的美化" class="headerlink" title="vim的美化"></a>vim的美化</h5><ul><li>使用啦懒人vim: spf13-vim美化</li><li>请看<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh</li><li>我的配置同样在<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting里面;</li><li>这个时候的vim没有办法和系统剪切版交互,我根据<a href="https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html" target="_blank" rel="noopener">https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html</a> 下载了其他一些插件:<br><pre><code>sudo apt-get install vim-scripts vim-gtk vim-gnome</pre></code><br>这样 vim –version|grep “cliboard” 会看到 +clipboard;<br>然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！</li></ul><h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容:"></a>其他内容:</h4><ul><li>OSlab还需要:<ul><li>sudo apt-get install curl</li><li>sudo apt-get install gcc-multilib</li></ul></li><li>git 配置请搜索廖雪峰</li><li>ctags 可以参考Mengzelev的<a href="https://mengzelev.github.io/2018/10/04/pa-inspirations/" target="_blank" rel="noopener">博客</a></li><li>感谢xnr给我推荐的network来查看linux的运行情况<ul><li>这是netdata的官方网站:<a href="https://github.com/netdata/netdata#user-base" target="_blank" rel="noopener">https://github.com/netdata/netdata#user-base</a></li><li>但是由于GFW,安装会出现报错,事实上需要终端翻墙才行</li><li>可以通过这篇<a href="https://blog.csdn.net/zhangvalue/article/details/80270169" target="_blank" rel="noopener">教程</a><br><pre><code> sudo apt-get install net-tools<br>  ifconfig<br></code></pre><br>查看inet 之后的内容来得知自己的server_ip</li><li>成功之后,进入 <a href="http://127.0.0.1:19999/" target="_blank" rel="noopener">http://127.0.0.1:19999/</a> (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验</li><li>相应配置可以参考这篇<a href="https://cloud.tencent.com/developer/article/1181577" target="_blank" rel="noopener">博客</a>或者自己搜索</li></ul></li><li>OSlab的kvm bug处理方法：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1479558" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=1479558</a><pre><code>chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content:KERNEL=="kvm", GROUP="kvm", MODE="0666"</code></pre></li><li>texlive 安装<pre><code>sudo apt install texlive-full</code></pre>相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting)vscode的保存即编译请<pre><code>Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾；</code></pre></li><li>ubuntu的截图:我参考了这篇<a href="https://blog.csdn.net/qq_17448289/article/details/56480805" target="_blank" rel="noopener">博客</a><ul><li>打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+</li><li>显然的配置好按键,然后在命令里面写<pre><code>gnome-screenshot -a</code></pre></li><li>hint:上面的命令终端输入也有效<br>截屏的图在文件夹的图片(picture)里面;</li></ul></li></ul><h4 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h4><ul><li>有空再研究怎么换主题;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;&lt;/li&gt;
&lt;li&gt;重装很多次的原因是因为
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Tyler-ytr.github.io/2020/01/21/hello-world/"/>
    <id>http://Tyler-ytr.github.io/2020/01/21/hello-world/</id>
    <published>2020-01-20T19:20:25.723Z</published>
    <updated>2020-01-20T19:20:25.723Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
