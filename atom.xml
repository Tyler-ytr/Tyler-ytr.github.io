<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tyler-yin&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/9cf7a8e81293a5a77561848afbba692b</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Tyler-ytr.github.io/"/>
  <updated>2022-10-19T07:06:02.547Z</updated>
  <id>http://Tyler-ytr.github.io/</id>
  
  <author>
    <name>Tyler-yin</name>
    <email>ytrpossible@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPU缓存一致性笔记</title>
    <link href="http://Tyler-ytr.github.io/2022/10/19/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%AC%94%E8%AE%B0/"/>
    <id>http://Tyler-ytr.github.io/2022/10/19/CPU缓存一致性笔记/</id>
    <published>2022-10-19T06:09:09.000Z</published>
    <updated>2022-10-19T07:06:02.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h1><h2 id="存储体系结构"><a href="#存储体系结构" class="headerlink" title="存储体系结构"></a>存储体系结构</h2><ol><li><p>计算机存储分了很多层次，扬长避短，有<strong>寄存器</strong>、<strong>L1 cache</strong>、<strong>L2 cache</strong>、<strong>L3 cache</strong>、<strong>主存</strong>（内存）和<strong>硬盘</strong>等。</p><p><img src="picture/image-20221019141719436.png" alt="image-20221019141719436"></p></li><li><p>缓存工作原理：</p><p><img src="picture/20201019641" alt="img"></p><p>cache line（缓存行）是缓存进行管理的最小存储单元，也叫缓存块，每个 cache line 包含 Flag、Tag 和 Data ，通常 Data 大小是 64 字节，但不同型号 CPU 的 Flag 和 Tag 可能不相同。从内存向缓存加载数据是按整个缓存行加载的，一个缓存行和一个相同大小的内存块对应。在图中横向是<strong>组(Set)</strong>，纵向是<strong>路(Way)</strong>。每一个元素是缓存行(cache line)。</p><p>给定addr定位缓存的方式：</p><ol><li>首先找到组号：<code>Set Index = (addr &gt;&gt; 6) % M;</code>(左移6位是因为 Block Offset 占 addr 的低 6 位，Data 为 64 字节)</li><li>然后遍历所有的路，找到cache line中的tag和addr中tag相等为止，所有路都没有成功那么缓存没有命中</li><li>整个缓存容量 = 组数 × 路数 × 缓存行大小</li></ol></li><li><p>相关shell命令：</p><ol><li>lscpu</li><li>getconf -a| grep CACHE</li></ol></li><li><p>缓存行替换策略，一般是LRU，可以通过位矩阵实现：</p><p><img src="picture/image-20221019142535798.png" alt="image-20221019142535798"></p><p>算法：首先初始化行列与缓存相同的矩阵，当访问某一个路对应的缓存行的时候，首先把该路对应的所有行置为1，然后把该路对应的所有列置为0；最近最少使用的缓存行对应的矩阵行中1的个数最少最先被替换出去；</p><p>例子里面首先是3，因此D3那一行首先都是1，然后把D3那一列变成0；然后是1，那么就把D1那一行都变成1然后把D1那一列都变成0…… </p></li></ol><h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>单核时代不存在这个问题，但是到了多核时代，引入了缓存一致性的我呢提，如果一个核心修改了缓存行里面的某一个值，那么需要有一种机制保证其他核心能够观察这个修改；</p><h3 id="缓存写"><a href="#缓存写" class="headerlink" title="缓存写"></a>缓存写</h3><ol><li>从缓存和内存的更新关系来看，分为：</li></ol><ul><li><ul><li><strong>写回（write-back）</strong>对缓存的修改不会立刻传播到内存，只有当缓存行被替换时，这些被修改的缓存行才会写回并覆盖内存中过时的数据。</li><li><strong>写直达（write through）</strong>缓存中任何一个字节的修改，都会立刻穿透缓存直接传播到内存，这种比较耗时。</li></ul></li></ul><ol start="2"><li>从写缓存时 CPU 之间的更新策略来看，分为：</li></ol><ul><li><ul><li><p><strong>写更新（Write Update）</strong>每次缓存写入新的值，该核心必须发起一次总线请求，通知其他核心更新他们缓存中对应的值。</p></li><li><ul><li>坏处：写更新会占用很多总线带宽；</li><li>好处：其他核心能立刻获得最新的值。</li></ul></li><li><p><strong>写无效（Write Invalidate）</strong>每次缓存写入新的值，都将其他核心缓存中对应的缓存行置为无效。</p></li><li><ul><li>坏处：当其他核心再次访问该缓存时，发现缓存行已经失效，必须从内存中重新载入最新的数据；</li><li>好处：多次写操作只需发一次总线事件，第一次写已经将其他核心缓存行置为无效，之后的写不必再更新状态，这样可以有效地节省核心间总线带宽。</li></ul></li></ul></li></ul><ol start="3"><li>从写缓存时数据是否被加载来看，分为：</li></ol><ul><li><ul><li><strong>写分配（Write Allocate）</strong>在写入数据前将数据读入缓存。当缓存块中的数据在未来读写概率较高，也就是程序空间局部性较好时，写分配的效率较好。</li><li><strong>写不分配（Not Write Allocate）</strong>在写入数据时，直接将数据写入内存，并不先将数据块读入缓存。当数据块中的数据在未来使用的概率较低时，写不分配性能较好。</li></ul></li></ul><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>MESI协议是⼀个基于<strong>失效</strong>的缓存⼀致性协议，是⽀持<strong>写回（write-back）</strong>缓存的最常⽤协议。</p><p>为了解决多个核心之间的数据传播问题，提出了<strong>总线嗅探（Bus Snooping）</strong>策略。本质上就是把所有的读写请求都通过总线（Bus）广播给所有的核心，然后让各个核心去<strong>嗅探</strong>这些请求，再根据本地的状态进行响应。</p><h4 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h4><ul><li><strong>已修改Modified (M)</strong>：缓存⾏是脏的，与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存⾏必须回写到主存，状态变为共享(S).</li><li><strong>独占Exclusive (E)</strong>：缓存⾏只在当前缓存中，但是⼲净的，缓存数据等于主存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。</li><li><strong>共享Shared (S)</strong>：缓存⾏也存在于其它缓存中且是⼲净的。缓存⾏可以在任意时刻抛弃。</li><li><strong>⽆效Invalid (I)</strong>：缓存⾏是⽆效的。</li></ul><p>这些状态信息实际上存储在<strong>缓存行</strong>（<strong>cache line</strong>）的 <strong>Flag</strong> 里。</p><h4 id="事件以及状态机"><a href="#事件以及状态机" class="headerlink" title="事件以及状态机"></a>事件以及状态机</h4><ul><li><p>处理器对缓存的请求:</p></li><li><ul><li><strong>PrRd</strong>：核心请求从缓存块中读出数据；</li><li><strong>PrWr</strong>：核心请求向缓存块写入数据。</li></ul></li><li><p>总线对缓存的请求:</p></li><li><ul><li><strong>BusRd</strong>：总线嗅探器收到来自其他核心的读出缓存请求；</li><li><strong>BusRdX</strong>：总线嗅探器收到另一核心写⼀个其不拥有的缓存块的请求；</li><li><strong>BusUpgr</strong>：总线嗅探器收到另一核心写⼀个其拥有的缓存块的请求；</li><li><strong>Flush</strong>：总线嗅探器收到另一核心把一个缓存块写回到主存的请求；</li><li><strong>FlushOpt</strong>：总线嗅探器收到一个缓存块被放置在总线以提供给另一核心的请求，和 Flush 类似，但只不过是从缓存到缓存的传输请求。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20221019145117675.png" alt="image-20221019145117675" title="">                </div>                <div class="image-caption">image-20221019145117675</div>            </figure><table><thead><tr><th><strong>当前状态 </strong></th><th><strong>事件 </strong></th><th><strong>响应</strong></th></tr></thead><tbody><tr><td><strong>M</strong></td><td>PrRd</td><td>⽆总线事务⽣成状态保持不变读操作为缓存命中</td></tr><tr><td></td><td>PrWr</td><td>⽆总线事务⽣成状态保持不变写操作为缓存命中</td></tr><tr><td></td><td>BusRd</td><td>状态变为共享(S)Shared发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存）</td></tr><tr><td></td><td>BusRdX</td><td>状态变为⽆效(I)Invalid发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存）</td></tr><tr><td><strong>E</strong></td><td>PrRd</td><td>⽆总线事务⽣成状态保持不变读操作为缓存命中</td></tr><tr><td></td><td>PrWr</td><td>⽆总线事务⽣成状态变为已修改(M)Modified向缓存块中写⼊修改后的值</td></tr><tr><td></td><td>BusRd</td><td>状态变为共享(<strong>S</strong>)Shared发出总线FlushOpt信号并发出块的内容</td></tr><tr><td></td><td>BusRdX</td><td>状态变为⽆效发出总线FlushOpt信号并发出块的内容</td></tr><tr><td><strong>S</strong></td><td>PrRd</td><td>⽆总线事务⽣成状态保持不变读操作为缓存命中</td></tr><tr><td></td><td>PrWr</td><td>发出总线事务BusUpgr信号状态转换为已修改(M)Modified其他缓存看到BusUpgr总线信号，标记其副本为为无效(I)Invalid</td></tr><tr><td></td><td>BusRd</td><td>状态变为共享(S)Shared可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据）</td></tr><tr><td></td><td>BusRdX</td><td>状态变为⽆效(I)Invalid可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据）</td></tr><tr><td><strong>I</strong></td><td>PrRd</td><td>给总线发BusRd信号其他处理器看到BusRd，检查⾃⼰是否有有效的数据副本，通知发出请求的缓存如果其他缓存有有效的副本，其中⼀个缓存发出数据，状态变为(S)Shared如果其他缓存都没有有效的副本，从主存获得数据，状态变为(E)Exclusive</td></tr><tr><td></td><td>PrWr</td><td>给总线发BusRdX信号状态转换为(M)Modified如果其他缓存有有效的副本, 其中⼀个缓存发出数据；否则从主存获得数据如果其他缓存有有效的副本, ⻅到BusRdX信号后⽆效其副本向缓存块中写⼊修改后的值</td></tr><tr><td></td><td>BusRd</td><td>状态保持不变，信号忽略</td></tr><tr><td></td><td>BusRdX/BusUpgr</td><td>状态保持不变，信号忽略</td></tr></tbody></table><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/image-20221019145117675.png" alt="image-20221019145117675" title="">                </div>                <div class="image-caption">image-20221019145117675</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="picture/640.gif" alt="状态机动图" title="">                </div>                <div class="image-caption">状态机动图</div>            </figure><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>编译器和处理器都必须遵守重排序规则。在单处理器的情况下，不需要任何额外的操作便能保持正确的顺序。但是对于多处理器来说，保证一致性通常需要增加内存屏障指令。即使编译器可以优化掉字段的访问（例如因为未使用加载到的值），编译器仍然需要生成内存屏障，就好像字段访问仍然存在一样（可以单独将内存屏障优化掉）。</p><p>内存屏障只与内存模型中的高级概念（例如 <strong>acquire</strong> 和 <strong>release</strong>）间接相关。内存屏障指令只直接控制 CPU 与其缓存的交互，以及它的写缓冲区（持有等待刷新到内存的数据的存储）和它的用于等待加载或推测执行指令的缓冲。这些影响可能导致缓存、主内存和其他处理器之间的进一步交互。</p><p>几乎所有的处理器都至少支持一个粗粒度的屏障指令（通常称为 <strong>Fence</strong>，也叫<strong>全屏障</strong>），它保证了严格的有序性：在 Fence 之前的所有读操作（load）和写操作（store）先于在 Fence 之后的所有读操作（load）和写操作（store）执行完。对于任何的处理器来说，这通常都是最耗时的指令之一（它的开销通常接近甚至超过原子操作指令）。大多数处理器还支持更细粒度的屏障指令。</p><ul><li><p><strong>LoadLoad Barrier（读读屏障）</strong></p><p>指令 <strong>Load1; LoadLoad; Load2</strong> 保证了 Load1 先于 Load2 和后续所有的 load 指令加载数据。通常情况下，在执行预测读（speculative loads）或乱序处理（out-of-order processing）的处理器上需要显式的 LoadLoad Barrier。在始终保证读顺序（load ordering）的处理器上，这些屏障相当于无操作（no-ops）。</p></li><li><p><strong>StoreStore Barrier（写写屏障）</strong></p><p>指令 <strong>Store1; StoreStore; Store2</strong> 保证了 Store1 的数据先于 Store2 及后续 store 指令的数据对其他处理器可见（刷新到内存）。通常情况下，在不保证严格按照顺序从写缓冲区（store buffers）或者 缓存（caches）刷新到其他处理器或内存的处理器上，需要使用 StoreStore Barrier。</p></li><li><p><strong>LoadStore Barrier（读写屏障）</strong></p><p>指令 <strong>Load1; LoadStore; Store2</strong> 保证了 Load1 的加载数据先于 Store2 及后续 store 指令刷新数据到主内存。只有在乱序（out-of-order）处理器上，等待写指令（waiting store instructions）可以绕过读指令（loads）的情况下，才会需要使用 LoadStore 屏障。</p></li><li><p><strong>StoreLoad Barrier（写读屏障）刷新写缓冲区，最耗时</strong></p><p>指令 <strong>Store1; StoreLoad; Load2</strong> 保证了 Store1 的数据对其他处理器可见（刷新数据到内存）先于 Load2 及后续的 load 指令加载数据。StoreLoad 屏障可以防止后续的读操作错误地使用了 Store1 写的数据，而不是使用来自另一个处理器的更近的对同一位置的写。因此只有需要将对同一个位置的写操作（stores）和随后的读操作（loads）分开时，才严格需要 StoreLoad 屏障。StoreLoad 屏障通常是开销最大的屏障，几乎所有的现代处理器都需要该屏障。之所以开销大，部分原因是它需要禁用绕过缓存（cache）从写缓冲区（Store Buffer）读取数据的机制。这可以通过让缓冲区完全刷新，外加暂停其他操作来实现，这就是 <strong>Fence</strong> 的效果。一般用 <strong>Fence</strong> 代替 StoreLoad Barrier ，所以事实上，执行 StoreLoad 指令同时也获得了其他三个屏障的效果，但是通过组合其他屏障通常不能获得与 StoreLoad Barrier 相同的效果。</p></li><li><p>各处理器支持的内存屏障和原子操作：</p><p><img src="picture/image-20221019150424979.png" alt="image-20221019150424979"></p></li><li><p>另外原文中还有写屏障，读屏障读写屏障等详细说明这里不加赘述</p></li><li><p>单向屏障：</p><p>单向屏障 (<strong>half-way barrier</strong>) 也是一种内存屏障，但它不是以读写来区分的，而是像单行道一样，只允许单向通行，例如 ARM 中的 stlr 和 ldar 指令就是这样。</p><ul><li><strong>stlr</strong> 的全称是 store release register，包括 StoreStore barrier 和 LoadStore barrier（场景少），通常使用 release 语义将寄存器的值写入内存；</li><li><strong>ldar</strong> 的全称是 load acquire register，包括 LoadLoad barrier 和 LoadStore barrier（对，你没看错，我没写错），通常使用 acquire 语义从内存中将值加载入寄存器；</li><li><strong>release</strong> 语义的内存屏障只不允许其前面的读写向后越过屏障，<strong>挡前不挡后</strong>；</li><li><strong>acquire</strong> 语义的内存屏障只不允许其后面的读写向前越过屏障，<strong>挡后不挡前</strong></li><li>StoreLoad barrier 就只能使用 <strong>dmb</strong>（全屏障） 代替了。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzkzMzM5MTUwNQ==&amp;mid=2247483899&amp;idx=1&amp;sn=3bd15de41b4c3d38f5b7e7bbd5bdac01&amp;chksm=c24c7c05f53bf51383fdf07844a4fdd53d6ff559e0e5450dbabfbf275c997c68d15674019b9b&amp;token=1184165571&amp;lang=zh_CN#rd" target="_blank" rel="noopener">CPU缓存一致性：从理论到实战</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CPU缓存一致性&quot;&gt;&lt;a href=&quot;#CPU缓存一致性&quot; class=&quot;headerlink&quot; title=&quot;CPU缓存一致性&quot;&gt;&lt;/a&gt;CPU缓存一致性&lt;/h1&gt;&lt;h2 id=&quot;存储体系结构&quot;&gt;&lt;a href=&quot;#存储体系结构&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="并发" scheme="http://Tyler-ytr.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发算法理论</title>
    <link href="http://Tyler-ytr.github.io/2022/10/06/%E5%B9%B6%E5%8F%91%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"/>
    <id>http://Tyler-ytr.github.io/2022/10/06/并发算法理论/</id>
    <published>2022-10-06T09:38:37.000Z</published>
    <updated>2022-10-09T05:43:39.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发算法理论"><a href="#并发算法理论" class="headerlink" title="并发算法理论"></a>并发算法理论</h1><p>[toc]</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="Sequential-Consistency-model"><a href="#Sequential-Consistency-model" class="headerlink" title="Sequential Consistency model"></a>Sequential Consistency model</h3><p> n个线程一个共享的内存memory，每一个读都是最近的写入的值；（交错，通过枚举行为得到所有可能的行为）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20221005142819393.png" alt="image-20221005142819393" title="">                </div>                <div class="image-caption">image-20221005142819393</div>            </figure><p>SC是比较强的内存模型；比如如下例子：</p><table><thead><tr><th>Init</th><th>x=y=0</th><th></th></tr></thead><tbody><tr><td>x=1</td><td>\</td><td>\</td><td></td><td>y=1</td></tr><tr><td>r1=y</td><td>\</td><td>\</td><td></td><td>r2=x</td></tr></tbody></table><p>在SC model不会出现r1=r2=0;但是在x86或者java会出现；</p><h2 id="弱内存模型"><a href="#弱内存模型" class="headerlink" title="弱内存模型"></a>弱内存模型</h2><h3 id="设计标准"><a href="#设计标准" class="headerlink" title="设计标准"></a>设计标准</h3><ol><li><p>DRF(data race freedom) guarantee 数据竞争保证：满足DRF的程序在弱内存模型下的行为和SC模型的行为一样；（其中怎么看待一个程序是不是DRF的指的是这个程序在SC下面是不是DRF的）</p><p>DRF定义：</p><p>当出现两个<strong>并发</strong>的<strong>冲突</strong>操作的时候会出现数据竞争：</p><ol><li>冲突：两个操作都访问一块内存区域并且至少一个是写操作</li><li>并发：<ol><li>在不同模型不一样</li><li>在java里面，就是两个操作没有happen-before顺序；<ol><li>如果是SC model；那么一个线程内部前后操作c1,c2；或者两个线程的通过锁保护的部分有happen-before关系；(也就是 $program ~order~\cup~synchronize-with$)</li></ol></li></ol></li></ol></li><li><p>可以被实现(不能特别强)</p><ol><li>优化：支持通常的优化（编译器的优化）</li><li>硬件：允许正常的map到现代体系结构的compilation scheme</li></ol></li><li>保证内存安全和安全保证（不能特别弱）,不能出现一些凭空出现的行为</li></ol><p>弱内存模型不好设计，编译器的优化会令人惊讶。</p><h3 id="java-memory-model的核心——happen-before-memory-model-hmm"><a href="#java-memory-model的核心——happen-before-memory-model-hmm" class="headerlink" title="java memory model的核心——happen-before memory model(hmm)"></a>java memory model的核心——happen-before memory model(hmm)</h3><ol><li>相对于SC的枚举定义行为的方式，HMM使用声明式(declarative semantics)定义程序的行为（给一个行为判定是不是满足weak memory model约束）</li></ol><h4 id="Happen-before-order"><a href="#Happen-before-order" class="headerlink" title="Happen before order"></a>Happen before order</h4><ol><li><p>程序执行：事件集合，他们之间存在顺序(po(program order)+sw(synchronize-with)):</p><p><img src="/picture/image-20221005164501388.png" alt="image-20221005164501388"></p></li><li><p>happen before order:$po\cup sw$的传递闭包:</p><p><img src="/picture/image-20221005164644229.png" alt="image-20221005164644229"></p></li><li><p>约束，Read能看到的：</p><ol><li>在它之前happen-before最近的写</li><li>与他毫无happen-before的写</li></ol><p>上图中r可以看到w1也可以看到w2</p></li><li><p>判定程序行为的方式：</p><ol><li><p>画执行图</p><p><img src="/picture/image-20221005165526334.png" alt="image-20221005165526334"></p></li><li><p>给一个行为，判断合不合理（先猜然后解读，形成环）</p><p><img src="/picture/image-20221005165510133.png" alt="image-20221005165510133"></p><p>存在good speculation和bad speculation;HMM可以产生out-of-thin-air read(凭空产生的读)</p></li><li><p>在HMM之上为了区分good/bad speculation 加入了很多复杂的内容形成了JMM</p></li></ol></li></ol><h2 id="并发的基本操作语义"><a href="#并发的基本操作语义" class="headerlink" title="并发的基本操作语义"></a>并发的基本操作语义</h2><h3 id="basic-domain"><a href="#basic-domain" class="headerlink" title="basic domain"></a>basic domain</h3><ol><li>$r\in Reg$ 表示寄存器，本地变量</li><li>$x\in Loc$ 共享的，地址</li><li>$v\in Val$ 值，包含0</li><li>$i\in Tid={1,..,N}$ 线程标识</li></ol><h3 id="Expressions-and-commands"><a href="#Expressions-and-commands" class="headerlink" title="Expressions and commands"></a>Expressions and commands</h3><ol><li>$e::=r|v|e+e|e-e|e*e|e/e$</li><li>$c::=skip|if~e~then~c~else~c|while~e~do~c|c;c|r:=e|r:=x|x:=e|r:=FAA(x,e)|r:=CAS(x,e,e)|fence $</li><li>FAA(x,e): fetch and add:读取x里面的值，存到局部变量r里面，然后加上e，这个是原子发生的；</li><li>CAS(x,e,e):Compare-and-Swap:比较memory里面的东西是否和前面一个e一样，如果一样就设置为新的值(后面的e)，如果不一样就什么都不做；这也是原子操作；返回值表示是否成功(成功r为1否则为0)</li><li>fence: SC下啥都不做；weak memory model里面x=1;fence;y=x;fence会保证x一定已经写入了memory；</li></ol><h3 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h3><p>$P:Tid\rightarrow Cmd,written ~as~P=c_1||…||c_N$</p><h3 id="描述程序含义"><a href="#描述程序含义" class="headerlink" title="描述程序含义"></a>描述程序含义</h3><p>$P,S,M\Rightarrow P’,S’,M‘$</p><p>S表示线程的寄存器集合，M表示共享内存，P表示程序；</p><p>初始状态，程序在状态上执行i:l步，转换成另外一种状态；</p><p>上述可以分为两个子系统，线程子系统，存储子系统；另外还需要把这两个子系统合起来</p><h4 id="线程子系统简述"><a href="#线程子系统简述" class="headerlink" title="线程子系统简述"></a>线程子系统简述</h4><ol><li>线程代码c， 自己的寄存器是s:$c,s\stackrel{l}{\longrightarrow}c’,s’$</li><li>顺序程序</li><li>提升到程序步骤:$P,S\stackrel{i:l}{\longrightarrow}P’,S’$</li></ol><h4 id="存储子系统简述"><a href="#存储子系统简述" class="headerlink" title="存储子系统简述"></a>存储子系统简述</h4><ol><li>描述内存访问以及fence</li><li>$M\stackrel{i:l}{\longrightarrow}M’$</li></ol><h3 id="线程子系统"><a href="#线程子系统" class="headerlink" title="线程子系统"></a>线程子系统</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20221005174019875.png" alt="image-20221005174019875" title="">                </div>                <div class="image-caption">image-20221005174019875</div>            </figure><p>横线上是前提，下面是结论；如果不需要前提直接可以走上面就没有；$\epsilon$  表示空指令; </p><p><img src="/picture/image-20221005174033350.png" alt="image-20221005174033350"></p><p>U(x,v,v+s(e))表示update，既可以读memory也可以写memory；</p><h4 id="合成到并发程序级别"><a href="#合成到并发程序级别" class="headerlink" title="合成到并发程序级别"></a>合成到并发程序级别</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20221005203506160.png" alt="image-20221005203506160" title="">                </div>                <div class="image-caption">image-20221005203506160</div>            </figure><p>这里l表示和memory model的交互；i是线程的id；</p><p>Transition表示只有线程i相关的部分(程序和register)发生了变化，表示：每次都是任取一个线程i走一步，然后代码就是线程i执行之后的结果，其他线程的部分不变</p><h3 id="存储子系统"><a href="#存储子系统" class="headerlink" title="存储子系统"></a>存储子系统</h3><h4 id="Sequential-Consistency-model-存储子系统"><a href="#Sequential-Consistency-model-存储子系统" class="headerlink" title="Sequential Consistency model 存储子系统"></a>Sequential Consistency model 存储子系统</h4><ol><li><p>SC model：</p><p><img src="/picture/image-20221005203737366.png" alt="image-20221005203737366"></p><p><img src="/picture/image-20221005203811327.png" alt="image-20221005203811327"></p></li></ol><h3 id="TSO-存储子系统"><a href="#TSO-存储子系统" class="headerlink" title="TSO 存储子系统"></a>TSO 存储子系统</h3><ol><li><p>TSO存储模型，用于x86：</p><p>每一个线程都有一个buffer，写的时候不会直接写而是写到buffer里面；然后不定时的把清空buffer，把里面的值写入到memory里面；读的时候先看buffer，有的话直接读取buffer否则读memory；</p><p>存在情况，线程A写到了自己的buffer里面，线程B读的是memory里面的值；</p><p><img src="/picture/image-20221005211622421.png" alt="image-20221005211622421"></p><p>相对于上面只有一个接口l，现在下面这部分需要考虑buffer和memory这块接口以及把他们合起来的方法； </p></li><li><p>TSO存储子系统的状态：</p><ol><li>A memory M:$Loc\rightarrow Val$  通过Loc可以获得值</li><li>A function B: $Tid\rightarrow (Loc,Val)^*$ 每一个线程都有自己的buffer，buffer里面是一串写操作(通过(Loc，Val)对表示)；</li></ol><p>初始状态：$&lt;M_0,B_0&gt;$</p><pre><code>1. $M_0=\lambda x.0$ 所有位置都是02. $B_0=\lambda i.\epsilon$ 所有buffer都是空的</code></pre></li><li><p>TSO存储子系统的状态转化：</p><p><img src="/picture/image-20221005212456638.png" alt="image-20221005212456638"></p><p>WRITE表示在原来的基础上增加一个$&lt;x,v&gt;$操作；</p><p>PROPAGATE表示把buffer里面的内容写入memory；buffer里面越往右越旧，所以先写右边的内容；</p><p>READ操作表示的是buffer里面有就读buffer否则就读memory，并且M,B不变；</p><p>RMW read modify write(指FAA,CAS这类指令)要求buffer为空，并且会对memory做更新；</p><p>FENCE 这个操作要求当前线程的buffer是空的；</p></li><li><p>TSO模型的例子:</p><p>| 例子 | store | buffering |<br>| —- | —– | ——— |<br>| x=1  | ||  | y=1       |<br>| r1=y | ||  | r2=x      |</p><p>r1=r2=1?</p><p>TSO模型可以（两边都读的旧值），SC模型不行</p></li></ol><h3 id="存储，线程合并起来"><a href="#存储，线程合并起来" class="headerlink" title="存储，线程合并起来"></a>存储，线程合并起来</h3><h4 id="SC-model"><a href="#SC-model" class="headerlink" title="SC model"></a>SC model</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20221005211134906.png" alt="image-20221005211134906" title="">                </div>                <div class="image-caption">image-20221005211134906</div>            </figure><p>初始的执行若干步($\Rightarrow *$)能够产生O说明这个O是被允许的；</p><h4 id="TSO-model"><a href="#TSO-model" class="headerlink" title="TSO model"></a>TSO model</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20221005213210938.png" alt="image-20221005213210938" title="">                </div>                <div class="image-caption">image-20221005213210938</div>            </figure><h2 id="并发的声明式语义-Declarative-semantics-for-concurrency"><a href="#并发的声明式语义-Declarative-semantics-for-concurrency" class="headerlink" title="并发的声明式语义(Declarative semantics for concurrency)"></a>并发的声明式语义(Declarative semantics for concurrency)</h2><ol><li><p>总体思想：不去想程序怎么执行（操作语义这么整），而是产生一系列程序有可能执行的图，然后通过规则判定这些图上哪一些能够被model解释</p></li><li><p>具体而言：</p><ol><li>Define the notion of a program <strong>execution</strong> (generalization of an execution trace)</li><li>Map a program to a set of executions (与程序有关)</li><li>Define a <strong>consistency</strong> predicate on executions (定义公理，比如happen-before等约束)</li><li>Semantics = set of consistent executions of a program (上述满足约束的所有程序)</li></ol></li><li><p>例子：</p><p><img src="/picture/image-20221006105106575.png" alt="image-20221006105106575"></p><ol><li>例子中有事件： Reads, Writes, Updates, Fences</li><li>有两种关系：<strong>程序执行顺序</strong>(Program order,po;或者“sequenced-before”, sb)，黑色实线; <strong>Reads-from 顺序</strong>, rf，绿色虚线</li></ol></li></ol><h3 id="执行图的定义"><a href="#执行图的定义" class="headerlink" title="执行图的定义"></a>执行图的定义</h3><ol><li><p>Label：有以下格式：</p><p>$R~x~v_r<del>W~x~v_w</del> U(x~v_r~ v_w) ~~F$</p><p>其中$x \in Loc$ and $v_r , v_w \in Val$.</p></li><li><p>Event：是一个元组$&lt;id, i, l&gt;$:</p><ol><li>$id\in N$表示事件标识符</li><li>$i \in Tid \cup {0}$ 是线程标识符</li><li>l是一个label</li></ol></li><li><p>执行图(execution graph)：是一个元组$&lt;E, po, rf&gt;$：</p><ol><li><p>E是events的有限集合</p></li><li><p>po (“program order”) 是 E 上的偏序关系</p></li><li><p>rf (“reads-from”) 是 E 上的二元关系：</p><p>For every $&lt;w, r&gt;\in rf$:</p><ol><li>$typ(w) \in {W, U}$ w操作要么是写要么是更新(U)</li><li>$typ(r) \in {R, U}$ r操作要么是读要么是更新</li><li>$loc(w) = loc(r)$ 读写的位置一样</li><li>$val_w(w) = val_r(r)$ 读写的值一样</li></ol><p>$rf^{ −1}$ is a function,that is: if $&lt;w_1, r&gt;$, $&lt;w_2, r&gt;$,then $w_1 = w_2$ ；表示读只能读一个写</p></li></ol></li><li><p>其他一些标记：</p><p><img src="/picture/image-20221006112245075.png" alt="image-20221006112245075"></p></li></ol><h3 id="程序映射到执行图"><a href="#程序映射到执行图" class="headerlink" title="程序映射到执行图"></a>程序映射到执行图</h3><ol><li><p>例子，与程序有关的图：</p><p><img src="/picture/image-20221006124708667.png" alt="image-20221006124708667"></p></li><li><p>线程子系统将一个<strong>顺序(sequential)</strong>执行图与每个命令关联起来。通过连接组成线程的顺序执行图可以得到程序的执行；</p><p>如果满足以下性质，一个图是<strong>sequential</strong>的（也就是与一个线程有关的执行图的性质）：</p><ol><li>$tid(a) = 0$ for every $a \in G.E$ （与下面第四点Thread restriction有关，表示只有一个线程）</li><li>$G.po$ is a total order on $G.E$  （一个线程中的事件一定是有序的）</li><li>$G.rf = \empty$</li></ol></li><li><p>命令的执行图的定义：</p><p><img src="/picture/image-20221006130330709.png" alt="image-20221006130330709"></p><p>与内存有交互的命令会产生执行图的变化</p><p><img src="/picture/image-20221006130355006.png" alt="image-20221006130355006"></p></li><li><p>Thread restriction：</p><p>给定线程号$i\in Tid$，以及一个执行图G，$G^i$表示把G的事件限制成只有与线程i相关的事件:${a\in G.E|tid(a)=i}$，并且把他们的线程标识都改成0，丢弃所有rf边；</p></li><li><p>Execution graph of a program:</p><p>$G$ is an execution graph of a program $P $ (with an outcome $O)$ if $G_i$ is an execution of $P(i) $ (with final store O(i)) for every<br>$i \in Tid$.</p></li></ol><h3 id="一致性谓词-consistency-predicate"><a href="#一致性谓词-consistency-predicate" class="headerlink" title="一致性谓词(consistency predicate)"></a>一致性谓词(<strong>consistency</strong> predicate)</h3><ol><li><p>假设X是执行图上的一些一致性谓词，那么程序P在X下<strong>允许</strong>出现的结果O，定义为如果存在一个执行图G满足：</p><ol><li>G is an execution graph of P with outcome O. G是P的执行图能产生O</li><li>G is X-consistent. G满足X-一致性</li></ol><p>或者，“catch-fire” semantics定义：(对应于C/C++的undefined behavior，此时任何的O都可以产生)</p><p>存在一个执行图G满足：</p><ol><li>G is an execution graph of P. G是P的执行图</li><li>G is X-consistent. G满足X-一致性</li><li>G is “bad”.</li></ol></li><li><p>Completeness<span id="Completeness">定义</span>：</p><p>一个执行图G成为completeness，如果codom(G.rf) = G.R使得<strong>每一个</strong>read都能从<strong>一些</strong>write read from</p><p>也就是图上所有的read都通过rf边连接到write</p></li></ol><h4 id="Sequential-consistency"><a href="#Sequential-consistency" class="headerlink" title="Sequential consistency"></a>Sequential consistency</h4><p>任何执行的结果都与所有处理器的操作按照程序指定的顺序按某种顺序执行是一样的。</p><ol><li><p>SC-consistent 定义：假设<strong>sc</strong>是G,E上面的全序；如果下列情况满足，则称G是关于<strong>sc</strong> SC -consistent的：</p><ol><li>If $&lt;a, b&gt; \in G.po$ then $&lt;a, b&gt;\in sc$. (program order 里的都满足sc)</li><li>If $&lt;a, b&gt; \in G.rf$ then $&lt;a, b&gt; \in sc $ and there does not exist $c \in G.W_{loc}(b)$ such that $&lt;a, c&gt; \in sc$ and $&lt;c, b&gt; \in sc$.  (不同线程之间读应该读上一次写，中间有write是不可能的)</li></ol></li><li><p>一个执行图如果满足下列条件那么是SC-consistent的：</p><ol><li>G is <a href="#Completeness">complete</a>. </li><li>G is SC-consistent wrt some total order sc on G.E. (所有事件之间要有一个sc order)</li></ol></li><li><p>例子：</p><p><img src="/picture/image-20221006152709317.png" alt="image-20221006152709317"></p><p>forbidden部分因为sc下一定会形成一个环，此时这个不是order了，因此不允许；</p><p>allowed部分可以先R y 0然后W y 1，此时就可以构成全序了；</p></li></ol><h4 id="Sequential-consistency-另外的定义"><a href="#Sequential-consistency-另外的定义" class="headerlink" title="Sequential consistency 另外的定义"></a>Sequential consistency 另外的定义</h4><ol><li><p>Modification order定义:</p><p>$mo$ is called a modification order for an execution graph G if $mo = \cup _{x\in Loc} mo_x$ where each $mo_x$ is a total order on $ G.Wx$ .</p><p>mo只在这张图的write之间建立，同一个loc上的write上面有一条边，称为$mo_x$，所有$mo_x$的并形成了mo；</p></li><li><p>SC的另一种定义：</p><p><img src="/picture/image-20221006153604699.png" alt="image-20221006153604699"></p><p>所有的po,rf,mo,rb边合起来是无环的；</p><p>rb的定义就是rf取逆然后加上mo，比如$Wy0 \rightarrow Wy1 (mo),Wy0\rightarrow Ry0(rf)$，因此$Ry0\rightarrow Wy0(rf^{-1})$，有$Ry0\rightarrow Wy1(rb)$ </p><p>rb的定义去掉id是考虑到U的情况（因为U和W可以有mo关系也可以有rf关系，有可能形成自环）</p></li></ol><p>两种定义是等价的，证明如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20221006154701915.png" alt="image-20221006154701915" title="">                </div>                <div class="image-caption">image-20221006154701915</div>            </figure><h4 id="Relax-Sequential-consistency"><a href="#Relax-Sequential-consistency" class="headerlink" title="Relax Sequential consistency"></a><span id="Relax_model">Relax Sequential consistency</span></h4><p>原因：在硬件里面实现SC非常昂贵，并且SC禁止了许多对于顺序代码的优化</p><ol><li><p>大多数硬件保证<strong>SC-per-location</strong>，又称作coherence；如果一个执行图是coherent的那么有如下性质：</p><ol><li><p>G is complete</p></li><li><p>对于所有的位置x，在所有对x的访问上存在一个全序关系$sc_x$:</p><ol><li><p>if $&lt;a,b&gt;\in [RW_x];G.po;[RW_x]$,then $&lt;a,b&gt;\in sc_x$</p><p>$Rw_X$表示对x的读写操作;</p><p>$&lt;a,b&gt;\in A;B$:</p><p><img src="/picture/image-20221007174308127.png" alt="image-20221007174308127"></p><p>这条的意思是a,b是和x的读写有关的，如果它们之间是program order的关系，那么它们要属于$sc_x$</p></li><li><p>If $&lt;a, b&gt; \in [W_x];G.rf; [Rx]$ , then $&lt;a, b&gt; \in sc_x$ and there does not exist $c \in G.W_x$ such that $&lt;a, c&gt; \in sc_x$ and<br>$&lt;c, b&gt; \in sc_x$ .</p><p>与前面的定义相似，主要区别是对于x的位置限定</p></li></ol></li></ol></li><li><p>另外一个版本的定义：</p><p><img src="/picture/image-20221007174938655.png" alt="image-20221007174938655"></p><p>主要区别是在同一个location上面不能成环；</p><blockquote><p> 个人总结：所有的对于同一个loc的write之间有一个全序mo，在某一个loc的read一定有rf关系（先写再write），然后所有的R,W之间有一个全序关系（program order）;取rf的反向边为fr，那么rb=fr+mo（类似于向量运算）；上面这些不能成环；</p></blockquote><p>反例：</p><ol><li><p>no-future-read,rmw-1：</p><p><img src="/picture/image-20221008112842239.png" alt="image-20221008112842239"></p></li><li><p>coherence-ww,coherence-rw,coherence-wr,coherence-rr:</p><p>下面程序对应于最后一个执行图，是不行的（有环）</p><p><img src="/picture/image-20221008112532721.png" alt="image-20221008112532721"></p></li><li><p>rmw-2,atomicity</p><p><img src="/picture/image-20221008113102746.png" alt="image-20221008113102746"></p></li></ol></li><li><p>另外一个版本的定义（对应于上面这些图）：</p><p>假设mo是执行图G的modification order，那么G关于mo是coherent的当且仅当以下性质成立：</p><ol><li>rf; po is irreflexive. (no-future-read)</li><li>mo; po is irreflexive. (coherence-ww)</li><li>mo; rf; po is irreflexive. (coherence-rw)</li><li>rf−1; mo; po is irreflexive. (coherence-wr)</li><li>rf−1; mo; rf; po is irreflexive. (coherence-rr)</li><li>rf is irreflexive. (rmw-1)</li><li>mo; rf is irreflexive. (rmw-2)</li><li>rf−1; mo; mo is irreflexive. (rmw-atomicity)</li></ol><blockquote><p>实际操作的时候，首先根据程序得到po，然后根据read的值得到rf关系，最后嵌入mo（多种嵌入方式分开讨论验证）</p></blockquote></li><li><p>coherence相对还是太弱了，没有办法让锁真正应用（因为lock之后对于其他地方的修改其实该一致性不做限制）</p></li></ol><h4 id="Release-acquire-RA-memory-model"><a href="#Release-acquire-RA-memory-model" class="headerlink" title="Release/acquire (RA) memory model"></a><span id="RA_model">Release/acquire (RA) memory model</span></h4><ol><li><p>注：$(a,b)\in (po\cup rf)^+$ 后者表示闭包，也就是a,b之间po,rf边出现一次或者多次；实际上比po要延续更长的距离，让model更强</p></li><li><p>RA实际上就是把coherence的po换成了$(a,b)\in (po\cup rf)^+$:</p><p><img src="/picture/image-20221008125242436.png" alt="image-20221008125242436"></p></li><li><p>具体定义：</p><p><img src="/picture/image-20221008125346556.png" alt="image-20221008125346556"></p></li><li><p>另一种定义：</p><ol><li>$(po \cup rf)^+$ is irreflexive. (no-future-read) 也就是po,rf无环；不会是某一个事件a开始经过若干个po,rf然后回到a；</li><li>$mo; (po \cup rf)^+$ is irreflexive. (coherence-ww) 不会是某一个事件a开始首先经过mo然后经过若干个po,rf然后回到a；</li><li>$rf^{−1}; mo; (po \cup rf)^+$ is irreflexive. (coherence-wr)</li><li>$rf^{−1}; mo; mo$ is irreflexive. (rmw-atomicity)</li></ol></li></ol><h4 id="Access-model"><a href="#Access-model" class="headerlink" title="Access model"></a>Access model</h4><p>大致思想是混合coherence model和RA memory model；</p><ol><li><p>每一个内存访问都有一个模式：</p><ol><li>Reads: rlx or acq</li><li>Writes: rlx or rel</li><li>RMWs: rlx, acq, rel or acq-rel</li></ol><blockquote><p>PS: rl 是 relax的缩写，指的是满足<a href="#Relax_model">coherence model</a>一致性；rel,release缩写，acq,acquire缩写，满足<a href="#RA_model">RA memory model</a>一致性</p></blockquote></li><li><p>强度顺序,$\sqsubset$定义：</p><p><img src="/picture/image-20221008155016396.png" alt="image-20221008155016396"></p><p>中间的表示读是rlx然后写不一样</p></li></ol><h5 id="Happen-before"><a href="#Happen-before" class="headerlink" title="Happen before"></a>Happen before</h5><ol><li><p>同步(Synchronization)：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20221008155231257.png" alt="image-20221008155231257" title="">                </div>                <div class="image-caption">image-20221008155231257</div>            </figure></p><p>表示的是W要么是release要么比release更强；R同理</p></li><li><p>Happen-before: $G.hb = (G.po \cup G.sw)^+$</p></li></ol><h4 id="C-C-11-memory-model-简介"><a href="#C-C-11-memory-model-简介" class="headerlink" title="C/C++11 memory model 简介"></a>C/C++11 memory model 简介</h4><ol><li><p>定义：实际上是把<a href="#Relax_model">coherence model</a>的po用hb进行了”增强”：</p><p><img src="/picture/image-20221008155501848.png" alt="image-20221008155501848"></p></li><li><p>C/C++11 memory model 下面的强度关系：(比access model 更多一点类型)</p><p>$non-atomic\sqsubset relaxed\sqsubset release/acquire\sqsubset sc$</p><ol><li>non-atomic用于没有数据竞争的代码（默认）</li><li>fence也有以上四种类型</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发算法理论&quot;&gt;&lt;a href=&quot;#并发算法理论&quot; class=&quot;headerlink&quot; title=&quot;并发算法理论&quot;&gt;&lt;/a&gt;并发算法理论&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="并发" scheme="http://Tyler-ytr.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>RDMA-learning4</title>
    <link href="http://Tyler-ytr.github.io/2022/04/23/RDMA-learning4/"/>
    <id>http://Tyler-ytr.github.io/2022/04/23/RDMA-learning4/</id>
    <published>2022-04-23T12:47:37.000Z</published>
    <updated>2022-10-09T05:47:47.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RDMA技术整理4-RDMA编程入门"><a href="#RDMA技术整理4-RDMA编程入门" class="headerlink" title="RDMA技术整理4 RDMA编程入门"></a>RDMA技术整理4 RDMA编程入门</h1><h2 id="连通测试"><a href="#连通测试" class="headerlink" title="连通测试"></a>连通测试</h2><p>物理拓扑：服务器6和8之间有一根直连网线；两台服务器各有一张cx5网卡，支持RoCe</p><ol><li><p>使用<code>ibdev2netdev</code>查看设备：</p><p><img src="/picture/image-20220426191053641.png" alt="image-20220426191053641"></p></li><li><p>使用<code>show_gids</code>看看网卡支持的RoCe版本</p><p><img src="/picture/image-20220426191319616.png" alt="image-20220426191319616"></p><p>这里的IPv4地址是通过<code>nmtui</code>进行配置的</p></li><li><p>服务器8根据如上的信息使用<code>ib_send_bw -d mlx5_1 -x 2</code>，作为信号的接收端；另一台服务器6使用<code>sudo ib_send_bw -d mlx5_3 192.168.42.8 --report_gbits -F -x 2</code>进行信息的发送；（5_3是服务器6里面有ipv4地址并且up的设备）</p></li><li><p>测试结果:</p><p>接收端：</p><p><img src="/picture/image-20220426191807687.png" alt="image-20220426191807687"></p><p>发送端：</p><p><img src="/picture/image-20220426191822803.png" alt="image-20220426191822803"></p></li></ol><h2 id="RDMA-常用命令"><a href="#RDMA-常用命令" class="headerlink" title="RDMA 常用命令"></a>RDMA 常用命令</h2><p>参考自<a href="https://blog.csdn.net/bandaoyu/article/details/115798693" target="_blank" rel="noopener">https://blog.csdn.net/bandaoyu/article/details/115798693</a></p><table><thead><tr><th>命令</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td><code>ibv_devinfo</code></td><td>显示device信息（简略）</td><td></td></tr><tr><td><code>ibv_devinfo mlx5_0</code></td><td>显示设备mlx5_0的详细信息</td><td></td></tr><tr><td><code>ibv_devinfo -v</code></td><td>显示网卡信息（详细）</td><td></td></tr><tr><td><code>ibv_devices</code></td><td>列出device</td><td></td></tr><tr><td><code>ibvdev2netdev</code></td><td>显示device和网口的对应关系</td><td>mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令</td></tr><tr><td><code>show_gids</code></td><td>显示gid列表</td><td>mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令</td></tr><tr><td><code>show_drop</code></td><td>查看端口包丢弃情况</td><td>mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令</td></tr><tr><td><code>ibstatus</code></td><td>查看核更改网卡工作模式：Ethernet 或infiniband模式</td><td></td></tr><tr><td><code>ibv_asyncwatch</code></td><td>监视 InfiniBand 异步事件</td><td></td></tr><tr><td><code>iblinkinfo.pl 或 iblinkinfo</code></td><td>显示光纤网络中所有链路的链路信息</td><td></td></tr><tr><td><code>sminfo</code></td><td>用法sminfo –help;查询 IB SMInfo 属性</td><td></td></tr><tr><td><code>ibstat 或 ibsysstat</code></td><td>查询 InfiniBand 设备状态或 IB 地址上的系统状态</td><td></td></tr><tr><td><code>hca_self_test.ofed</code></td><td>RDMA网卡自测</td><td>mellonx</td></tr><tr><td><code>/etc/infiniband/info</code></td><td>Mellanox OFED 安装的信息</td><td>mellonx</td></tr><tr><td><code>cat /etc/infiniband/openib.conf</code></td><td>看自动加载的模块列表</td><td>mellonx</td></tr><tr><td>`lspci</td><td>grep Mellanox`</td><td></td><td>检查Mellanox网卡是否安装和版本</td></tr></tbody></table><h2 id="RDMA-编程入门"><a href="#RDMA-编程入门" class="headerlink" title="RDMA 编程入门"></a>RDMA 编程入门</h2><h3 id="RDMA-编程入门1"><a href="#RDMA-编程入门1" class="headerlink" title="RDMA 编程入门1"></a>RDMA 编程入门1</h3><p>这部分来自<a href="https://github.com/tarickb/the-geek-in-the-corner" target="_blank" rel="noopener">the-geek-in-the-corner</a>的<a href="https://github.com/tarickb/the-geek-in-the-corner/tree/master/01_basic-client-server" target="_blank" rel="noopener">01_basic-client-server</a>；</p><p>在上述配置中的运行方法和连通实验类似：</p><ol><li><p>在两个服务器使用make；</p></li><li><p>服务器8作为server使用<code>./server</code>，程序告知端口号是36436；</p></li><li><p>服务器6作为client使用<code>./client 192.168.42.8 36436</code>；这里的IP地址和上面连通测试使用的IP地址一样</p></li><li><p>运行结果：</p><p>server8，服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp@R750-427Server8:~/worker/the-geek-in-the-corner/01_basic-client-server$ ./server</span><br><span class="line">listening on port 36436.</span><br><span class="line">received connection request.</span><br><span class="line">received message: message from active/client side with pid 21871</span><br><span class="line">connected. posting send...</span><br><span class="line">send completed successfully.</span><br><span class="line">peer disconnected.</span><br></pre></td></tr></table></figure><p>server6，客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp@R750-427Server6:~/worker/the-geek-in-the-corner/01_basic-client-server$ ./client 192.168.42.8 36436</span><br><span class="line">address resolved.</span><br><span class="line">route resolved.</span><br><span class="line">connected. posting send...</span><br><span class="line">send completed successfully.</span><br><span class="line">received message: message from passive/server side with pid 14356</span><br><span class="line">disconnected.</span><br></pre></td></tr></table></figure><p>这部分代码的目标是连接两个应用程序，让他们能够交换数据。这部分的关键是QP pair和CP，连接的每一端都有发送-接受队列和一个完成队列。构建队列并且对他们相互连接的步骤如下：</p><ul><li>创建保护域（关联队列对、完成队列、内存注册等）、完成队列和发送-接收队列对。</li><li>确定队列对的地址。 </li><li>将地址传送到另一个节点（通过某些带外机制）。</li><li>将队列对转换为“随时可以接收”（RTR） 状态，然后转换为“准备发送”（RTS） 状态。</li><li>根据需要发布发送、接收等操作</li></ul><p>主动端（请求端）和被动端（响应端）的具体步骤如下：</p><p><strong>被动端：</strong></p><ol><li>创建一个事件通道，以便我们可以接收 rdmacm 事件，例如连接请求和连接建立的通知。</li><li>绑定到地址。</li><li>创建侦听器并返回端口/地址。</li><li>等待连接请求。</li><li>创建保护域、完成队列和发送-接收队列对。</li><li>接受连接请求。</li><li>等待建立连接。</li><li>根据需要发布操作。</li></ol><p><strong>主动端：</strong></p><ol><li>创建一个事件通道，以便我们可以接收 rdmacm 事件，例如地址解析、路由解析和连接建立的通知。</li><li>创建连接标识符。</li><li>解析对等方的地址，这会将连接标识符绑定到本地 RDMA 设备。</li><li>创建保护域、完成队列和发送-接收队列对。</li><li>解析到对等方的路由。</li><li>连接。等待建立连接。</li><li>根据需要发布操作。</li></ol></li></ol><p>双方将共享相当数量的代码 - 被动端的步骤 1、5、7 和 8 大致相当于主动端的步骤 1、4、7 和 8。一旦建立了连接，与套接字一样，双方都是对等的。利用连接需要我们在队列对上发布操作。接收操作（不出所料）发布在接收队列上。在发送队列上，我们发布发送请求、RDMA 读/写请求和原子操作请求。</p><hr><h5 id="Passive-Server-side"><a href="#Passive-Server-side" class="headerlink" title="Passive/Server side"></a>Passive/Server side</h5><p>上面交代了被动端设置的部分，现在是详细的代码部分。因为几乎所有的内容都是异步处理的；因此这项工作首先需要构建一个事件处理循环和一组时间处理器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rdma/rdma_cma.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_NZ(x) do &#123; <span class="meta-keyword">if</span> ( (x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned non-zero)."</span> ); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_Z(x)  do &#123; <span class="meta-keyword">if</span> (!(x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned zero/null)."</span>); &#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, reason);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来设置一个事件通道，创建一个ramdacm ID(相当于套接字)，绑定之后再循环中等待事件，这部分是修改<code>main()</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> *<span class="title">event</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_id</span> *<span class="title">listener</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_event_channel</span> *<span class="title">ec</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line"> </span><br><span class="line">  TEST_Z(ec = rdma_create_event_channel());</span><br><span class="line">  TEST_NZ(rdma_create_id(ec, &amp;listener, <span class="literal">NULL</span>, RDMA_PS_TCP));</span><br><span class="line">  TEST_NZ(rdma_bind_addr(listener, (struct sockaddr *)&amp;addr));</span><br><span class="line">  TEST_NZ(rdma_listen(listener, <span class="number">10</span>)); <span class="comment">/* backlog=10 is arbitrary */</span></span><br><span class="line"> </span><br><span class="line">  port = ntohs(rdma_get_src_port(listener));</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"listening on port %d.\n"</span>, port);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (rdma_get_cm_event(ec, &amp;event) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> <span class="title">event_copy</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;event_copy, event, <span class="keyword">sizeof</span>(*event));</span><br><span class="line">    rdma_ack_cm_event(event);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (on_event(&amp;event_copy))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_id(listener);</span><br><span class="line">  rdma_destroy_event_channel(ec);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ec 是指向 rdmacm 事件通道的指针。listener是指向侦听器的 rdmacm ID 的指针。我们在创建它时指定了<code>RDMA_PS_TCP</code>，这表明我们需要一个面向连接的可靠队列对。<code>RDMA_PS_UDP</code>将指示无连接、不可靠的队列对。 </p><p>然后，我们将此 ID 绑定到套接字地址。通过将端口（<code>addr.sin_port</code>）设置为零，我们指示 rdmacm 选择一个可用端口。我们还指出，我们希望侦听任何可用 RDMA 接口/设备上的连接。 </p><p>我们的事件循环从 rdmacm 获取事件，确认事件，然后对其进行处理。未能确认事件将导致rdma_destroy_id（） 阻塞。连接的被动端的事件处理程序仅对三个事件感兴趣：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_connect_request</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_CONNECT_REQUEST)</span><br><span class="line">    r = on_connect_request(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_ESTABLISHED)</span><br><span class="line">    r = on_connection(event-&gt;id-&gt;context);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_DISCONNECTED)</span><br><span class="line">    r = on_disconnect(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    die(<span class="string">"on_event: unknown event."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码结合前面的main函数break的条件可以看出来，这里只关注<code>on_event</code>里面的三种事件，如果不是这三种就会继续循环（等待）；</p><p>rdmacm 允许我们将 <code>void *</code>上下文指针与 ID 相关联。我们将使用它来附加连接上下文结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp</span> *<span class="title">qp</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">recv_mr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">send_mr</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> *recv_region;</span><br><span class="line">  <span class="keyword">char</span> *send_region;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它包含一个指向队列对（冗余，但略微简化了代码）、两个缓冲区（一个用于发送，另一个用于接收）和两个内存区域（用于发送/接收的内存必须“注册”到谓词库）的指针。当我们收到连接请求时，如果尚未构建动词上下文，我们首先构建该上下文。然后，在构建了连接上下文结构之后，我们预先发布了我们的接收信息（稍后会详细介绍），并接受连接请求：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_connect_request</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_init_attr</span> <span class="title">qp_attr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_conn_param</span> <span class="title">cm_params</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"received connection request.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  build_context(id-&gt;verbs);</span><br><span class="line">  build_qp_attr(&amp;qp_attr);</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(rdma_create_qp(id, s_ctx-&gt;pd, &amp;qp_attr));</span><br><span class="line"> </span><br><span class="line">  id-&gt;context = conn = (struct connection *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct connection));</span><br><span class="line">  conn-&gt;qp = id-&gt;qp;</span><br><span class="line"> </span><br><span class="line">  register_memory(conn);</span><br><span class="line">  post_receives(conn);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;cm_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(cm_params));</span><br><span class="line">  TEST_NZ(rdma_accept(id, &amp;cm_params));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们推迟构建谓词上下文，直到收到第一个连接请求，因为<code>rdmacm listener ID 不一定绑定到特定的 RDMA 设备（以及关联的谓词上下文）。但是，我们收到的第一个连接请求将在</code>id-&gt;verbs` 处具有有效的谓词上下文结构。构建谓词上下文涉及设置静态上下文结构、创建保护域、创建完成队列、创建完成通道以及启动线程以从队列中提取完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_context</span> *<span class="title">ctx</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_pd</span> *<span class="title">pd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_comp_channel</span> *<span class="title">comp_channel</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">pthread_t</span> cq_poller_thread;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">s_ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s_ctx-&gt;ctx != verbs)</span><br><span class="line">      die(<span class="string">"cannot handle events in more than one context."</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  s_ctx = (struct context *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct context));</span><br><span class="line">  <span class="comment">//设置静态上下文结构、创建保护域、创建完成队列、创建完成通道</span></span><br><span class="line">  s_ctx-&gt;ctx = verbs;</span><br><span class="line"> </span><br><span class="line">  TEST_Z(s_ctx-&gt;pd = ibv_alloc_pd(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;comp_channel = ibv_create_comp_channel(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;cq = ibv_create_cq(s_ctx-&gt;ctx, <span class="number">10</span>, <span class="literal">NULL</span>, s_ctx-&gt;comp_channel, <span class="number">0</span>));</span><br><span class="line">  TEST_NZ(ibv_req_notify_cq(s_ctx-&gt;cq, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(pthread_create(&amp;s_ctx-&gt;cq_poller_thread, <span class="literal">NULL</span>, poll_cq, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用完成通道允许我们阻塞轮询器线程等待完成。我们创建完成队列，并将<code>cqe</code>设置为 10（<code>cqe</code>是<code>ibv_create_cq</code> 函数里面的第二个参数），表示我们希望在队列上留出 10 个条目的空间。此数字应设置得足够大，以便队列不会溢出。轮询器在通道上等待，确认完成，重新排列完成队列（使用 <code>ibv_req_notify_cq()</code>），然后从队列中提取事件，直到没有事件留下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    TEST_NZ(ibv_get_cq_event(s_ctx-&gt;comp_channel, &amp;cq, &amp;ctx));</span><br><span class="line">    ibv_ack_cq_events(cq, <span class="number">1</span>);</span><br><span class="line">    TEST_NZ(ibv_req_notify_cq(cq, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc))</span><br><span class="line">      on_completion(&amp;wc);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到我们的连接请求。构建动词上下文后，我们必须初始化队列对属性结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(qp_attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qp_attr));</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;send_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;recv_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;qp_type = IBV_QPT_RC;</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;cap.max_send_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先将结构清零，然后设置我们关心的属性。 <code>send_cq</code> 和 <code>recv_cq</code>分别是发送和接收完成队列。<code>qp_type</code> 设置为表明我们想要一个可靠的、面向连接的队列对。队列对功能结构 <code>qp_attr-&gt;cap</code> 用于与动词驱动程序协商最小功能。在这里，我们请求十个挂起的发送和接收（在它们各自的队列中的任何时间），以及每个发送或接收请求一个分散/收集元素（SGE；实际上是一个内存位置/大小元组）。建立队列对初始化属性后，我们调用 rdma_create_qp() 来创建队列对。然后我们为我们的连接上下文结构（结构连接）分配内存，并为我们的发送和接收操作分配/注册内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  conn-&gt;send_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">  conn-&gt;recv_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;send_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd, </span><br><span class="line">    conn-&gt;send_region, </span><br><span class="line">    BUFFER_SIZE, </span><br><span class="line">    IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE));</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;recv_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd, </span><br><span class="line">    conn-&gt;recv_region, </span><br><span class="line">    BUFFER_SIZE, </span><br><span class="line">    IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们分配两个缓冲区，一个用于发送，另一个用于接收，然后用动词注册它们。我们指出需要对这些内存区域进行本地写入和远程写入访问。连接请求事件处理程序中的下一步（变得相当长）是预先发布接收。在接受连接之前必须发布接收工作请求 （WR） 的原因是，基础硬件不会缓冲传入消息 — 如果接收请求尚未发布到工作队列，则传入消息将被拒绝，对等方将收到接收器未就绪 （RNR） 错误。我将在另一篇文章中进一步讨论这个问题，但现在只需说必须在发送之前发布接收。我们将通过在接受连接之前发布收到的邮件，并在建立连接后发送发送来强制执行此操作。发布接收需要我们构建一个接收工作请求结构，然后将其发布到接收队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  wr.wr_id = (<span class="keyword">uintptr_t</span>)conn;</span><br><span class="line">  wr.next = <span class="literal">NULL</span>;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;recv_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;recv_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_recv(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（任意）<code>wr_id</code>字段用于存储连接上下文指针。最后，完成所有这些设置后，我们已准备好接受连接请求。这是通过调用rdma_accept（）来完成的。 我们需要处理的下一个事件是RDMA_CM_EVENT_ESTABLISHED，这表示已建立连接。这个处理程序很简单 - 它只是发布一个发送工作请求：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">context</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">snprintf</span>(conn-&gt;send_region, BUFFER_SIZE, <span class="string">"message from passive/server side with pid %d"</span>, getpid());</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"connected. posting send...\n"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(wr));</span><br><span class="line"> </span><br><span class="line">  wr.opcode = IBV_WR_SEND;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;send_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;send_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_send(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与我们用于发布接收的代码没有根本的不同，除了发送请求指定了操作码。此处，IBV_WR_SEND指示必须与对等体上的相应接收请求匹配的发送请求。其他选项包括 RDMA 写入、RDMA 读取和各种原子操作。在 wr.send_flags 中指定IBV_SEND_SIGNALED表示我们需要此发送请求的完成通知。</p><p>我们要处理的最后一个 rdmacm 事件是RDMA_CM_EVENT_DISCONNECTED，我们将在其中执行一些清理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">id</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"peer disconnected.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_qp(id);</span><br><span class="line"> </span><br><span class="line">  ibv_dereg_mr(conn-&gt;send_mr);</span><br><span class="line">  ibv_dereg_mr(conn-&gt;recv_mr);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;send_region);</span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;recv_region);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_id(id);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所要做的就是处理从完成队列中提取的完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;status != IBV_WC_SUCCESS)</span><br><span class="line">    die(<span class="string">"on_completion: status is not IBV_WC_SUCCESS."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;opcode &amp; IBV_WC_RECV) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)(<span class="title">uintptr_t</span>)<span class="title">wc</span>-&gt;<span class="title">wr_id</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received message: %s\n"</span>, conn-&gt;recv_region);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_SEND) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send completed successfully.\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回想一下，在 post_receives（） 中，我们设置了对连接上下文结构的wr_id。就是这样！建造很简单，但不要忘记-lrdmacm。此处提供了被动端/服务器和主动端/客户端的完整代码。（在之后的部分作者讨论了优化）</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/tarickb/the-geek-in-the-corner" target="_blank" rel="noopener">the-geek-in-the-corner</a></li><li><a href="https://thegeekinthecorner.wordpress.com/2010/08/13/building-an-rdma-capable-application-with-ib-verbs-part-1-basics/" target="_blank" rel="noopener">Building an RDMA-capable application with IB verbs, part 1: basics</a></li><li><a href="https://thegeekinthecorner.wordpress.com/2013/02/02/rdma-tutorial-pdfs/" target="_blank" rel="noopener">RDMA tutorial PDFs</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RDMA技术整理4-RDMA编程入门&quot;&gt;&lt;a href=&quot;#RDMA技术整理4-RDMA编程入门&quot; class=&quot;headerlink&quot; title=&quot;RDMA技术整理4 RDMA编程入门&quot;&gt;&lt;/a&gt;RDMA技术整理4 RDMA编程入门&lt;/h1&gt;&lt;h2 id=&quot;连
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="RDMA" scheme="http://Tyler-ytr.github.io/tags/RDMA/"/>
    
  </entry>
  
  <entry>
    <title>项目开发记录</title>
    <link href="http://Tyler-ytr.github.io/2022/04/19/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://Tyler-ytr.github.io/2022/04/19/项目开发记录/</id>
    <published>2022-04-19T03:16:27.000Z</published>
    <updated>2022-04-19T03:20:20.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="院系项目开发记录"><a href="#院系项目开发记录" class="headerlink" title="院系项目开发记录"></a>院系项目开发记录</h1><p>参与院系项目开发，对开发过程中的一些配置进行记录；</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>Node需要大于16，采用了项目<a href="https://github.com/jasongin/nvs" target="_blank" rel="noopener">https://github.com/jasongin/nvs</a> 进行项目的配置；在win里面输入nvs就可以下载以及选择对应的node版本号；</li><li>yarn使用<code>npm i -g yarn</code></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;院系项目开发记录&quot;&gt;&lt;a href=&quot;#院系项目开发记录&quot; class=&quot;headerlink&quot; title=&quot;院系项目开发记录&quot;&gt;&lt;/a&gt;院系项目开发记录&lt;/h1&gt;&lt;p&gt;参与院系项目开发，对开发过程中的一些配置进行记录；&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="备忘录" scheme="http://Tyler-ytr.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="杂谈" scheme="http://Tyler-ytr.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>RDMA技术整理3</title>
    <link href="http://Tyler-ytr.github.io/2022/04/18/RDMA-learning3/"/>
    <id>http://Tyler-ytr.github.io/2022/04/18/RDMA-learning3/</id>
    <published>2022-04-18T06:30:04.000Z</published>
    <updated>2022-04-23T12:51:26.767Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="RDMA技术整理3-RDMA基本功能"><a href="#RDMA技术整理3-RDMA基本功能" class="headerlink" title="RDMA技术整理3 RDMA基本功能"></a>RDMA技术整理3 RDMA基本功能</h1><h2 id="RDMA基本元素"><a href="#RDMA基本元素" class="headerlink" title="RDMA基本元素"></a>RDMA基本元素</h2><p>参考于知乎<a href="https://zhuanlan.zhihu.com/p/141267386" target="_blank" rel="noopener">专栏</a></p><p>| 缩略语 | 全称                     | 含义                                                         |<br>| —— | ———————— | ———————————————————— |<br>| WQ     | Work Queue               | 储存工作请求的队列                                           |<br>| WQE    | Work Queue Element       | 工作队列里面的元素                                           |<br>| QP     | Queue Pair               | 一对WQ，包括了SQ,RQ；<strong>通信的基本单元</strong>                      |<br>| SQ     | Send Queue               | QP中的发送端队列                                             |<br>| RQ     | Receive Queue            | QP中的接受端队列                                             |<br>| SRQ    | Shared Receive Queue     | 共享接收队列，几个QP共享同一个RQ时，我们称其为SRQ            |<br>| CQ     | Completion Queue         | 完成队列，承载CQE的容器，一个先进先出的队列                  |<br>| CQE    | Completion Queue Element | 如果WQE是软件下发给硬件的“任务书”的话，那么CQE就是硬件完成任务之后返回给软件的“任务报告”。 |<br>| WR     | Work Request             | 工作请求，WQE和CQE在用户层的“映射”                           |<br>| WC     | Work Completion          | 工作完成，WQE和CQE在用户层的“映射”                           |</p><p><img src="/picture/image-20220419210626804.png" alt="RDMA基本元素"></p><h2 id="RMDA基本操作"><a href="#RMDA基本操作" class="headerlink" title="RMDA基本操作"></a>RMDA基本操作</h2><p>RDMA有two-sided和one-sided的区别，一般情况下涉及大量数据的收发更多使用的是one-sided操作，另外在resource-disaggregation的场景中也一般使用one-sided的操作，因为memory节点在设计中往往不会给强力的CPU；</p><h4 id="RDMA双端操作-SEND-amp-RECV"><a href="#RDMA双端操作-SEND-amp-RECV" class="headerlink" title="RDMA双端操作 SEND &amp; RECV"></a>RDMA双端操作 SEND &amp; RECV</h4><p>双端操作的含义是：完成一次通信过程需要两端CPU的参与，并且接收端需要提前显式下发WQE( Work Queue Element)；</p><p><img src="/picture/image-20220423160249262.png" alt="SEND-RECV操作"></p><p>在SEND-RECV操作中，不仅仅发送端需要下发WQE，接收端也需要下发WQE，目的是告诉硬件收到的数据要放到哪一个地址，发送端并不知道发送的数据会放到哪里，因此每一次发送数据的时候接收端需要提前准备好接受Buffer；具体如上图（另外执行顺序并不完全和上面的顺序一致，比如步骤<code>8</code> <code>11</code> <code>12</code>和步骤<code>9</code> <code>10</code>的先后是不一定的）</p><p>这部分在下一篇博客中有具体的实现。</p><h4 id="RDMA-one-sided-操作-WRITE-amp-READ"><a href="#RDMA-one-sided-操作-WRITE-amp-READ" class="headerlink" title="RDMA one-sided 操作 WRITE &amp; READ"></a>RDMA one-sided 操作 WRITE &amp; READ</h4><p>one-sided的含义在于，除了准备阶段，服务端的CPU都不需要参与，也不需要感知数据写入和结束接受的过程，因此称为是one-sided的。</p><p>在进行WRITE和READ操作之前，首先会经历准备阶段，也就是请求端需要获得响应端某块内存的权限，具体而言：对于RDMA，响应者的buffer被描述成为一个<em>虚拟地址(VA,Virtual Address)</em>和一个<em>R-KEY</em>;在WRITE或者READ操作开始之前，响应方会把这个buffer的控制权传递给请求方，请求方会控制缓冲区，知道控制权传回到响应程序；这个准备过程通常可以用SEND/RECV来完成。完成了之后响应端的CPU就不会再参与数据收发的过程，解放了远端CPU，降低了通信时延。另外<em>虚拟地址</em>–物理地址的转换是通过RDMA网卡来完成的。</p><p>接下来是WRITE操作的流程：</p><p><img src="/picture/image-20220423200538298.png" alt="WRITE操作"></p><ol><li>请求端APP以WQE（WR）的形式下发一次WRITE任务。</li><li>请求端硬件从SQ中取出WQE，解析信息。</li><li>请求端网卡根据WQE中的虚拟地址，转换得到物理地址，然后从内存中拿到待发送数据，组装数据包。</li><li>请求端网卡将数据包通过物理链路发送给响应端网卡。</li><li>响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，将数据放置到指定内存区域。</li><li>响应端回复ACK报文给请求端。</li><li>请求端网卡收到ACK后，生成CQE，放置到CQ中。</li><li>请求端APP取得任务完成信息。</li></ol><p>READ是WRITE相反的过程，是请求端主动读取响应端内存的行为，要注意到”读“这个动作的数据是附带在响应端回复的报文里面的，具体流程如下：</p><p><img src="/picture/image-20220423201323814.png" alt="READ操作"></p><ol><li>请求端APP以WQE的形式下发一次READ任务。</li><li>请求端网卡从SQ中取出WQE，解析信息。</li><li>请求端网卡将READ请求包通过物理链路发送给响应端网卡。</li><li>响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，从指定内存区域取出数据。</li><li>响应端硬件将数据组装成回复数据包发送到物理链路。</li><li>请求端硬件收到数据包，解析提取出数据后放到READ WQE指定的内存区域中。</li><li>请求端网卡生成CQE，放置到CQ中。</li><li>请求端APP取得任务完成信息。</li></ol><hr><p>通过RDMA的READ,WRITE操作，其实可以发现这个和本地内存拷贝非常像，只不过一个是用RDMA网卡一个使用CPU来做罢了。</p></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf" target="_blank" rel="noopener">RDMA用户编程手册</a></li><li>IB Specification Vol 1-Release-1.5-2021-08-06b.pdf</li><li><a href="https://www.zhihu.com/column/c_1231181516811390976" target="_blank" rel="noopener">RDMA杂谈</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h1 id=&quot;RDMA技术整理3-RDMA基本功能&quot;&gt;&lt;a href=&quot;#RDMA技术整理3-RDMA基本功能&quot; class=&quot;headerlink&quot; title=&quot;RDMA技术整理3 RDMA基本功能&quot;&gt;&lt;/a&gt;RDMA技术整理3 RDMA基本功能&lt;/h1&gt;
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="RDMA" scheme="http://Tyler-ytr.github.io/tags/RDMA/"/>
    
  </entry>
  
  <entry>
    <title>RDMA技术整理2</title>
    <link href="http://Tyler-ytr.github.io/2022/04/16/RDMA-learning2/"/>
    <id>http://Tyler-ytr.github.io/2022/04/16/RDMA-learning2/</id>
    <published>2022-04-16T09:24:19.000Z</published>
    <updated>2022-04-18T09:26:54.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RDMA技术整理2-RDMA概述"><a href="#RDMA技术整理2-RDMA概述" class="headerlink" title="RDMA技术整理2 RDMA概述"></a>RDMA技术整理2 RDMA概述</h1><h2 id="RDMA背景"><a href="#RDMA背景" class="headerlink" title="RDMA背景"></a>RDMA背景</h2><h3 id="TCP-IP通信"><a href="#TCP-IP通信" class="headerlink" title="TCP/IP通信"></a>TCP/IP通信</h3><p>使用传统的TCP/IP通信，数据需要通过用户空间发送到远端的用户空间，就需要经历若干次内存拷贝。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416195905028.png" alt="TCP/IPvsRDMA" title="">                </div>                <div class="image-caption">TCP/IPvsRDMA</div>            </figure><ul><li>数据发送方需要讲数据从用户空间 Buffer 复制到内核空间的 Socket Buffer</li><li>数据发送方要在内核空间中添加数据包头，进行数据封装</li><li>数据从内核空间的 Socket Buffer 复制到 NIC Buffer 进行网络传输</li><li>数据接受方接收到从远程机器发送的数据包后，要将数据包从 NIC Buffer 中复制到内核空间的 Socket Buffer</li><li>经过一系列的多层网络协议进行数据包的解析工作，解析后的数据从内核空间的 Socket Buffer 被复制到用户空间 Buffer</li><li>这个时候再进行系统上下文切换，用户应用程序才被调用</li></ul><p>这就带来了高速网络环境下面，TCP/IP在主机侧数据移动和复制操作的高开销，影响了带宽。</p><p>针对这个问题提出了多种解决方案，主要介绍如下两种：</p><ul><li>TCP offloading engine</li><li>RDMA</li></ul><h3 id="TCP-offloading-engine"><a href="#TCP-offloading-engine" class="headerlink" title="TCP offloading engine"></a>TCP offloading engine</h3><p>这个技术主要就是把CPU进行的多层网络协议数据包处理工作，比如数据复制、协议处理和中断处理等等操作转移到支持offloading的网卡上。如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416200207230.png" alt="TCP offloading engine" title="">                </div>                <div class="image-caption">TCP offloading engine</div>            </figure><ul><li>TOE(TCP offloading engine)技术将原来在协议栈中进行的IP分片、TCP分段、重组、checksum校验等操作，转移到网卡硬件中进行</li><li>普通网卡处理每个数据包都要触发一次中断，TOE 网卡则让每个应用程序<strong>完成一次完整的数据处理进程</strong>后才触发一次中断，显著减轻服务器对中断的响应负担。</li><li>TOE 网卡在接收数据时，在网卡内进行协议处理，因此，它不必将数据复制到内核空间缓冲区，而是直接复制到用户空间的缓冲区，这种“零拷贝”方式避免了网卡和服务器间的不必要的数据往复拷贝。</li></ul><h3 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h3><p>RDMA的目的是更快更轻量级的网络通信，利用了Kernel Bypass和Zero Copy技术的低延迟特性，减少了CPU占用和内存带宽瓶颈。对外RDMA提供了基于IO的通道，允许一个应用程序通过RDMA设备对远程的虚拟内存进行直接的读写。它的整体架构图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416202541620.png" alt="RDMA整体架构" title="">                </div>                <div class="image-caption">RDMA整体架构</div>            </figure><p>RDMA技术有以下特点：</p><ul><li><strong>CPU Offload</strong>：无需CPU干预，应用程序可以访问远程主机内存而<strong>不消耗远程主机中的任何CPU</strong>。远程主机内存能够<strong>被读取</strong>而不需要远程主机上的进程（或CPU)参与。远程主机的CPU的缓存(cache)不会被访问的内存内容所填充</li><li><strong>Kernel Bypass</strong>：RDMA 提供一个专有的 Verbs interface 而不是传统的TCP/IP Socket interface。应用程序可以<strong>直接在用户态执行数据传输</strong>，不需要在内核态与用户态之间做上下文切换</li><li><strong>Zero Copy</strong>：每个应用程序都能直接访问集群中的设备的虚拟内存，这意味着应用程序能够直接执行数据传输，在不涉及到网络软件栈的情况下，数据能够被<strong>直接发送到缓冲区</strong>或者能够直接从缓冲区里接收，而<strong>不需要被复制到网络层</strong>。</li></ul><h2 id="RDMA架构"><a href="#RDMA架构" class="headerlink" title="RDMA架构"></a>RDMA架构</h2><p>目前主要有三种硬件实现，可以使用同一套API：</p><ol><li><strong>Infiniband：</strong>基于 InfiniBand 架构的 RDMA 技术，由 IBTA（InfiniBand Trade Association）提出。搭建基于 IB 技术的 RDMA 网络需要专用的 IB 网卡和 IB 交换机。从性能上，很明显Infiniband网络最好，但网卡和交换机是价格也很高，然而RoCEv2和iWARP仅需使用特殊的网卡就可以了，价格也相对便宜很多。</li><li><strong>iWARP：</strong>Internet Wide Area RDMA Protocal，基于 TCP/IP 协议的 RDMA 技术，由 IETF 标 准定义。iWARP 支持在标准以太网基础设施上使用 RDMA 技术，而不需要交换机支持无损以太网传输，但服务器需要使用支持iWARP 的网卡。与此同时，受 TCP 影响，性能稍差。</li><li><strong>RoCE：</strong>基于以太网的 RDMA 技术，也是由 IBTA 提出。RoCE支持在标准以太网基础设施上使用RDMA技术，但是需要交换机支持无损以太网传输，需要服务器使用 RoCE 网卡，性能与 IB 相当。</li></ol><p>下面以Infiniband技术为例介绍它的分层架构：</p><p>这部分来自于前面的<a href="https://houmin.cc/posts/454a90d3/" target="_blank" rel="noopener">博客</a>以及<a href="https://www.mellanox.com/pdf/whitepapers/IB_Intro_WP_190.pdf" target="_blank" rel="noopener">Introduction to InfiniBand</a></p><h3 id="Infiniband分层与架构"><a href="#Infiniband分层与架构" class="headerlink" title="Infiniband分层与架构"></a>Infiniband分层与架构</h3><p>Inifiniband包含了多种设备，channel adapter、switch、router、subnet manager，它提供了一种基于通道的点对点消息队列转发模型，每个应用都可通过创建的虚拟通道直接获取本应用的数据消息，无需其他操作系统及协议栈的介入。Channel adapter是安装在主机或者其他任何系统(如存储设备)上的网络适配器，这种组件为数据包的始发地或者目的地；Switch包含了多个InfiniBand端口根据每个数据包 LRH 里面的 LID，负责将一个端口上收到的数据包发送到另一个端口。Router根据 L3 中的 GRH，负责将 Packet 从一个子网转发到另一个子网，当被转到到另一子网时，Router 会重建数据包中的 LID。Subnet Manager负责配置本地子网，使其保持工作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418135934106.png" alt="image-20220418135934106" title="">                </div>                <div class="image-caption">image-20220418135934106</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418140051181.png" alt="image-20220418140051181" title="">                </div>                <div class="image-caption">image-20220418140051181</div>            </figure><hr><p>InfiniBand 有着自己的协议栈，从上到下依次包括传输层、网络层、数据链路层和物理层：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418140528211.png" alt="image-20220418140528211" title="">                </div>                <div class="image-caption">image-20220418140528211</div>            </figure><p>如上图是数据包的封装。</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>物理层支持光线和铜，绝大多数采用4 Link；</p><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>这部分是架构的核心，包含了如下部分：</p><ul><li>Packets：链路层由两种类型的Packets，Data Packet 和 Management Packet，数据包最大可以为 4KB，数据包传输的类型包括两种类型<ul><li>Memory：RDMA read/write，atomic operation（其实就是内存操作）</li><li>Channel：send/receive，multicast transmission</li></ul></li><li>Switching：在子网中，Packet 的转发和交换是在链路层完成的<ul><li>一个子网内的每个设备有一个由 subnet manager分配的 16 bit Local ID (<strong>LID</strong>)</li><li>每个 Packet 中有一个 Local Route Header (LRH) 指定了要发送的目标 LID</li><li>在一个子网中通过 LID 来负责寻址</li></ul></li><li>Qos：链路层提供了 QoS 保证，不需要数据缓冲<ul><li>Virtual Lanes：一种在一条物理链路上创建多条虚拟链路的机制。虚拟通道表示端口的一组用于收发数据包的缓冲区。支持的 VL 数是端口的一个属性。</li><li>每个 Link 支持 15 个标准的 VL 和一个用于 Management 的 VL15，VL15 具有最高等级，VL0 具有最低等级</li><li>Service Level：InfiniBand 支持多达 16 个服务等级，但是并没有指定每个等级的策略。InfiniBand 通过将 SL 和 VL 映射支持 QoS</li></ul></li><li>Credit Based Flow Control：发送数据包之前，发送方和接收方需要协商数据量credit，接收方保证有足够的Buffer，之后传输才能进行。</li><li>Data Integrity：链路层通过 Packet 中的 CRC 字段来进行数据完整性校验，其组成包括 ICRC 和 VCRC。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418141433546.png" alt="image-20220418141433546" title="">                </div>                <div class="image-caption">image-20220418141433546</div>            </figure><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层负责将 Packet 从一个子网路由到另一个子网：</p><p>在子网之间发送的数据包包含全局路由标头 （GRH）。GRH 包含数据包源和目标的 128 位 IPv6 地址。数据包通过基于每个设备的 64 位全局唯一 ID （GUID） 的路由器在子网之间转发。路由器在每个子网中使用正确的本地地址修改 LRH。因此，路径中的最后一个路由器将 LRH 中的 LID 替换为目标端口的 LID。</p><p>下面是 GRH 报头的格式，长40字节，可选，用于组播数据包以及需要穿越多个子网的数据包。它使用 GID 描述了源端口和目标端口，其格式与 IPv6 报头相同。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418142238178.png" alt="image-20220418142238178" title="">                </div>                <div class="image-caption">image-20220418142238178</div>            </figure><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层负责 Packet 的按序传输、根据 MTU 分段和很多传输层的服务(reliable connection, reliable datagram, unreliable connection, unreliable datagram, raw datagram)。InfiniBand 的传输层提供了一个巨大的提升，因为所有的函数都是在硬件中实现的。</p><h2 id="RDMA技术相对于传统技术"><a href="#RDMA技术相对于传统技术" class="headerlink" title="RDMA技术相对于传统技术"></a>RDMA技术相对于传统技术</h2><p>在<a href="https://tyler-ytr.github.io/2022/04/16/RDMA-learning/">技术整理1</a>中介绍了DMA的知识；RDMA与DMA相似，它的含义是远程直接地址访问；通过RDMA，本端节点可以“直接”访问远端节点的内存。所谓直接，指的是可以像访问本地内存一样，绕过传统以太网复杂的TCP/IP网络协议栈读写远端内存，而这个过程对端是不感知的，而且这个读写过程的大部分工作是由硬件而不是软件完成的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418154052322.png" alt="传统以太网socket通信" title="">                </div>                <div class="image-caption">传统以太网socket通信</div>            </figure><p>在传统的以太网socket通信中，一次收发过程如下：</p><ol><li>发送端和接收端通过Socket库提供的接口建立链接（就是在两个节点间建立了一条逻辑上的道路，数据可以沿这条道路从一端发送到另一端）并分别在内存中申请好发送和接收Buffer。</li><li>发送端APP通过Socket接口陷入内核态，待发送数据经过TCP/IP协议栈的一层层封装，最后被<strong>CPU复制到Socket Buffer</strong>中。</li><li>发送端通过网卡驱动，告知网卡可以发送数据了，网卡将通过DMA从Buffer中复制封装好的数据包到内部缓存中，然后将其发送到物理链路。</li><li>接收端网卡收到数据包后，将数据包放到接收Buffer中，然后CPU将通过内核中的TCP/IP协议栈对报文进行层层解析，取出有效的数据。</li><li>接收端APP通过Socket接口陷入内核态，CPU将数据从内核空间复制到用户空间。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418154402936.png" alt="socket数据流向" title="">                </div>                <div class="image-caption">socket数据流向</div>            </figure><p>因此数据相当于如上图流向，需要从用户空间复制到内核空间（CPU）然后网卡从内核空间把处理好的数据从物理链路发送到对端网卡；对端网卡过程相似。</p><hr><p><img src="/picture/image-20220418154130159.png" alt="RDMA通信"></p><p>RDMA把模型分成了两部分，一部分是控制通路一部分是数据通路，控制通路需要进入内核态准备通信所需的内存资源，而数据通路指的是实际数据交互过程中的流程。具体的通信过程如下：</p><ol><li>发送端和接收端分别通过控制通路陷入内核态创建好通信所需要的内存资源。</li><li>在数据通路上，接收端APP通知硬件准备接收数据，告诉硬件将接收到的数据放在哪片内存中。</li><li>在数据通路上，发送端APP通知硬件发送数据，告诉硬件待发送数据位于哪片内存中。</li><li>发送端RDMA网卡从内存中搬移数据，组装报文发送给对端。</li><li>对端收到报文，对其进行解析并通过DMA将有效载荷写入内存。然后以某种方式通知上层APP，告知其数据已经接受并且存放到指定位置</li></ol><p>具体的数据流向如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220418154657351.png" alt="RDMA数据流向" title="">                </div>                <div class="image-caption">RDMA数据流向</div>            </figure><p>可以看出这部分减少了CPU的参与，报文的组装和解析<strong>通过硬件而不是CPU</strong>完成。这就是RDMA技术的优势所在。</p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul><li><a href="https://houmin.cc/posts/454a90d3/" target="_blank" rel="noopener">https://houmin.cc/posts/454a90d3/</a></li><li><a href="https://www.cnblogs.com/bandaoyu/p/15478210.html" target="_blank" rel="noopener">https://www.cnblogs.com/bandaoyu/p/15478210.html</a></li><li><a href="https://www.zhihu.com/column/c_1231181516811390976" target="_blank" rel="noopener">RDMA杂谈</a></li><li><a href="https://zhuanlan.zhihu.com/p/139548242" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/139548242</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RDMA技术整理2-RDMA概述&quot;&gt;&lt;a href=&quot;#RDMA技术整理2-RDMA概述&quot; class=&quot;headerlink&quot; title=&quot;RDMA技术整理2 RDMA概述&quot;&gt;&lt;/a&gt;RDMA技术整理2 RDMA概述&lt;/h1&gt;&lt;h2 id=&quot;RDMA背景&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="RDMA" scheme="http://Tyler-ytr.github.io/tags/RDMA/"/>
    
  </entry>
  
  <entry>
    <title>RDMA技术整理1</title>
    <link href="http://Tyler-ytr.github.io/2022/04/16/RDMA-learning/"/>
    <id>http://Tyler-ytr.github.io/2022/04/16/RDMA-learning/</id>
    <published>2022-04-16T07:35:20.000Z</published>
    <updated>2022-04-16T09:54:17.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RDMA技术整理1-DMA技术概述"><a href="#RDMA技术整理1-DMA技术概述" class="headerlink" title="RDMA技术整理1 DMA技术概述"></a>RDMA技术整理1 DMA技术概述</h1><p>RDMA全称是Remote Direct Memory Access，基本理念可以看成是远程的DMA技术，目的是为了解决网络传输中数据处理的延迟。因此首先了解一下DMA技术</p><h2 id="DMA技术与零拷贝"><a href="#DMA技术与零拷贝" class="headerlink" title="DMA技术与零拷贝"></a>DMA技术与零拷贝</h2><p>参考于该<a href="https://alanwin.top/2021/04/25/DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/" target="_blank" rel="noopener">博客</a></p><p>该技术用于I/O过程。众所周知，磁盘速度相对于内存以及CPU cache非常慢，因此有很多用于优化磁盘的技术比如零拷贝，异步I/O等等。DMA也是其中的技术之一。</p><h3 id="DMA背景"><a href="#DMA背景" class="headerlink" title="DMA背景"></a>DMA背景</h3><p>DMA技术之前，I/O过程如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416154343317.png" alt="传统IO" title="">                </div>                <div class="image-caption">传统IO</div>            </figure><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p>这种策略需要CPU亲自参与数据的搬运，在传输大量数据的时候用CPU搬运显然是开销过大的；因此开发了新设备DMA控制器负责数据的搬运。具体过程如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416160547943.png" alt="有DMA的IO" title="">                </div>                <div class="image-caption">有DMA的IO</div>            </figure><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时<strong>不占用 CPU</strong>，CPU 可以执行其他任务；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看出在数据传输的过程中，CPU不再参与数据搬运的工作，这部分由DMA做完了，CPU要做的是进行DMA的调用。DMA一开始是存在于主板，现在一般处于各个I/O设备中。</p><hr><h2 id="文件传输过程"><a href="#文件传输过程" class="headerlink" title="文件传输过程"></a>文件传输过程</h2><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。传统的方法需要两个系统调用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416163740770.png" alt="传统传输文件" title="">                </div>                <div class="image-caption">传统传输文件</div>            </figure><p>如上图<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，每一次调用都意味着：用户态保留现场，转换到内核态处理，转换到用户态这样的过程，每一次切换都需要耗时几十纳秒到几微秒，高并发情况下会影响系统性能。</p><p>另外发生了四次拷贝：</p><ol><li>磁盘通过DMA拷贝到内核缓冲区</li><li>内核缓冲区数据拷贝到用户缓冲区</li><li>用户缓冲区拷贝到内核缓冲区</li><li>内核缓冲区通过DMA拷贝到网卡缓冲区</li></ol><p>数据拷贝也会消耗CPU资源降低系统性能。</p><p>总共发生了<strong>四次上下文切换和四次数据拷贝</strong>。</p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>为了优化文件传输的性能，主要从两个方面下手：减少用户态和内核态上下文的切换（也就是减少系统调用），减少<strong>数据拷贝</strong>的次数；</p><p>为了实现<strong>零拷贝</strong>，目前主要由两种方式：</p><ul><li>mmap+write</li><li>sendfile</li></ul><h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap+write"></a>mmap+write</h4><p>使用read()会把内核缓冲区的数据拷贝到用户缓冲区中，使用mmap()会直接把内核缓冲区<strong>映射</strong>到用户空间，减少了内核和用户空间之间的数据拷贝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416164931279.png" alt="mmap+write" title="">                </div>                <div class="image-caption">mmap+write</div>            </figure><p>如上图：调用了mmap()之后，DMA就会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；然后使用write()会让系统直接把内核缓冲区的数据拷贝到socket缓冲区中，最后DMA把socket缓冲区的数据拷贝到网卡缓冲区中。</p><p>因此mmap()代替read()可以减少一次数据拷贝。最后需要<strong>四次上下文切换，三次数据拷贝</strong>。</p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>在linux 2.1内核中出现了sendfile()系统调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>它可以代替read(),write()系统调用，减少了一次系统调用（相当于减少了两次上下文切换）；另外它可以直接把内核缓冲区的数据拷贝到socket缓冲区中不需要拷贝到用户态，最后只有<strong>两次上下文切换和三次数据拷贝</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416165731481.png" alt="sendfile1" title="">                </div>                <div class="image-caption">sendfile1</div>            </figure><hr><p>如果网卡支持SG-DMA(<em>The Scatter-Gather Direct Memory Access</em>)，那么可以进一步减少通过CPU把内核缓冲区拷贝到socket缓冲区的过程；</p><p>linux系统可以通过如下命令查看是否支持:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ethtool -k eth0 | grep scatter-gather</span></span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure><p>如果支持该功能，并且linux内核&gt;=2.4，那么sendfile()的过程会发生如下变化：</p><ol><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220416171231492.png" alt="sendfile2" title="">                </div>                <div class="image-caption">sendfile2</div>            </figure><p>这就是零拷贝，因为没有通过CPU来进行数据搬运的过程；</p><p>最后总共使用了两次上下文切换和两次数据拷贝，并且都不需要走CPU，都是DMA进行的拷贝；可以把传输文件的性能提高至少一倍以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RDMA技术整理1-DMA技术概述&quot;&gt;&lt;a href=&quot;#RDMA技术整理1-DMA技术概述&quot; class=&quot;headerlink&quot; title=&quot;RDMA技术整理1 DMA技术概述&quot;&gt;&lt;/a&gt;RDMA技术整理1 DMA技术概述&lt;/h1&gt;&lt;p&gt;RDMA全称是Rem
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="RDMA" scheme="http://Tyler-ytr.github.io/tags/RDMA/"/>
    
  </entry>
  
  <entry>
    <title>算法框架</title>
    <link href="http://Tyler-ytr.github.io/2022/02/15/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://Tyler-ytr.github.io/2022/02/15/算法框架/</id>
    <published>2022-02-15T02:50:07.000Z</published>
    <updated>2022-04-16T09:25:41.535Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://labuladong.gitee.io/" target="_blank" rel="noopener">https://labuladong.gitee.io/</a> 进行模板的整理</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220215105403320.png" alt="image-20220215105403320" title="">                </div>                <div class="image-caption">image-20220215105403320</div>            </figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220222115911238.png" alt="image-20220222115911238" title="">                </div>                <div class="image-caption">image-20220222115911238</div>            </figure><ol><li><p>对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。</p></li><li><p>对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</p></li><li><p><strong>BST 的中序遍历结果是有序的（升序）</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    <span class="built_in">print</span>(root.val);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行BST验证的时候不能仅仅只考虑左右以及根节点，因为root的整个左子树都要小于root.val，右子树同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode <span class="built_in">min</span>, TreeNode <span class="built_in">max</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span> != null &amp;&amp; root.val &lt;= <span class="built_in">min</span>.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> != null &amp;&amp; root.val &gt;= <span class="built_in">max</span>.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, <span class="built_in">min</span>, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, <span class="built_in">max</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BST搜索元素记得左小右大就行了，插入元素同理（找到root==nullptr的时候插入一个新的节点）。</p></li></ol><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>DFS 遍历框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">if</span> (root == null) </span><br><span class="line">&#123;         </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;     </span><br><span class="line"> <span class="comment">// 前序位置     </span></span><br><span class="line"> traverse(root.left);     </span><br><span class="line"> <span class="comment">// 中序位置     </span></span><br><span class="line"> traverse(root.right);     </span><br><span class="line"> <span class="comment">// 后序位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输入一棵二叉树的根节点，层序遍历这棵二叉树</span><br><span class="line">void levelTraverse(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return;</span><br><span class="line">    Queue&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从上到下遍历二叉树的每一层</span><br><span class="line">    while (!q.isEmpty()) &#123;</span><br><span class="line">        int sz &#x3D; q.size();</span><br><span class="line">        &#x2F;&#x2F; 从左到右遍历每一层的每个节点</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode cur &#x3D; q.poll();</span><br><span class="line">            &#x2F;&#x2F; 将下一层节点放入队列</span><br><span class="line">            if (cur.left !&#x3D; null) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur.right !&#x3D; null) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离</span><br><span class="line">int BFS(Node start, Node target) &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构</span><br><span class="line">    Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路</span><br><span class="line">    </span><br><span class="line">    q.offer(start); &#x2F;&#x2F; 将起点加入队列</span><br><span class="line">    visited.add(start);</span><br><span class="line">    int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数</span><br><span class="line"></span><br><span class="line">    while (q not empty) &#123;</span><br><span class="line">        int sz &#x3D; q.size();</span><br><span class="line">        &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur &#x3D; q.poll();</span><br><span class="line">            &#x2F;* 划重点：这里判断是否到达终点 *&#x2F;</span><br><span class="line">            if (cur is target)</span><br><span class="line">                return step;</span><br><span class="line">            &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F;</span><br><span class="line">            for (Node x : cur.adj()) &#123;</span><br><span class="line">                if (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* 划重点：更新步数在这里 *&#x2F;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>归并排序</p><p>归并排序的逻辑，若要对 <code>nums[lo..hi]</code> 进行排序，我们先对 <code>nums[lo..mid]</code> 排序，再对 <code>nums[mid+1..hi]</code> 排序，最后把这两个有序的子数组合并，整个数组就排好序了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 后序遍历位置 ******/</span></span><br><span class="line">    <span class="comment">// 合并两个排好序的子数组</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序</p><p>快速排序的逻辑是，若要对 <code>nums[lo..hi]</code> 进行排序，我们先找一个分界点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>，然后递归地去 <code>nums[lo..p-1]</code> 和 <code>nums[p+1..hi]</code> 中寻找新的分界点，最后整个数组就被排序了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严蔚敏《数据结构》标准分割函数</span></span><br><span class="line"> Paritition1(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">   <span class="keyword">int</span> pivot = A[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     A[low] = A[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">int</span> pivot = Paritition1(A, low, high);</span><br><span class="line">     QuickSort(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">     QuickSort(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考&lt;a href=&quot;https://labuladong.gitee.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://labuladong.gitee.io/&lt;/a&gt; 进行模板的整理&lt;/p&gt;
&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="算法模板" scheme="http://Tyler-ytr.github.io/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>spark学习笔记</title>
    <link href="http://Tyler-ytr.github.io/2022/01/12/spark-learning/"/>
    <id>http://Tyler-ytr.github.io/2022/01/12/spark-learning/</id>
    <published>2022-01-12T05:00:30.000Z</published>
    <updated>2022-10-09T05:51:40.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spark学习笔记"><a href="#spark学习笔记" class="headerlink" title="spark学习笔记"></a>spark学习笔记</h2><h2 id="idea-maven加速"><a href="#idea-maven加速" class="headerlink" title="idea maven加速"></a>idea maven加速</h2><ol><li><p>右键项目中的pom.xml等，在Maven中选择修改setting.xml，如果没有这个配置文件会有create setting.xml的选项，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>uk<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://uk.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>OSChina Central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>internal nexus repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加如上的mirrors</p></li></ol><h2 id="Spark-依赖"><a href="#Spark-依赖" class="headerlink" title="Spark 依赖"></a>Spark 依赖</h2><p>这部分需要在项目的pom.xml中进行配置，主要是增加了dependencies那部分内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testclasses<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意的是，可以通过右击pom.xml然后maven然后reload project来完成这部分依赖的下载</p><h2 id="HADOOP-环境依赖"><a href="#HADOOP-环境依赖" class="headerlink" title="HADOOP 环境依赖"></a>HADOOP 环境依赖</h2><p>如果没有HADOOP环境依赖就会报一个恶心的错误 Could not locate executablenull\bin\winutils.exe in the Hadoop binaries以及这个诱发的奇奇怪怪的错误。可能可以采用<a href="https://github.com/steveloughran/winutils；实操使用的是尚硅谷给的配置文件，已经上传到了百度网盘。" target="_blank" rel="noopener">https://github.com/steveloughran/winutils；实操使用的是尚硅谷给的配置文件，已经上传到了百度网盘。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1z23GQYaPmzq7VDS_f2646A </span><br><span class="line">提取码：piza</span><br></pre></td></tr></table></figure><p>然后配置一下环境变量，HADOOP_HOME 给 hadoop-3.1.0；然后Path环境变量加一个%HADOOP_HOME%\bin，重启IDEA就行了</p><h2 id="wordcount"><a href="#wordcount" class="headerlink" title="wordcount"></a>wordcount</h2><p>这部分参考了尚硅谷的教程，文件结构如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20220113170935084.png" alt="image-20220113170935084" title="">                </div>                <div class="image-caption">image-20220113170935084</div>            </figure><p>代码如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">spark01_wordcount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Application</span></span><br><span class="line">    <span class="comment">//Spark框架</span></span><br><span class="line">    <span class="comment">//TODO 建立和Spark框架的连接</span></span><br><span class="line">    <span class="comment">//JDBC：Connection</span></span><br><span class="line">    <span class="comment">// 创建 Spark 运行配置对象</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="comment">// 创建 Spark 上下文环境对象（连接对象）</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 执行业务操作</span></span><br><span class="line">    <span class="comment">//1.读取文件，获取一行一行的数据</span></span><br><span class="line">    <span class="comment">//Hello World</span></span><br><span class="line">    <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"datas"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.将一行数据进行拆分，形成一个个的单词（分词=&gt;扁平化：将整体拆分成个体的操作）</span></span><br><span class="line">    <span class="comment">//"Hello World" =&gt; Hello,World...</span></span><br><span class="line">    <span class="comment">//val words: RDD[String] = lines.flatMap(s =&gt; s.split(" "))</span></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将数据根据单词进行分组，便于统计</span></span><br><span class="line">    <span class="comment">//(hello,hello...),(world,world,world...)</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = words.groupBy(word =&gt; word)</span><br><span class="line">    <span class="comment">//4.将分组后的数据进行转换</span></span><br><span class="line">    <span class="comment">//(hello,hello...),(world,world,world...)</span></span><br><span class="line">    <span class="comment">//(hello,2),(world,3)</span></span><br><span class="line">    <span class="keyword">val</span> res: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordGroup.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt; &#123;</span><br><span class="line">        (word, list.size)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.将转换的结果采集到控制台打印出来</span></span><br><span class="line">    <span class="keyword">val</span> array: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = res.collect()</span><br><span class="line">    array.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO　关闭 Spark 连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scala快速入门"><a href="#scala快速入门" class="headerlink" title="scala快速入门"></a>scala快速入门</h2><p>因为spark由scala编写而成，因此快速入门一下scala,学习了这个专栏<a href="https://zhuanlan.zhihu.com/p/32859134" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32859134</a></p><p>scala是一种函数式语言，其函数也能当成值来使用。Scala提供了轻量级的语法用以定义匿名函数，支持高阶函数，允许嵌套多层函数，并支持柯里化。Scala的case class及其内置的模式匹配相当于函数式编程语言中常用的代数类型。可以利用Scala的模式匹配，编写类似正则表达式的代码处理数据。</p><p>从并发角度而言：Scala使用Actor作为其并发模型，Actor是类似线程的实体，通过“邮箱”发收消息。Actor可以复用线程，因此可以在程序中可以使用数百万个Actor，而线程只能创建数千个。在2.10之后的版本中，使用Akka作为其默认Actor实现。</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul><li>变量</li><li>函数</li><li>数组</li><li>映射和元组转换</li><li>类与对象</li><li>继承与特质</li><li>集合</li><li>模式匹配和样例</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li><p>不强制指定变量的类型可以编译器推断出来</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">8</span>*<span class="number">5</span></span><br><span class="line">res0:<span class="type">Int</span>=<span class="number">40</span></span><br></pre></td></tr></table></figure></li><li><p>val值不能改变它的内容，鼓励使用val</p></li><li><p>可变的变量用var</p></li><li><p>变量或者函数的类型写在变量或者函数的后面，有点像go</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test:<span class="type">String</span>=<span class="string">"test"</span></span><br></pre></td></tr></table></figure></li><li><p>不需要使用分号最后，仅当同一行代码中存在多条语句时才需要分号隔开。</p></li><li><p>常用的数据类型与Java一样，Byte、Char、Short、Int、Long、Float、Double及Boolean，这些都是类。</p></li><li><p>+-*/%等操作符实际上是方法。</p></li><li><p>对于BigInt和BigDecimal对象，可以以常规的方式使用数学操作符（但在Java中同样的操作要写成x.multiply(x)）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="keyword">val</span> x:<span class="type">BigInt</span>=<span class="number">11111111222222222333333333333</span></span><br><span class="line">scala&gt;x*x</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li>表达式有值，语句执行动作。</li><li>函数式中不使用return。</li><li>语句中，分号不是必需的。</li><li>代码块也有值，最后一个表达式就是值。if表示式有值。</li><li>Scala中，几乎所有构造出来的语法结构都有值，不像Java中把表达式和语句（if语句）分为两类。</li></ol><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><ol><li><p>在Scala中if/else<strong>表达式</strong>有值，这个值就是在if或else之后的表达式的值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala &gt; <span class="keyword">var</span> x = <span class="number">10</span> </span><br><span class="line">x : <span class="type">Int</span> = <span class="number">10</span> </span><br><span class="line">scala &gt; <span class="keyword">val</span> r = <span class="keyword">if</span> ( x &gt; <span class="number">0</span> ) <span class="number">1</span> <span class="keyword">else</span> - <span class="number">1</span> </span><br><span class="line">r : <span class="type">Int</span> = <span class="number">1</span> </span><br><span class="line">scala &gt; <span class="keyword">var</span> x = <span class="number">0</span> </span><br><span class="line">x : <span class="type">Int</span> = <span class="number">0</span> </span><br><span class="line">scala &gt; <span class="keyword">val</span> r = <span class="keyword">if</span> ( x &gt; <span class="number">0</span> ) <span class="number">1</span> <span class="keyword">else</span> - <span class="number">1</span> </span><br><span class="line">r : <span class="type">Int</span> = - <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>可能if没有输出值，但在Scala中，每个表达式都有某种值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala &gt; <span class="keyword">var</span> x = <span class="number">0</span> </span><br><span class="line">x : <span class="type">Int</span> = <span class="number">0</span> </span><br><span class="line">scala &gt; <span class="keyword">val</span> r = <span class="keyword">if</span> ( x &gt; <span class="number">0</span> ) <span class="number">1</span> </span><br><span class="line">r : <span class="type">AnyVal</span> = ()## 因为x=<span class="number">0</span>，所以此时未定义</span><br></pre></td></tr></table></figure></li></ol><h4 id="块表达式"><a href="#块表达式" class="headerlink" title="块表达式"></a>块表达式</h4><ol><li>在Scala中{}块包含一系列表达式，其结果也是一个表达式。块中最后一个表达式的值就是块的值。</li><li>对于某个val的初始化需要分多步完成的情况很实用。</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dis = &#123; <span class="keyword">val</span> dx = x - x0 ; <span class="keyword">val</span> dy = y - y0 ; sqrt ( dx * dx + dy * dy )&#125;</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ol><li>while 循环和java一样</li><li>for循环：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to n ) &#123; </span><br><span class="line">r = r * i </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 to n：[1,n]</li><li>1 until n:[1,n)</li></ul><h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><ol><li><p>可以多个生成器，用分号隔开</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala &gt; <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">3</span> ; j &lt;- <span class="number">1</span> to <span class="number">3</span> ) print (( <span class="number">10</span> * i + j ) + <span class="string">" "</span> )</span><br></pre></td></tr></table></figure></li><li><p>每个生成器都可以带一个守卫，以if开头的Boolean表达式 (if前并没有分号)</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala &gt; <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">3</span> ; j &lt;- <span class="number">1</span> to <span class="number">3</span> <span class="keyword">if</span> i != j ) print (( <span class="number">10</span> * i + j ) + <span class="string">" "</span> )</span><br></pre></td></tr></table></figure></li><li><p>for推导式：for循环的循环以yield开始，则该循环会构造出一个集合，每次迭代生成集合中的一个值。和python yield一样</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span>(i &lt; <span class="number">-1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i%<span class="number">3</span></span><br><span class="line">res2:scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>]=<span class="type">Vector</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><ol><li><p>需要给出函数名、参数和函数体</p></li><li><p>必须给出所有参数的类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x:<span class="type">Double</span>)= <span class="keyword">if</span> (x&gt;=<span class="number">0</span>)x <span class="keyword">else</span> -x</span><br></pre></td></tr></table></figure></li><li><p>递归函数必须指定返回值类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac</span></span>(n:<span class="type">Int</span>):<span class="type">Int</span> = <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="number">1</span> <span class="keyword">else</span> n* fac(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></li><li><p>不需要return</p></li><li><p>用=连接函数体</p></li><li><p>默认参数以及带名参数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="function"><span class="keyword">def</span> <span class="title">decorate</span></span>(str:<span class="type">String</span>,left:<span class="type">String</span>=<span class="string">"["</span>,right:<span class="type">String</span>=<span class="string">"]"</span>)=left+str+right</span><br><span class="line">scala&gt;decorate(<span class="string">"test"</span>)</span><br><span class="line">scala&gt;decorate(<span class="string">"test"</span>,<span class="string">"&#123;"</span>,<span class="string">"&#125;"</span>)</span><br></pre></td></tr></table></figure></li><li><p>也可以指定参数，此时顺序可以不一样</p></li><li><p>可以混用未命名以及指定参数，未命名的排在前面，和C++一样</p></li><li><p>可以实现接受可变长列表的参数，用*</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(arg:<span class="type">Int</span>*)=&#123;</span><br><span class="line"><span class="keyword">var</span> result=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(arg &lt;- args)result+=arg</span><br><span class="line">result</span><br><span class="line">&#125;</span><br><span class="line">scala&gt;<span class="keyword">val</span> s = sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">s: <span class="type">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>可以用_*把一个整数区间转换成参数序列：</p><p>对于上面的sum，应该输入一个列表，因此输入sum(1 to 5)是错的，需要输入sum(1 to 5: _*)</p></li><li><p>如果函数体包含在花括号当中，但没有前面的 <code>=</code>号，返回类型是Unit，这样的函数被称做过程。过程不返回值，调用它仅仅是为了它的副作用。</p></li><li><p>当val被声明为lazy时，它的初始化将被推迟，直到首次对它取值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> words = scala . io . <span class="type">Source</span> . fromFile ( <span class="string">"/usr/share/dict/words"</span> ). mkString</span><br><span class="line">##可以故意把文件名写错，试一下在初始化语句被执行的时候会不会报错（只有访问words时才提示文件未找到）</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>长度固定使用Array，长度有变化使用ArrayBuffer</li><li>提供初始值时不要使用new</li><li>用()来访问元素</li><li>for(elem &lt;- arr)遍历元素</li><li>for(elem &lt;- arr if …) yield …将原数组转为新数组</li></ol><h4 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h4><ol><li><p>整数初始化为0，string用new初始化为null，提供初始值不需要new，用()访问（相当于C++[]）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> nums = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> str1 = <span class="type">Array</span>(<span class="string">"Hello"</span>, <span class="string">"Scala"</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> s = str1(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h4><ol><li><p>使用ArrayBuffer，需要import scala.collection.mutable.ArrayBuffer</p></li><li><p>初始化:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> b = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br></pre></td></tr></table></figure></li><li><p>+=追加元素或者多个用括号包起来的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b+=<span class="number">1</span></span><br><span class="line">scala&gt; b+=(<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>++=追加任何集合</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b++=<span class="type">Array</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure></li><li><p>用b.trimEnd(2)移除最后两个元素</p></li><li><p>可以在任何地方插入或者移除(不高效，需要移动后面的所有元素)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.insert(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ## 在下标<span class="number">2</span>的地方插入<span class="number">3</span>,<span class="number">4</span>，比如(<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>)变成了(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用toArray变成定长，toBuffer变成变长</p></li></ol><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until b.length)</span><br><span class="line">println(i + <span class="string">":"</span> + b(i))</span><br><span class="line">##或者不用下标</span><br><span class="line">scala&gt;  <span class="keyword">for</span>(elem &lt;- b)</span><br><span class="line">println(elem)</span><br></pre></td></tr></table></figure><h4 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h4><ol><li><p>for推导式，从一个数组转换，生成一个全新的数组</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> res = <span class="keyword">for</span>(elem &lt;- a) <span class="keyword">yield</span> <span class="number">2</span> * elem</span><br></pre></td></tr></table></figure></li><li><p>ArrayBuffer同理</p></li></ol><h3 id="映射和元组转换"><a href="#映射和元组转换" class="headerlink" title="映射和元组转换"></a>映射和元组转换</h3><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><ol><li><p>这是键值对的集合，相当于字典</p></li><li><p>例子:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">## 不可变映射，值不能够被改变</span><br><span class="line">scala&gt; <span class="keyword">val</span> scores = <span class="type">Map</span>(<span class="string">"Alice"</span> -&gt; <span class="number">90</span>, <span class="string">"Bob"</span> -&gt; <span class="number">88</span>)</span><br><span class="line">## 可变映射</span><br><span class="line">scala&gt; <span class="keyword">val</span> scores1 = scala.collection.mutable.<span class="type">Map</span>(<span class="string">"Alice"</span> -&gt; <span class="number">90</span>, <span class="string">"Bob"</span> -&gt; <span class="number">88</span>)</span><br><span class="line">## 构造一个空映射，需要选定一个映射实现并给出类型参数(注意最后是 方括号[] )</span><br><span class="line">scala&gt; <span class="keyword">val</span> scores2 = <span class="keyword">new</span> scala.collection.mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>]</span><br><span class="line">## 使用()获取键值</span><br><span class="line">scala&gt; <span class="keyword">val</span> aliceScore = scores(<span class="string">"Alice"</span>)</span><br><span class="line">## 判断映射中是否包括某个指定键的值，用contains方法</span><br><span class="line">scala&gt; <span class="keyword">val</span> bobScore = <span class="keyword">if</span>(scores.contains(<span class="string">"Bob"</span>)) scores(<span class="string">"Bob"</span>) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">## 等价于:</span><br><span class="line">scala&gt; <span class="keyword">val</span> bobScore1 = scores.getOrElse(<span class="string">"Bob"</span>, <span class="number">0</span>)</span><br><span class="line">## 可变映射中更新某个映射中的值或添加一个新的映射关系</span><br><span class="line">scala&gt; <span class="keyword">val</span> scores1 = scala.collection.mutable.<span class="type">Map</span>(<span class="string">"Alice"</span> -&gt; <span class="number">90</span>, <span class="string">"Bob"</span> -&gt; <span class="number">88</span>)</span><br><span class="line">scores1(<span class="string">"Bob"</span>) = <span class="number">99</span></span><br><span class="line">scores1(<span class="string">"Fred"</span>) = <span class="number">79</span> ##<span class="type">Fred</span>不存在，会添加一个新的关系</span><br><span class="line">## 使用+=操作来添加多个关系(key不存在就添加，存在就更新)</span><br><span class="line">scores1 += (<span class="string">"Yezhiwei"</span> -&gt; <span class="number">100</span>, <span class="string">"Fred"</span> -&gt; <span class="number">90</span>)</span><br><span class="line">## 使用-=操作来移除某个键值对</span><br><span class="line">scores1 -= <span class="string">"Bob"</span></span><br><span class="line">## 不可变映射同样的操作不会改变原来的值，但是会返回一个新的对象</span><br><span class="line">## 可以使用scores.keys或者scores.values来访问键或者值</span><br></pre></td></tr></table></figure></li></ol><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ol><li><p>元组是不同类型的值的聚集，用圆括号包裹</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (1, 3.14, &quot;Fred&quot;)</span><br></pre></td></tr></table></figure></li><li><p>元组的组元从1开始，比如可以:</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">"Fred"</span>)</span><br><span class="line">res11: (<span class="type">Int</span>, <span class="type">Double</span>, <span class="type">String</span>) = (<span class="number">1</span>,<span class="number">3.14</span>,<span class="type">Fred</span>)</span><br><span class="line">scala&gt; res11._1</span><br><span class="line">res12: <span class="type">Int</span> = <span class="number">1</span>s</span><br></pre></td></tr></table></figure></li><li><p>可以使用模式匹配来获取组元</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val (first, second, third) &#x3D; res11</span><br><span class="line">## 不需要的值用_</span><br><span class="line">scala&gt; val (first, second, _) &#x3D; res11</span><br></pre></td></tr></table></figure></li><li><p>元组可以用于函数需要返回不止一个值的情况</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="string">"Hello Scala"</span>.partition(_.isUpper)</span><br><span class="line">res13: (<span class="type">String</span>, <span class="type">String</span>) = (<span class="type">HS</span>,ello cala)</span><br></pre></td></tr></table></figure></li></ol><h3 id="类定义与构造器"><a href="#类定义与构造器" class="headerlink" title="类定义与构造器"></a>类定义与构造器</h3><ol><li>每一个类有一个主构造器，它执行类中所有的语句</li><li>类中自带getter以及setter方法(<a href="https://juejin.cn/post/6844903958222225415" target="_blank" rel="noopener">jvm getter/setter方法</a>)</li><li>用@BeanProperty注解生成JavaBean的getXxx/setXxx方法</li><li>辅助构造器是可选的，它们都叫做this</li></ol><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    | <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    | <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span>() &#123;value += <span class="number">1</span>&#125;</span><br><span class="line">    | <span class="function"><span class="keyword">def</span> <span class="title">current</span></span>() = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Scala生成面向JVM的类时，其中有一个私有的age字段及相应的两个公有的getter和setter方法；</p><p>对于私有字段，getter和setter方法也是私有的；</p><p>在Scala中，getter和setter分别叫做age和age_= (注意下划线和等号间没有空格)</p></blockquote><ol><li>重新定义getter和setter方法，如：年龄不能设置成比现在的更小</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    | <span class="keyword">private</span> <span class="keyword">var</span> privateAge = <span class="number">0</span></span><br><span class="line">    | <span class="function"><span class="keyword">def</span> <span class="title">age</span> </span>= privateAge</span><br><span class="line">    | <span class="function"><span class="keyword">def</span> <span class="title">age_=</span> </span>(newValue: <span class="type">Int</span>) &#123;</span><br><span class="line">    | <span class="keyword">if</span> (newValue &gt; privateAge) privateAge = newValue</span><br><span class="line">    | &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如何控制Scala对每个字段生成getter和setter的方法？</li></ol><blockquote><p>如果字段是私有的，则getter和setter方法也是私有的</p><p>如果字段是val， 则只生成getter方法</p><p>如果不需要任何getter和setter，将字段声明为private[this]即可</p></blockquote><ol start="3"><li>用@BeanProperty注解生成JavaBean的getXxx/setXxx方法</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.reflect.<span class="type">BeanProperty</span></span><br><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    | <span class="meta">@BeanProperty</span> <span class="keyword">var</span> name: <span class="type">String</span> = _</span><br></pre></td></tr></table></figure><blockquote><p>将会生成四个方法：</p><ol><li>name: String</li><li>name_=(new Value: String): Unit</li><li>getName(): String</li><li>setName(newValue: String): Unit</li></ol></blockquote><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><ol><li><p>主构造器例子:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scalaclass </span></span><br><span class="line"><span class="type">Person</span>(<span class="keyword">val</span> name: <span class="type">String</span>, <span class="keyword">val</span> age: <span class="type">Int</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 以上代码相当于Java的以下代码public </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    </span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> name;    </span><br><span class="line"><span class="keyword">private</span> int age;    </span><br><span class="line">public <span class="type">Person</span>(<span class="type">String</span> name, int age) &#123;        </span><br><span class="line"><span class="keyword">this</span>.name = name;        </span><br><span class="line"><span class="keyword">this</span>.age = age;    &#125;    </span><br><span class="line"><span class="comment">// getter and setter    </span></span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了主构造器之外可以定义任意多的辅助构造器，辅助构造器的名称为this，每一个辅助构造器都需要以一个对先前定义的其他辅助构造器或者主构造器的调用开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">private var name &#x3D; &quot;&quot;</span><br><span class="line">private var age &#x3D; 0</span><br><span class="line">def this(name: String) &#123;</span><br><span class="line">&#x2F;&#x2F; 调用主构造器</span><br><span class="line">this()</span><br><span class="line">this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def this(name:String,age: Int)&#123;</span><br><span class="line">&#x2F;&#x2F; 调用前一个辅助构造器</span><br><span class="line">this(name)</span><br><span class="line">this.age&#x3D;age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>参考<a href="https://mp.weixin.qq.com/s?__biz=MzA5Njk3Njc5Mw==&amp;mid=2247483867&amp;idx=1&amp;sn=3ca65bd2a2363d77ee4259b314308ddb&amp;chksm=90a6ab2da7d1223b571750066eaff1087c900d4262b9963baf6f23cb9d242a43575354b2f6c9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">单例对象</a></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>参考<a href="https://mp.weixin.qq.com/s?__biz=MzA5Njk3Njc5Mw==&amp;mid=2247483870&amp;idx=1&amp;sn=578b11b803aff5d6b1d3eb81432ede7a&amp;chksm=90a6ab28a7d1223ef98ff6ae969d0fa4a7653be5f9c55ef24e13875f6f31af49736f46bec1e9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">继承</a></p><h3 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h3><p>参考<a href="https://mp.weixin.qq.com/s?__biz=MzA5Njk3Njc5Mw==&amp;mid=2247483873&amp;idx=1&amp;sn=eab766315c5f6878a112f043ab39ba05&amp;chksm=90a6ab17a7d1220191005ffa841857d7933e04946a024c3d264adbe65f78f82303dfa43855f1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">特质</a></p><p>我感觉是一种聚合的形式</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>同时可以参考这个<a href="https://cloud.tencent.com/developer/article/1793532" target="_blank" rel="noopener">博客</a></p><ol><li><p>匿名函数,并且可以放到变量中,或者直接传递给另一个函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala &gt; <span class="keyword">val</span> test=(x:<span class="type">Double</span>) =&gt; <span class="number">3</span> * x</span><br><span class="line">scala &gt; <span class="type">Array</span>(<span class="number">3.14</span>,<span class="number">1.42</span>).map((x:<span class="type">Double</span>)=&gt;<span class="number">3</span>*x)</span><br></pre></td></tr></table></figure><p>在变量中存储非你梦函数需要_，这个表示这个函数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala &gt;   <span class="function"><span class="keyword">def</span>  <span class="title">fun</span> </span>( msg :   <span class="type">String</span> )   &#123; println ( msg )&#125;</span><br><span class="line">scala &gt;  <span class="keyword">val</span> f  =  fun _</span><br></pre></td></tr></table></figure></li><li><p>带函数参数的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala &gt;   <span class="function"><span class="keyword">def</span>  <span class="title">mulBy</span> </span>( factor :   <span class="type">Double</span> )   =   ( x :   <span class="type">Double</span> )   =&gt;  factor  *  x</span><br><span class="line">mulBy :   ( factor :   <span class="type">Double</span> ) <span class="type">Double</span>   =&gt;   <span class="type">Double</span>   </span><br><span class="line"></span><br><span class="line">scala &gt;  <span class="keyword">val</span> q  =  mulBy ( <span class="number">5</span> )  </span><br><span class="line">q :   <span class="type">Double</span>   =&gt;   <span class="type">Double</span>   =   &lt;function1&gt;   </span><br><span class="line"></span><br><span class="line">scala &gt;  q ( <span class="number">20</span> )  res14 :   <span class="type">Double</span>   =   <span class="number">100.0</span>   </span><br><span class="line"><span class="comment">// val q = mulBy(5) 相当于 val q = (x: Double) =&gt; 5 * x</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数可以作为参数，进行传递（大多数情况都是通过匿名函数的形式）</span></span><br><span class="line"><span class="comment">//定义一个函数calculator，该函数接收一个函数类型的参数op，op定义了对两个整数要进行什么样的操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculator</span></span>(a:<span class="type">Int</span>,b:<span class="type">Int</span>,op:(<span class="type">Int</span>,<span class="type">Int</span>)=&gt;<span class="type">Int</span>): <span class="type">Int</span> =&#123;</span><br><span class="line">  op(a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数f1,完成两个整数的加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a:<span class="type">Int</span>,b:<span class="type">Int</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//println(calculator(10,20,op))</span></span><br><span class="line">println(calculator(<span class="number">50</span>, <span class="number">20</span>, (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">  a - b</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">println(calculator(<span class="number">50</span>, <span class="number">20</span>, _ - _))</span><br><span class="line">println(calculator(<span class="number">50</span>, <span class="number">20</span>, _ + _))</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>函数可以作为返回值进行返回:</p><ol><li>函数的嵌套</li><li>函数链式调用，通过参数传递数据，在执行的过程中，函数始终占据栈内存，容易导致内存溢出</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数可以作为返回值进行返回----函数的嵌套</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>():()=&gt;<span class="type">Unit</span> =&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">        println(<span class="string">"f2函数被调用了"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将f2作为返回值返回给f1</span></span><br><span class="line">      f2 _</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ff就是f2</span></span><br><span class="line">    <span class="comment">//var ff = f1()</span></span><br><span class="line">    <span class="comment">//ff()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//f1()()</span></span><br></pre></td></tr></table></figure></li><li><p>闭包</p><ol><li>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</li><li>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</li><li>内层函数访问外层函数的局部变量，会自动延长外层函数局部变量的生命周期，与内层函数形成一个闭合的效果，我们称之为闭包</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    def f1(): (Int)=&gt;Int =&#123;</span></span><br><span class="line"><span class="comment">      var a:Int = 10</span></span><br><span class="line"><span class="comment">      def f2(b:Int): Int =&#123;</span></span><br><span class="line"><span class="comment">        a + b</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      f2 _</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行f1函数返回f2,将返回的f2赋值给ff变量</span></span><br><span class="line">    <span class="comment">//val ff: Int =&gt; Int = f1()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//闭包：内存函数f2要访问外层函数f1局部变量a，当外层函数f1执行结束之后，f1会释放栈内存，但是会自动的延长f1函数的局部变量的生命周期，</span></span><br><span class="line">    <span class="comment">//    和内层函数f2形成一个闭合的效果，我们将这种闭合的效果称之为闭包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果存在闭包，那么编译器会生成包含$anonfun$的字节码文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//闭包  = 外层函数的局部变量  + 内层函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用ff函数，其实就是调用f2</span></span><br><span class="line">    <span class="comment">//println(ff(20))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以直接通过如下方式调用</span></span><br><span class="line">    <span class="comment">//println(f1()(30))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println(<span class="string">"-----------------------------------"</span>)</span><br><span class="line">    <span class="comment">//以上代码可以转换为如下代码</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    def f3() =&#123;</span></span><br><span class="line"><span class="comment">      var a:Int = 10</span></span><br><span class="line"><span class="comment">      (b:Int) =&gt; a + b</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    f3()(30)</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure></li><li><p>柯里化</p><ol><li>将一个参数列表中的多个参数，拆分为多个参数列表</li><li>好处1：每一个参数列表表示函数清晰明确</li><li>好处2：简化闭包代码的编写</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柯里化</span></span><br><span class="line">    <span class="comment">//将一个函数的一个参数列表中的多个参数，拆分为多个参数列表</span></span><br><span class="line">    <span class="comment">//简化闭包代码的编写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f4</span></span>()(b:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">      <span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">      a + b</span><br><span class="line">    &#125;</span><br><span class="line">    println(f4()(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//f4在执行的时候，其实会转换为以下结构</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    def f4() =&#123;</span></span><br><span class="line"><span class="comment">      var a:Int = 10</span></span><br><span class="line"><span class="comment">      (b:Int) =&gt; a + b</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>PS: <a href="https://developer.51cto.com/article/661533.html" target="_blank" rel="noopener">Python 闭包中自由变量与全局变量的区别</a>;<a href="https://www.cnblogs.com/yssjun/p/9887239.html" target="_blank" rel="noopener">python闭包</a></p><h3 id="模式匹配和样例类"><a href="#模式匹配和样例类" class="headerlink" title="模式匹配和样例类"></a>模式匹配和样例类</h3><ol><li><p>mathch表达式是一个更好的switch，不会有穿透到下一个分支的问题</p><ol><li><p>与if类似，match也是表达式，而不是语句</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      println(matchTest(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Int</span>): <span class="type">String</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">"many"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scalac Test.scala </span><br><span class="line">$ scala Test</span><br><span class="line">many</span><br></pre></td></tr></table></figure></li><li><p>scala模式匹配不会自动进入下一个分支，不需要再每一个分支后面使用break</p></li><li><p>case _等价于default</p></li><li><p>match可以使用任意类型，不一定需要数字</p></li><li><p>还可以给模式添加守卫，比如匹配所有的数字:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      println(matchTest(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Int</span>): <span class="type">String</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">      <span class="keyword">case</span> _ <span class="keyword">if</span> <span class="type">Character</span>.isDigit(x)=&gt;<span class="type">Character</span>.digit(x,<span class="number">10</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">"many"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以对类型匹配，比如case x:Int=&gt;x这样</p></li><li><p>另外还有一些技巧见<a href="https://mp.weixin.qq.com/s?__biz=MzA5Njk3Njc5Mw==&amp;mid=2247483879&amp;idx=1&amp;sn=d010cf4cdb1844de02ce332e0bf828d8&amp;chksm=90a6ab11a7d12207eb7558674ee1f296545b3ed75ded918fb03adeb933d08f4f9a420638d8b5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">原文</a></p></li></ol></li><li><p>样例类，常用于模式匹配:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> alice = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>)</span><br><span class="line">        <span class="keyword">val</span> bob = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">val</span> charlie = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Charlie"</span>, <span class="number">32</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (person &lt;- <span class="type">List</span>(alice, bob, charlie)) &#123;</span><br><span class="line">        person <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>) =&gt; println(<span class="string">"Hi Alice!"</span>)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">32</span>) =&gt; println(<span class="string">"Hi Bob!"</span>)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Person</span>(name, age) =&gt;</span><br><span class="line">               println(<span class="string">"Age: "</span> + age + <span class="string">" year, name: "</span> + name + <span class="string">"?"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 样例类</span></span><br><span class="line">   <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ scalac <span class="type">Test</span>.scala </span><br><span class="line">$ scala <span class="type">Test</span></span><br><span class="line"><span class="type">Hi</span> <span class="type">Alice</span>!</span><br><span class="line"><span class="type">Hi</span> <span class="type">Bob</span>!</span><br><span class="line"><span class="type">Age</span>: <span class="number">32</span> year, name: <span class="type">Charlie</span>?</span><br></pre></td></tr></table></figure><p>PS:在声明样例类时，下面的过程自动发生了：</p><ul><li>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</li><li>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</li><li>提供unapply方法使模式匹配可以工作；</li><li>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spark学习笔记&quot;&gt;&lt;a href=&quot;#spark学习笔记&quot; class=&quot;headerlink&quot; title=&quot;spark学习笔记&quot;&gt;&lt;/a&gt;spark学习笔记&lt;/h2&gt;&lt;h2 id=&quot;idea-maven加速&quot;&gt;&lt;a href=&quot;#idea-maven加速&quot;
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式系统" scheme="http://Tyler-ytr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="spark" scheme="http://Tyler-ytr.github.io/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存1</title>
    <link href="http://Tyler-ytr.github.io/2022/01/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%981/"/>
    <id>http://Tyler-ytr.github.io/2022/01/07/分布式缓存1/</id>
    <published>2022-01-07T06:18:05.000Z</published>
    <updated>2022-01-07T06:22:48.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式缓存1：CPU与分布式系统"><a href="#分布式缓存1：CPU与分布式系统" class="headerlink" title="分布式缓存1：CPU与分布式系统"></a>分布式缓存1：CPU与分布式系统</h1><p>这部分主要参考博客<a href="https://xie.infoq.cn/article/fa1f0f9ac1cfee7845f7b29fe" target="_blank" rel="noopener">https://xie.infoq.cn/article/fa1f0f9ac1cfee7845f7b29fe</a> 中的内容</p><p>单个存储器读吞吐没有办法满足要求的情况下，往往会在存储器上面增加一个或者多个缓存，但是因为相同的数据被复制到同一个或者多个地方，就会产生数据一致性的问题。不一致的数据可能出现在<strong>同级 Cache 之间 (Cache Coherence)</strong> 和<strong>上下级 Cache 之间</strong>。解决这些数据一致性问题的方案可以统称为 Cache Policies。从本质上看，所有 Cache Policies 的设计目的都可以概括为：<strong>在增加一级缓存之后，系统看起来和没加缓存的行为一致，但得益于局部性原理，系统的读吞吐量提高、时延减少</strong>。</p><p>考虑的缓存的位置，以下主要从：</p><ul><li>单核处理器</li><li>多核处理器</li><li>Cache/DB架构</li></ul><p>三个部分进行讨论。</p><h2 id="单核处理器中的Cache-policy"><a href="#单核处理器中的Cache-policy" class="headerlink" title="单核处理器中的Cache policy"></a>单核处理器中的Cache policy</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式缓存1：CPU与分布式系统&quot;&gt;&lt;a href=&quot;#分布式缓存1：CPU与分布式系统&quot; class=&quot;headerlink&quot; title=&quot;分布式缓存1：CPU与分布式系统&quot;&gt;&lt;/a&gt;分布式缓存1：CPU与分布式系统&lt;/h1&gt;&lt;p&gt;这部分主要参考博客&lt;a hr
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式系统" scheme="http://Tyler-ytr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统</title>
    <link href="http://Tyler-ytr.github.io/2021/12/26/distributed-system/"/>
    <id>http://Tyler-ytr.github.io/2021/12/26/distributed-system/</id>
    <published>2021-12-26T03:35:38.000Z</published>
    <updated>2021-12-29T04:36:42.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式系统的特征以及系统模型"><a href="#分布式系统的特征以及系统模型" class="headerlink" title="分布式系统的特征以及系统模型"></a>分布式系统的特征以及系统模型</h2><p><strong>什么是分布式系统</strong></p><p>分布式系统是若干独立计算机的集合，在用户看来是一个单一相关系统。</p><p>例如:分配给用户的工作站网络、机房中动态分配的处理器池、单个文件系统等。</p><p>分布式系统涉及到网络、处理器、内存、存储、协议等。</p><p><strong>分布式系统的目标</strong></p><ul><li>使资源可访问</li><li>透明性</li><li>开放性</li><li>可扩展性</li></ul><p><strong>为什么要分布式</strong></p><ul><li>经济：相比于大型机，微型处理器的性价比更高</li><li>速度：分布式系统比大型机计算能力更强</li><li>内在分布：一些应用需要在不同空间的机器上运行</li><li>可靠性：当某一台机器挂掉时，分布式系统仍能运行</li><li>可增加：通过增加分布式系统的组件使其计算能力增强</li></ul><p><strong>使资源可访问</strong></p><p>分布式系统的最主要目标是使用户能够方便地访问远程资源，并且以一种受控方式与其他用户共享这些资源。</p><p><strong>透明性</strong></p><p>对用户和应用程序员屏蔽分布式系统组件和分散性，系统被认为是一个整体，而不是独立的组件集合。透明性对用户和应用程序员隐藏了与手头任务无直接关系的资源，并匿名使用，使得分布的某些特性对应用程序员具有不可见性，这样应用程序员只要关心特定应用的设计问题。</p><p><strong>开放性</strong></p><p>能与其他开放的系统进行交互，不考虑底层环境，要求系统：</p><ol><li>良好说明的接口</li><li>支持程序的可移植性</li><li>系统容易交互</li></ol><p><strong>可拓展性</strong></p><p>三个方面：</p><ol><li><strong>规模</strong>上可扩展（用户和处理器数目）</li><li><strong>地域</strong>上可扩展（节点最大距离）</li><li><strong>管理</strong>上可扩展（管理域数）</li></ol><p><strong>分布式系统的类型</strong></p><ul><li>分布式计算系统：<ul><li>集群计算：本质是通过高速局域网连接的一组高端系统，每个节点运行相同的操作系统，硬件几乎相同，只有一个管理节点，同构性</li><li>网格计算：异构性，硬件、操作系统、网络、管理域都不尽相同，可以跨广域网</li></ul></li><li>分布式信息系统：<ul><li>事务处理系统：有ACID四种特性，主要应用于数据库，邮件系统，财务系统等<ul><li>原子性：对于外部来说，事务处理不可见</li><li>一致性：事务处理不会违反系统的不变性</li><li>独立性：并发的事务不会相互干扰</li><li>持久性：事务处理一旦提交，所发生改变是永久性的</li></ul></li></ul></li><li>分布式普适系统：新兴的下一代分布式系统，其中节点小，移动，并且经常嵌入在更大的系统中，其特<br>征在于系统自然地混合到用户环境中；</li></ul><p><strong>如何理解机制与策略</strong></p><p>在开放的分布式系统中要获得灵活性，就要把系统组织成规模相对较小且容易修改和替换的组件，需要将策略和机制分离。</p><p><strong>分布式操作系统、网络操作系统和基于中间件的系统</strong></p><ul><li>分布式操作系统：配置在分布式系统上的操作系统，能够直接对分布式系统中的各种资源进行动态分<br>配，并能有效地控制和协调分布式系统中各任务的并行执行，同时还向用户提供了一个方便的、透明的<br>使用整个分布式系统的界面。</li><li>网络操作系统：是在网络环境下实现对网络资源的管理和控制的操作系统，是用户与网络资源之间的接<br>口。网络操作系统是建立在独立的操作系统之上，为网络用户提供使用网络系统资源的桥梁。在多个用<br>户争用系统资源时，网络操作系统进行资源调剂管理，它依靠各个独立的计算机操作系统对所属资源进<br>行管理，协调和管理网络用户进程或程序与联机操作系统进行交互。</li><li>基于中间件的系统：在网络操作系统之上增加一个中间层，屏蔽各底层平台之间的异构性，从而增加分<br>布式系统的透明性</li></ul><hr><h2 id="分布式系统架构"><a href="#分布式系统架构" class="headerlink" title="分布式系统架构"></a>分布式系统架构</h2><p><strong>分布式系统架构的风格</strong></p><ol><li><p>组织成逻辑上不同的组件，并且将这些组件分布在不同的机器上</p><ol><li>分层体系结构（client-server架构）</li><li>Object-based style for distributed object systems 对于分布式对象系统使用基于对象的风格</li></ol><p><img src="/picture/image-20211226175558158.png" alt="image-20211226175558158"></p></li><li><p>在空间（匿名）时间（异步）的解耦过程中产生了替代的样式（Decoupling processes in space (“anonymous”) and also time (“asynchronous”) has led to alternative styles）</p><ol><li><p>以数据为中心的体系结构</p><p>思想：进程通信需要一个公用仓库（共享的分布式文件系统）</p></li><li><p>基于事件的体系结构</p><p><img src="/picture/image-20211226180719684.png" alt="image-20211226180719684"></p></li></ol><p>a图是空间解耦，进程通过事件的传播来通信，事件传播可以有选择地携带数据，分布式系统的事件传播通常与发布/订阅系统有关；</p><p>b图是时间空间都解耦，将基于事件的体系结构与以数据为中心的体系结构组合形成共享数据空间</p></li></ol><p><strong>分布式系统组织形式</strong></p><ol><li><p>集中式</p><ol><li><p>客户端服务器模式：</p><ul><li><p>提供服务器的进程</p></li><li><p>提供客户端的进程</p></li><li><p>客户端和服务器可以在不同的机器上运行</p></li><li><p>客户端遵守<strong>请求/回复行为</strong>来使用服务</p><p><img src="/picture/image-20211226211552973.png" alt="客户端服务器之间的交互"></p></li></ul></li><li><p>为了在客户和服务器之间划分界限，使用了应用分层：</p><ol><li><p>用户接口层：含有与用户交互所需的一切如显示管理</p></li><li><p>处理层：应用程序</p></li><li><p>数据层：使用的实际数据</p><p><img src="/picture/image-20211226211748596.png" alt="搜索引擎的抽象"></p></li></ol></li><li><p>多层体系结构</p><ol><li>单层：哑终端/主机</li><li>双层：客户端/单服务器</li><li>三层：每一层都在不同的机器上运行</li></ol><p><img src="/picture/image-20211226211922476.png" alt="各种客户服务器的组织架构"></p><p>其中a-c式瘦客户，后面的是胖客户</p></li></ol></li><li><p>非集中式</p><ol><li><p>结构化的点对点系统：</p><p>比如chord，CAN等等，特点在于节点以特定的分布式数据结构进行组织。在一个结构化的覆盖网络(如逻辑环或超立方体)中组织节点，并使特定节点仅根据其ID负责某些服务。</p><p><img src="/picture/image-20211226212647705.png" alt="image-20211226212647705"></p><p><img src="/picture/image-20211226212655369.png" alt="image-20211226212655369"></p></li><li><p>非结构化的点对点系统 </p><p>构建类似于随机图的覆盖网络，基本模型是每一个节点都维护一个含有c个邻节点的列表。随机选择一个邻居v，如果v有答案，它会回答，否则v随机选择它的一个邻居。（维护一个超级节点）</p></li></ol></li><li><p>混合式</p><p>它将客户服务器体系结构和非集中式体系结构组合在了一起</p><ol><li><p>边界服务器系统：用于内容分发网络，在进行过滤和编码转换后提供内容服务，还可用于优化内容和应用程序的分布性。</p><p><img src="/picture/image-20211226214358553.png" alt="把英特网堪称一系列边界服务器"></p></li><li><p>协作分布式系统：比如BitTorrent文件共享，点对点文件下载：</p><p><img src="/picture/image-20211226214447039.png" alt="BitTorrent工作原理"></p><p>一旦一个节点确定了从哪里下载文件，它就加入了一群下载者的行列，这些下载者并行地从源文件获取文件块，但也在彼此之间分发这些文件块。</p></li></ol></li></ol><p><strong>分布式系统组织为中间件</strong></p><p>中间件在<strong>应用程序</strong>和<strong>分布式平台</strong>之间形成了一个层，可以提供<strong>分布式透明性</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211226214734990.png" alt="image-20211226214734990" title="">                </div>                <div class="image-caption">image-20211226214734990</div>            </figure><p>方式之一为中断器：作为一种软件结构，能中断正常的控制流，从而允许其他代码运行。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程线程的定义</strong></p><p>进程是特定上下文里一个执行的流，可以包含多个线程，有自己独立的内存管理单元，切换时也需要一<br>个进程所拥有的全部内容。<br>线程是一段执行流，是轻量级的进程，只需要简单切换堆栈和寄存器内的值即可，共享内存单元。</p><p><strong>LWP</strong></p><p>轻量级进程，这个采用了用户级线程和内核级线程的混合形式,</p><p>其中对于用户级线程：</p><ul><li>所有的线程都在用户的进程地址空间中创建。</li><li>优点：所有的操作都能在单个进程中完成，导致实现起来很高效。</li><li>缺点：难以从操作系统和block中得到支持。内核提供的所有服务都是代表线程所在的进程执行的，如果内核决定阻塞一个线程，那么整个进程将被阻塞。</li></ul><p>内核级线程：</p><ul><li>可以解决上述问题</li><li>但是由于每一个线程操作（创建删除同步化）都需要内核来进行执行，需要系统调用，导致内核级线程的开销可能和进程差不多大</li></ul><p>LWP：</p><ul><li><p>运行在单个重量级进程的上下文中，每一个进程都可以包含多个LWP。另外系统还提供用户级线程包，包括了用于线程同步的工具，这部分内容完全在用户空间实现。并且可以被多个LWP共用。</p><p><img src="/picture/image-20211227140800732.png" alt="image-20211227140800732"></p></li><li><p>优点在于：线程创建，销毁，同步化工作开销小不需要内核干预，并且如果进程中有足够数量的LWP，阻塞的系统调用将不需要整个进程被挂起，另外应用程序不需要知道LWP存在，事实上只能见到用户级线程，并且通过在不同CPU执行不同的LWP，可以在多处理器系统中方便的使用</p></li><li><p>缺点在于：必须进行LWP的创建和销毁工作，开销不必内核级线程小，但是只需要偶尔进行，并且受到操作系统的完全控制</p></li></ul><hr><p><strong>代码迁移</strong></p><ul><li><p>代码迁移的方法：</p><ul><li>代码段(Code Segment)：包含实际的代码</li><li>数据段(Data Segment)：包含状态</li><li>执行状态(Execution State)：包含线程执行对象代码的上下文</li></ul></li><li><p>强弱迁移</p><ul><li><p>弱迁移：只迁移代码部分和数据部分，最后被目标进程或另外一个独立进程执行</p></li><li><p>强迁移：迁移执行部分，要么复制进程，要么克隆(所有数据完全复制，和原来的进程并行)</p><p><img src="/picture/image-20211227151251247.png" alt="image-20211227151251247"></p></li></ul></li></ul><hr><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p><strong>通信的类型</strong></p><ul><li>瞬时通信(Transient Commnunication)：通讯系统只有在发送和接收应用程序正<br>在运行时才能存储消息</li><li>持久通信(Persistent Communication)：提交传输的消息一直由通信中间件存储，<br>直到该消息被传送给接收方为止</li><li>异步通信(Asynchronous Communication)：发信方发信后立即继续，消息存储在发信方主机或者通信服务器的缓冲区中。</li><li>同步通信(Synchronous Communication)：发信方在到达同步点前保持阻塞。</li></ul><p><strong>远程过程调用RPC</strong></p><p>PS: 一般程序的调用：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211227153318439.png" alt="image-20211227153318439" title="">                </div>                <div class="image-caption">image-20211227153318439</div>            </figure><p>RPC的工作过程：</p><ol><li><p>客户过程以正常的方式调用客户存根(client stub)；</p></li><li><p>客户存根生成一个消息，然后调用本地操作系统；</p></li><li><p>客户端操作系统将消息发送给远程操作系统；</p></li><li><p>远程操作系统将消息交给服务器存根；</p></li><li><p>服务器存根调将参数提取出来，而后调用服务器；</p></li><li><p>服务器执行要求的操作，操作完成后将结果返回给服务器存根；</p></li><li><p>服务器存根将结果打包成一个消息，而后调用本地操作系统；</p></li><li><p>服务器操作系统将含有结果的消息发送给客户端操作系统；</p></li><li><p>客户端操作系统将消息交给客户存根；</p></li><li><p>客户存根将结果从消息中提取出来，返回给调用它的客户存根</p><p><img src="/picture/image-20211227154006443.png" alt="image-20211227154006443"></p><p><img src="/picture/image-20211227154100592.png" alt="image-20211227154100592"></p></li></ol><p><strong>故障处理</strong></p><p>5 种故障</p><ol><li><p>客户端不能定位服务器：使用特定的返回值 (异常处理)</p><p>例如：服务器故障，服务器进化但客户端使用过期的客户端存根<br>可能的解决方案：用特殊代码（如-1）作为返回值声明故障；抛出异常或信号</p></li><li><p>客户端到服务器的请求消息丢失：设置一个计时器 超时重发。</p></li><li><p>服务器发给客户的应答消息丢失：设置一个计时器，对于不幂等的请求 为客户请求分配序号 服务器<br>区别不同的请求。</p></li><li><p>服务器在收到消息后崩溃(接受后执行前崩溃或者执行后发送前崩溃)：等待服务器启动 然后重发请<br>求(至少一次)；或者立即放弃并报告失败(至多一次)；或者不做任何保证 ;</p></li><li><p>客户机在发送消息后崩溃：</p><p>客户端在发送请求后，在收到服务器响应前故障，通讯是活跃的，但没有parent 在等待响应，形成孤儿</p><ol><li>消除 extermination: 在日志文件中纪录 RPC 请求 重启后清除孤儿 。</li><li>再生 reincarnation: 按时间顺序编号不同的时间段。当客户端重启时，广播 一条消息宣布新的时间段开始，当广播到达时终止所有远程计算，无需日志。(服务端杀死所有的)（另一种说法：设置一个epoch,每个客户端进程重启为一个新的epoch。新epoch到达意味着之前的计算全部杀死）</li><li>温和再生 gentle reincarnation: 与再生相似，但是当广播到达时，每台机器会寻找远程计算的所<br>有者，仅当找不到所有者时，计算才会被终止 。（服务端杀死掉线的）（另一种说法：设置一个epoch,每个客户端进程重启为一个新的epoch。新epoch 到达意味着将没有主的孤儿进程杀死 ）</li><li>过期 expiration: 赋予每个RPC一个标准时间配额，未完成任务明确申请额外配额。</li></ol></li></ol><p><strong>动态绑定</strong></p><p>绑定：一种让客户端找到服务器的方法</p><p>静态绑定：将服务器地址（IP、端口）硬编码到客户端代码中</p><p>动态绑定过程：</p><ol><li>服务器启动时向Binder 注册<br>Register 请求：参数:ID、名字、版本、地址<br>Unregister 请求：参数:ID、名字、版本</li><li>客户端存根向Binder 查找服务器接口<br>Lookup 请求：参数: 名字、版本；返回：ID、地址<br>调用：客户端根据地址发送RPC 调用</li></ol><p>优点：灵活性，可以支持多个支持同一接口的服务器，绑定程序可以验证客户端和服务器都使用相同版本的接口</p><p>缺点：导出/导入接口的额外开销花费时间，绑定程序可能成为大型分布式系统中的瓶颈</p><hr><p><strong>基于消息的通信</strong></p><ul><li>瞬时通信(Transient Commnunication)：通讯系统只有在发送和接收应用程序正<br>在运行时才能存储消息</li><li>持久通信(Persistent Communication)：提交传输的消息一直由通信中间件存储，<br>直到该消息被传送给接收方为止</li><li>异步通信(Asynchronous Communication)：发信方发信后立即继续，消息存储在发信方主机或者通信服务器的缓冲区中。</li><li>同步通信(Synchronous Communication)：发信方在到达同步点前保持阻塞。</li></ul><p><strong>面向流的通信</strong></p><ul><li><p>分类</p><ul><li>连续数据流：支持异构数据传输的通信设施</li><li>离散媒体：数据项在时间上的联系不重要</li><li>连续媒体：不同数据项在时间上的联系非常重要，如：音频、视频、动画</li></ul></li><li><p>不同传输模式</p><ul><li>异步传输模式（离散媒体）：没有时间限制</li><li>同步传输模式（连续媒体）：没有最大延迟时间</li><li>等时传输模式（连续媒体）：最大延迟时间、最小延迟时间</li></ul></li><li>流与Qos<ul><li>利用区分服务为不同类型的数据提供服务</li><li>利用缓冲区减少延时抖动</li><li>交错传输来降低丢包影响</li></ul></li></ul><p>PS：流媒体看直播卡顿的解决的方法：</p><ul><li>利用区分服务为不同类型的数据提供服务</li><li>利用缓冲区减少延时抖动</li><li>交错传输来降低丢包影响</li><li>使用更好的带宽估计算法</li></ul><h2 id="同步和资源管理"><a href="#同步和资源管理" class="headerlink" title="同步和资源管理"></a>同步和资源管理</h2><p><strong>Lamport时钟</strong></p><p>参考了该<a href="https://yang.observer/2020/07/26/time-lamport-logical-time/" target="_blank" rel="noopener">博客</a></p><ol><li><p>先后关系：把事件 a 发生在 b 之前定义为 a → b，以下三种条件满足a → b：</p><ol><li>a和b是同一个进程内的事件，a发生在b之前，则 a → b。</li><li>a和b在不同的进程中，a是发送进程内的发送事件，b是同一消息接收进程内的接收事件，则 a → b。</li><li>如果a → b并且b → c，则a → c。</li></ol><p>如果a和b没有先后关系，则称两个事件是并发的，记作 a || b。<br>例子：</p><p><img src="/picture/image-20211227222919525.png" alt="image-20211227222919525"></p><p>​    这个例子中：</p><ul><li>a → b → c → d</li><li>a → b → e</li><li>f → c → d</li><li>a || f</li><li>e || d</li><li>b || f</li><li>e || c</li></ul><ol start="2"><li><p>逻辑时钟算法：分布式系统中每个进程Pi保存一个本地逻辑时钟值Ci，Ci (a) 表示进程Pi发生事件a时的逻辑时钟值，Ci的更新算法如下：</p><ol><li>进程Pi每发生一次事件，Ci加1。</li><li>进程Pi给进程Pj发送消息，需要带上自己的本地逻辑时钟Ci。</li><li>进程Pj接收消息，更新Cj为 max (Ci, Cj) + 1。</li></ol><p>上述例子的逻辑时钟：</p><p><img src="/picture/image-20211227223041307.png" alt="image-20211227223041307"></p><p>从以上算法可以很容易地得出下面两个结论：</p><ol><li>同一个进程内的两个事件a和b，如果 a → b，那么 Ci (a) &lt; Ci (b)。</li><li>a是Pi进程的消息发送事件，b是Pj进程该消息的接收事件，那么 Ci (a) &lt; Cj (b)。</li></ol></li><li><p>另外如果 C (a) &lt; C (b)，那么可以得出 a → b 吗？</p><p>答案是不能，举个反例，图二中C (e) = 2，C (d) = 3，虽然 C (e) &lt; C (d)，但并不能得出 e → d，e和d实际上是并发关系 e || d，也就是说由于并发的存在，导致反向的推论并不成立。</p></li></ol></li></ol><p><strong>向量时钟</strong></p><p>在向量时钟中如果C (a) &lt; C (b)，可以得出 a → b，它的思想是进程间通信的时候，不光同步本进程的时钟值，还同步自己知道的其他进程的时钟值。</p><p>分布式系统中每个进程Pi保存一个本地逻辑时钟向量值VCi，向量的长度是分布式系统中进程的总个数。VCi (j) 表示进程Pi知道的进程Pj的本地逻辑时钟值，VCi的更新算法如下：</p><ol><li>初始化VCi的值全为0：VCi = [0, … , 0]</li><li>进程Pi每发生一次事件，VCi[i]加1。</li><li>进程Pi给进程Pj发送消息，需要带上自己的向量时钟VCi。</li><li>进程Pj接收消息，需要做两步操作。<ol><li>对于VCj向量中的每个值VCj[k]，更新为 max (VCi[k], VCj[k])。</li><li>将VCj中自己对应的时钟值加1，即VCj[j]加1</li></ol></li></ol><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211227223758776.png" alt="image-20211227223758776" title="">                </div>                <div class="image-caption">image-20211227223758776</div>            </figure><p>向量时钟中的向量的偏序关系定义如下：</p><ul><li>如果向量VCi中的每个元素VCi[k]都小于等于VCj中的对应元素VCj[k]，则VCi <em>≤</em> VCj。</li><li>如果VCi中的每个元素VCi[k]都和VCj中的对应元素VCj[k]相等，则VCi = VCj。</li><li>如果VCi和VCj不能比较大小，则称两个向量是并发的 VCi || VCj。</li></ul><p>因此可以有以下推论：</p><ul><li>同一个进程内的两个事件a和b，如果 a → b，那么 VCi (a) &lt; VCi (b)。</li><li>a是Pi进程的消息发送事件，b是Pj进程该消息的接收事件，那么 VCi (a) &lt; VCj (b)。</li></ul><p>然后可以推出：<strong>对于任意两个事件a和b，如果 a → b，那么 VC (a) &lt; VC (b)</strong>。</p><p>证明VC(a) &lt; VC(b) 可以推导a → b：</p><ul><li><p>如果事件a和b在同一个进程内，很显然 a → b。</p></li><li><p>如果事件a和b在不同进程内，比如Pa和Pb。</p><p>设VCa = [m ,n], VCb = [s, t]。</p><p>因为VCa &lt; VCb，所以m <em>≤</em> s，所以必然在不早于a之前和不晚于b之后的时间内，Pa向Pb发送了消息，否则Pb对Pa的计数器得不到及时刷新，s就不会小于m。</p><p>实际上可以分为如下四种情况：</p><p><img src="/picture/image-20211227224429102.png" alt="image-20211227224429102"></p><ol><li>当a = c且d = b，易得a → b。</li><li>当a = c且d → b，由传递性，得a → b。</li><li>同样对于d = b且a → c的情况。</li><li>当a → c且d → b，根据进程内的算法逻辑性和传递性，也很容易得出结论。</li></ol></li><li><p>综上: VCa &lt; VCb 推导出 a → b 得证。</p></li></ul><hr><p><strong>分布式系统中的互斥访问</strong></p><ol><li><p>集中式算法：基于上述的选举算法，选出一个进程作为集中协调者，该协调者同时管理一个请求等<br>待队列。当队列为空时，协调者对临界区请求应答。当队列不为空或者临界区尚未释放时，把请求添加<br>到等待队列的队尾，然后或者对请求不予应答，或者直接拒绝（此时该请求会一直查询临界区使用状<br>态），直至从队头取出该请求后再允许其进入临界区。</p><p>优点：</p><ul><li>保持互斥</li><li>公平</li><li>无饥饿</li><li>容易失效：请求、授权、释放</li></ul><p>缺点：</p><ul><li>单点故障</li><li>性能瓶颈</li><li>无法区分coordinator 失效or 权限拒绝</li></ul><p>PS: 非集中式 多个leader</p></li><li><p>分布式算法：基于时间戳；</p><ol><li>进程如果想进入临界区，那么构建含临界区名字、进程编号、当前时间的消息发给所有进程；</li><li>进程收到请求消息：<ol><li>如果接收方未在临界区<ol><li>想进入临界区：对比消息的timestamp，如果接收消息的timestamp比较早，返回<br>OK；否则缓存请求，返回空</li><li>不想进入临界区：返回OK</li></ol></li><li>如果接收方已在临界区，缓存请求</li></ol></li></ol></li><li><p>令牌环算法：</p><ol><li>用软件的方法，按照进程的地址或者编号等，为总线型的网络构造一个逻辑环。一个令牌环只能<br>对应进入一个临界区。</li><li>过程：令牌环绕进程环依次传递，如果接受进程如果不需要进入临界区，则继续传递给下一个进程，如<br>果接受进程需要进入临界区，那么此时传递暂停，令牌等待，直到进程从临界区返回后继续。</li><li>缺点：令牌丢失的检测和再生因为无法确定时间间隔而非常困难；进程崩溃虽然可以恢复，但是需要通<br>过每个进程向前继进程发送确认消息来实现，也就需要每个进程都维护当前的配置信息。</li></ol></li><li><p>比较：</p><p><img src="/picture/image-20211227231113593.png" alt="image-20211227231113593"></p></li></ol><p><strong>分布式系统中的选举机制</strong></p><ol><li><p>bully算法：</p><ol><li><p>发起选举的条件，一是任何进程发现原有协调者崩溃时，可以发起选举；二是原来崩溃的进程P恢复以<br>后，可以重新发起选举，但是最后不一定会赢得选举，因为可能还有编号比P大的进程在P崩溃期间已经<br>开始运行。</p></li><li><p>选举过程：</p><ol><li>发起选举的进程Q只能向编号比自己大的进程发起election消息</li><li>如果Q一直没有接受到OK应答消息，则由Q获胜充当协调者，否则，退出选举</li></ol><p>因此最大的进程总是取胜，所以叫 bully(欺凌)算法</p></li><li><p>例子：</p><p><img src="/picture/image-20211227233130739.png" alt="image-20211227233130739"></p></li></ol></li><li><p>环算法：</p><ol><li><p>发起选举的条件：所有进程已经按照编号进行排序并且链接成环，任何一个或者多个进程发现原有协<br>调者崩溃或者没有响应时，开始发起选举。</p></li><li><p>选举过程：发起消息者构造election消息，依次向后传递。传递过程中如果后继进程已经崩溃，则绕<br>过（不仅仅是刚刚崩溃了的协调者），如果后继进程正在运行，则把编号添加进election消息成员列表。待绕环一周返回到发起者后，根据选举消息中的编号（选取成员列表里面最大的那个）选出协调者，并用coordinator消息绕环通知所有进程，循环一周后该消息被删除。</p></li><li><p>栗子：</p><p><img src="/picture/image-20211227233428655.png" alt="image-20211227233428655"></p></li></ol></li></ol><hr><h2 id="复制与一致性"><a href="#复制与一致性" class="headerlink" title="复制与一致性"></a>复制与一致性</h2><p><strong>复制的优势和不足</strong>（分布式系统多副本的优点和缺点）</p><ul><li>优点：<ul><li>可靠性：避免单点故障</li><li>性能：对服务器数量和地理区域上的扩展</li></ul></li><li>不足：<ul><li>复制透明性：某个用户不知道某个对象是复制的</li><li>一致性问题：更新过程开销大，可能影响系统可用性</li></ul></li></ul><hr><p>一致性模型实质上是进程和数据存储之间的一个约定，也就是如果进程同意遵守某些规则，那么数据存储将正常运行</p><p>PS：一致性模型的类型：</p><ul><li>面向数据一致性模型：本地数据存储的组织通常在分布在多个进程，并进行复制</li><li>面向客户的一致性模型：保证单个客户端访问数据存储的一致性</li></ul><p><strong>数据一致性模型</strong></p><p>参考了<a href="https://int64.me/2020/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0.html" target="_blank" rel="noopener">博客1</a>以及<a href="https://cloud.tencent.com/developer/article/1015442" target="_blank" rel="noopener">博客2</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211228142648852.png" alt="image-20211228142648852" title="">                </div>                <div class="image-caption">image-20211228142648852</div>            </figure><p><strong>不引入同步操作的一致性模型</strong></p><ul><li><p>严格一致性（Strict Consistency）：</p><p>所有共享访问事项的绝对时间顺序</p><ul><li>任何读操作返回与最新写操作结果对应的值</li><li>依赖绝对全局时间; 所有写入对所有进程都即时可见，并维护绝对全局时间顺序</li><li>分布式系统中无法实现</li></ul></li><li><p>线性一致性（Linearizability），又称为强一致性或者原子一致性：</p><p>所有进程都必须以相同的顺序查看所有共享访问。此外，访问根据（非唯一）全局时间戳排序;</p><p><strong>一旦某一个读操作返回了新值，之后所有的读（包括相同或不同的客户端）都必须返回新值</strong></p></li><li><p>顺序一致性(Sequential)：</p><p>所有进程都以相同的顺序查看所有共享访问。访问不是按时间排序；</p><ul><li>与线性一致性类似，对时间顺序无要求</li><li>从单个处理器 (线程或者进程)的角度来看，执行指令的顺序以编程中的顺序为准。</li><li>从所有的处理器(线程或者进程)的角度来看，指令的执行保持一个单一的顺序。</li></ul><p>与线性一致性比较的例子：</p><p><img src="/picture/image-20211228150820914.png" alt="image-20211228150820914"></p><p>因为a中可以找到一个执行序列： <code>Write(&quot;y&quot;, 1) -&gt; Read(&quot;x&quot; -&gt; 0) -&gt; Write(&quot;x&quot;, 1) -&gt; Read(&quot;y&quot; -&gt; 1)</code> 满足顺序一致性。但是从时间角度看<code>Write(&quot;x&quot;,1)</code> 要先于 <code>Read(&quot;x&quot;) -&gt; 0</code> 执行，但是 Read 却没有读取到最新值，所以不满足线性一致性。</p><p>b中都满足</p><p>c中找不到这样的执行序列，所以不满足顺序一致性；</p><p><strong>顺序一致性和线性一致性都是要找到一个满足 “写后读” 的一组操作历史，差异在于线性一致性要求严格的时间序，而顺序一致性只要求满足编程顺序</strong>。</p></li><li><p>因果一致性（Causal Consistency）</p><p>所有进程都以相同的顺序查看与因果相关的共享访问</p><ul><li>有因果关系的写操作，不同的进程看到相同的顺序</li><li>没有因果关系的写操作，不同的进程可以看到不同顺序</li></ul><p>来自这个<a href="https://zhuanlan.zhihu.com/p/71913226" target="_blank" rel="noopener">知乎</a>的例子:</p><p><img src="/picture/image-20211228153131011.png" alt="image-20211228153131011"></p><p><img src="/picture/image-20211228153136952.png" alt="image-20211228153136952"></p></li><li><p>管道一致性（FIFO Consistency/PRAM）</p><p>所有进程都按使用顺序看到彼此的写入；不同进程的写入可能并不总是按相同的顺序显示</p><ul><li>由同一个进程进行的写操作，必须看到相同的顺序</li><li>不同进程的写操作，不同进程可以看到不同顺序</li></ul><p>这个算是一种弱一致性</p></li></ul><hr><p><strong>引入同步操作的一致性模型</strong></p><ul><li><p>弱一致性（Weak Consistency）</p><p>只有在同步完成后，才能让共享数据保持一致；（有一个同步事件S，保证在S之后的读能看到S之前的读写顺序。）</p><p>具体限制：</p><ul><li>对数据存储所关联的同步变量的访问是顺序一致的；说明了所有进程都以相同的顺序看到对同步变量进行的所有操作</li><li>每个拷贝完成所有先前执行的写操作之前，不允许对同步变量进行任何操作（说明了同步”清空管道”）</li><li>所有先前对同步变量执行的操作都执行完毕之前，不允许对数据项进行任何读或写操作（说明访问数据项时，无论读数据或写数据,所有先前的同步都已经完成。）</li></ul></li><li><p>释放一致性（Release Consistency）</p><p>退出关键区域时，共享数据保持一致（写数据时加全局锁，加锁之后的顺序就不能乱来，不加锁的话读到什么都可以。还锁的时候同步）</p><ul><li>获取操作：用于通知数据存储进程进入临界区的操作</li><li>释放操作︰表明进程刚刚离开临界区的操作</li></ul><p>具体限制：</p><ul><li>对共享数据执行读操作或写操作之前，所有进程先前执行的获取操作都必须已经成功完成</li><li>在释放操作被允许执行前，所有进程先前执行的读操作和写操作都必须已经完成</li><li>对同步变量的访问是FIFO一致的(不需要顺序一致)</li></ul></li><li><p>入口一致性：</p><p>进入共享数据对应临界区时，共享数据一致（每个数据的读写都要加锁，不加锁读数据，不保证给出什么东西，给出nil都可以。拿锁的时候同步）</p><ul><li>要求每个普通的共享数据项都要与某种同步变量关联</li><li>具体限制为<ul><li>在一个进程可以获取一个同步变量之前，所有的由此同步变量保护的共享数据的更新都必须已经相对于该进程执行完毕<ul><li>执行获取操作时，所有的受保护数据的远程改变都必须已经可见</li></ul></li><li>在一个进程对一个同步变量的独占访问被允许执行之前，其他的进程不可以拥有这个同步变量，甚至也不能以非独占的方式拥有这个同步变量<ul><li>更新共享数据项之前，必须以独占的方式进入临界区</li></ul></li><li>一个进程对一个同步变量执行独占访问之后，在对该同步变量的所有者进行检查之前，任何其他的进程都不能执行下一个非独占访问<ul><li>非独占方式进入临界区之前，必须检查保护这个临界区同步变量的所有者,以获得受保护的共享数据的最新副本</li></ul></li></ul></li></ul></li></ul><hr><p><strong>以客户为中心的一致性模型</strong></p><ul><li><p>最终一致性</p><p>如果在一段相当长的时间内没有更新操作, 那么所有的副本将逐渐成为一致的</p></li><li><p>单调读：</p><p>如果一个进程数据项x 的值，那么该进程对x 执行的任何后续读操作将总是得到第一次读取的那个值或更新的值，保证之后不会看到x的更老的版本（读出来一个值之后再读一次，不会读出更老的值。）</p></li><li><p>单调写：</p><p>一个进程对数据项x 执行的写操作必须在该进程对x 执行任何后续写操作之前完成；写操作必须顺序完成，不能交叉（写完一个值之后，才能继续写下一个，不允许写的过程中开始一个新的写时间(read your write):写了之后，后续的读一定能读到这个值，而不会读到旧值写的时候，保证所替换掉的是之前读出来的值）</p></li><li><p>写后读 Read your writes（读写一致性）：</p><p>一个进程对数据项x 执行一次写操作的结果总是会被该进程对x执行的后续读操作看见；保证读取最新（写了之后，后续的读一定能读到这个值，而不会读到旧值）</p><p><img src="/picture/image-20211228163203615.png" alt="image-20211228163203615"></p></li><li><p>读后写 writes-follow-reads consistency （写读一致性）：</p><p>同一个进程对数据项x 执行的读操作之后的写操作，保证发生在与x 读取值相同或比之更新的值上；更新作为前一个读操作结果传播（写的时候，保证所替换掉的是之前读出来的值）</p><p><img src="/picture/image-20211228163229625.png" alt="image-20211228163229625"></p></li></ul><hr><p><strong>数据一致性协议实例</strong></p><p><strong>基于法定数量的协议 Quorum-based protocols</strong></p><ul><li>对于一个具有 N 个副本的文件<ul><li>客户要读取时，必须组织一个服务器数量为 Nr 的读团体(read quorum)</li><li>客户要修改时，必须组织一个服务器数量为 Nw 的写团体(write quorum)</li></ul></li><li>其中，Nr 与 Nw 满足以下限制条件<ul><li>Nr+Nw&gt;N: 用于防止读写冲突</li><li>Nw&gt;N/2: 用于防止写写冲突</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211228171012230.png" alt="image-20211228171012230" title="">                </div>                <div class="image-caption">image-20211228171012230</div>            </figure><hr><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p><strong>可靠（Dependable System）的系统的特征</strong> </p><p>有群友总结为 ASMR</p><ul><li>可用性：在任意给定的时刻，系统都可以正确及时地工作，并执行用户的请求。 A</li><li>安全性：系统偶然出现故障时还能正确操作和执行。 S</li><li>可维护性：表示发生故障后系统能被恢复到可用性的难易程度 M</li><li>可靠性：系统可以无故障持续运行； R</li></ul><p>PS 基础定义：</p><p>error → fault → failure</p><ul><li>fault: 造成error 的原因</li><li>error：系统错误的状态，可能导致failure</li><li>failure：没有满足承诺，无法提供服务</li></ul><p>故障分类：</p><ul><li>Crash failure（服务器重启，重启正常）</li><li>Omission failure（遗漏错误）</li><li>Timing failure（超时）</li><li>Responsne failure</li><li>Byzantine faiure</li></ul><p><strong>提高系统可信性的途径</strong></p><ul><li>使用冗余来掩盖故障：<ul><li>信息冗余：添加额外的位或码恢复错乱的信息。</li><li>时间冗余：多次执行需要的动作。可以使用事务。适用于临时性或者间歇性的错误。</li><li>物理冗余：添加额外的装备（硬件）或者进程（软件）使系统整体容忍部分错误。</li></ul></li></ul><p><strong>K容错系统</strong></p><p>参考<a href="https://chenxfeng.github.io/2017/06/13/parellel_and_distributed_computing/distributed_compute6/" target="_blank" rel="noopener">博客</a></p><p>K容错：系统能够经受k个组件的故障并且还能满足规范要求。当这些组件是失败沉默的情况下，需要<br>k+1个组件可以提供k容错；如果发生拜占庭失败，至少需要2k+1个进程才能获得k容错。 课本P242页</p><p>怎么证明可以参考这个<a href="https://zhuanlan.zhihu.com/p/44198965" target="_blank" rel="noopener">知乎</a></p><p><strong>拜占庭问题</strong></p><p>在容错计算机系统中，经常需要部件之间的信息传递与分发，而一个失效的部件将会向其他部件发送错误的消息。容错计算机中失效部件向不同部件发送错误消息的问题，可被抽象为拜占庭将军问题：</p><p>算法流程：</p><ul><li>每个将军向其他n-1 个将军告知自己的兵力（真实或说谎）</li><li>每个将军将收到的消息组成一个长度为n 的向量</li><li>每个将军将自己的向量发送给其他n-1 个将军</li><li>每个将军检查每个接收到的向量中的第i 个元素，将其众数作为其结果向量的第i个元素</li></ul><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211228194256257.png" alt="image-20211228194256257" title="">                </div>                <div class="image-caption">image-20211228194256257</div>            </figure><p><strong>系统恢复</strong></p><p>恢复：发生故障的进程能够恢复到正确的状态</p><ul><li><p>两种形式</p><ul><li>后向恢复：从当前错误状态回退到先前正确状态</li><li>前向恢复：尝试从某点继续执行，把系统带入一个正确的新状态</li></ul></li><li><p>检查点：系统定时记录状态到稳定存储</p><ul><li><p>每个进程独立地设置本地检查点，依赖项的记录方式使进程可以联合回滚到一致的全局状态</p></li><li><p>但每个进程回退的状态可能不一致，需要继续回退，可能造成多米诺效应</p><p><img src="/picture/image-20211228194433000.png" alt="多米诺效应"></p></li></ul></li><li><p>协调的检查点：</p><ul><li>所有进程同步地把各自状态写到本地稳定存储中</li></ul></li></ul><hr><p><strong>PS 两阶段提交</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211229105045012.png" alt="二阶段提交" title="">                </div>                <div class="image-caption">二阶段提交</div>            </figure><p>为什么两阶段提交叫做阻塞提交协议？</p><p>当所有参与者都从协作者那里接收到信息变成READY状态的时候，并且同时协作者崩溃的时候就会发生阻塞</p><hr><h2 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h2><p>Paxos协议</p><p>参考的<a href="https://zhuanlan.zhihu.com/p/29706905" target="_blank" rel="noopener">知乎</a></p><p>Paxos 保证了：安全性 和 最终一致性（Eventual liveness）：</p><ul><li>安全性：只有被提议的值才可能会被选择，只有一个值会被选择，只有最终被选择的值才会被进程所保存。</li><li>Eventual liveness, 如果系统正常运行下去，在未来的某一个点，最终会达成共识。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211229104843788.png" alt="通信实例" title="">                </div>                <div class="image-caption">通信实例</div>            </figure><p>Raft协议</p><ul><li>用户选举</li><li>Log Replication</li></ul><p>Gossip协议</p><p>需要O(logN)轮才能把信息传播到所有节点，push SI总共传播的信息数量O(NlogN);Pulland push-pull SI 需要传播的信息数量O(NloglogN)</p><p><strong>大数据处理系统</strong></p><p>对于DAG型作业Spark+Yarn的优势在哪里？</p><ul><li>DAG型的每个中间结果hadoop会有频繁的磁盘IO，spark用分布式弹性数据集把中间结果存在内存中，避免了DAG中间结构的频繁IO</li><li>hadoop+hdfs的集群，集群需要同时进行资源管理和任务控制，耦合度高。Yarn只负责资源管理，将任务控制交给应用去设计，耦合度低。虽然Yarn应用的逻辑变复杂了，但可以支持更多的编程模型和设备。</li></ul><hr><table><thead><tr><th></th><th>容错</th><th>拜占庭协定</th></tr></thead><tbody><tr><td>沉默错</td><td>k+1</td><td>2k+1</td></tr><tr><td>拜占庭错</td><td>2k+1</td><td>3k+1</td></tr></tbody></table><p>(所有挂k个，表格里面是总量)</p><p>沉默错拜占庭协定2k+1: 挂掉的节点k个醒了之后需要k+1个正确的来达成一致性</p><p>容错取众数，拜占庭协定需要两轮，可以参考这个<a href="https://zhuanlan.zhihu.com/p/44198965" target="_blank" rel="noopener">知乎</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式系统的特征以及系统模型&quot;&gt;&lt;a href=&quot;#分布式系统的特征以及系统模型&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的特征以及系统模型&quot;&gt;&lt;/a&gt;分布式系统的特征以及系统模型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是分布式系统&lt;/stro
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="分布式系统" scheme="http://Tyler-ytr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PDF技巧记录</title>
    <link href="http://Tyler-ytr.github.io/2021/12/25/pdf-trick/"/>
    <id>http://Tyler-ytr.github.io/2021/12/25/pdf-trick/</id>
    <published>2021-12-25T15:25:19.000Z</published>
    <updated>2021-12-25T15:31:21.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PDF书签编辑"><a href="#PDF书签编辑" class="headerlink" title="PDF书签编辑"></a>PDF书签编辑</h2><p>使用PdgCntEditor可以对PDF文件书签整体进行编辑。</p><p>可以通过这个<a href="链接：https://pan.baidu.com/s/133aEfCgGlqd7egwsZyOz1g">网盘链接</a>下载，密码是9dyu；</p><h3 id="PDF点击书签之后的缩放"><a href="#PDF点击书签之后的缩放" class="headerlink" title="PDF点击书签之后的缩放"></a>PDF点击书签之后的缩放</h3><p>这个居然在Adobe Acrobat Pro里面难以解决，除非一个一个书签点击属性加入缩放比率：适合可见；</p><p>使用PdgCntEditor之后可以通过点击PDF图标然后进行点击目录后页面缩放的选项就好了；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PDF书签编辑&quot;&gt;&lt;a href=&quot;#PDF书签编辑&quot; class=&quot;headerlink&quot; title=&quot;PDF书签编辑&quot;&gt;&lt;/a&gt;PDF书签编辑&lt;/h2&gt;&lt;p&gt;使用PdgCntEditor可以对PDF文件书签整体进行编辑。&lt;/p&gt;
&lt;p&gt;可以通过这个&lt;a hr
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows配置" scheme="http://Tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>java_learning</title>
    <link href="http://Tyler-ytr.github.io/2021/12/01/java-learning/"/>
    <id>http://Tyler-ytr.github.io/2021/12/01/java-learning/</id>
    <published>2021-12-01T06:34:39.000Z</published>
    <updated>2021-12-01T06:57:40.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java学习笔记"><a href="#java学习笔记" class="headerlink" title="java学习笔记"></a>java学习笔记</h1><p>学习参考资料：</p><ul><li>深入理解java虚拟机-JVM高级特性与最佳实践（第三版）</li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4NDY5Mjc1Mg==&amp;action=getalbum&amp;album_id=1326602114365276164&amp;scene=173&amp;from_msgid=2247483934&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target="_blank" rel="noopener">jvm系列总结</a></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="java类的加载"><a href="#java类的加载" class="headerlink" title="java类的加载"></a>java类的加载</h3><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java学习笔记&quot;&gt;&lt;a href=&quot;#java学习笔记&quot; class=&quot;headerlink&quot; title=&quot;java学习笔记&quot;&gt;&lt;/a&gt;java学习笔记&lt;/h1&gt;&lt;p&gt;学习参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深入理解java虚拟机-JVM高级特性与最佳实践（
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jvm" scheme="http://Tyler-ytr.github.io/tags/jvm/"/>
    
      <category term="java" scheme="http://Tyler-ytr.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>shell命令杂记</title>
    <link href="http://Tyler-ytr.github.io/2021/11/10/shell-collect/"/>
    <id>http://Tyler-ytr.github.io/2021/11/10/shell-collect/</id>
    <published>2021-11-10T07:58:23.000Z</published>
    <updated>2021-11-11T09:22:28.205Z</updated>
    
    <content type="html"><![CDATA[<p>用于记录一些遇到过的shell;</p><h4 id="一些shell命令含义的记录"><a href="#一些shell命令含义的记录" class="headerlink" title="一些shell命令含义的记录"></a>一些shell命令含义的记录</h4><ol><li><p><strong>1&gt;/dev/null 2&gt;&amp;1的含义</strong> </p><ol><li>> 代表重定向到哪里，例如：echo “123” &gt; /home/123.txt</li><li>1 表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null” </li><li>2 表示stderr标准错误</li><li>&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 </li></ol><p>因此该语句：</p><ol><li>1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 </li><li>2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 </li></ol></li><li><p>/dev/zero文件代表一个永远输出 0的设备文件，使用它作输入可以得到全为空的文件。因此可用来创建新文件和以覆盖的方式清除旧文件。</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用于记录一些遇到过的shell;&lt;/p&gt;
&lt;h4 id=&quot;一些shell命令含义的记录&quot;&gt;&lt;a href=&quot;#一些shell命令含义的记录&quot; class=&quot;headerlink&quot; title=&quot;一些shell命令含义的记录&quot;&gt;&lt;/a&gt;一些shell命令含义的记录&lt;/h4&gt;&lt;
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="shell" scheme="http://Tyler-ytr.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>vscode+latex 配置</title>
    <link href="http://Tyler-ytr.github.io/2021/11/08/vscode-latex-setting/"/>
    <id>http://Tyler-ytr.github.io/2021/11/08/vscode-latex-setting/</id>
    <published>2021-11-08T02:45:56.000Z</published>
    <updated>2021-11-08T05:38:51.085Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装texlive，验证的方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tex -v</span><br><span class="line">latex -v</span><br><span class="line">xelatex -v</span><br><span class="line">pdflatex -v</span><br></pre></td></tr></table></figure></li><li><p>vscode 安装 Latex Workshop插件以及Code Spell Checker插件</p></li><li><p>配置json，打开配置的方法是Ctrl+shift+p然后搜索setj选择 <code>首选项：打开设置</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"xelatex -&gt; bibtex -&gt; xelatex*2"</span>,</span><br><span class="line">      <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="string">"xelatex"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "latex-workshop.latex.tools": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOCFILE%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOCFILE%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOCFILE%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"%DOCFILE%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "latex-workshop.view.pdf.viewer": "tab",</span><br><span class="line">  "latex-workshop.latex.clean.fileTypes": [</span><br><span class="line">    "*.aux",</span><br><span class="line">    "*.bbl",</span><br><span class="line">    "*.blg",</span><br><span class="line">    "*.idx",</span><br><span class="line">    "*.ind",</span><br><span class="line">    "*.lof",</span><br><span class="line">    "*.lot",</span><br><span class="line">    "*.out",</span><br><span class="line">    "*.toc",</span><br><span class="line">    "*.acn",</span><br><span class="line">    "*.acr",</span><br><span class="line">    "*.alg",</span><br><span class="line">    "*.glg",</span><br><span class="line">    "*.glo",</span><br><span class="line">    "*.gls",</span><br><span class="line">    "*.ist",</span><br><span class="line">    "*.fls",</span><br><span class="line">    "*.log",</span><br><span class="line">    <span class="string">"*.fdb_latexmk"</span></span><br><span class="line">  ],</span><br><span class="line">  "latex-workshop.latex.autoClean.run": "onBuilt"</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>快捷键：</p><ul><li><code>ctrl+alt+b</code> 编译latex；</li><li><code>ctrl+alt+x</code>：显示LaTeX面板(左侧编译命令面板和文档大纲)</li><li><code>ctrl+alt+c</code>：清除辅助文件（目前的设置是自动清除的所以不太需要）</li><li><code>ctrl+alt+v</code>：查看编译的pdf文件</li><li><code>ctrl+alt+j</code>：正向搜索。固定光标到tex文件的某一个位置能够在pdf那里自动定位到该位置，需要在上面的自动清楚设置里面不清除.gz文件</li><li><code>ctrl</code>: 反向搜索，在阅读vscode里面预览的pdf的时候按住ctrl然后点击某位置，左边的tex会自动定位到该位置；</li></ul></li><li><p>中文支持:</p><ol><li><p>xelatex：</p><p>加入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;ctex&#125;</span><br></pre></td></tr></table></figure></li><li><p>pdflatex：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;CJKutf8&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span><br><span class="line">      </span><br><span class="line">\end&#123;CJK&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装texlive，验证的方式:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows 配置" scheme="http://Tyler-ytr.github.io/tags/windows-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>邮件处理</title>
    <link href="http://Tyler-ytr.github.io/2021/11/02/email_note/"/>
    <id>http://Tyler-ytr.github.io/2021/11/02/email_note/</id>
    <published>2021-11-02T13:08:35.000Z</published>
    <updated>2021-11-02T13:25:04.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="邮件批量发送"><a href="#邮件批量发送" class="headerlink" title="邮件批量发送"></a>邮件批量发送</h2><p>主要依赖yagmail库进行邮件的批量发送，样例脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#殷天润制作</span></span><br><span class="line"><span class="comment">#使用说明:在批好的作业的文件夹下面: python py_email.py即可</span></span><br><span class="line"><span class="comment">## 记得改一下subject 和 passwd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  yagmail</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_id</span><span class="params">(filename)</span>:</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>,len(filename)<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> filename[index]==<span class="string">'1'</span> <span class="keyword">or</span> filename[index]==<span class="string">'2'</span>:</span><br><span class="line">print(filename[index:index+<span class="number">9</span>])</span><br><span class="line"><span class="keyword">return</span> filename[index:index+<span class="number">9</span>]</span><br><span class="line"><span class="keyword">elif</span> filename[index]==<span class="string">'M'</span> <span class="keyword">or</span> filename[index]==<span class="string">'D'</span> <span class="keyword">or</span> filename[index]==<span class="string">'m'</span> <span class="keyword">or</span> filename[index]==<span class="string">'d'</span>:</span><br><span class="line">print(filename[index:index+<span class="number">10</span>])</span><br><span class="line"><span class="keyword">return</span> filename[index:index+<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user=<span class="string">'mg21330xxx@smail.nju.edu.cn'</span></span><br><span class="line">passwd=<span class="string">"passwd"</span></span><br><span class="line">smtp_host=<span class="string">"smtp.exmail.qq.com"</span></span><br><span class="line">mail=yagmail.SMTP(user=user,password=passwd,host=smtp_host,port=<span class="number">465</span>)</span><br><span class="line">path=<span class="string">"./"</span></span><br><span class="line">filelist=os.listdir(path)</span><br><span class="line"><span class="comment"># 遍历输出每一个文件的名字和类型</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">    <span class="comment"># 输出指定后缀类型的文件</span></span><br><span class="line"><span class="keyword">if</span>(item.endswith(<span class="string">'.pdf'</span>)):</span><br><span class="line">file=item</span><br><span class="line">uid=get_id(item)</span><br><span class="line">uid_email=uid+<span class="string">"@smail.nju.edu.cn"</span></span><br><span class="line"><span class="comment">#print(uid_email)</span></span><br><span class="line">print(uid_email)</span><br><span class="line">mail.send(to=[uid_email],subject=<span class="string">'计算机网络作业批改_xxx'</span>, contents=<span class="string">'批改见附件'</span>,   attachments=[file] )   </span><br><span class="line"><span class="comment">## 记得改一下subject</span></span><br></pre></td></tr></table></figure><h2 id="邮件附件批量下载"><a href="#邮件附件批量下载" class="headerlink" title="邮件附件批量下载"></a>邮件附件批量下载</h2><blockquote><p>主要参考了<a href="https://club.excelhome.net/thread-563004-1-1.html" target="_blank" rel="noopener">https://club.excelhome.net/thread-563004-1-1.html</a><br><a href="https://blog.csdn.net/qq_35132089/article/details/115509617" target="_blank" rel="noopener">https://blog.csdn.net/qq_35132089/article/details/115509617</a></p></blockquote><p>主要是借助VBA以及outlook；</p><p>流程如下:</p><p>在outlook的收件箱新建文件夹，命名为:homework;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211102211300861.png" alt="homework" title="">                </div>                <div class="image-caption">homework</div>            </figure><p>然后把要处理的邮件批量放进去，这一步可以现在腾讯企业邮箱批量的把邮件移动到某文件夹然后再放进去；</p><p>然后在D盘创建文件夹，比如名字为temp;</p><p>然后对outlook进行信任部分的设置，具体操作是打开选项：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211102211602890.png" alt="trust setting1" title="">                </div>                <div class="image-caption">trust setting1</div>            </figure><p>然后信任中心，信任中心设置，启用所有宏：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211102211649316.png" alt="trust setting2" title="">                </div>                <div class="image-caption">trust setting2</div>            </figure><p>最后打开outlook,按住alt+f11，调出VBA编辑的页面，填入如下代码:</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Savetheattachment()     </span><br><span class="line"><span class="keyword">Dim</span> olApp <span class="keyword">As</span> <span class="keyword">New</span> Outlook.Application</span><br><span class="line">    <span class="keyword">Dim</span> nmsName <span class="keyword">As</span> Outlook.<span class="keyword">NameSpace</span></span><br><span class="line">    <span class="keyword">Dim</span> vItem <span class="keyword">As</span> <span class="built_in">Object</span></span><br><span class="line">    <span class="keyword">Set</span> nmsName = olApp.GetNamespace(<span class="string">"MAPI"</span>)</span><br><span class="line">    <span class="keyword">Set</span> myFolder = nmsName.GetDefaultFolder(olFolderInbox)</span><br><span class="line">    <span class="keyword">Set</span> fldFolder = myFolder.Folders(<span class="string">"homework"</span>)</span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> vItem <span class="keyword">In</span> fldFolder.Items         </span><br><span class="line">    <span class="comment">'-----Save Attachment------</span></span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> att <span class="keyword">In</span> vItem.Attachments</span><br><span class="line">                att.SaveAsFile <span class="string">"D:\temp\"</span> &amp; att.FileName</span><br><span class="line">            <span class="keyword">Next</span></span><br><span class="line">    <span class="comment">'------Save Attachment-------</span></span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line">    <span class="keyword">Set</span> fldFolder = <span class="literal">Nothing</span></span><br><span class="line">    <span class="keyword">Set</span> nmsName = <span class="literal">Nothing</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211102212058420.png" alt="running VBA" title="">                </div>                <div class="image-caption">running VBA</div>            </figure><p>然后如图示点击运行即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;邮件批量发送&quot;&gt;&lt;a href=&quot;#邮件批量发送&quot; class=&quot;headerlink&quot; title=&quot;邮件批量发送&quot;&gt;&lt;/a&gt;邮件批量发送&lt;/h2&gt;&lt;p&gt;主要依赖yagmail库进行邮件的批量发送，样例脚本如下&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="python心得" scheme="http://Tyler-ytr.github.io/tags/python%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>hacker&#39;s delight 阅读</title>
    <link href="http://Tyler-ytr.github.io/2021/10/29/hacker-delight-reading/"/>
    <id>http://Tyler-ytr.github.io/2021/10/29/hacker-delight-reading/</id>
    <published>2021-10-29T04:29:48.000Z</published>
    <updated>2021-10-29T06:05:38.117Z</updated>
    
    <content type="html"><![CDATA[<p>主要是P4使用中可能会需要一些骚操作，遂阅读此书；</p><blockquote><p>默认字长为32位；</p></blockquote><h2 id="ch2"><a href="#ch2" class="headerlink" title="ch2"></a>ch2</h2><ol><li><p>最右边的位元：</p><ol><li>考虑用x+1,x-1配上与或非取反进行操作，比如$x \&amp; (x-1)$;</li><li>$\neg x\&amp;(x+1)$,$\neg x\&amp;(x-1)$,$\neg x |(x+1)$……</li><li>这块建议查书；</li></ol></li><li><p>从右到左的可计算性：</p><ol><li><p>如果一个函数能够以位元为单位从右到左计算出来，那么它肯定可以用加法减法按位和按位与以及按位取反及其复合指令实现；反之，如果这些基本指令描述一个函数，那么它必然可以通过从右到左的按位运算做出来；</p></li><li><p>我觉得可能要反复揣摩这个定理：</p><p><img src="/picture/image-20211029134915635.png" alt="image-20211029134915635"></p></li><li><p>根据书上的特例可以很清晰的理解它要表达的用于构造的例子：</p><p><img src="/picture/image-20211029135925706.png" alt="image-20211029135925706"></p><p><img src="/picture/image-20211029135929924.png" alt="image-20211029135929924"></p><p>上面的可以通过下面的获得，第二行第三行按位与然后和第一行按位或然后和第四行按位与（先执行操作然后对位置定位）</p></li><li><p>与此同时有一些问题没法用五个基本运算组合得出，这里就要看想要获得的结果与原始输入之间的关系，是不是从右到左的，也就是说最右边的值不应该和它左边的有联系，比如如下的例子：</p><p><img src="/picture/image-20211029140134548.png" alt="image-20211029140134548"></p></li></ol></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是P4使用中可能会需要一些骚操作，遂阅读此书；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;默认字长为32位；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ch2&quot;&gt;&lt;a href=&quot;#ch2&quot; class=&quot;headerlink&quot; title=&quot;ch2&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hacker&#39;s delight" scheme="http://Tyler-ytr.github.io/tags/hacker-s-delight/"/>
    
  </entry>
  
  <entry>
    <title>p4_overview</title>
    <link href="http://Tyler-ytr.github.io/2021/10/25/p4-overview/"/>
    <id>http://Tyler-ytr.github.io/2021/10/25/p4-overview/</id>
    <published>2021-10-25T05:05:18.000Z</published>
    <updated>2021-10-27T07:19:09.030Z</updated>
    
    <content type="html"><![CDATA[<p>主要来自对<a href="https://github.com/jafingerhut/p4-guide/blob/master/README-p4lang-repos.md" target="_blank" rel="noopener">https://github.com/jafingerhut/p4-guide/blob/master/README-p4lang-repos.md</a> 的学习</p><h2 id="文档与博客"><a href="#文档与博客" class="headerlink" title="文档与博客"></a>文档与博客</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><a href="https://p4.org/specs/" target="_blank" rel="noopener">p4文档页面</a></li><li><a href="https://p4.org/p4-spec/p4runtime/main/P4Runtime-Spec.html#fig-reference-architecture" target="_blank" rel="noopener">p4runtime文档</a></li><li><a href="https://p4.org/p4-spec/docs/P4-16-v1.2.2.html" target="_blank" rel="noopener">p4_16语言文档</a></li><li><a href="https://p4.org/p4-spec/docs/PSA-v1.1.0.html" target="_blank" rel="noopener">p4_16 Portable Switch Architecture (PSA)文档</a></li><li><a href="https://p4.org/p4-spec/docs/PNA-v0.5.0.html" target="_blank" rel="noopener">p4 Portable NIC Architecture (PNA) 文档</a></li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1080440" target="_blank" rel="noopener">P4语言编程详解</a></li></ul><h2 id="p4-lang组织下面的仓库"><a href="#p4-lang组织下面的仓库" class="headerlink" title="p4 lang组织下面的仓库"></a>p4 lang组织下面的仓库</h2><p> <a href="https://github.com/p4lang/" target="_blank" rel="noopener">p4lang organization</a> 是github的一个组织。以下是该组织2019-3.31的所有仓库,并按类别进行了归类：</p><h3 id="规范文件"><a href="#规范文件" class="headerlink" title="规范文件"></a>规范文件</h3><ul><li><a href="https://github.com/p4lang/p4-spec" target="_blank" rel="noopener"><code>p4-spec</code></a> - Containsspecification documents for the P4_14 language, the P4_16 language,and Portable Switch Architecture (PSA).</li><li><a href="https://github.com/p4lang/p4runtime" target="_blank" rel="noopener"><code>p4runtime</code></a> - Specification documents for the P4Runtime control-plane API</li><li><a href="https://github.com/p4lang/p4-applications" target="_blank" rel="noopener"><code>p4-applications</code></a> - P4 Applications WG repo</li></ul><h3 id="文档、研究论文和教程"><a href="#文档、研究论文和教程" class="headerlink" title="文档、研究论文和教程"></a>文档、研究论文和教程</h3><ul><li><a href="https://github.com/p4lang/papers" target="_blank" rel="noopener"><code>papers</code></a> - Repository for papers   related to P4</li><li><a href="https://github.com/p4lang/tutorials" target="_blank" rel="noopener"><code>tutorials</code></a> - P4 language  tutorials</li><li><a href="https://github.com/p4lang/education" target="_blank" rel="noopener"><code>education</code></a> - P4 for Education</li><li><a href="https://github.com/p4lang/p4lang.github.io" target="_blank" rel="noopener"><code>p4lang.github.io</code></a> -P4.org website</li></ul><h3 id="P4-编译器"><a href="#P4-编译器" class="headerlink" title="P4 编译器"></a>P4 编译器</h3><p> some only front end, some front end plus back end for one or more P4 targets</p><ul><li><a href="https://github.com/p4lang/p4c" target="_blank" rel="noopener"><code>p4c</code></a> - P4_16 prototype compiler   (also compiles P4_14 programs)</li><li><a href="https://github.com/p4lang/p4c-bm" target="_blank" rel="noopener"><code>p4c-bm</code></a> - Generates the JSON   configuration for the behavioral-model (bmv2), as well as the C/C++   PD code</li><li><a href="https://github.com/p4lang/p4-hlir" target="_blank" rel="noopener"><code>p4-hlir</code></a> - P4_14 compiler, written in Python, which stops at generating an intermediate representation, from which one can start in writing a back end compiler</li><li><a href="https://github.com/p4lang/p4c-behavioral" target="_blank" rel="noopener"><code>p4c-behavioral</code></a> - P4 compiler for the behavioral model.  Deprecated.</li></ul><h3 id="P4-行为模型，用于在通用计算机上运行-P4-程序"><a href="#P4-行为模型，用于在通用计算机上运行-P4-程序" class="headerlink" title="P4 行为模型，用于在通用计算机上运行 P4 程序"></a>P4 行为模型，用于在通用计算机上运行 P4 程序</h3><ul><li><a href="https://github.com/p4lang/behavioral-model" target="_blank" rel="noopener"><code>behavioral-model</code></a> - Rewrite of the behavioral model as a C++ project without<br>auto-generated code.  Also known as <code>bmv2</code>.</li><li><a href="https://github.com/p4lang/p4c-behavioral" target="_blank" rel="noopener"><code>p4c-behavioral</code></a> - P4 compiler for the behavioral model.  Deprecated.</li></ul><h3 id="P4Runtime-API-规范和一些实现代码，包括客户端和服务器代码"><a href="#P4Runtime-API-规范和一些实现代码，包括客户端和服务器代码" class="headerlink" title="P4Runtime API 规范和一些实现代码，包括客户端和服务器代码"></a>P4Runtime API 规范和一些实现代码，包括客户端和服务器代码</h3><ul><li><a href="https://github.com/p4lang/p4runtime" target="_blank" rel="noopener"><code>p4runtime</code></a> - Specification documents for the P4Runtime control-plane API</li><li><a href="https://github.com/p4lang/PI" target="_blank" rel="noopener"><code>PI</code></a> - An implementation framework for a P4Runtime server</li><li><a href="https://github.com/p4lang/grpc" target="_blank" rel="noopener"><code>grpc</code></a> - grpc - (forked from grpc/grpc) The C based gRPC (C++, Python, Ruby, Objective-C, PHP,C#) (forked from grpc/grpc)</li><li><a href="https://github.com/p4lang/protobuf" target="_blank" rel="noopener"><code>protobuf</code></a> - Protocol Buffers Google’s data interchange format (forked from<br>protocolbuffers/protobuf)</li></ul><h3 id="由-p4-org-以外的组织创建的开源工具，供一个或多个p4lang存储库使用"><a href="#由-p4-org-以外的组织创建的开源工具，供一个或多个p4lang存储库使用" class="headerlink" title="由 p4.org 以外的组织创建的开源工具，供一个或多个p4lang存储库使用"></a>由 p4.org 以外的组织创建的开源工具，供一个或多个<code>p4lang</code>存储库使用</h3><ul><li><a href="https://github.com/p4lang/grpc" target="_blank" rel="noopener"><code>grpc</code></a> - grpc - (forked from grpc/grpc) The C based gRPC (C++, Python, Ruby, Objective-C, PHP,C#) (forked from grpc/grpc)</li><li><a href="https://github.com/p4lang/protobuf" target="_blank" rel="noopener"><code>protobuf</code></a> - Protocol Buffers Google’s data interchange format (forked from<br>protocolbuffers/protobuf)</li><li><a href="https://github.com/p4lang/rules_protobuf" target="_blank" rel="noopener"><code>rules_protobuf</code></a> - Bazel rules for building protocol buffers and gRPC services (java, c++,go, …) (forked from pubref/rules_protobuf)</li><li><a href="https://github.com/p4lang/mininet" target="_blank" rel="noopener"><code>mininet</code></a> - Emulator for rapid prototyping of Software Defined Networks <a href="http://mininet.org" target="_blank" rel="noopener">http://mininet.org</a> (forked from <a href="https://github.com/mininet/mininet" target="_blank" rel="noopener">mininet/mininet</a>)</li><li><a href="https://github.com/p4lang/SAI" target="_blank" rel="noopener"><code>SAI</code></a> - Switch Abstraction Interface (forked from <a href="https://github.com/opencomputeproject/SAI" target="_blank" rel="noopener">opencomputeproject/SAI</a>)</li><li><a href="https://github.com/p4lang/scapy-vxlan" target="_blank" rel="noopener"><code>scapy-vxlan</code></a> - A scapy clone, with support for additional packet headers</li><li><a href="https://github.com/p4lang/third-party" target="_blank" rel="noopener"><code>third-party</code></a> - Third-party dependencies for p4lang software</li><li><a href="https://github.com/p4lang/thrift" target="_blank" rel="noopener"><code>thrift</code></a> - Mirror of Apache Thrift (forked from<br><a href="https://github.com/apache/thrift" target="_blank" rel="noopener">apache/thrift</a>)</li></ul><h3 id="用于创建和运行自动化测试"><a href="#用于创建和运行自动化测试" class="headerlink" title="用于创建和运行自动化测试"></a>用于创建和运行自动化测试</h3><ul><li><a href="https://github.com/p4lang/mininet" target="_blank" rel="noopener"><code>mininet</code></a> - Emulator for rapid prototyping of Software Defined Networks <a href="http://mininet.org" target="_blank" rel="noopener">http://mininet.org</a> (forked<br>from <a href="https://github.com/mininet/mininet" target="_blank" rel="noopener">mininet/mininet</a>)</li><li><a href="https://github.com/p4lang/ntf" target="_blank" rel="noopener"><code>ntf</code></a> - Network Test Framework</li><li><a href="https://github.com/p4lang/ptf" target="_blank" rel="noopener"><code>ptf</code></a> - Packet Test Framework</li><li><a href="https://github.com/p4lang/scapy-vxlan" target="_blank" rel="noopener"><code>scapy-vxlan</code></a> - A scapy clone, with support for additional packet headers</li></ul><h3 id="可能不再维护的部分"><a href="#可能不再维护的部分" class="headerlink" title="可能不再维护的部分"></a>可能不再维护的部分</h3><ul><li><a href="https://github.com/p4lang/p4-build" target="_blank" rel="noopener"><code>p4-build</code></a> - Infrastructure needed to generate, build and install the PD library for a given P4 program</li><li><a href="https://github.com/p4lang/p4app" target="_blank" rel="noopener"><code>p4app</code></a> - (No description)</li><li><a href="https://github.com/p4lang/p4factory" target="_blank" rel="noopener"><code>p4factory</code></a> - Compile P4 and run the P4 behavioral simulator.  Deprecated.</li><li><a href="https://github.com/p4lang/p4ofagent" target="_blank" rel="noopener"><code>p4ofagent</code></a> - Openflow agent on a P4 dataplane</li><li><a href="https://github.com/p4lang/switch" target="_blank" rel="noopener"><code>switch</code></a> - Consolidated switch repo (API, SAI and Netlink)</li></ul><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>Sample command lines to compile P4 source file foo.p4 to bmv2 JSON configuration file:</p><pre><code># foo.p4 is P4_14 source codep4c-bmv2 --json foo.json foo.p4p4c --target bmv2 --arch v1model --std p4-14 foo.p4# foo.p4 is P4_16 source codep4c --target bmv2 --arch v1model foo.p4</code></pre><p>Sample command line for converting P4_14 source code to P4_16 source code:</p><pre><code>p4test --std p4-14 --pp foo-translated-to-p4-16.p4 foo-in-p4-14.p4</code></pre><h2 id="P4依赖关系图"><a href="#P4依赖关系图" class="headerlink" title="P4依赖关系图"></a>P4依赖关系图</h2><p>可以参考<a href="https://github.com/jafingerhut/p4-guide/blob/master/dependencies.pdf" target="_blank" rel="noopener">https://github.com/jafingerhut/p4-guide/blob/master/dependencies.pdf</a></p><div class="row">    <embed src="/picture/dependencies.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="p4语言概览"><a href="#p4语言概览" class="headerlink" title="p4语言概览"></a>p4语言概览</h2><ul><li>相对于C</li><li>P4删除了 loops, recursive calls, pointers, malloc, and free<ul><li>删除 loops, recursive calls,对于每一个包的工作可以限制在一个特定的时间，更加适合高性能的P4可编程平台</li><li>删除 pointers, malloc, 以及自用的通用数据结构，从而不可能又任意大小的数据结构，但是我们可以实现具有固定深度的树</li></ul></li><li>增加了解析器<code>parser</code>, 重点关注将接收到的数据包的内容解析为一系列报头时最需要的功能<ul><li>解析器被定义为有限状态机，其中的状态必须命名并定义它们之间可能的转换。实际上，允许在解析器有限状态机中有循环，但最高性能目标通常会将您限制为可展开到编译时已知最大迭代次数的循环，例如，用于解析长度最多为5个报头的MPLS报头序列（其中5或其他值是您在源代码中选择的数字）。</li><li>P4专注于数据包报头处理。对于P4程序而言，数据包中任何未解析为某个报头的部分都被视为数据包的“有效载荷”，通常在处理完数据包后，数据包会随数据包一起携带，未经修改。您可以随意修改标题字段</li></ul></li><li>增加了tables这样的数据结构，每一个表都有一个搜索的键值，并且可以定义一个或者多个操作</li><li>不同的交换机体系结构可能还有一些另外的库，比如PSA（ <a href="https://p4.org/specs/" target="_blank" rel="noopener">Portable Switch Architecture</a> ）里面的packet/byte counters等等</li><li>字段以及变量可以是任意位宽的整数（有最大位数限制），P4不支持浮点数运算，同时P4实现哦那个杨不需要实现乘法除法模运算，因为大多数包处理应用程序通常用不到</li><li>没有浮点数咋整相关的文章<a href="https://github.com/jafingerhut/p4-guide/blob/master/docs/floating-point-operations.md" target="_blank" rel="noopener">integer arithmetic is sufficient for implementing fixed point operations</a></li></ul><h2 id="P4-14-和-P4-16的比较"><a href="#P4-14-和-P4-16的比较" class="headerlink" title="P4_14 和 P4_16的比较"></a>P4_14 和 P4_16的比较</h2><h3 id="16相对于14的好处"><a href="#16相对于14的好处" class="headerlink" title="16相对于14的好处"></a>16相对于14的好处</h3><ul><li>更加像C++等语言的语法</li><li>p4_14没有参数和返回值，需要操作全局变量；p4_16没有全局变量，但是有in,out,inout 等具有方向性的参数</li><li>tables 以及 externs 的设计；</li></ul><h3 id="16相对于14的缺点"><a href="#16相对于14的缺点" class="headerlink" title="16相对于14的缺点"></a>16相对于14的缺点</h3><p>18年的时候16的支持不如14，但是时代变了；</p><h2 id="bmv2使用"><a href="#bmv2使用" class="headerlink" title="bmv2使用"></a>bmv2使用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要来自对&lt;a href=&quot;https://github.com/jafingerhut/p4-guide/blob/master/README-p4lang-repos.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.c
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
      <category term="p4 guide" scheme="http://Tyler-ytr.github.io/tags/p4-guide/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Tyler-ytr.github.io/2021/09/16/hello-world/"/>
    <id>http://Tyler-ytr.github.io/2021/09/16/hello-world/</id>
    <published>2021-09-16T15:19:03.152Z</published>
    <updated>2020-01-20T19:20:25.723Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ns_learning</title>
    <link href="http://Tyler-ytr.github.io/2021/09/11/ns-learning/"/>
    <id>http://Tyler-ytr.github.io/2021/09/11/ns-learning/</id>
    <published>2021-09-11T10:00:15.000Z</published>
    <updated>2021-12-28T12:43:52.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ns3学习总结"><a href="#ns3学习总结" class="headerlink" title="ns3学习总结"></a>ns3学习总结</h1><h2 id="ns3简介"><a href="#ns3简介" class="headerlink" title="ns3简介"></a>ns3简介</h2><h3 id="ns3关键概念"><a href="#ns3关键概念" class="headerlink" title="ns3关键概念"></a>ns3关键概念</h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>ns3是一个网络simulator,为了防止混淆，使用节点来代替主机，用来表示基本设备的抽象；</p><p>使用Node类来进行描述，具体调用科研使用NodeContainer 类，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NodeContainer nodes;</span><br><span class="line">nodes.Create (2)&#39;&#39;</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>需要被仿真的用户程序被抽象成为应用，在Application类中进行了描述；它的实例还有UdpEchoClientApplication以及UdpEchoServerApplication等等，前者用来回显服务端所回复的分组；</p><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><p>网络中数据里流过的媒介成为信道，在channel类中进行了描述，它提供了管理通信子网对象和把节点连接到它们的各种方法，几个信道模型的实例包括：CsmaChannel,PointToPointChannel 以及WifiChannel;</p><h4 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h4><p>这个概念相当于硬件设备以及软件驱动的总和，网络设备在ns3中安装在节点上面，使得节点通过信道和其他节点通信，一个节点可以通过多个网络设备同时连接到多条信道上面。主要在NetDevice类中进行了描述，这部分也允许开发者自定义。几个网络设备的实例包括：CsmaNetDevice,PointToPointNetDevice以及Wi-FiNetDevice。</p><h4 id="拓扑帮助"><a href="#拓扑帮助" class="headerlink" title="拓扑帮助"></a>拓扑帮助</h4><p>可以使用拓扑生成器来让配置IP等等任务变得容易。同时拓扑生成器还能帮助整合例如创建网络设备，配置MAC地址，把网络设备装到节点上面，设置节点协议栈，连接网络设备到信道等等分立的工作。这部分主要在Helper类中。</p><h3 id="ns3优化技术"><a href="#ns3优化技术" class="headerlink" title="ns3优化技术"></a>ns3优化技术</h3><h4 id="logging系统"><a href="#logging系统" class="headerlink" title="logging系统"></a>logging系统</h4><h5 id="logging等级"><a href="#logging等级" class="headerlink" title="logging等级"></a>logging等级</h5><p>一共由低到高提供了7个等级：</p><ul><li>LOG_ERROR—记录错误信息;</li><li>LOG_WARN—记录警告信息;</li><li>LOG_DEBUG—记录一些调试信息;</li><li>LOG_INFO—记录一些程序相关的信息;</li><li>LOG_FUNCTION一当有函数被调用时，该调用信息就被记录;</li><li>LOG_LOGIC—对于整体逻辑的描述;</li><li>LOG_ALL-包含上述的所有信息。</li></ul><h5 id="脚本中设置记录模块"><a href="#脚本中设置记录模块" class="headerlink" title="脚本中设置记录模块"></a>脚本中设置记录模块</h5><p>在脚本中可以使用进行记录，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LogComponentEnable ( <span class="string">"UdpEchoClientApplication"</span>，LOG_LEVEL_INFO) ;</span><br><span class="line">LogcomponentEnable (<span class="string">"UdpEchoserverApplication"</span>，LOG_LEVEL_INFO);</span><br></pre></td></tr></table></figure><p>在first.cc这个例子中，大致的效果为:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211009205558340.png" alt="image-20211009205558340" title="">                </div>                <div class="image-caption">image-20211009205558340</div>            </figure><h5 id="在环境变量中设置"><a href="#在环境变量中设置" class="headerlink" title="在环境变量中设置"></a>在环境变量中设置</h5><p>可以使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="string">'NS_LOG=UdpEchoClientApplication=level_all|prefix_func|prefix_time:UdpEchoServerApplication=level_all|prefix_func|prefix_time'</span></span><br></pre></td></tr></table></figure><p>在外部环境变量设置等级，并且覆盖文件中的等级的效果，现在大致的效果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211009205733732.png" alt="image-20211009205733732" title="">                </div>                <div class="image-caption">image-20211009205733732</div>            </figure><p>prefix_func增加了函数调用信息，prefix_time增加了时间信息；</p><h5 id="自定义logging代码"><a href="#自定义logging代码" class="headerlink" title="自定义logging代码"></a>自定义logging代码</h5><p>在first.cc中有一句代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NS_LOG_COMPONENT_DEFINE(<span class="string">"FirstscriptExample"</span>);</span><br></pre></td></tr></table></figure><p>这个代码向ns-3系统中注册了“FirstScriptExample”这个组件，通过记录组件，可以在仿真脚本中使用Logging系统进行自定义的输出语句；</p><p>然后可以在代码中创建节点之前的位置添加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NS_LOG_INFO(<span class="string">"Creating Topology"</span>);</span><br></pre></td></tr></table></figure><p>此时重新编译是没有效果的，因为没有激活这个组件，可以用如下两种方法激活:</p><ol><li><p>在代码中添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogComponentEnable (&quot;FirstScriptExample&quot;, LOG_LEVEL_INFO);</span><br></pre></td></tr></table></figure></li><li><p>在外部环境变量激活</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NS_LOG=FirstScriptExample=info</span><br></pre></td></tr></table></figure></li></ol><p>效果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211009210157505.png" alt="方法1" title="">                </div>                <div class="image-caption">方法1</div>            </figure>方法1没有覆盖之前的环境变量。<br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20211009210646796.png" alt="方法2" title="">                </div>                <div class="image-caption">方法2</div>            </figure><h2 id="ns3安装"><a href="#ns3安装" class="headerlink" title="ns3安装"></a>ns3安装</h2><p>参考<a href="http://www.soolco.com/post/94032_1_1.html；" target="_blank" rel="noopener">http://www.soolco.com/post/94032_1_1.html；</a></p><p>尝试了使用官方文档<a href="https://www.nsnam.org/wiki/Installation" target="_blank" rel="noopener">https://www.nsnam.org/wiki/Installation</a> 的bake进行安装但是比较不成功，建议参考上述博客进行安装。安装依赖建议使用清华源。安装过程和编译过程比较消耗时间，建议虚拟机或者真机保证4GB以上的内存。</p><h3 id="ns3依赖"><a href="#ns3依赖" class="headerlink" title="ns3依赖"></a>ns3依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu18.04 使用;使用-y可以自动确认，可以改成.sh脚本，chmod赋予权限之后使用。</span></span><br><span class="line">sudo apt-get -y install g++ python3</span><br><span class="line">sudo apt-get -y install g++ python3 python3-dev pkg-config sqlite3</span><br><span class="line">sudo apt-get -y install python3-setuptools git</span><br><span class="line">sudo apt-get -y install qt5-default mercurial</span><br><span class="line">sudo apt-get -y install gir1.2-goocanvas-2.0 python-gi python-gi-cairo python-pygraphviz python3-gi python3-gi-cairo python3-pygraphviz gir1.2-gtk-3.0 ipython ipython3</span><br><span class="line">sudo apt-get -y install openmpi-bin openmpi-common openmpi-doc libopenmpi-dev</span><br><span class="line">sudo apt-get -y install autoconf cvs bzr unrar</span><br><span class="line">sudo apt-get -y install gdb valgrind</span><br><span class="line">sudo apt-get -y install uncrustify</span><br><span class="line">sudo apt-get -y install doxygen graphviz imagemagick</span><br><span class="line">sudo apt-get -y install texlive texlive-extra-utils texlive-latex-extra texlive-font-utils dvipng latexmk</span><br><span class="line">sudo apt-get -y install python3-sphinx dia</span><br><span class="line">sudo apt-get -y install gsl-bin libgsl-dev libgsl23 libgslcblas0</span><br><span class="line">sudo apt-get -y install tcpdump</span><br><span class="line">sudo apt-get -y install sqlite sqlite3 libsqlite3-dev</span><br><span class="line">sudo apt-get -y install libxml2 libxml2-dev</span><br><span class="line">sudo apt-get -y install cmake libc6-dev libc6-dev-i386 libclang-6.0-dev llvm-6.0-dev automake</span><br><span class="line">sudo apt-get -y install python3-pip</span><br><span class="line">sudo apt-get -y install libgtk-3-dev</span><br><span class="line">sudo apt-get -y install vtun lxc uml-utilities</span><br><span class="line">sudo apt-get -y install libboost-signals-dev libboost-filesystem-dev</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这部分pip相关 如有需要请换源之后处理</span></span><br><span class="line">sudo pip3 install --upgrade pip</span><br><span class="line">python3 -m pip install --user cxxfilt</span><br><span class="line">pip3 install pygccxml</span><br><span class="line">pip3 install CastXML</span><br><span class="line">pip3 install PyBindGen</span><br></pre></td></tr></table></figure><h3 id="ns3安装-1"><a href="#ns3安装-1" class="headerlink" title="ns3安装"></a>ns3安装</h3><p>在右侧链接地址<code>https://www.nsnam.org/releases/</code>下载想要的版本。然后根据一下指令解压安装，版本号自行修改，我安装的是3.34</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xjf ns-allinone-3.34.tar.bz2 # 解压</span><br><span class="line">chmod -R 777 ns-allinone-3.34 # 修改权限</span><br><span class="line">ls</span><br><span class="line">cd ns-allinone-3.34 # 切换到解压目录下</span><br></pre></td></tr></table></figure><p>使用以下编译:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;build.py --enable-examples --enable-test</span><br></pre></td></tr></table></figure><p>之后根据编译的提示来进行另外的调整</p><p>查看一些细节可以:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ns-3.34</span><br><span class="line">.&#x2F;waf --build-profile&#x3D;debug --enable-examples --enable-test configure</span><br></pre></td></tr></table></figure><p>最后进行测试: 这部分巨花时间，大概得2-3个小时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;test.py</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;waf --run hello-simulator # 验证是否安装成功</span><br></pre></td></tr></table></figure><p>我使用virtualbox虚拟机大概做了一个18.04的镜像，账户是cs144，密码是123456，如有需要自行取用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ns3学习总结&quot;&gt;&lt;a href=&quot;#ns3学习总结&quot; class=&quot;headerlink&quot; title=&quot;ns3学习总结&quot;&gt;&lt;/a&gt;ns3学习总结&lt;/h1&gt;&lt;h2 id=&quot;ns3简介&quot;&gt;&lt;a href=&quot;#ns3简介&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="http://Tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="ns3" scheme="http://Tyler-ytr.github.io/tags/ns3/"/>
    
      <category term="实验基础" scheme="http://Tyler-ytr.github.io/tags/%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mininetlab 学习</title>
    <link href="http://Tyler-ytr.github.io/2021/09/03/mininetlab/"/>
    <id>http://Tyler-ytr.github.io/2021/09/03/mininetlab/</id>
    <published>2021-09-03T07:55:16.000Z</published>
    <updated>2021-09-11T10:00:51.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mininet-学习"><a href="#Mininet-学习" class="headerlink" title="Mininet 学习"></a>Mininet 学习</h1><p>来自<a href="https://www.51openlab.com/college/" target="_blank" rel="noopener">https://www.51openlab.com/college/</a> 的教程，以下是学习总结</p><h2 id="Mininet-简介"><a href="#Mininet-简介" class="headerlink" title="Mininet 简介"></a>Mininet 简介</h2><p>Mininet 基于Linux Container这一个内核虚拟化技术开发，利用linux的network namespace机制在一台电脑上创建多台虚拟主机，此外，Mininet建立的网络拓扑的交换节点可以是Open vSwitch、Linux Bridge等软件交换机，交换节点之间的链路采用Linux的veth pair (virtual Ethernet pair)机制实现，控制器可以部署在网络可达的任意地方。因此，Mininet可以定制任意灵活的SDN网络拓扑，为实验用户提供快捷可靠的实验环境。</p><p>Mininet架构按datapath的运行权限不同，分为kernel datapath和userspace datapath两种，其中kernel datapath把分组转发的逻辑编译进入Linux内核，效率非常高; userspace datapath把分组转发逻辑实现为一个应用程序，叫做ofdatapath,效率虽不及kernel datapath，但更为灵活，更容易重新编译。</p><p>Mininet的kernel datapath架构如下图所示，控制器和交换机的网络接口都在root 命名空间中，每个主机都在自己独立的命名空间里，这也就表明每个主机在自己的命名空间中都会有自己独立的虚拟网卡eth0。控制器就是一个用户进程，它会在loopback上预留的6633端口监听来自交换机安全信道的连接。每个交换机对应几个网络接口，比如sO-eth0、sO-eth1以及一个ofprotocol进程，它负责管理和维护同一控制器之间的安全信道。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210903160253663.png" alt="image-20210903160253663" title="">                </div>                <div class="image-caption">image-20210903160253663</div>            </figure><p>Mininet的userspace datapath架构如下图所示，与kernel datapath架构不同，网络的每个节点都拥有自己独立的namespace。因为分组转发逻辑是实现在用户空间，所以多出了一个进程叫ofdatapath。另外，Mininet除了支持kernel datapath和userspace datapath这两种架构以外，还支持OVS交换机。OVS充分利用内核的高效处理能力，它的性能和kernel datapath相差无几</p><h3 id="Mininet-安装"><a href="#Mininet-安装" class="headerlink" title="Mininet 安装"></a>Mininet 安装</h3><ol><li><p>下载github源码然后编译安装，</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"> git clone http:&#x2F;&#x2F;github.com&#x2F;mininet&#x2F;mininet.git</span><br></pre></td></tr></table></figure><p> 其中./install.sh是安装的命令，格式如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;install.sh [options]</span><br></pre></td></tr></table></figure><p> options如下</p></li></ol><ul><li>-a :  完整安装，默认在home目录下，包括 Mininet VM,以及Open vSwich的依赖关系，OpenFlow, Wireshark分离器以及POX<ul><li>-nfv 安装mininet核心文件及其依赖，OpenFlow 和 Open vSwitch</li><li>-s mydir: 可以把源代码建立到一个特定的目录中</li></ul></li></ul><ol start="2"><li><p>查看mininet版本</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd mininet</span><br><span class="line">cat INSTALL|more</span><br></pre></td></tr></table></figure></li><li><p>安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd util</span><br><span class="line">.&#x2F;install.sh -a</span><br></pre></td></tr></table></figure></li><li><p>测试基本功能</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mn --test pingall</span><br></pre></td></tr></table></figure><p> <img src="/picture/image-20210903162108693.png" alt="image-20210903162108693"></p></li><li><p>查看安装好的mininet版本:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mn --version</span><br></pre></td></tr></table></figure></li></ol><h2 id="Mininet-拓扑构建与命令使用"><a href="#Mininet-拓扑构建与命令使用" class="headerlink" title="Mininet 拓扑构建与命令使用"></a>Mininet 拓扑构建与命令使用</h2><ol><li><p>MiniEdit:</p><p>这个可以可视化的在界面编辑任意拓扑，然后生成python自定义拓扑脚本，Mininetnet2.20+内置，在mininet/examples里面提供mininetedit.py脚本；</p></li><li><p>Mininet参数</p><p>topo： 用于指定网络拓扑，Mininet支持minimal,singel,linear 和tree 三种</p><ul><li>minimal: 创建一个交换机和两个主机相连的简单拓扑。默认无—topo参数的情况下就是这样。其内部实现就是调用了single,2对应的函数。</li><li>single,n:设置一个交换机和n个主机相连的拓扑。</li><li>linear,n:创建n个交换机，每个交换机只连接一个主机，并且所有交换机成线型排列。</li><li>tree,depth=n,fanout=m:创建深度为n，每层树枝为m的树型拓扑。因此形成的拓扑的交换机个数为(mn-1) /(m-1)，主机个数为mn。</li><li>–custom:在上述已有拓扑的基础上，Mininet支持自定义的拓扑，使用一个简单的Python API即可。–custom需和–topo一起使用，如mn –custom file.py –topo mytopo。</li></ul></li><li><p>内部交互命令:</p><p>| 参数                               | 作用 |<br>| ———————————- | —- |<br>| -h                                 | show this help message and exit     |<br>| –switch=SWITCH                    |   [kernel user ovsk]   |<br>| –host=HOST                        |   [process]   |<br>| –controller=CONTROLLER            | [nox_dump none ref remote nox_pysw]     |<br>| –topo=TOPO                        | [tree reversed single linear minimal],arg1,arg2,…argN |<br>| -c,–clean                         | clean and exit |<br>| –custom=CUSTOM                    | read custom topo and node params from .py file |<br>| –test=TEST                        | [cli build pingall pingpair iperf all iperfudp none] |<br>| -x,–xterms                        | spawn xterms for each node |<br>| –mac                              | set MACs equal to DPIDs |<br>| –arp                              | set all-pairs ARP entries |<br>| -v VEIBOSITY,–verbosity=VEIBOSITY | [info warning critical error debug output] |<br>| –ip=IP                            | [ip address as a dotted decimal string for aremote controller] |<br>| –port=PORT                        | [port integer for a listening remote controller] |<br>| –innamespace                      | sw and ctrl in namespace |<br>| –listenport=LISTENPORT            | [base port for passive switch listening controller] |<br>| –nolistenport                     | don’t use passive listening port |<br>| –pre=PRE                          | [CLI script to run before tests] |<br>| –post=POST                        | [CLI script to run after tests] |</p></li><li><p>Mininet常用命令总结：</p><p>|命令|作用|<br>|—-|—-|<br>|help|默认列出所有命令文档，后面加命令名将介绍该命令用法 dump打印节点信息|<br>|gterm|给定节点上开启gnome-terminal 注：可能导致mn崩溃|<br>|xterm|给定节点上开启xterm|<br>|intfs|列出所有的网络接口|<br>|iperf|两个节点之间进行简单的iPerf TCP测试|<br>|iperfudp|两个节点之间用制定带宽UDP进行测试|<br>|net|显示网络链接情况|<br>|noecho|运行交互式窗口，关闭回应（echoing）|<br>|pingpair|在前两个主机之间互Ping测试|<br>|source|从外部文件中读入命令|<br>|dpctl|在所有交换机上用dptcl执行相关命令，本地为tcp 127.0.0.1:6634|<br>|link|禁用或启用两个节点之间的链路|<br>|nodes|列出所有的节点信息|<br>|pingall|所有主机节点之间互Ping|<br>|py|执行Python表达式|<br>|sh|运行外部shell命令|<br>|quit/exit|退出|</p></li></ol><h3 id="实际构建拓扑"><a href="#实际构建拓扑" class="headerlink" title="实际构建拓扑"></a>实际构建拓扑</h3><ol><li><p>构建single拓扑:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --topo&#x3D;single,3</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210903174617790.png" alt="image-20210903174617790"></p><p><code>exit</code>退出</p><p>single拓扑中整个网络拓扑中交换机有且仅有一个，交换机下面可以挂一个或者多个主机；本例会创建一个交换机，3个主机，3个主机挂在一个交换机下面</p></li><li><p>构建linear拓扑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --topo&#x3D;linear,3</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210903174730214.png" alt="image-20210903174730214"></p><p>线性拓扑中交换机连接呈线性排列，每一个交换机连接的主机数目只有一个，本例创建了3个交换机，3个主机，3个主机挂在各自交换机下面并且交换机之间互相连接</p></li><li><p>构建tree拓扑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --topo&#x3D;tree,depth&#x3D;2,fanout&#x3D;2</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210903175036157.png" alt="image-20210903175036157"></p><p>创建了一个数，s1为根，下面是s2,s3,然后s2,s3各自挂两个主机；depth表示交换机深度，fanout表示每一层的节点数量；</p></li><li><p>创建自定义拓扑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;openlab&#x2F;openlab&#x2F;mininet&#x2F;custom</span><br><span class="line">sudo mn --custom topo-2sw-2host.py --topo mytopo</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210903175436545.png" alt="image-20210903175436545"></p><p>python 脚本如下:</p><p><img src="/picture/image-20210903175538940.png" alt="image-20210903175538940"></p></li></ol><h3 id="内部交互命令"><a href="#内部交互命令" class="headerlink" title="内部交互命令"></a>内部交互命令</h3><ol><li>使用net显示连接信息</li><li>使用nodes查看节点信息</li><li>使用links查看连路鲁棒性信息</li><li>使用pingall验证所有主机间通信查看结果</li><li>使用xterm h1 h2进入设备可视化操作界面</li><li>exit退出</li><li>mn -c 清楚释放Mininet构建配置的交换机及主机</li></ol><h3 id="可视化构建"><a href="#可视化构建" class="headerlink" title="可视化构建"></a>可视化构建</h3><ol><li><p>使用MiniEdit</p><p>在mininet/examples下执行miniedit.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;miniedit.py</span><br></pre></td></tr></table></figure></li><li><p>如下图，可以选择的助教有：主机，OpenFlow交换机，传统交换机，传统路由器，链路，控制器：</p><p><img src="/picture/image-20210903180059575.png" alt="image-20210903180059575"></p></li><li><p>Miniedit属性配置</p><p>在左侧设备列表中选中需要的设备，在右侧空白区域单击，设备即添加成功。设备及链路上可进行鼠标右击长按，选择Properties即可对其进行配置。在控制器上进行鼠标右击长按，选择Properties即可对控制器进行配置:</p><p><img src="/picture/image-20210903180311795.png" alt="image-20210903180311795"></p><p>然后修改了交换机，选择Porperties，配置了16位的DPID：</p><p><img src="/picture/image-20210903180550232.png" alt="image-20210903180550232"></p><p>然后修改了主机的IP地址：</p><p><img src="/picture/image-20210903180606359.png" alt="image-20210903180606359"></p><p>修改的同时miniedit.py会在窗口中显示修改的设备属性<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210903180633749.png" alt="image-20210903180633749" title="">                </div>                <div class="image-caption">image-20210903180633749</div>            </figure></p></li><li><p>全局配置</p><p>Miniedit左上角Edit可以剪切删除设备，对整个网络进行全局配置</p><p><img src="/picture/image-20210903180728737.png" alt="image-20210903180728737"></p></li><li><p>点击左下角run即可运行设置好的网络拓扑</p><p><img src="/picture/image-20210903180824459.png" alt="image-20210903180824459"></p><p>然后此时对交换机主机右击常看可以查看交换机的bridge信息以及打开host终端</p></li><li><p>Minideit保存脚本</p><p>File–Export Level 2 Scirpt可以保存为python脚本，默认在mininet/examples下面，用 chomod给权限之后直接运行可以直接重现</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 temp.py</span><br><span class="line">sudo .&#x2F;temp.py</span><br></pre></td></tr></table></figure></li></ol><h2 id="Mininet-调用API扩展自定义拓扑"><a href="#Mininet-调用API扩展自定义拓扑" class="headerlink" title="Mininet 调用API扩展自定义拓扑"></a>Mininet 调用API扩展自定义拓扑</h2><ol><li>Mininet作为一个基于Python的网络仿真工具，可以分为两大部分:Python库和运行文件。前者对网络中元素进行抽象和实现，例如定义主机类来表示网络中的一台主机;后者则基于这些库完成模拟过程。<br>topo 类中包含构建网络的函数如：<ul><li>addHost(“host name”): 添加主机</li><li>addSwitch(“sw name”): 添加交换机</li><li>addLink(node,node): 添加链路</li><li>attach(port):添加端口</li></ul></li></ol><ol start="2"><li><p>首先使用自定义拓扑:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --custom topo-2sw-2host.py --topo mytopo</span><br></pre></td></tr></table></figure></li><li><p>添加主机h3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py net.addHost(‘h3’)</span><br></pre></td></tr></table></figure></li><li><p>添加s3与主机h3之间的链路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py net.addLink(s3,net.get(‘h3’))</span><br></pre></td></tr></table></figure></li><li><p>在Mininet交互环境中添加端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py s3.attach(‘s3-eth3’)</span><br></pre></td></tr></table></figure></li><li><p>在Mininet交互环境中对主机进行配置IP地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py net.get(‘h3’).cmd(‘ifconfig h3-eth0 10.3’)</span><br></pre></td></tr></table></figure></li><li><p>查看节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dump</span><br><span class="line">nodes</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210903221343833.png" alt="image-20210903221343833"></p></li><li><p>验证连通性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h1 ping h3</span><br><span class="line">pingall</span><br></pre></td></tr></table></figure></li></ol><h2 id="Mininet-流表应用实战1——手动添加流表"><a href="#Mininet-流表应用实战1——手动添加流表" class="headerlink" title="Mininet 流表应用实战1——手动添加流表"></a>Mininet 流表应用实战1——手动添加流表</h2><ol><li><p>自定义拓扑脚本文件exper1.py，脚本代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"><span class="keyword">from</span> mininet.net <span class="keyword">import</span> Mininet</span><br><span class="line"><span class="keyword">from</span> mininet.node <span class="keyword">import</span> RemoteController</span><br><span class="line"><span class="keyword">from</span> mininet.link <span class="keyword">import</span> TCLink</span><br><span class="line"><span class="keyword">from</span> mininet.util <span class="keyword">import</span> dumpNodeConnections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTopo</span><span class="params">( Topo )</span>:</span></span><br><span class="line">    <span class="string">"Simple topology example."</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">( self )</span>:</span></span><br><span class="line">        <span class="string">"Create custom topo."</span></span><br><span class="line">        <span class="comment"># Initialize topology</span></span><br><span class="line">        Topo.__init__( self )</span><br><span class="line">        <span class="comment"># Add hosts and switches</span></span><br><span class="line">        Host1 = self.addHost(h1)</span><br><span class="line">        Host2 = self.addHost(h2)</span><br><span class="line">        Host3 = self.addHost(h3)</span><br><span class="line">        Switch1 = self.addSwitch(s1)</span><br><span class="line">        Switch2 = self.addSwitch(s2)</span><br><span class="line">        <span class="comment"># Add links</span></span><br><span class="line">        self.addLink( Host1, Switch1 )</span><br><span class="line">        self.addLink( Host2, Switch1 )</span><br><span class="line">        self.addLink( Host3, Switch2 )</span><br><span class="line">        self.addLink( Switch1, Switch2 )</span><br><span class="line">topos = &#123;mytopo: ( <span class="keyword">lambda</span>: MyTopo() ) &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行脚本并且远程指定一个不存在的控制器，使交换机不受控制器控制；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --custom exper1.py --topo mytopo --controller&#x3D;remote,ip&#x3D;127.0.0.1,port&#x3D;6653</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210906210457031.png" alt="image-20210906210457031"></p></li><li><p>使用如下命令打开可视化终端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xterm h1 h2 h3</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210906210631094.png" alt="image-20210906210631094"></p></li><li><p>使用如下命令<code>dpctl dump-flows</code>查看交换机当前的flow table信息。</p><p><img src="/picture/image-20210906211022175.png" alt="image-20210906211022175"></p><p>可以看到交换机s1 s2中没有流表</p></li><li><p>h2中使用<code>tcp dump -n -i h2-eth0</code>抓取网卡h2-eth0上的数据包</p><p>h3中使用<code>tcp dump -n -i h3-eth0</code>抓取网卡h2-eth0上的数据包</p></li><li><p>在主机h1中执行如下命令分别ping主机h2和h3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ping -c 3 10.0.0.2</span><br><span class="line"># ping -c 3 10.0.0.3</span><br></pre></td></tr></table></figure></li><li><p>在主机h2和h3上查看tcpdump抓包结果。</p><p><img src="/picture/image-20210907023743542.png" alt="image-20210907023743542"></p><p>发现主机h1ping h2和h3都失败了，主机h2和h3么有收到任何ICMP ecjp reqiest packet。原理解析：ping操作时，由于拓扑里没有SDN控制器，也没有用dptcl给OpenFlow交换机添加任何flow entry,所以交换机不会做转发决定，并直接丢弃h1到h2及h1到h3的ping包。</p></li><li><p>添加流表</p><p>执行如下命令添加交换机端口流表使主机h1和h2通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; dpctl add-flow in_port&#x3D;1,actions&#x3D;output:2</span><br><span class="line">mininet&gt; dpctl add-flow in_port&#x3D;2,actions&#x3D;output:1</span><br></pre></td></tr></table></figure><p>然后使用dpctl dump-flows查看流表，发现添加成功:</p><p><img src="/picture/image-20210907025832428.png" alt="image-20210907025832428"></p></li><li><p>再次 ping,发现h2可以ping通,h3不可以:</p><p><img src="/picture/image-20210907025905095.png" alt="image-20210907025905095"></p><p>原理解析：用dpctl对交换机添加flow，让交换机从s1-eth1这个端口接收到的所有traffic都从s1-eth2这个端口发出去。用dpctl给交换机添加双向流表，因为ping包除了echo request还有echo reply。所以还需要用dpctl对交换机添加flow，让交换机从s1-eth2这个端口接收到的所有traffic都从s1-eth1这个端口发出去。添加这两条flow后，h1能够ping通h2，但是并没有为h1和h3之间添加对应的端口流表，所以h1与h3不通。</p></li><li><p>添加协议流表使h1/h2通信:</p><p>执行如下命令删除之前通过端口添加的流表并且查看，确保交换机流表为空:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpctl del-flows</span><br><span class="line">dpctl dump-flows</span><br></pre></td></tr></table></figure></li><li><p>执行如下命令添加两条traffic类型为IPV4协议相关的flow entry并且查看下发的流表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpctl add-flow dl_type&#x3D;0x0800,nw_dst&#x3D;10.0.0.2,actions&#x3D;output:2</span><br><span class="line">dpctl add-flow dl_type&#x3D;0x0800,nw_dst&#x3D;10.0.0.1,actions&#x3D;output:1</span><br><span class="line">dpctl dump-flows</span><br></pre></td></tr></table></figure></li><li><p>执行命令ping h2 和h3：</p><pre><code>![image-20210907030326211](/picture/image-20210907030326211.png)</code></pre></li></ol><p>​    可以看到无法ping通</p><ol start="13"><li><p>在主机h2,h3上面查看:</p><p><img src="/picture/image-20210907030627886.png" alt="image-20210907030627886"></p><p>原理解析：用dpctl对交换机添加flow，让交换机把所有EtherType为0x0800（IPv4）并且destiation IP为10.0.0.2的traffic从s1-eth2这个端口发出去。用dpctl对交换机添加flow，让交换机把所有EtherType为0x0800（IPv4）并且destiation IP为10.0.0.1的traffic从s1-eth1这个端口发出去。但处在同一网段下的主机，它们之间的交流是L2 forwarding，需要靠ARP来解析MAC地址，之前只匹配了0x0800(IPv4)协议，并没有匹配到0x0806(ARP)，这样当交换机收到h1的ARP包后，因为没有控制器，flow table里面也没有相应的flow告诉它如何转发这个ARP包，交换机只能将它丢弃，从而导致h1 ping h2失败，所以需要添加ARP协议的流表来使通信。</p></li><li><p>执行命令<code>dpctl add-flow dl_type=0x0806,actions=NORMAL</code>添加ARP(0x0806)协议相关的流表，让交换机以NORMAL形式（广播）将所有ARP包从各个端口广播出去:</p></li><li><p>执行dpctl dump-flows查看:</p><p><img src="/picture/image-20210907030845798.png" alt="image-20210907030845798"></p><p>然后ping h2和h3 发现可以ping通h2:</p><p><img src="/picture/image-20210907030928420.png" alt="image-20210907030928420"></p><p><img src="/picture/image-20210907030936961.png" alt="image-20210907030936961"></p></li></ol><h2 id="Mininet流表应用实战——控制器下发流表协议分析"><a href="#Mininet流表应用实战——控制器下发流表协议分析" class="headerlink" title="Mininet流表应用实战——控制器下发流表协议分析"></a>Mininet流表应用实战——控制器下发流表协议分析</h2><ol><li>实验原理：在SDN环境下，当交换机收到一个数据包并且交换机中没有与改数据包匹配的流表项的时候，交换机将此数据包发给控制器，由控制器决策数据包如何处理，控制器下发决策后，交换机根据控制器下发的信息来进行数据包的处理，即转发或者丢弃这个数据包。</li><li>这个实验做了一下，基本就是控制器，主机两个，主机上进行抓包然后分析协议</li></ol><h2 id="Mininet-多数据中心网络拓扑流量带宽实验"><a href="#Mininet-多数据中心网络拓扑流量带宽实验" class="headerlink" title="Mininet 多数据中心网络拓扑流量带宽实验"></a>Mininet 多数据中心网络拓扑流量带宽实验</h2><ol><li>使用mininet中的iperf工具在网络中生成UDP流量，iperf客户端传送数据流到iperf的服务端，由服务端接收并记录相关信息。网络性能评估中一个巨大的挑战就是如何生成真实的网络流量，可以通过程序来创造人工的网络流量，通过建立测试环境来模拟真实的状况。此应用主要以数据中心网络为目标场景，在mininet仿真环境中尽可能地还原数据中心内部的真实流量情况。</li><li><p>Mininet数据中心应用价值：</p><ul><li>树状拓扑结构容错能力强</li><li>降低数据中心成本消耗</li><li>提供重新排列的全带宽无阻碍路径</li><li>提高带宽利用率</li><li>分析数据中心网络流量性能</li><li>为真实数据中心和仿真测试床提供有用信息</li></ul></li><li><p>在mininet中进行自定义命令iperfmulti功能拓展主要分为4步：<br> 1.修改mininet/net.py<br> 2.修改mininet/cli.py<br> 3.修改bin/mn<br> 4.重新安装Mininet核心文件：~/mininet/util/install.sh -n</p></li><li><p>实验拓扑:</p><p><img src="/picture/image-20210907215209183.png" alt="image-20210907215209183"></p></li><li><p>实验设备：</p><p><img src="/picture/image-20210907221043663.png" alt="image-20210907221043663"></p></li></ol><h3 id="编写网络带宽测试程序"><a href="#编写网络带宽测试程序" class="headerlink" title="编写网络带宽测试程序"></a>编写网络带宽测试程序</h3><ol><li><p>在mininet/net.py中的”def iperf”下面添加定义iperf_single()函数实现两个主机间的iperf udp 测试,代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iperf_single</span><span class="params">( self,hosts=None, udpBw=<span class="string">'10M'</span>, period=<span class="number">60</span>, port=<span class="number">5001</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Run iperf between two hosts using UDP.</span></span><br><span class="line"><span class="string">           hosts: list of hosts; if None, uses opposite hosts</span></span><br><span class="line"><span class="string">           returns: results two-element array of server and client speeds"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hosts:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> len( hosts ) == <span class="number">2</span></span><br><span class="line">        client, server = hosts</span><br><span class="line">        filename = client.name[<span class="number">1</span>:] + <span class="string">'.out'</span></span><br><span class="line">        output( <span class="string">'*** Iperf: testing bandwidth between '</span> )</span><br><span class="line">        output( <span class="string">"%s and %s\n"</span> % ( client.name, server.name ) )</span><br><span class="line">        iperfArgs = <span class="string">'iperf -u '</span></span><br><span class="line">        bwArgs = <span class="string">'-b '</span> + udpBw + <span class="string">' '</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"***start server***"</span></span><br><span class="line">        server.cmd( iperfArgs + <span class="string">'-s -i 1'</span> + <span class="string">' &gt; /home/sdnlab/log/'</span> + filename + <span class="string">'&amp;'</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"***start client***"</span></span><br><span class="line">        client.cmd(</span><br><span class="line">            iperfArgs + <span class="string">'-t '</span>+ str(period) + <span class="string">' -c '</span> + server.IP() + <span class="string">' '</span> + bwArgs</span><br><span class="line">            +<span class="string">' &gt; /home/sdnlab/log/'</span> + <span class="string">'client'</span> + filename +<span class="string">'&amp;'</span>)</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210907220635571.png" alt="image-20210907220635571"></p></li><li><p>在Mininet类中添加自定义命令iperfmulti()函数，这个函数的作用使实现为每一台主机随机选择另一台主机作为iperf的服务器段，通过调用iperf_single，自身以客户端的身份按照指令参数发送UDP流，服务器生成的报告以重定向的方式输出到文件中。使用iperfmulti命令，主机随机地向另一台主机发起一个恒定带宽的UDP数据流。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iperfMulti</span><span class="params">(self, bw, period=<span class="number">60</span>)</span>:</span></span><br><span class="line">       base_port = <span class="number">5001</span></span><br><span class="line">       server_list = []</span><br><span class="line">       client_list = [h <span class="keyword">for</span> h <span class="keyword">in</span> self.hosts]</span><br><span class="line">       host_list = []</span><br><span class="line">       host_list = [h <span class="keyword">for</span> h <span class="keyword">in</span> self.hosts]</span><br><span class="line">   </span><br><span class="line">       cli_outs = []</span><br><span class="line">       ser_outs = []</span><br><span class="line">   </span><br><span class="line">       _len = len(host_list)</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, _len):</span><br><span class="line">           client = host_list[i]</span><br><span class="line">           server = client</span><br><span class="line">           <span class="keyword">while</span>( server == client ):</span><br><span class="line">               server = random.choice(host_list)</span><br><span class="line">           server_list.append(server)</span><br><span class="line">           self.iperf_single(hosts = [client, server], udpBw=bw, period= period, port=base_port)</span><br><span class="line">           sleep(<span class="number">.05</span>)</span><br><span class="line">           base_port += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">       sleep(period)</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"test has done"</span></span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210907220651767.png" alt="image-20210907220651767"></p></li><li><p>打开/mininet/cli.py文件，加入如下代码，注册iperfmulti命令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_iperfmulti</span><span class="params">( self, line )</span>:</span></span><br><span class="line">        <span class="string">"""Multi iperf UDP test between nodes"""</span></span><br><span class="line">        args = line.split()</span><br><span class="line">        <span class="keyword">if</span> len(args) == <span class="number">1</span>:</span><br><span class="line">            udpBw = args[ <span class="number">0</span> ]</span><br><span class="line">            self.mn.iperfMulti(udpBw)</span><br><span class="line">        <span class="keyword">elif</span> len(args) == <span class="number">2</span>:</span><br><span class="line">            udpBw = args[ <span class="number">0</span> ]</span><br><span class="line">            period = args[ <span class="number">1</span> ]</span><br><span class="line">            err = <span class="literal">False</span></span><br><span class="line">            self.mn.iperfMulti(udpBw, float(period))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error(<span class="string">'invalid number of args: iperfmulti udpBw period\n'</span> +<span class="string">'udpBw examples: 1M 120\n'</span>)</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20210907220705100.png" alt="image-20210907220705100"></p></li><li><p>使用<code>sudo vim mininet/bin/mn</code>，加入iperfmulti可执行命令:</p><p><img src="/picture/image-20210907220743581.png" alt="image-20210907220743581"></p></li><li><p>执行如下命令重新编译Mininet:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd openlab&#x2F;mininet&#x2F;util</span><br><span class="line">.&#x2F;install.sh -n</span><br></pre></td></tr></table></figure></li><li><p>使用sudo mn 创建一个topo查看是否存在iperfmulti命令，作为验证：</p><p><img src="/picture/image-20210907220846860.png" alt="image-20210907220846860"></p></li></ol><h3 id="构建多数据中心拓扑"><a href="#构建多数据中心拓扑" class="headerlink" title="构建多数据中心拓扑"></a>构建多数据中心拓扑</h3><ol><li><p>在/mininet/custom中创建fattree.py，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="string">"""Custom topology example</span></span><br><span class="line"><span class="string">Adding the 'topos' dict with a key/value pair to generate our newly defined</span></span><br><span class="line"><span class="string">topology enables one to pass in '--topo=mytopo' from the command line.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"><span class="keyword">from</span> mininet.net <span class="keyword">import</span> Mininet</span><br><span class="line"><span class="keyword">from</span> mininet.node <span class="keyword">import</span> RemoteController,CPULimitedHost</span><br><span class="line"><span class="keyword">from</span> mininet.link <span class="keyword">import</span> TCLink</span><br><span class="line"><span class="keyword">from</span> mininet.util <span class="keyword">import</span> dumpNodeConnections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTopo</span><span class="params">( Topo )</span>:</span></span><br><span class="line">    <span class="string">"Simple topology example."</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">( self )</span>:</span></span><br><span class="line">        <span class="string">"Create custom topo."</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize topology</span></span><br><span class="line">        Topo.__init__( self )</span><br><span class="line">        L1 = <span class="number">2</span></span><br><span class="line">        L2 = L1 * <span class="number">2</span> </span><br><span class="line">        L3 = L2</span><br><span class="line">        c = []</span><br><span class="line">        a = []</span><br><span class="line">        e = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add core ovs  </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range( L1 ):</span><br><span class="line">                sw = self.addSwitch( <span class="string">'c&#123;&#125;'</span>.format( i + <span class="number">1</span> ) )</span><br><span class="line">                c.append( sw )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add aggregation ovs</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range( L2 ):</span><br><span class="line">                sw = self.addSwitch( <span class="string">'a&#123;&#125;'</span>.format( L1 + i + <span class="number">1</span> ) )</span><br><span class="line">                a.append( sw )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add edge ovs</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range( L3 ):</span><br><span class="line">                sw = self.addSwitch( <span class="string">'e&#123;&#125;'</span>.format( L1 + L2 + i + <span class="number">1</span> ) )</span><br><span class="line">                e.append( sw )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add links between core and aggregation ovs</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range( L1 ):</span><br><span class="line">                sw1 = c[i]</span><br><span class="line">                <span class="keyword">for</span> sw2 <span class="keyword">in</span> a[i/<span class="number">2</span>::L1/<span class="number">2</span>]:</span><br><span class="line">                <span class="comment"># self.addLink(sw2, sw1, bw=10, delay='5ms', loss=10, max_queue_size=1000, use_htb=True)</span></span><br><span class="line">                        self.addLink( sw2, sw1 )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add links between aggregation and edge ovs</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range( <span class="number">0</span>, L2, <span class="number">2</span> ):</span><br><span class="line">                <span class="keyword">for</span> sw1 <span class="keyword">in</span> a[i:i+<span class="number">2</span>]:</span><br><span class="line">                    <span class="keyword">for</span> sw2 <span class="keyword">in</span> e[i:i+<span class="number">2</span>]:</span><br><span class="line">                        self.addLink( sw2, sw1 )</span><br><span class="line"></span><br><span class="line">        <span class="comment">#add hosts and its links with edge ovs</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> sw1 <span class="keyword">in</span> e:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                    host = self.addHost( <span class="string">'h&#123;&#125;'</span>.format( count ) )</span><br><span class="line">                    self.addLink( sw1, host )</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">topos = &#123; <span class="string">'mytopo'</span>: ( <span class="keyword">lambda</span>: MyTopo() ) &#125;</span><br></pre></td></tr></table></figure><p>Mininet创建网络拓扑的代码中，可以通过改变代码中定义的L1变量来设置核心交换机的数量，并通过添加额外的交换机和链路来构成更复杂的数据中心网络拓扑。随着边缘交换机的增加，主机个数也随之增长，利用Mininet的易用性和扩展性，可以创建基于多种数据中心场景下的网络拓扑，达到更好更全面的实验效果。</p></li><li><p>在控制器主机上面用ifconfig看主机的ip:</p><p><img src="/picture/image-20210907221233085.png" alt="image-20210907221233085"></p></li><li><p>在host，也就是mininet所在的主机上面使用如下命令生成测试拓扑结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --custom fattree.py --topo mytopo --controller&#x3D;remote,ip&#x3D;30.0.1.69,port&#x3D;6653</span><br></pre></td></tr></table></figure><p>这里ip以上面查出来的为准；</p><p>用<code>pingall</code>验证连通性</p></li><li><p>控制器上通过OPENDAYLIGHT，在浏览器:<code>http://30.0.1.69:8181/index.html</code>中可以看到ODL控制器。查看拓扑如下:</p><p><img src="/picture/image-20210907221616586.png" alt="image-20210907221616586"></p></li><li><p>在mininet主机上面可以iperf h1 h2测主机间带宽</p></li><li><p>使用<code>iperfmulti 0.025M</code>可以看到8太主机随机向另外的主机发数据包，然后数据记录在/home/sdnlab/log里面。</p><p><img src="/picture/image-20210907221750866.png" alt="image-20210907221750866"></p></li></ol><blockquote><p>这个实验可以用来借鉴测试速度之类的实验</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mininet-学习&quot;&gt;&lt;a href=&quot;#Mininet-学习&quot; class=&quot;headerlink&quot; title=&quot;Mininet 学习&quot;&gt;&lt;/a&gt;Mininet 学习&lt;/h1&gt;&lt;p&gt;来自&lt;a href=&quot;https://www.51openlab.com/c
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="http://Tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="实验基础" scheme="http://Tyler-ytr.github.io/tags/%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="mininet" scheme="http://Tyler-ytr.github.io/tags/mininet/"/>
    
  </entry>
  
  <entry>
    <title>cs144_1</title>
    <link href="http://Tyler-ytr.github.io/2021/08/02/cs144-1/"/>
    <id>http://Tyler-ytr.github.io/2021/08/02/cs144-1/</id>
    <published>2021-08-02T08:21:32.000Z</published>
    <updated>2021-08-26T13:43:35.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS144"><a href="#CS144" class="headerlink" title="CS144"></a>CS144</h2><p>整体参考<a href="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html;https://juejin.cn/post/6929693406528536583#heading-6" target="_blank" rel="noopener">https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html;https://juejin.cn/post/6929693406528536583#heading-6</a></p><p>整体实验来自<a href="https://cs144.github.io/" target="_blank" rel="noopener">https://cs144.github.io/</a></p><p>查重可以参考 <a href="https://github.com/jplag/jplag；简略说明：https://canjuly.github.io/2019/04/15/JPlag/" target="_blank" rel="noopener">https://github.com/jplag/jplag；简略说明：https://canjuly.github.io/2019/04/15/JPlag/</a></p><h3 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h3><p>工作量 5-8小时 可能？    </p><ol><li><p><strong>虚拟机安装</strong></p><blockquote><p>安装虚拟机镜像之后，记得修改内存，处理器；</p><p>在windows terminal 使用<code>ssh -p 2222 cs144@localhost</code>，或者在mobaxterm 访问地址为127.0.0.1 名称为cs144 端口号为22的session</p></blockquote><p>GUI:<code>sudo apt-get install --reinstall lightdm</code></p><p>启动GUI<code>sudo systemctl start lightdm</code></p></li><li><p><strong>Networking by hand</strong></p><ol><li><p>访问 <a href="http://cs144.keithw.org/hello" target="_blank" rel="noopener">http://cs144.keithw.org/hello</a> </p><p>如果不想安装图形界面，可以安装w3m,然后使用<code>w3m  http://cs144.keithw.org/hello</code>访问网页</p></li><li><p>使用telnet访问<a href="http://cs144.keithw.org/hello" target="_blank" rel="noopener">http://cs144.keithw.org/hello</a> 的时候要注意根据文件提示使用</p><p>如果用了退出键会进入<code>telnet &gt;</code></p></li><li><p>发邮件那个实验可以参考163邮箱发邮件这个博客</p><p><a href="https://blog.csdn.net/qq_33862644/article/details/79339532" target="_blank" rel="noopener">https://blog.csdn.net/qq_33862644/article/details/79339532</a></p><p>qq邮箱参考 <a href="https://www.cnblogs.com/cthon/p/9151467.html" target="_blank" rel="noopener">https://www.cnblogs.com/cthon/p/9151467.html</a></p><p>以下是QQ邮箱：</p><ol><li><p>base64编码:</p><blockquote><p>601576661 NjAxNTc2NjYx</p><p>amd1dXd6ZnN3dG1uYmNn??== 这个由设置-&gt; 账户-&gt; POP3/ SMTP服务开启之后得到的权限码获得的 然后经过base64编码之后的产物,最后两位5我用??代替</p></blockquote></li><li><p>操作过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cs144@cs144vm:~$ telnet smtp.qq.com 25</span><br><span class="line">Trying 203.205.232.7...</span><br><span class="line">Connected to smtp.qq.com.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line">220 newxmesmtplogicsvrsza28.qq.com XMail Esmtp QQ Mail Server.</span><br><span class="line">helo larry</span><br><span class="line">250-newxmesmtplogicsvrsza28.qq.com-10.62.17.92-20691606</span><br><span class="line">250-SIZE 73400320</span><br><span class="line">250 OK</span><br><span class="line">auth login</span><br><span class="line">334 VXNlcm5hbWU6</span><br><span class="line">NjAxNTc2NjYx</span><br><span class="line">334 UGFzc3dvcmQ6</span><br><span class="line">amd1dXd6ZnN3dG1uYmNn??&#x3D;&#x3D;</span><br><span class="line">235 Authentication successful</span><br><span class="line">mail from:&lt;601576661@qq.com&gt;</span><br><span class="line">250 OK.</span><br><span class="line">rcot to:&lt;492671684@qq.com&gt;</span><br><span class="line">502 Invalid input from 100.107.4.130 to newxmesmtplogicsvrsza28.qq.com</span><br><span class="line">rcpt to:&lt;492671684@qq.com&gt;</span><br><span class="line">250 OK</span><br><span class="line">data</span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;. &#x2F;&#x2F;注意这个是end data的方法</span><br><span class="line">to: hello &#x2F;&#x2F;这个显示出来是 发件人: hello</span><br><span class="line">from: test &#x2F;&#x2F;这个显示出来是 收件人: test</span><br><span class="line">subject: this is a test.&#x2F;&#x2F;这个是标题</span><br><span class="line">hello telnet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">250 OK: queued as.</span><br><span class="line"></span><br><span class="line">502 Invalid input from 100.107.4.130 to newxmesmtplogicsvrsza28.qq.com</span><br><span class="line">quit&#x2F;&#x2F;使用quit退出</span><br></pre></td></tr></table></figure></li></ol></li><li><p>netcat 小实验 体验一下，可以用tmux分屏</p></li></ol></li><li><p><strong>Writing a network program using an OS stream socket</strong></p><ol><li><p>这块需要阅读文档，重点要阅读<a href="https://cs144.github.io/doc/lab0/class_t_c_p_socket.html#details" target="_blank" rel="noopener"><strong>TCPSocket</strong>  类</a> 里面的样例</p><p>具体实现不是那么复杂</p></li><li><p>有可能有必要演示怎么debug 用vscode+插件</p></li></ol></li><li><p><strong>An in-memory reliable byte stream</strong></p><ol><li>这块编程是C++ 11;可能预先需要讲一下面向对象？<a href="https://github.com/0voice/cpp_new_features" target="_blank" rel="noopener">https://github.com/0voice/cpp_new_features</a></li><li>需要提示一下STL库啥的</li></ol></li></ol><h3 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h3><ol><li>比较复杂，为了提高速度需要利用STL的set或者其他基于红黑树的数据结构</li><li>任务目标是实现一个流重组器（stream reassembler），可以将带索引的字节流碎片重组成有序的字节流。</li><li>可能需要提前教授GDB，或者VS code 代码调试的方法</li><li>大概需要1-2天 5-10小时</li><li>建议提示使用STL set，可能得给一个类似于线段树的数据结构？</li></ol><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><ol><li><p>实现TCP Receiver，这是TCP实现中处理传入字元流的部分。TCPReceiver在传入的TCP段(通过Internet携带的数据报的有效负载)和传入的字节流之间进行转换；</p><p>总的来说接收端除了写入到来的流，还有两个工作：</p><ol><li>告诉发送端ackno; This is the first byte that the receiver needs from the sender.</li><li>告诉发送端window size:the distance between the “first unassembled” index and the “first unacceptable” index</li></ol></li><li><p>第一部分是实现wrapping_integers，这个用途是实现序列号、绝对序列号与流索引间的转换。</p><p>这一部分不是很困难，我觉得1个小时连带搜索应该可以解决；如果要提示的话可以提示比特运算，与或什么的；同时可以提供<a href="http://c.biancheng.net/cpp/biancheng/view/3297.html" target="_blank" rel="noopener">C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast</a> 这类作为写32位数字的提示；另外需要提醒他们查一查位运算，比如<a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="noopener">bithacks</a>,无符号长整型1(1ul)；</p></li></ol><ol start="3"><li><p>第二部分时实现TCP_receiver;这部分会讲TCP段的格式，需要实现一个接收器，基于滑动窗口算法；</p><ol><li><p>文档比较丰富，这块会比较花时间；与此同时 细节比较多</p></li><li><p>segment_received接口从bool改成了void;</p><p>之前的如果段的任何部分在窗口内，则返回true；现在直接是void;这部分业务工作不确定是不是调整到了lab4;讲义中并没有找到;</p></li><li><p>事实上我做的时候觉得没有博客那么复杂，因为减少了一个判断在不在窗口这个部分;实际上要考虑的就是SYN，初始化ISN，计算要装入Lab1 ressembler里面的东西的index以及payload即可;</p></li></ol></li></ol><h3 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h3><ol><li>本节比较复杂，需要花一段时间理解逻辑</li><li></li></ol><h3 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h3><p>复刻的困难是这个用到了斯坦福的服务器，具体看<a href="https://github.com/CS144/sponge/blob/lab4-startercode/tun.sh;服务器的配置在https://github.com/CS144/sponge/blob/lab4-startercode/etc/tunconfig;他们的服务器是169.254.1.1/24" target="_blank" rel="noopener">https://github.com/CS144/sponge/blob/lab4-startercode/tun.sh;服务器的配置在https://github.com/CS144/sponge/blob/lab4-startercode/etc/tunconfig;他们的服务器是169.254.1.1/24</a> 可能也有169.254.1.0/24；</p><p>另外在<a href="https://github.com/CS144/sponge/blob/lab4-startercode/txrx.sh" target="_blank" rel="noopener">https://github.com/CS144/sponge/blob/lab4-startercode/txrx.sh</a> 里面也有用到服务器的地方;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CS144&quot;&gt;&lt;a href=&quot;#CS144&quot; class=&quot;headerlink&quot; title=&quot;CS144&quot;&gt;&lt;/a&gt;CS144&lt;/h2&gt;&lt;p&gt;整体参考&lt;a href=&quot;https://www.cnblogs.com/kangyupl/p/stanford_c
      
    
    </summary>
    
      <category term="计算机实验" scheme="http://Tyler-ytr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="计算机网络" scheme="http://Tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>cn_lab1</title>
    <link href="http://Tyler-ytr.github.io/2021/08/01/cn-lab1/"/>
    <id>http://Tyler-ytr.github.io/2021/08/01/cn-lab1/</id>
    <published>2021-08-01T08:35:02.000Z</published>
    <updated>2021-08-01T08:59:07.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><p>根据<a href="https://pavinberg.gitbook.io/nju-network-lab/lab-1" target="_blank" rel="noopener">https://pavinberg.gitbook.io/nju-network-lab/lab-1</a> 进行实验</p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li><p>安装虚拟机报错；</p><p>在安装给的虚拟机的时候无法创建，报错明细如下；</p><blockquote><p><em>Implementation of the USB 2.0 controller not found!</em></p><p><em>Because the USB 2.0 controller state is part of the saved VM state, the VM cannot be started. To fix this problem, either install the ‘Oracle VM VirtualBox Extension Pack’ or disable USB 2.0 support in the VM settings.</em></p><p><em>Note! This error could also mean that an incompatible version of the ‘Oracle VM VirtualBox Extension Pack’ is installed (VERR_NOT_FOUND).”</em></p></blockquote><p>根据<a href="https://zhaokaifeng.com/?p=443" target="_blank" rel="noopener">https://zhaokaifeng.com/?p=443</a> 给的解决方法，通过禁用USB解决了这个问题；首先进入设置-&gt;USB设备-&gt;把<code>启用USB控制器</code>的勾点掉</p></li><li><p>修改分辨率那块我觉得除了VB那里安装拓展之外，内部还需要在设置(<code>setting</code>)里面进入<code>display</code>进行分辨率的设置，可以参考<a href="https://blog.csdn.net/colin_lisicong/article/details/70193556" target="_blank" rel="noopener">https://blog.csdn.net/colin_lisicong/article/details/70193556</a></p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lab1&quot;&gt;&lt;a href=&quot;#Lab1&quot; class=&quot;headerlink&quot; title=&quot;Lab1&quot;&gt;&lt;/a&gt;Lab1&lt;/h2&gt;&lt;p&gt;根据&lt;a href=&quot;https://pavinberg.gitbook.io/nju-network-lab/lab-1&quot;
      
    
    </summary>
    
      <category term="计算机实验" scheme="http://Tyler-ytr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="计算机网络" scheme="http://Tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Summer_plan</title>
    <link href="http://Tyler-ytr.github.io/2021/07/30/Summer-plan/"/>
    <id>http://Tyler-ytr.github.io/2021/07/30/Summer-plan/</id>
    <published>2021-07-30T02:53:56.000Z</published>
    <updated>2021-07-30T14:17:01.749Z</updated>
    
    <content type="html"><![CDATA[<ul><li>期望学习的知识：<ul><li>Haskell</li><li>Javascript</li><li>Leetcode刷题</li><li>C++ STL</li><li>P4</li><li>计算机网络实验部分</li></ul></li><li>初期计划（7.30+7）<ul><li>Haskell 安装之后，每日一个chapter</li><li>Leetcode每日一题<ul><li><a href="https://github.com/youngyangyang04/leetcode-master" target="_blank" rel="noopener">https://github.com/youngyangyang04/leetcode-master</a></li><li>算法基础leetcode 35,</li></ul></li><li>看完P4的PDF</li><li>Javascript DOM 编程艺术 1</li><li>C++ STL每日一到两个视频</li><li>调研计网实验</li></ul></li><li>To be done</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;期望学习的知识：&lt;ul&gt;
&lt;li&gt;Haskell&lt;/li&gt;
&lt;li&gt;Javascript&lt;/li&gt;
&lt;li&gt;Leetcode刷题&lt;/li&gt;
&lt;li&gt;C++ STL&lt;/li&gt;
&lt;li&gt;P4&lt;/li&gt;
&lt;li&gt;计算机网络实验部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="个人计划" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="plan" scheme="http://Tyler-ytr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>数据分析和拟合</title>
    <link href="http://Tyler-ytr.github.io/2021/07/12/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E6%8B%9F%E5%90%88/"/>
    <id>http://Tyler-ytr.github.io/2021/07/12/数据分析和拟合/</id>
    <published>2021-07-12T11:01:42.000Z</published>
    <updated>2021-07-12T11:05:02.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python数据拟合和分析"><a href="#python数据拟合和分析" class="headerlink" title="python数据拟合和分析"></a>python数据拟合和分析</h1><p>以下内容是我在进行webRTC拥塞控制部分进行训练集traces分析和生成的总结；举办方提供了一部分真实环境的数据，但我认为对于训练来说可能不够，因此需要自己生成一部分;</p><h2 id="数据拟合"><a href="#数据拟合" class="headerlink" title="数据拟合"></a>数据拟合</h2><p>使用fitter库进行数据的拟合；大概的效果如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210712190334719.png" alt="image-20210712190334719" title="">                </div>                <div class="image-caption">image-20210712190334719</div>            </figure><h3 id="fitter-库"><a href="#fitter-库" class="headerlink" title="fitter 库"></a>fitter 库</h3><p>fitter库的源码位置:<a href="https://github.com/cokelaer/fitter" target="_blank" rel="noopener">https://github.com/cokelaer/fitter</a></p><p>安装fitter库: <code>pip install fitter</code></p><p>fitter库的文档:<a href="https://fitter.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://fitter.readthedocs.io/en/latest/</a></p><h3 id="fitter库使用案例"><a href="#fitter库使用案例" class="headerlink" title="fitter库使用案例"></a>fitter库使用案例</h3><p>生成模拟数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # First, we create a data sample following a Gamma distribution</span><br><span class="line">&gt;&gt;&gt; from scipy import stats</span><br><span class="line">&gt;&gt;&gt; data &#x3D; stats.gamma.rvs(2, loc&#x3D;1.5, scale&#x3D;2, size&#x3D;20000)</span><br></pre></td></tr></table></figure><p>使用 fitter库进行拟合:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # We then create the Fitter object</span><br><span class="line">&gt;&gt;&gt; import fitter</span><br><span class="line">&gt;&gt;&gt; f &#x3D; fitter.Fitter(data)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # just a trick to use only 10 distributions instead of 80 to speed up the fitting</span><br><span class="line">&gt;&gt;&gt; f.distributions &#x3D; f.distributions[0:10] + [&#39;gamma&#39;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # fit and plot</span><br><span class="line">&gt;&gt;&gt; f.fit()</span><br><span class="line">&gt;&gt;&gt; f.summary()</span><br><span class="line">        sumsquare_error</span><br><span class="line">gamma          0.000095</span><br><span class="line">beta           0.000179</span><br><span class="line">chi            0.012247</span><br><span class="line">cauchy         0.044443</span><br><span class="line">anglit         0.051672</span><br><span class="line">[5 rows x 1 columns]</span><br></pre></td></tr></table></figure><p>它在使用fit函数的时候如果没有额外的参数会用scipy的80多个分布进行逐个拟合，默认的拟合时间是30秒；</p><h3 id="fitter库参数"><a href="#fitter库参数" class="headerlink" title="fitter库参数"></a>fitter库参数</h3><ol><li><p>fitter    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fitter</span>.<span class="title">fitter</span>.<span class="title">Fitter</span><span class="params">(data, xmin=None, xmax=None, bins=<span class="number">100</span>, distributions=None, timeout=<span class="number">30</span>, density=True)</span></span></span><br></pre></td></tr></table></figure><ul><li>data (list) –输入的样本数据；</li><li>xmin (float) – 如果为None，则使用数据最小值，否则将忽略小于xmin的数据；</li><li>xmax (float) – 如果为None，则使用数据最大值，否则将忽略大于xmin的数据；</li><li>bins (int) – 累积直方图的组数，默认=100；</li><li>distributions (list) – 给出要查看的分布列表。 如果没有，则尝试所有的scipy分布(80种),常用的分布distributions=[‘norm’,‘t’,‘laplace’,‘cauchy’, ‘chi2’,’ expon’, ‘exponpow’, ‘gamma’,’ lognorm’, ‘uniform’]；</li><li>verbose (bool) –</li><li>timeout – 给定拟合分布的最长时间，（默认=10s） 如果达到超时，则跳过该分布。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from fitter import Fitter</span><br><span class="line"># may take some time since by default, all distributions are tried</span><br><span class="line"># but you call manually provide a smaller set of distributions</span><br><span class="line">f &#x3D; Fitter(data, distributions&#x3D;[&#39;gamma&#39;, &#39;rayleigh&#39;, &#39;uniform&#39;])</span><br><span class="line">f.fit()</span><br><span class="line">f.summary()</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>进行fitter了之后可以调用一下函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f.fit() #fit(amp&#x3D;1, progress&#x3D;False, n_jobs&#x3D;-1)</span><br><span class="line">f.df_errors #返回这些分布的拟合质量（均方根误差的和）</span><br><span class="line">f.fitted_param #返回拟合分布的参数</span><br><span class="line">f.fitted_pdf #使用最适合数据分布的分布参数生成的概率密度</span><br><span class="line">f.summary() #返回排序好的分布拟合质量（拟合效果从好到坏）,并绘制数据分布和Nbest分布 summary(Nbest&#x3D;5, lw&#x3D;2, plot&#x3D;True, method&#x3D;&#39;sumsquare_error&#39;)</span><br><span class="line">f.get_best(method&#x3D;&#39;sumsquare_error&#39;) #返回最佳拟合分布及其参数</span><br><span class="line">f.hist() #绘制组数&#x3D;bins的标准化直方图</span><br><span class="line">f.plot_pdf(names&#x3D;None, Nbest&#x3D;3, lw&#x3D;2) #绘制分布的概率密度函数 plot_pdf(names&#x3D;None, Nbest&#x3D;5, lw&#x3D;2, method&#x3D;&#39;sumsquare_error&#39;)</span><br></pre></td></tr></table></figure></li><li><p>使用注意点</p><p>我在使用上述函数的时候f.hist()之后并没有出现图片，通过研究了它源码的issue发现比较保险的方法是import matplotlib,在 <strong>f.hist()之后加上plt.show()或者savefig()等操作</strong>，这样就能够显示图片了;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">.....</span><br><span class="line">f.hist()</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure></li></ol><h3 id="实际使用的脚本"><a href="#实际使用的脚本" class="headerlink" title="实际使用的脚本"></a>实际使用的脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批处理版</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> fitter <span class="keyword">import</span> Fitter</span><br><span class="line">f = glob.iglob(<span class="string">r'*.json'</span>)  <span class="comment"># 当前目录所有py文件，与glob区别，iglob每次只获取一个匹配路径</span></span><br><span class="line">old_picture = glob.iglob(<span class="string">r'*.jpg'</span>)</span><br><span class="line"></span><br><span class="line">result=<span class="string">"最佳拟合分布"</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        information=file+<span class="string">"\n"</span></span><br><span class="line">        trace_pattern = []</span><br><span class="line">        data = json.load(f)</span><br><span class="line">        data_intervals = data[<span class="string">"uplink"</span>][<span class="string">"trace_pattern"</span>]</span><br><span class="line">        capacity = []</span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> data_intervals:</span><br><span class="line">            capacity.append(ele[<span class="string">"capacity"</span>])</span><br><span class="line">        print(<span class="string">"capacity_mean"</span>, np.mean(capacity))</span><br><span class="line">        capacity.sort()</span><br><span class="line">        length = len(capacity)</span><br><span class="line">        capacity = capacity[<span class="number">0</span>:length<span class="number">-5</span>]</span><br><span class="line">        filter1 = Fitter(capacity,distributions=[<span class="string">"lomax"</span>,<span class="string">"pareto"</span>,<span class="string">"johnsonsu"</span>,<span class="string">"exponweib"</span>,<span class="string">"powerlognorm"</span>])</span><br><span class="line">        filter1.fit()</span><br><span class="line">        print(type(filter1.summary()))</span><br><span class="line">        print(filter1.get_best(method=<span class="string">'sumsquare_error'</span>))</span><br><span class="line">        summary=str(filter1.summary())</span><br><span class="line">        information=information+<span class="string">"summary\n"</span>+summary+<span class="string">"\n"</span></span><br><span class="line">        best_method=str(filter1.get_best(method=<span class="string">'sumsquare_error'</span>))</span><br><span class="line">        information=information+best_method</span><br><span class="line">        filter1.plot_pdf(names=<span class="literal">None</span>, Nbest=<span class="number">3</span>, lw=<span class="number">2</span>)</span><br><span class="line">        filter1.plot_pdf(names=<span class="literal">None</span>, Nbest=<span class="number">3</span>, lw=<span class="number">2</span>)</span><br><span class="line">        <span class="comment">#plt.show()</span></span><br><span class="line">        plt.savefig(<span class="string">"fit_&#123;&#125;.jpg"</span>.format(file))</span><br><span class="line">        plt.close()</span><br><span class="line">        result=result+<span class="string">"\n"</span>+information</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"fit_result.txt"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure><p>效果是批处理如下json格式的数据，会统计一个文件夹中的数据，给每一个数据绘图，并且把summary写道<code>fit_result.txt</code>中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"type"</span>: <span class="string">"video"</span>,</span><br><span class="line"> <span class="attr">"downlink"</span>: &#123;&#125;,</span><br><span class="line"> <span class="attr">"uplink"</span>: &#123;</span><br><span class="line">  <span class="attr">"trace_pattern"</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"duration"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">"capacity"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"loss"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"jitter"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="number">0.0</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"duration"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">"capacity"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"loss"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"jitter"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="number">0.0</span></span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="数据折线图"><a href="#数据折线图" class="headerlink" title="数据折线图"></a>数据折线图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">plt.plot(time_x,time_capacity)</span><br><span class="line">xlabels = [<span class="string">"&#123;&#125;"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> time_x] <span class="comment">#修改x轴的刻度</span></span><br><span class="line">plt.xticks(time_x, xlabels) </span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'row'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'column'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.savefig(<span class="string">"time_&#123;&#125;.jpg"</span>.format(</span><br><span class="line">file))</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure><h2 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h2><p>经过查阅scipy的文档以及简单了看了fitter项目的源码，上面get_best()得到的形如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;johnsonsu&#39;: (-0.43618926054816165, 1.8086581271068694, 26026.47774558232, 26854.12469365103)</span><br></pre></td></tr></table></figure><p>表示的参数为a, b, loc, scale;</p><p>具体含义见下图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210712190221706.png" alt="image-20210712190221706" title="">                </div>                <div class="image-caption">image-20210712190221706</div>            </figure><p>通过上面fitter得到的参数，可以使用如下的代码进行数据的生成，生成的格式是narray:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import scipy.stats as st</span><br><span class="line">size_t&#x3D;1500</span><br><span class="line">params&#x3D;(-0.43618926054816165, 1.8086581271068694, 26026.47774558232, 26854.12469365103)</span><br><span class="line">data&#x3D;list(st.johnsonsu.rvs(*params,size&#x3D;int(size_t))) # 格式是numpy</span><br></pre></td></tr></table></figure><h2 id="数据筛选"><a href="#数据筛选" class="headerlink" title="数据筛选"></a>数据筛选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 数据筛选</span><br><span class="line">data1&#x3D;data[:]</span><br><span class="line">for ele in data1:</span><br><span class="line">    if ele &lt; 0.0:</span><br><span class="line">        data.remove(ele)</span><br><span class="line">    if ele &gt; 400.0:</span><br><span class="line">        data.remove(ele)</span><br></pre></td></tr></table></figure><p>如果没有data1=data[:]的操作会出现无法删除的问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python数据拟合和分析&quot;&gt;&lt;a href=&quot;#python数据拟合和分析&quot; class=&quot;headerlink&quot; title=&quot;python数据拟合和分析&quot;&gt;&lt;/a&gt;python数据拟合和分析&lt;/h1&gt;&lt;p&gt;以下内容是我在进行webRTC拥塞控制部分进行训练集
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python心得" scheme="http://Tyler-ytr.github.io/tags/python%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>git以及ssh代理的配置</title>
    <link href="http://Tyler-ytr.github.io/2021/07/02/git%E4%BB%A5%E5%8F%8Assh%E4%BB%A3%E7%90%86%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://Tyler-ytr.github.io/2021/07/02/git以及ssh代理的配置/</id>
    <published>2021-07-02T07:43:45.000Z</published>
    <updated>2021-07-02T07:48:14.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git以及ssh代理的配置"><a href="#git以及ssh代理的配置" class="headerlink" title="git以及ssh代理的配置"></a>git以及ssh代理的配置</h2><p>鄢老师提供的方案并根据自己的情况进行了调整；</p><h4 id="修改ssh的config文件"><a href="#修改ssh的config文件" class="headerlink" title="修改ssh的config文件"></a>修改ssh的config文件</h4><p>文件位置在<code>C:\Users\用户名\.ssh</code></p><p>目前的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    ProxyCommand connect -H 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure><h4 id="修改gitconfig文件"><a href="#修改gitconfig文件" class="headerlink" title="修改gitconfig文件"></a>修改gitconfig文件</h4><p>文件位置在<code>C:\Users\用户名\.gitconfig</code>里面;</p><p>目前的版本:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email &#x3D; 邮箱</span><br><span class="line">name &#x3D; 名字</span><br><span class="line">[core]</span><br><span class="line">autocrlf&#x3D;input</span><br><span class="line">[socks]</span><br><span class="line">proxy&#x3D;127.0.0.1:7890</span><br><span class="line">[http &quot;http:&#x2F;&#x2F;github.com&quot;]</span><br><span class="line">proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890</span><br><span class="line">[filter &quot;lfs&quot;]</span><br><span class="line">clean&#x3D;git-lfs clean -- %f</span><br><span class="line">smudge&#x3D;git-lfs smudge -- %f</span><br><span class="line">process&#x3D;git-lfs filter-process</span><br><span class="line">required&#x3D;true</span><br></pre></td></tr></table></figure><p>如果改了代理的客户端请修改端口7890即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git以及ssh代理的配置&quot;&gt;&lt;a href=&quot;#git以及ssh代理的配置&quot; class=&quot;headerlink&quot; title=&quot;git以及ssh代理的配置&quot;&gt;&lt;/a&gt;git以及ssh代理的配置&lt;/h2&gt;&lt;p&gt;鄢老师提供的方案并根据自己的情况进行了调整；&lt;/p&gt;
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>学校服务器访问外网的配置</title>
    <link href="http://Tyler-ytr.github.io/2021/07/02/%E5%AD%A6%E6%A0%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://Tyler-ytr.github.io/2021/07/02/学校服务器访问外网的配置/</id>
    <published>2021-07-02T07:37:05.000Z</published>
    <updated>2021-07-02T07:38:25.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问外网的配置"><a href="#访问外网的配置" class="headerlink" title="访问外网的配置"></a>访问外网的配置</h1><p>服务器1命令行中使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setproxy</span><br></pre></td></tr></table></figure><p>就可以通过代理服务器1的服务器1的端口访问外网。</p><h3 id="NAT的方法-目前不用，仅作参考"><a href="#NAT的方法-目前不用，仅作参考" class="headerlink" title="NAT的方法(目前不用，仅作参考)"></a>NAT的方法(目前不用，仅作参考)</h3><p>服务器1可以上外网；服务器2不能上外网，但是在内网与服务器1互通；下面的操作是用iptables在服务器1上对服务器2搭建一个NAT; 并且修改服务器2的默认路由，达到服务器2访问外网的目的；</p><h4 id="服务器1"><a href="#服务器1" class="headerlink" title="服务器1"></a>服务器1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 服务器2 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>查看iptables：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -L</span><br></pre></td></tr></table></figure><p>带检索的查看iptables:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -L POSTROUTING --line-numbers</span><br></pre></td></tr></table></figure><p>删除刚刚操作之后的表项:(请根据查询的编号决定是不是1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -D POSTROUTING 1</span><br></pre></td></tr></table></figure><h4 id="服务器2"><a href="#服务器2" class="headerlink" title="服务器2"></a>服务器2</h4><p>查看路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>增加默认路由:(这个操作可能会让ssh连接断掉)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add default gw 服务器1</span><br></pre></td></tr></table></figure><p>删除路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route del default gw 服务器1</span><br></pre></td></tr></table></figure><h4 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程:"></a>具体实现流程:</h4><p>A表示服务器1；B表示服务器2</p><p>首先用在A上iptables -t nat -A POSTROUTING -s B的地址 -j MASQUERADE；然后SSH连接B；B上用sudo route add default gw A的地址；此时SSH 会连接B失败；然后从A上用SSH连接B；此时连接的B可以通过A的NAT访问外网然后安装v2ray;然后删除路由;退出之后在A上删除刚刚的iptables表项</p><p>iptables那步的作用是搭建了A对于B开启了nat服务;B通过修改路由把数据包转发到A上，进而访问外网;</p><p>上面的方法也是一种上网方法；只不过不是很方便</p><p>配置完之后通过v2ray访问外网;</p><h4 id="实现流程的反思"><a href="#实现流程的反思" class="headerlink" title="实现流程的反思"></a>实现流程的反思</h4><p>实际上可能不需要那么复杂。在能出外网的服务器1上面安装v2ray，更改配置文件保证http,socks5的代理就行了；不能连接外网的服务器通过export ALL_PROXY=socks5://服务器1的地址:端口;就可以出去了</p><h3 id="v2ray（目前使用）"><a href="#v2ray（目前使用）" class="headerlink" title="v2ray（目前使用）"></a>v2ray（目前使用）</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>通过来自<a href="https://github.com/v2fly/fhs-install-v2ray的脚本安装" target="_blank" rel="noopener">https://github.com/v2fly/fhs-install-v2ray的脚本安装</a>;</p><p><strong>v2ray启用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable v2ray</span><br></pre></td></tr></table></figure><p><strong>v2ray打开:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start v2ray</span><br></pre></td></tr></table></figure><p><strong>v2ray关闭:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop v2ray</span><br></pre></td></tr></table></figure><p>每次修改完配置文件之后需要重启</p><h4 id="服务器1-1"><a href="#服务器1-1" class="headerlink" title="服务器1"></a>服务器1</h4><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;log&quot;: &#123;</span><br><span class="line">&quot;access&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;access.log&quot;,</span><br><span class="line">&quot;error&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;error.log&quot;,</span><br><span class="line">&quot;loglevel&quot;: &quot;warning&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">&quot;inbounds&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">      &quot;port&quot;: 端口号,</span><br><span class="line">      &quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      &quot;port&quot;: 端口号,</span><br><span class="line">      &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;outbounds&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">&quot;settings&quot;: &#123;&#125;,</span><br><span class="line">&quot;tag&quot;: &quot;direct&quot;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;routing&quot;: &#123;</span><br><span class="line">    &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;,</span><br><span class="line">    &quot;rules&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">        &quot;outboundTag&quot;: &quot;direct&quot;,</span><br><span class="line">        &quot;domain&quot;: [&quot;geosite:cn&quot;] </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">        &quot;outboundTag&quot;: &quot;direct&quot;,</span><br><span class="line">        &quot;ip&quot;: [</span><br><span class="line">          &quot;geoip:cn&quot;, </span><br><span class="line">          &quot;geoip:private&quot; </span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置文件实现了socks5和http的代理;</p><h4 id="服务器2-1"><a href="#服务器2-1" class="headerlink" title="服务器2"></a>服务器2</h4><p>我在.bashrc里面最后添加了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias setproxy&#x3D;&quot;export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;服务器1:端口号;echo &#39;You can use &#39;unset ALL_PROXY&#39; to unset it &#39;&quot;</span><br></pre></td></tr></table></figure><p>使用setproxy即可通过服务器1访问外网;通过unset ALL_PROXY来修改回默认设置;</p><p>于此同时该服务器也安装了v2ray；有需求的同学可以自行配置;</p><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget www.baidu.com</span><br></pre></td></tr></table></figure><p>来进行连通性的测试;（不知道什么原因ping不通baidu）</p><h4 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h4><p><a href="https://www.v2ray.com/" target="_blank" rel="noopener">https://www.v2ray.com/</a></p><p><a href="https://segmentfault.com/a/1190000039686752" target="_blank" rel="noopener">https://segmentfault.com/a/1190000039686752</a></p><p><a href="https://blog.csdn.net/yelllowcong/article/details/75949296" target="_blank" rel="noopener">https://blog.csdn.net/yelllowcong/article/details/75949296</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;访问外网的配置&quot;&gt;&lt;a href=&quot;#访问外网的配置&quot; class=&quot;headerlink&quot; title=&quot;访问外网的配置&quot;&gt;&lt;/a&gt;访问外网的配置&lt;/h1&gt;&lt;p&gt;服务器1命令行中使用:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-6:实现网络测量</title>
    <link href="http://Tyler-ytr.github.io/2021/04/20/p4%E5%AD%A6%E4%B9%A0-6/"/>
    <id>http://Tyler-ytr.github.io/2021/04/20/p4学习-6/</id>
    <published>2021-04-20T04:16:42.000Z</published>
    <updated>2021-04-27T16:17:31.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="p4学习-6-实现网络测量"><a href="#p4学习-6-实现网络测量" class="headerlink" title="p4学习-6:实现网络测量"></a>p4学习-6:实现网络测量</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><p>这个练习的目标是写一个P4程序允许一个主机区检测网络中所有链路的利用情况。这个练习是在基础的<a href="https://tyler-ytr.github.io/2021/02/21/p4%E5%AD%A6%E4%B9%A0-2/">IPV4 forwarding</a>练习上搭建的。具体来说，我们将修改基本的P4程序，以处理源路由探测包，使其能够在每一跳提取出口链路利用率，并将其交付给主机进行监控。</p><p>探测包由下面三种header types组成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe</span><br><span class="line">&#x2F;&#x2F; packet has traversed so far.</span><br><span class="line">&#x2F;&#x2F;顶层的探测header,指出这个探测包经过了多少跳</span><br><span class="line">header probe_t &#123;</span><br><span class="line">    bit&lt;8&gt; hop_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The data added to the probe by each switch at each hop.</span><br><span class="line">&#x2F;&#x2F;每一个交换机加到探测包上面的数据</span><br><span class="line">header probe_data_t &#123;</span><br><span class="line">    bit&lt;1&gt;    bos;&#x2F;&#x2F;bottom of stack</span><br><span class="line">    bit&lt;7&gt;    swid;&#x2F;&#x2F;switch ID</span><br><span class="line">    bit&lt;8&gt;    port;</span><br><span class="line">    bit&lt;32&gt;   byte_cnt;&#x2F;&#x2F;和下面的寄存器应该对应</span><br><span class="line">    time_t    last_time;&#x2F;&#x2F;和下面的寄存器应该对应</span><br><span class="line">    time_t    cur_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Indicates the egress port the switch should send this probe</span><br><span class="line">&#x2F;&#x2F; packet out of. There is one of these headers for each hop.</span><br><span class="line">&#x2F;&#x2F;指示交换机应该发送该探测报文的出口端口。每个跳跃都有一个这样的 header</span><br><span class="line">header probe_fwd_t &#123;</span><br><span class="line">    bit&lt;8&gt;   egress_spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/link-monitor-topo.png" alt="topology" title="">                </div>                <div class="image-caption">topology</div>            </figure><p>拓扑如上，包含了四个主机连接到四个交换机上面，连接方式好像他们在fat tree 的pod上一样。</p><p>为了监控链路利用率，交换机将维持两个寄存器数组：</p><ul><li><code>byte_cnt_reg</code> 自最后一个探测包从端口传输出去以来，每个端口传输出去的字节数。</li><li><code>last_time_reg</code>保存探测包最后一次从每个端口发送出去的时间。</li></ul><p>P4程序将被写成V1Model形式（bmv2交换机），V1model可以参考它的<a href="https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4" target="_blank" rel="noopener">官方源码</a></p><h5 id="补充：-FatTree胖树拓扑结构"><a href="#补充：-FatTree胖树拓扑结构" class="headerlink" title="补充： FatTree胖树拓扑结构"></a>补充： FatTree胖树拓扑结构</h5><p>传统结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210420125915925.png" alt="image-20210420125915925" title="">                </div>                <div class="image-caption">image-20210420125915925</div>            </figure><p>传统数据中心采用多层级的树形结构，这种结构针对客户端/服务器（C/S）模式能有较好的效果。树形结构包括单根树和多根树。多根数的根节点往往作为备份节点存在（我们以方格代表交换机）</p><blockquote><p>缺点：传统单根/多根拓扑结构有以下缺点：成本高，根部交换机必须要有足够大的带宽来满足下层服务器之间的通信；性能瓶颈，无法满足数据中心内部大规模的MapReduce和数据拷贝。</p></blockquote><p>FatTree 拓扑结构：</p><p>Fat-Tree是以交换机为中心的拓扑。支持在横向拓展的同时拓展路径数目；且所有交换机均为相同端口数量的普通设备，降低了网络建设成本。</p><p>整个拓扑网络分为三个层次：自上而下分别为边缘层（edge）、汇聚层（aggregate）和核心层（core），其中汇聚层交换机与边缘层交换机构成一个pod，交换设备均采用商用交换设备。</p><p>一个k元的Fat-Tree可以归纳为5个特征：</p><ul><li>每台交换机都有k个端口；</li><li>核心层为顶层，一共有(k/2)^2个交换机；</li><li>一共有k个pod，每个pod有k台交换机组成。其中汇聚层和接入层各占k/2台交换机；</li><li>接入层每个交换机可以容纳k/2台服务器，因此，k元Fat-Tree一共有k个pod，每个pod容纳$k<em>k/4$个服务器，所有pod共能容纳$k</em>k*k/4$台服务器；任意</li><li>两个pod之间存在k条路径。</li></ul><p>例子：</p><p>二叉FatTree</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/eY8DUtD.png" alt="二叉FatTree" title="">                </div>                <div class="image-caption">二叉FatTree</div>            </figure><p>四叉FatTree</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/Q8efPRm.png" alt="四叉FatTree" title="">                </div>                <div class="image-caption">四叉FatTree</div>            </figure><p>因此上面练习的拓扑就像四叉FatTree的一个pod</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>headers部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F;</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4  &#x3D; 0x800;</span><br><span class="line">const bit&lt;16&gt; TYPE_PROBE &#x3D; 0x812;</span><br><span class="line"></span><br><span class="line">#define MAX_HOPS 10</span><br><span class="line">#define MAX_PORTS 8</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;48&gt; time_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123;</span><br><span class="line">    macAddr_t dstAddr;</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe</span><br><span class="line">&#x2F;&#x2F; packet has traversed so far.</span><br><span class="line">header probe_t &#123;</span><br><span class="line">    bit&lt;8&gt; hop_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The data added to the probe by each switch at each hop.</span><br><span class="line">header probe_data_t &#123;</span><br><span class="line">    bit&lt;1&gt;    bos;</span><br><span class="line">    bit&lt;7&gt;    swid;</span><br><span class="line">    bit&lt;8&gt;    port;</span><br><span class="line">    bit&lt;32&gt;   byte_cnt;</span><br><span class="line">    time_t    last_time;</span><br><span class="line">    time_t    cur_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Indicates the egress port the switch should send this probe</span><br><span class="line">&#x2F;&#x2F; packet out of. There is one of these headers for each hop.</span><br><span class="line">header probe_fwd_t &#123;</span><br><span class="line">    bit&lt;8&gt;   egress_spec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct parser_metadata_t &#123;</span><br><span class="line">    bit&lt;8&gt;  remaining;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123;</span><br><span class="line">    bit&lt;8&gt; egress_spec;</span><br><span class="line">    parser_metadata_t parser_metadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t              ethernet;</span><br><span class="line">    ipv4_t                  ipv4;</span><br><span class="line">    probe_t                 probe;</span><br><span class="line">    probe_data_t[MAX_HOPS]  probe_data;</span><br><span class="line">    probe_fwd_t[MAX_HOPS]   probe_fwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比之前的<a href="https://tyler-ytr.github.io/2021/02/21/p4%E5%AD%A6%E4%B9%A0-2/">IPV4 forwarding</a>多了三个探测包的header</p><p><strong>Parser部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ethernet &#123;</span><br><span class="line">        packet.extract(hdr.ethernet);</span><br><span class="line">        transition select(hdr.ethernet.etherType) &#123;</span><br><span class="line">            TYPE_IPV4: parse_ipv4;</span><br><span class="line">            TYPE_PROBE: parse_probe;</span><br><span class="line">            default: accept;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ipv4 &#123;</span><br><span class="line">        packet.extract(hdr.ipv4);</span><br><span class="line">        transition accept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_probe &#123;</span><br><span class="line">        packet.extract(hdr.probe);</span><br><span class="line">        meta.parser_metadata.remaining &#x3D; hdr.probe.hop_cnt + 1;</span><br><span class="line">        transition select(hdr.probe.hop_cnt) &#123;</span><br><span class="line">            0: parse_probe_fwd;</span><br><span class="line">            default: parse_probe_data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_probe_data &#123;</span><br><span class="line">        packet.extract(hdr.probe_data.next);</span><br><span class="line">        transition select(hdr.probe_data.last.bos) &#123;</span><br><span class="line">            1: parse_probe_fwd;</span><br><span class="line">            default: parse_probe_data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_probe_fwd &#123;</span><br><span class="line">        packet.extract(hdr.probe_fwd.next);</span><br><span class="line">        meta.parser_metadata.remaining &#x3D; meta.parser_metadata.remaining - 1;</span><br><span class="line">        &#x2F;&#x2F; extract the forwarding data</span><br><span class="line">        meta.egress_spec &#x3D; hdr.probe_fwd.last.egress_spec;</span><br><span class="line">        transition select(meta.parser_metadata.remaining) &#123;</span><br><span class="line">            0: accept;</span><br><span class="line">            default: parse_probe_fwd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>流程是：先进入start状态，通过ethernet的etherType确定是    ipv4包还是探测包，如果是ipv4包，略；如果是探测包，那么看看是不是第一个跳，探测包经过第一跳的时候不会有其他信息，因此可以直接进入向前转发的状态；否则就更新matada里面的remaing，进入parse_probe_data状态解析probe_data.next的信息，知道解析到last.bos也就是栈底的时候再进入向前转发状态；向前转发状态(<code>parse_probe_fwd</code>)里面,使用<code>hdr.probe.hop_cnt</code>指出了哪一个<code>egress_spec</code>来处理向前转发，并且把这个端口号存在一个metadata的域里面；</p></blockquote><p><strong>Ingress Control 部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec &#x3D; port;</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr;</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (hdr.probe.isValid()) &#123;</span><br><span class="line">            standard_metadata.egress_spec &#x3D; (bit&lt;9&gt;)meta.egress_spec;</span><br><span class="line">            hdr.probe.hop_cnt &#x3D; hdr.probe.hop_cnt + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比basic那个实验多了一个如果hdr.probe.isValid()（也就是这个包是探测包），就记录 <code>egress_spec</code>并且更新<code>hdr.probe.hop_cnt</code> </p></blockquote><p><strong>Egress Control 部分</strong></p><p>这部分是状态处理发生的地方，使用<code>byte_cnt_regs</code>寄存器在计算自最后一个探测包通过该端口以来通过每个端口的字节数；</p><p>这部分增加了一个新的<code>probe_data</code>  ,并且填写了 <code>bos</code> (bottom of stack) 和 <code>swid</code> (switch ID)；</p><p>要做的部分是填写探测包字段的其余部分，以确保您可以正确地测量链路利用率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   ********************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; count the number of bytes seen since the last probe</span><br><span class="line">    register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg;</span><br><span class="line">    &#x2F;&#x2F; remember the time of the last probe</span><br><span class="line">    register&lt;time_t&gt;(MAX_PORTS) last_time_reg;</span><br><span class="line"></span><br><span class="line">    action set_swid(bit&lt;7&gt; swid) &#123;</span><br><span class="line">        hdr.probe_data[0].swid &#x3D; swid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table swid &#123;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            set_swid;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        bit&lt;32&gt; byte_cnt;</span><br><span class="line">        bit&lt;32&gt; new_byte_cnt;</span><br><span class="line">        time_t last_time;</span><br><span class="line">        time_t cur_time &#x3D; standard_metadata.egress_global_timestamp;</span><br><span class="line">        &#x2F;&#x2F; increment byte cnt for this packet&#39;s port</span><br><span class="line">        byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port);</span><br><span class="line">        byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length;</span><br><span class="line">        &#x2F;&#x2F; reset the byte count when a probe packet passes through</span><br><span class="line">        new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt;</span><br><span class="line">        byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt);</span><br><span class="line"></span><br><span class="line">        if (hdr.probe.isValid()) &#123;</span><br><span class="line">            &#x2F;&#x2F; fill out probe fields</span><br><span class="line">            hdr.probe_data.push_front(1);</span><br><span class="line">            hdr.probe_data[0].setValid();</span><br><span class="line">            if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; set switch ID field</span><br><span class="line">            swid.apply();</span><br><span class="line">            &#x2F;&#x2F; TODO: fill out the rest of the probe packet fields</span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].port &#x3D; ...</span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].byte_cnt &#x3D; ...</span><br><span class="line">            &#x2F;&#x2F; TODO: read &#x2F; update the last_time_reg</span><br><span class="line">            &#x2F;&#x2F; last_time_reg.read(&lt;val&gt;, &lt;index&gt;);</span><br><span class="line">            &#x2F;&#x2F; last_time_reg.write(&lt;index&gt;, &lt;val&gt;); </span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].last_time &#x3D; ...</span><br><span class="line">            &#x2F;&#x2F; hdr.probe_data[0].cur_time &#x3D; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   ********************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; count the number of bytes seen since the last probe</span><br><span class="line">    register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg;</span><br><span class="line">    &#x2F;&#x2F; remember the time of the last probe</span><br><span class="line">    register&lt;time_t&gt;(MAX_PORTS) last_time_reg;</span><br><span class="line"></span><br><span class="line">    action set_swid(bit&lt;7&gt; swid) &#123;</span><br><span class="line">        hdr.probe_data[0].swid &#x3D; swid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table swid &#123;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            set_swid;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        bit&lt;32&gt; byte_cnt;</span><br><span class="line">        bit&lt;32&gt; new_byte_cnt;</span><br><span class="line">        time_t last_time;</span><br><span class="line">        time_t cur_time &#x3D; standard_metadata.egress_global_timestamp;</span><br><span class="line">        &#x2F;&#x2F; increment byte cnt for this packet&#39;s port</span><br><span class="line">        byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port);</span><br><span class="line">        byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length;</span><br><span class="line">        &#x2F;&#x2F; reset the byte count when a probe packet passes through</span><br><span class="line">        new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt;</span><br><span class="line">        byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt);</span><br><span class="line"></span><br><span class="line">        if (hdr.probe.isValid()) &#123;</span><br><span class="line">            &#x2F;&#x2F; fill out probe fields</span><br><span class="line">            hdr.probe_data.push_front(1);</span><br><span class="line">            hdr.probe_data[0].setValid();</span><br><span class="line">            if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                hdr.probe_data[0].bos &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; set switch ID field</span><br><span class="line">            swid.apply();</span><br><span class="line">            hdr.probe_data[0].port &#x3D; (bit&lt;8&gt;)standard_metadata.egress_port;</span><br><span class="line">            hdr.probe_data[0].byte_cnt &#x3D; byte_cnt;</span><br><span class="line">            &#x2F;&#x2F; read &#x2F; update the last_time_reg</span><br><span class="line">            last_time_reg.read(last_time, (bit&lt;32&gt;)standard_metadata.egress_port);</span><br><span class="line">            last_time_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, cur_time);</span><br><span class="line">            hdr.probe_data[0].last_time &#x3D; last_time;</span><br><span class="line">            hdr.probe_data[0].cur_time &#x3D; cur_time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其余部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*************   C H E C K S U M    C O M P U T A T I O N   ***************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyComputeChecksum(inout headers  hdr, inout metadata meta) &#123;</span><br><span class="line">     apply &#123;</span><br><span class="line">update_checksum(</span><br><span class="line">    hdr.ipv4.isValid(),</span><br><span class="line">            &#123; hdr.ipv4.version,</span><br><span class="line">      hdr.ipv4.ihl,</span><br><span class="line">              hdr.ipv4.diffserv,</span><br><span class="line">              hdr.ipv4.totalLen,</span><br><span class="line">              hdr.ipv4.identification,</span><br><span class="line">              hdr.ipv4.flags,</span><br><span class="line">              hdr.ipv4.fragOffset,</span><br><span class="line">              hdr.ipv4.ttl,</span><br><span class="line">              hdr.ipv4.protocol,</span><br><span class="line">              hdr.ipv4.srcAddr,</span><br><span class="line">              hdr.ipv4.dstAddr &#125;,</span><br><span class="line">            hdr.ipv4.hdrChecksum,</span><br><span class="line">            HashAlgorithm.csum16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">        packet.emit(hdr.probe);</span><br><span class="line">        packet.emit(hdr.probe_data);</span><br><span class="line">        packet.emit(hdr.probe_fwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  S W I T C H  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">V1Switch(</span><br><span class="line">MyParser(),</span><br><span class="line">MyVerifyChecksum(),</span><br><span class="line">MyIngress(),</span><br><span class="line">MyEgress(),</span><br><span class="line">MyComputeChecksum(),</span><br><span class="line">MyDeparser()</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h4 id="probe-hdrs-py分析"><a href="#probe-hdrs-py分析" class="headerlink" title="probe_hdrs.py分析:"></a>probe_hdrs.py分析:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line">TYPE_PROBE &#x3D; 0x812</span><br><span class="line"></span><br><span class="line">class Probe(Packet):</span><br><span class="line">   fields_desc &#x3D; [ ByteField(&quot;hop_cnt&quot;, 0)]</span><br><span class="line"></span><br><span class="line">class ProbeData(Packet):</span><br><span class="line">   fields_desc &#x3D; [ BitField(&quot;bos&quot;, 0, 1),</span><br><span class="line">                   BitField(&quot;swid&quot;, 0, 7),</span><br><span class="line">                   ByteField(&quot;port&quot;, 0),</span><br><span class="line">                   IntField(&quot;byte_cnt&quot;, 0),</span><br><span class="line">                   BitField(&quot;last_time&quot;, 0, 48),</span><br><span class="line">                   BitField(&quot;cur_time&quot;, 0, 48)]</span><br><span class="line"></span><br><span class="line">class ProbeFwd(Packet):</span><br><span class="line">   fields_desc &#x3D; [ ByteField(&quot;egress_spec&quot;, 0)]</span><br><span class="line"></span><br><span class="line">bind_layers(Ether, Probe, type&#x3D;TYPE_PROBE)</span><br><span class="line">bind_layers(Probe, ProbeFwd, hop_cnt&#x3D;0)</span><br><span class="line">bind_layers(Probe, ProbeData)</span><br><span class="line">bind_layers(ProbeData, ProbeData, bos&#x3D;0)</span><br><span class="line">bind_layers(ProbeData, ProbeFwd, bos&#x3D;1)</span><br><span class="line">bind_layers(ProbeFwd, ProbeFwd)</span><br></pre></td></tr></table></figure><p>这部分是在控制平面用scapy定义了探测包的结构，从bind_layers可以看出，结构关系大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ethernet&#123;</span><br><span class="line">.....</span><br><span class="line">Probe&#123;</span><br><span class="line">ProbeFwd&#123;</span><br><span class="line">ProbeFwd&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ProbeData&#123;</span><br><span class="line">ProbeData&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样其中ProbeFwd以及ProbeData可以嵌套；具体的结构在class里面进行了定义</p><h4 id="send-py分析"><a href="#send-py分析" class="headerlink" title="send.py分析"></a>send.py分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">from probe_hdrs import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    probe_pkt &#x3D; Ether(dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;, src&#x3D;get_if_hwaddr(&#39;eth0&#39;)) &#x2F; \</span><br><span class="line">                Probe(hop_cnt&#x3D;0) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;4) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;1) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;4) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;1) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;3) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;2) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;3) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;2) &#x2F; \</span><br><span class="line">                ProbeFwd(egress_spec&#x3D;1)# 根据拓扑也就是s1-s1的4端口出到s4,s41端口出到s2……</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            sendp(probe_pkt, iface&#x3D;&#39;eth0&#39;)# 每隔一秒发一个探测包</span><br><span class="line">            time.sleep(1)</span><br><span class="line">        except KeyboardInterrupt:</span><br><span class="line">            sys.exit()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这部分要结合拓扑图来看:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/link-monitor-topo.png" alt="topology" title="">                </div>                <div class="image-caption">topology</div>            </figure><p>这部分probe_pkt这个包其实仔细观察不难发现，它里面的ProbeFwd和拓扑图的路线完全一致，假设是s1进行了发包，那么就是从s1-s1的4端口出到s4,s4的1端口出到s2……然后完成了一个回路到了s1;下面的代码只是每隔一秒钟发一下罢了；</p><h4 id="receive-py分析"><a href="#receive-py分析" class="headerlink" title="receive.py分析"></a>receive.py分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from probe_hdrs import *</span><br><span class="line"></span><br><span class="line">def expand(x):</span><br><span class="line">    yield x</span><br><span class="line">    while x.payload:</span><br><span class="line">        x &#x3D; x.payload</span><br><span class="line">        yield x</span><br><span class="line"></span><br><span class="line">def handle_pkt(pkt):</span><br><span class="line">    if ProbeData in pkt:</span><br><span class="line">        data_layers &#x3D; [l for l in expand(pkt) if l.name&#x3D;&#x3D;&#39;ProbeData&#39;]</span><br><span class="line">        print &quot;&quot;</span><br><span class="line">        for sw in data_layers:</span><br><span class="line">            utilization &#x3D; 0 if sw.cur_time &#x3D;&#x3D; sw.last_time else 8.0*sw.byte_cnt&#x2F;(sw.cur_time - sw.last_time)</span><br><span class="line">            print &quot;Switch &#123;&#125; - Port &#123;&#125;: &#123;&#125; Mbps&quot;.format(sw.swid, sw.port, utilization)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    iface &#x3D; &#39;eth0&#39;</span><br><span class="line">    print &quot;sniffing on &#123;&#125;&quot;.format(iface)</span><br><span class="line">    sniff(iface &#x3D; iface,</span><br><span class="line">          prn &#x3D; lambda x: handle_pkt(x)) #prn指定回调函数，每当一个符合filter的报文被探测到时，就会执行回调函数，通常使用lambda表达式来写回调函数</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>expand 这个就是一个走yield的递归的函数；</p><p>handle_pkt这部分首先实会不停的往后整pkt得到ProbeData的部分然后存到data_layer里面，然后解析里面的内容，看utilization，计算公式就是以Bit为单位的数据除以时间；</p><p>main还是里面的sniff是一个过滤器，其实是iface为”eth0”的包就扔到handle_pkt里面去处理；</p><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><ol><li><p>跑:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br></pre></td></tr></table></figure><ul><li>编译link_monitor.p4</li><li>在mininet里面启动如上面图片的拓扑并且将所有的交换机都设置好p4程序和相应的table entries</li><li>根据topology.json设置所有的主机</li></ul></li><li><p>使用mininet打开h1端口，开两个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; xterm h1 h1</span><br></pre></td></tr></table></figure></li><li><p>在一个窗口里面跑send.py脚本可以开始每秒发送探测包。探测包的路线和拓扑图一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./send.py</span><br></pre></td></tr></table></figure></li><li><p>在另一个窗口跑receive.py可以开始接受并且接受这些探测包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./receive.py</span><br></pre></td></tr></table></figure><blockquote><p>报告的链路利用率和交换机端口号将始终为0，因为探测字段还没有填写。</p></blockquote></li><li><p>在h1和h4之间开一个iperf流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt;iperf h1 h4</span><br></pre></td></tr></table></figure></li><li><p>在所有窗口里面exit然后make stop</p></li></ol><blockquote><p>测量的链路利用率与iperf报告的不一致，因为探测包字段还没有填充。您的目标是填写探测包字段，以便两个测量结果一致。</p></blockquote><h6 id="控制平面的一些说明"><a href="#控制平面的一些说明" class="headerlink" title="控制平面的一些说明"></a>控制平面的一些说明</h6><p>P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。</p><p>在这个练习中，我们已经为您实现了控制平面逻辑。作为启动Mininet实例的一部分，<code>make run</code>命令将在每个交换机的表中安装包处理规则。这些是在<code>sX-runtime.json</code>中定义的，其中<code>X</code> 对应开关号。</p><p><strong>注意点：</strong>我们使用P4Runtime来安装控制平面规则。 <code>sX-runtime.json</code>文件的运行时的内容指的是表、键和动作的特定名称，如编译器生成的P4Info文件中定义的(在执行<code>make run</code>后查找 <code>build/link_monitor.p4.p4info.txt</code>文件)。P4程序中添加或重命名表、键或操作的任何更改都需要反映在这些 <code>sX-runtime.json</code>文件中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;p4学习-6-实现网络测量&quot;&gt;&lt;a href=&quot;#p4学习-6-实现网络测量&quot; class=&quot;headerlink&quot; title=&quot;p4学习-6:实现网络测量&quot;&gt;&lt;/a&gt;p4学习-6:实现网络测量&lt;/h2&gt;&lt;h4 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#实验目标&quot;
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>匈牙利算法</title>
    <link href="http://Tyler-ytr.github.io/2021/04/13/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://Tyler-ytr.github.io/2021/04/13/匈牙利算法/</id>
    <published>2021-04-13T07:12:02.000Z</published>
    <updated>2021-04-13T08:26:14.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>匈牙利算法适用于二分图匹配有关的问题</p><p><strong>二分图</strong>（<strong>Bipartite graph</strong>）是一类特殊的<strong>图</strong>，它可以被划分为两个部分，每个部分内的点互不相连。下图是典型的二分图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/v2-81f21981c992bc0b5b1acf04b37ff6c2_720w.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，在上面的二分图中，每条边的端点都分别处于点集X和Y中。匈牙利算法主要用来解决两个问题：求二分图的<strong>最大匹配数</strong>和<strong>最小点覆盖数</strong>。</p><p>在图论中，一个“匹配”（matching）是一个边的集合，其中任意两条边都没有公共顶点。</p><p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。<br>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。</p><p>交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p>增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。</p><hr><h4 id="邻接矩阵算法"><a href="#邻接矩阵算法" class="headerlink" title="邻接矩阵算法"></a>邻接矩阵算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//m代表右侧集合的元素数量,n代表左侧集合的元素数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];<span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="keyword">int</span> match[MAXN];<span class="comment">//记录当前右侧元素所对一个的左侧元素</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//记录右侧元素是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;<span class="comment">//右边并且i没有被访问</span></span><br><span class="line">            vis[i] = <span class="literal">true</span>;<span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || <span class="built_in">find</span>(match[i]))&#123;<span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">                match[i] = x;<span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接链表算法"><a href="#邻接链表算法" class="headerlink" title="邻接链表算法"></a>邻接链表算法</h4><h5 id="邻接链表数据结构"><a href="#邻接链表数据结构" class="headerlink" title="邻接链表数据结构"></a>邻接链表数据结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="comment">//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],tot;<span class="comment">//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;<span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to=v;<span class="comment">//对边进行编号</span></span><br><span class="line">    edge[tot].next=head[u];<span class="comment">//将U这个点上一次连接的点记录如果没有即为-1</span></span><br><span class="line">    head[u]=tot++;<span class="comment">//等于边的编号，之后edge[head[u]]即可调用这个边</span></span><br><span class="line">&#125;<span class="comment">//加边函数</span></span><br></pre></td></tr></table></figure><p>理解一下邻接链表：</p><p>邻接矩阵如下，但是它不适合稀疏图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/2019072120555471.png" alt="邻接矩阵" title="">                </div>                <div class="image-caption">邻接矩阵</div>            </figure><p>邻接链表适合稀疏图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/20190721205858715.png" alt="邻接链表" title="">                </div>                <div class="image-caption">邻接链表</div>            </figure><p>因此结合上面的代码，head数组相当于邻接链表的一个个头，head[a]可以得到a的第一个边，通过edge[head[a]]获得，然后edge[head[a]].next可以得到下一条边的编号……</p><h5 id="邻接链表匈牙利"><a href="#邻接链表匈牙利" class="headerlink" title="邻接链表匈牙利"></a>邻接链表匈牙利</h5> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200010</span>;<span class="comment">//边数的最大值</span></span><br><span class="line"><span class="comment">//参考资料https://zhuanlan.zhihu.com/p/96229700；</span></span><br><span class="line"><span class="comment">//整理的笔记:https://tyler-ytr.github.io/2021/04/13/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</span></span><br><span class="line"><span class="comment">//邻接链表定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="comment">//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],tot;<span class="comment">//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;<span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to=v;<span class="comment">//对边进行编号</span></span><br><span class="line">    edge[tot].next=head[u];<span class="comment">//将U这个点上一次连接的点记录如果没有即为-1</span></span><br><span class="line">    head[u]=tot++;<span class="comment">//等于边的编号，之后edge[head[u]]即可调用这个边</span></span><br><span class="line">&#125;<span class="comment">//加边函数</span></span><br><span class="line"><span class="comment">//匈牙利算法</span></span><br><span class="line"><span class="keyword">int</span> match[maxn];<span class="comment">//记录当前右侧元素所对一个的左侧元素</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];<span class="comment">//记录当前右侧元素有没有被访问过</span></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//左侧元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//dfs左侧元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;<span class="comment">//顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后</span></span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;<span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span>(match[v]==<span class="number">-1</span>||dfs(match[v]))&#123;<span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">                match[v]=u;<span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i))++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>问题 A: 二部图最大匹配</p><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个由X、Y两部分组成的二部图，试求图上最大匹配的规模（无需输出方案）</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第1行输入两个数，分别代表X和Y部的顶点数 第2行~第x+1行，第i行的第一个数k表示X部第(i-1)个与Y部的k个点之间有边。接下来k个数为Y部与其有边的顶点的标号。（点的标号从1开始） 输入保证X部、Y部顶点数量均不超过10^5，总边数不超过2*10^5。</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>输出1行，行内只有一个整数，为图上最大匹配的规模</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">2 3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h5><blockquote><p>样例解释：一个最大匹配是{(X1, Y3), (X2, Y2), (X4, Y1)} 。</p><p><strong>一个显而易见的事实是：你不应该尝试使用邻接矩阵存储图上的边。</strong></p><p>事实上，正确执行的算法并不需要每次遍历整个图（就像样例这样，除了X2以外的点搜索的第一条边就可以加入匹配）。我们提供的绝大部分数据是稀疏图，如果你的算法对此做了正确设计，使用C/C++实现的程序执行时间应该明显低于1秒。<br>如果你写出了时间复杂度Theta(V^2)的实现，那……也许你会在一部分数据上超时，也许不会</p></blockquote><p>代码:(耗时99)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn&#x3D;200010;&#x2F;&#x2F;边数的最大值</span><br><span class="line">&#x2F;&#x2F;参考资料https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;96229700；</span><br><span class="line">&#x2F;&#x2F;整理的笔记:https:&#x2F;&#x2F;tyler-ytr.github.io&#x2F;2021&#x2F;04&#x2F;13&#x2F;%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&#x2F;</span><br><span class="line">&#x2F;&#x2F;邻接链表定义</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">&#x2F;&#x2F;to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键</span><br><span class="line">int head[maxn],tot;&#x2F;&#x2F;tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    tot&#x3D;0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">&#125;&#x2F;&#x2F;初始化函数</span><br><span class="line">void addedge(int u,int v)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tot].to&#x3D;v;&#x2F;&#x2F;对边进行编号</span><br><span class="line">    edge[tot].next&#x3D;head[u];&#x2F;&#x2F;将U这个点上一次连接的点记录如果没有即为-1</span><br><span class="line">    head[u]&#x3D;tot++;&#x2F;&#x2F;等于边的编号，之后edge[head[u]]即可调用这个边</span><br><span class="line">&#125;&#x2F;&#x2F;加边函数</span><br><span class="line">&#x2F;&#x2F;匈牙利算法</span><br><span class="line">int match[maxn];&#x2F;&#x2F;记录当前右侧元素所对一个的左侧元素</span><br><span class="line">bool vis[maxn];&#x2F;&#x2F;记录当前右侧元素有没有被访问过</span><br><span class="line">int N;&#x2F;&#x2F;左侧元素的数量</span><br><span class="line">bool dfs(int u)&#123;&#x2F;&#x2F;dfs左侧元素</span><br><span class="line">    for (int i&#x3D;head[u];i!&#x3D;-1;i&#x3D;edge[i].next)&#123;&#x2F;&#x2F;顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后</span><br><span class="line">        int v&#x3D;edge[i].to;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v]&#x3D;true;&#x2F;&#x2F;记录状态为访问过</span><br><span class="line">            if(match[v]&#x3D;&#x3D;-1||dfs(match[v]))&#123;&#x2F;&#x2F;如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span><br><span class="line">                match[v]&#x3D;u;&#x2F;&#x2F;当前左侧元素成为当前右侧元素的新匹配</span><br><span class="line">                return true;&#x2F;&#x2F;返回匹配成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Hungarian()&#123;</span><br><span class="line">    int res&#x3D;0;</span><br><span class="line">    memset(match,-1,sizeof(match));</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;++i)&#123;</span><br><span class="line">        memset(vis,false,sizeof(vis));</span><br><span class="line">        if(dfs(i))++res;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">&#x2F;&#x2F;X为左侧，Y为右侧</span><br><span class="line">    int M;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    &#x2F;&#x2F;printf(&quot;%d\n&quot;,N);</span><br><span class="line">    int tempnum;</span><br><span class="line">    int tempy;</span><br><span class="line">    int j&#x3D;0;</span><br><span class="line">    init();</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;cin&gt;&gt;tempnum;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;tempnum);</span><br><span class="line">        &#x2F;&#x2F;printf(&quot;%d\n&quot;,tempnum);</span><br><span class="line">        for (j&#x3D;0;j&lt;tempnum;j++)&#123;</span><br><span class="line">            &#x2F;&#x2F;cin&gt;&gt;tempy;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tempy);</span><br><span class="line">            addedge(i,tempy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;建图完毕</span><br><span class="line">    int result &#x3D; Hungarian();</span><br><span class="line">    printf(&quot;%d\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;匈牙利算法&quot;&gt;&lt;a href=&quot;#匈牙利算法&quot; class=&quot;headerlink&quot; title=&quot;匈牙利算法&quot;&gt;&lt;/a&gt;匈牙利算法&lt;/h2&gt;&lt;p&gt;匈牙利算法适用于二分图匹配有关的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分图&lt;/strong&gt;（&lt;strong&gt;Bip
      
    
    </summary>
    
      <category term="算法模板" scheme="http://Tyler-ytr.github.io/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++预处理指令</title>
    <link href="http://Tyler-ytr.github.io/2021/04/13/C-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/"/>
    <id>http://Tyler-ytr.github.io/2021/04/13/C-预处理指令/</id>
    <published>2021-04-13T05:14:06.000Z</published>
    <updated>2021-04-13T06:53:16.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-翻译流程与预处理指令"><a href="#C-翻译流程与预处理指令" class="headerlink" title="C++翻译流程与预处理指令"></a>C++翻译流程与预处理指令</h2><p>参考了<a href="https://www.bookstack.cn/read/cppreference-language/85f4d80f537f13a4.md" target="_blank" rel="noopener">C++语言构造手册</a>,<a href="https://zh.cppreference.com/w/cpp/language/translation_phases" target="_blank" rel="noopener">cppreference</a></p><p>翻译阶段复制自cppreference</p><h1 id="翻译阶段"><a href="#翻译阶段" class="headerlink" title="翻译阶段"></a>翻译阶段</h1><p>编译器处理 C++ 源文件时，如同严格按照以下顺序进行各个阶段的处理：</p><h3 id="阶段-1"><a href="#阶段-1" class="headerlink" title="阶段 1"></a>阶段 1</h3><p>1) （以实现定义方式）将源文件的各个单独字节，映射为<em>基本源字符集</em>的字符。特别是，操作系统相关的行尾指示符均被替换为换行字符。<em>基本源字符集</em>由以下 96 个字符组成：</p><p>a) 5 个空白字符（空格 (space)、水平制表 (horizontal tab)、垂直制表 (vertical tab)、换页 (form feed)和 换行 (new-line)）</p><p>b) 10 个数字字符，从 ‘0’ 到 ‘9’</p><p>c) 52 个字母，从 ‘a’ 到 ‘z’ 以及从 ‘A’ 到 ‘Z’</p><p>d) 29 个标点字符：_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ “ ‘</p><p>2) 任何无法被映射到基本源字符集中的字符的源文件字符，均被替换为其<a href="https://zh.cppreference.com/w/cpp/language/escape" target="_blank" rel="noopener">通用字符名</a>（用 <code>\u</code> 或 <code>\U</code> 转义），或某种被等价处理的由实现定义的形式。</p><table><thead><tr><th>3) 将各个<a href="https://zh.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">三标符序列</a>替换为其对应的单字符表示。</th><th>(C++17 前)</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h3 id="阶段-2"><a href="#阶段-2" class="headerlink" title="阶段 2"></a>阶段 2</h3><p>1) 当反斜杠出现于行尾（其后紧跟换行符）时，删除该反斜杠和换行符并将两个物理源码行组合成一个逻辑源码行。这是单趟操作：如果有一行以两个反斜杠结束且后随一个空行，这三行不会合为一行。若于此阶段组成了通用字符名（\uXXXX），则行为未定义。</p><p>2) 若此步骤后，非空源文件不以换行符结束（无论是原本就无换行，还是以反斜杠结束），则其行为未定义 (C++11 前)在最后添加一个换行符 (C++11 起)。</p><h3 id="阶段-3"><a href="#阶段-3" class="headerlink" title="阶段 3"></a>阶段 3</h3><p>1) 将源文件分解为<a href="https://zh.cppreference.com/w/cpp/comment" target="_blank" rel="noopener">注释</a>，空白字符（空格、水平制表、换行、垂直制表和换页）的序列，和下列各种<em>预处理记号</em>：</p><p>a) 头文件名，如 <iostream> 或 “myfile.h”</p><p>b) <a href="https://zh.cppreference.com/w/cpp/language/identifiers" target="_blank" rel="noopener">标识符</a></p><p>c) 预处理数字</p><p>d) ，包含<a href="https://zh.cppreference.com/w/cpp/language/user_literal" target="_blank" rel="noopener">用户定义</a>的 (C++11 起)<a href="https://zh.cppreference.com/w/cpp/language/character_literal" target="_blank" rel="noopener">字符</a>与<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串</a>字面量</p><p>e) 运算符与标点（包括<a href="https://zh.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">代用记号</a>），如 +、&lt;&lt;=、&lt;%、## 或 and</p><p>f) 不属于任何其他类别的单独非空白字符</p><table><thead><tr><th>2) 恢复在任何原始<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串字面量</a>的首尾双引号之间在阶段 1 和 2 期间进行的所有变换。</th><th>(C++11 起)</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>3) 以一个空格字符替换每段注释。</p><p>保留换行符。未指明是否可将非换行空白字符序列缩减成单个空格字符。</p><p>若一个给定字符前的输入已被解析为预处理记号，下一个预处理记号通常会由能构成预处理记号的最长字符序列够成，即使这样处理会导致后续分析失败。这常被称为<em>最大吞噬</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo &#x3D; 1;</span><br><span class="line">int bar &#x3D; 0xE+foo;   &#x2F;&#x2F; 错误：非法的预处理数字 0xE+foo</span><br><span class="line">int baz &#x3D; 0xE + foo; &#x2F;&#x2F; OK</span><br><span class="line"> </span><br><span class="line">int quux &#x3D; bar+++++baz; &#x2F;&#x2F; 错误：bar++ ++ +baz，而非 bar++ + ++baz。</span><br></pre></td></tr></table></figure><p>最大吞噬规则仅有的例外是：</p><table><thead><tr><th>若以下一个字符开头的字符序列可作为<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">原始字符串字面量</a>的前缀和起始双引号，则下个预处理记号应当为原始字符串字面量。该字面量由匹配原始字符串模式的最短字符序列组成。<code>#define R &quot;x&quot; const char* s = R&quot;y&quot;; // 非良构的原始字符串字面量，而非 &quot;x&quot; &quot;y&quot; const char* s2 = R&quot;(a)&quot; &quot;b)&quot;; // 原始字符串字面量后随普通字符串字面量</code>若接下来三个字符是 <code>**&lt;::**</code>且后继字符不是 <code>**:**</code> 或者 <code>**&gt;**</code>，则把 <code>**&lt;**</code> 自身当做预处理记号（而非<a href="https://zh.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="noopener">代用记号</a> <code>&lt;:</code> 的首字符）。<code>struct Foo { static const int v = 1; }; std::vector&lt;::Foo&gt; x; // OK，&lt;: 未被当作 [ 的代用记号 extern int y&lt;::&gt;;     // OK，同 extern int y[]。 int z&lt;:::Foo::value:&gt;; // OK，int z[::Foo::value];</code></th><th>(C++11 起)</th></tr></thead><tbody><tr><td></td></tr></tbody></table><ul><li>头文件名预处理记号仅在 <code>#include</code> 指令中形成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; x; &#x2F;&#x2F; OK，&lt;int&gt; 不是头文件名</span><br></pre></td></tr></table></figure><h3 id="阶段-4"><a href="#阶段-4" class="headerlink" title="阶段 4"></a>阶段 4</h3><p>1) 执行<a href="https://zh.cppreference.com/w/cpp/preprocessor" target="_blank" rel="noopener">预处理器</a>。</p><p>2) <a href="https://zh.cppreference.com/w/cpp/preprocessor/include" target="_blank" rel="noopener">#include</a> 指令所引入的每个文件都经历阶段 1 到 4 的处理，递归执行。</p><p>3) 此阶段结束时，所有预处理器指令都应从源（代码）移除。</p><h3 id="阶段-5"><a href="#阶段-5" class="headerlink" title="阶段 5"></a>阶段 5</h3><p>1) 将<a href="https://zh.cppreference.com/w/cpp/language/character_literal" target="_blank" rel="noopener">字符字面量</a>及<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串字面量</a>中的所有字符从源字符集转换到<em>执行字符集</em>（可以是 UTF-8 这样的多字节字符集，只要阶段 1 中所列的<em>基本源字符集</em>的 96 个字符都拥有单字节表示即可）。</p><p>2) 将字符字面量和非原始字符串字面量中的<a href="https://zh.cppreference.com/w/cpp/language/escape" target="_blank" rel="noopener">转义序列</a>和通用字符名展开，并转换到<em>执行字符集</em>。 若某个通用字符名所指定的字符不是执行字符集的成员，则结果是由实现定义的，但保证不是空（宽）字符。</p><p>注意：某些实现能以命令行选项控制此阶段所进行的转换：gcc 和 clang 用 -finput-charset 指定源字符集的编码，用 -fexec-charset 和 -fwide-exec-charset 指定无编码前缀的 (C++11 起)字符串和字符字面量中的执行字符集的编码，而 Visual Studio 2015 Update 2 及之后版本分别用 /source-charset 和 /execution-charset 指定源字符集和执行字符集。</p><h3 id="阶段-6"><a href="#阶段-6" class="headerlink" title="阶段 6"></a>阶段 6</h3><p>拼接相邻的<a href="https://zh.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="noopener">字符串字面量</a>。</p><h3 id="阶段-7"><a href="#阶段-7" class="headerlink" title="阶段 7"></a>阶段 7</h3><p>进行编译：将各个预处理记号转换成记号。将所有记号当作一个翻译单元进行语法和语义分析并进行翻译。</p><h3 id="阶段-8"><a href="#阶段-8" class="headerlink" title="阶段 8"></a>阶段 8</h3><p>检验每个翻译单元，产生所要求的模板实例化的列表，其中包括<a href="https://zh.cppreference.com/w/cpp/language/class_template" target="_blank" rel="noopener">显式实例化</a>所要求的实例化。定位模板定义，并进行所要求的实例化，以产生<em>实例化单元</em>。</p><h3 id="阶段-9"><a href="#阶段-9" class="headerlink" title="阶段 9"></a>阶段 9</h3><p>将翻译单元、实例化单元和为满足外部引用所需的库组件汇集成一个程序映像，它含有在其执行环境中执行所需的信息。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>某些编译器不实现实例化单元（又称为<a href="http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc" target="_blank" rel="noopener">模板仓库</a>或<a href="http://www-01.ibm.com/support/knowledgecenter/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html?lang=en" target="_blank" rel="noopener">模板注册表</a>），而是简单地在阶段 7 编译每个模板实例化，存储代码于其所显式或隐式要求的对象文件中，然后由连接器于阶段 9 将这些编译后的实例化缩减到一个。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>C++11 standard (ISO/IEC 14882:2011):</li></ul><ul><li>C++98 standard (ISO/IEC 14882:1998):</li></ul><h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><h4 id="基本的预编译指令"><a href="#基本的预编译指令" class="headerlink" title="基本的预编译指令"></a>基本的预编译指令</h4><ul><li>$#$ 空指令</li><li>$#define$ 定义宏</li><li>$#include$ 包含一个源代码文件</li><li>$#undef$取消已经定义的宏</li><li>$#if$如果给定条件为真，则编译下面的代码</li><li>$#ifdef$如果宏已经定义就编译下面的代码</li><li>$#ifndef$如果宏没有定义，就编译下面的代码</li><li>$#elif$如果前面的$#if$给定条件不为真，当前条件为真，就编译下面的代码</li><li>$#endif$结束一个$#if….#else$条件编译块</li><li>$#error$停止编译并且显示错误信息</li></ul><h4 id="define-的一些使用"><a href="#define-的一些使用" class="headerlink" title="$# define$ 的一些使用"></a>$# define$ 的一些使用</h4><p>预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。记住仅仅是进行标识符的替换。</p><p>例子如下：</p><ul><li><p>用#define实现求最大值和最小值的宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) (((x)&gt;(y))?(x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(x,y) (((x)&lt;(y))?(x):(y))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAX    <span class="comment">//判断这个宏是否被定义</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3 and 5 the max is:%d\n"</span>,MAX(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIN</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3 and 5 the min is:%d\n"</span>,MIN(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)三元运算符要比if,else效率高</span></span><br><span class="line"><span class="comment"> * （2）宏的使用一定要细心，需要把参数小心的用括号括起来，</span></span><br><span class="line"><span class="comment"> * 因为宏只是简单的文本替换，不注意，容易引起歧义错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>宏定义错误使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR(x) (x*x)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SQR<span class="comment">//只需要宏名就可以了，不需要参数，有参数的话会警告</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,SQR(b+<span class="number">2</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *首先说明，这个宏的定义是错误的。并没有实现程序中的B+2的平方</span></span><br><span class="line"><span class="comment"> * 预处理的时候，替换成如下的结果：b+2*b+2</span></span><br><span class="line"><span class="comment"> * 正确的宏定义应该是：#define SQR(x) ((x)*(x))</span></span><br><span class="line"><span class="comment"> * 所以，尽量使用小括号，将参数括起来。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>宏参数的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONS(a,b) (int)(a##e##b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> STR</span></span><br><span class="line">    <span class="built_in">printf</span>(STR(VCK));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONS</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,CONS(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* （绝大多数是使用不到这些的，使用到的话，查看手册就可以了）</span></span><br><span class="line"><span class="comment"> * 第一个宏，用#把参数转化为一个字符串</span></span><br><span class="line"><span class="comment"> * 第二个宏，用##把2个宏参数粘合在一起，及aeb,2e3也就是2000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>用宏得到一个字的高位或低位的字节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_LO(xxx) ((byte)((word)(xxx) &amp; 255))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_HI(xxx) ((byte)((word)(xxx) &gt;&gt; 8))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个字2个字节，获得低字节（低8位），与255（0000,0000,1111,1111）按位相与</span></span><br><span class="line"><span class="comment"> * 获得高字节（高8位），右移8位即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>用宏定义得到一个数组所含元素的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE(a) (sizeof((a))/sizeof((a[0])))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ARR_SIZE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"array has %d items.\n"</span>,ARR_SIZE(<span class="built_in">array</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *总的大小除以每个类型的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="ifdef-ifndef-endif-…的使用"><a href="#ifdef-ifndef-endif-…的使用" class="headerlink" title="$#ifdef$,$#ifndef$,$#endif$…的使用"></a>$#ifdef$,$#ifndef$,$#endif$…的使用</h4><p>以上这些预编译指令，都是条件编译指令，也就是说，将决定那些代码被编译，而哪些不被编译</p><ul><li><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define DEBUG</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    char c;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        c &#x3D; getchar();</span><br><span class="line">        if(&#39;\n&#39; !&#x3D; c)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        if(&#39;q&#39; &#x3D;&#x3D; c || &#39;Q&#39; &#x3D;&#x3D; c)</span><br><span class="line">        &#123;</span><br><span class="line">#ifdef DEBUG&#x2F;&#x2F;判断DEBUG是否被定义了</span><br><span class="line">            printf(&quot;We get:%c,about to exit.\n&quot;,c);</span><br><span class="line">#endif</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;i &#x3D; %d&quot;,i);</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">            printf(&quot;,we get:%c&quot;,c);</span><br><span class="line">#endif</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*#endif用于终止#if预处理指令。*&#x2F;</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#error指令将使编译器显示一条错误信息，然后停止编译。</span><br><span class="line">#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。</span><br><span class="line">#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-翻译流程与预处理指令&quot;&gt;&lt;a href=&quot;#C-翻译流程与预处理指令&quot; class=&quot;headerlink&quot; title=&quot;C++翻译流程与预处理指令&quot;&gt;&lt;/a&gt;C++翻译流程与预处理指令&lt;/h2&gt;&lt;p&gt;参考了&lt;a href=&quot;https://www.book
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论-3</title>
    <link href="http://Tyler-ytr.github.io/2021/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA-3/"/>
    <id>http://Tyler-ytr.github.io/2021/03/22/机器学习导论-3/</id>
    <published>2021-03-22T03:14:15.000Z</published>
    <updated>2021-03-22T04:01:29.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><blockquote><p><a href="https://datawhalechina.github.io/pumpkin-book/#/chapter3/chapter3" target="_blank" rel="noopener">南瓜书本章连接</a></p></blockquote><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><ul><li>线性模型一般形式$f(x)=w_1x_1+w_2x_2+\cdots+w_dx_d+b$</li><li>向量形式$f(x)=w^{T}x+b$</li></ul><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><ul><li><p>单一属性</p><ul><li><p>基本目标:$f(x)=wx_{i}+b$使得$f(x_{i})\simeq y_{i}$</p><blockquote><p>目的是把离散的(比如身高的高中低)转换成连续的量(比如高1.0中0.5),这种情况主要考虑”序”，比如青绿，黑色，蓝色可能没有序，这个时候不妨把它变成[0,1,0]这种向量编码(几个维度整几维);</p></blockquote></li><li><p>回归:均方误差最小化</p><p>$(w^{<em>},b^{</em>})=arg\ min_{(w,b)}\sum_{i=1}^{m}(f(x_{i})-y_i)^2$</p><p>可以使用最小二乘参数估计（求偏导让导数为零，例子要求w,b），计算暂略</p><blockquote><p>偏导(w)整的主要是关于(w)的变化率，等于零的时候意味着到了极大/极小值;</p></blockquote></li></ul></li><li><p>多元属性</p><ul><li><p>基本目标:$f(x_i)=w^Tx_i+b$使得$f(x_{i})\simeq y_{i}$</p></li><li><p>回归:</p><p>$\hat{w}^*=\arg \min_{\hat{w}}(y-X\hat{w})^T(y-X\hat{w})$</p><p>如果满秩:$\hat{w}^*=(X^{T}X)^{-1}X^Ty$；$f(\hat{x_{i}})=\hat{x_{i}}^{T}(X^{T}X)^{-1}$</p><p>如果不满秩,求助于归纳偏好或者引入正则化(regularization)(也就是加入限制)</p></li></ul></li><li><p>求解非线性的模型——广义线性模型:</p><ul><li>比如$\ln y=w^Tx+b$,就可以用$e^{w^Tx+b}$来进行毕竟，称作对数线性回归;</li><li>$g(\cdot)$为联系函数(link function)，比如$g(\cdot)=\ln(\cdot)$</li></ul></li></ul><h3 id="二分类任务"><a href="#二分类任务" class="headerlink" title="二分类任务"></a>二分类任务</h3><ul><li><p>线性回归的实际输出:$z=w^{T}x+b$</p><p>期望输出 $y\in{0,1}$</p><p>这个二分类任务就是为了找到一个z,y的联系函数</p></li><li><p>理想模型：单位阶跃函数</p><blockquote><p>缺陷:数学性质很糟糕，不连续</p></blockquote></li><li><p>替代函数——对数几率函数（logistic function）属于sigmoid函数的一种:</p><blockquote><p>logistic 和逻辑没有关系,logistic源于logit 不是logic;</p></blockquote><ul><li><p><strong>$y=\frac{1}{1+e^{-z}}$</strong></p><p>可以表示成$y=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-(w^{T}x+b)}}$</p></li><li><p>两边取对数:</p><p>$\ln\frac{y}{1-y}=w^{T}x+b=\ln\frac{p(y=1|x)}{p(y=0|x)}$</p><blockquote><p>$\frac{y}{1-y}$称作几率(odds)，反映了x作为正例相对于负例的相对可能性;对数几率(log odds，亦称logit)</p></blockquote></li></ul><blockquote><p>不需要假设数据分布,可以得到“类别”的近似概率预测，并且可以直接应用现有的数值优化算法求最优解，这是分类学习算法</p></blockquote><p><img src="picture/image-20210322115345578.png" alt="image-20210322115345578"></p></li><li><p>使用极大似然法(maximum likelihood method)求解,给定数据集${(x_{i}, y_{i})}^{m}<em>{i=1}$,对率回归模型最大化“对数似然”:<br>$$<br>l(w,b)=\sum</em>{i=1}^{m}\ln p (y_i|x_i;w,b)<br>$$</p></li></ul><blockquote><p>似然:正例的可能性*正例+负例的可能性*负例</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线性模型&quot;&gt;&lt;a href=&quot;#线性模型&quot; class=&quot;headerlink&quot; title=&quot;线性模型&quot;&gt;&lt;/a&gt;线性模型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://datawhalechina.github.io/pumpkin
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论-2 模型评估与选择</title>
    <link href="http://Tyler-ytr.github.io/2021/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA-2/"/>
    <id>http://Tyler-ytr.github.io/2021/03/22/机器学习导论-2/</id>
    <published>2021-03-22T02:18:18.000Z</published>
    <updated>2021-03-22T03:26:07.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习导论-2-模型评估与选择"><a href="#机器学习导论-2-模型评估与选择" class="headerlink" title="机器学习导论-2 模型评估与选择"></a>机器学习导论-2 模型评估与选择</h2><blockquote><p><a href="https://datawhalechina.github.io/pumpkin-book/#/chapter2/chapter2" target="_blank" rel="noopener">南瓜书本章推理</a></p></blockquote><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><ul><li><p>假设空间</p><ul><li>假设满足XX条件的是好瓜</li></ul></li><li><p>版本空间</p><ul><li>有限训练集，已知XX是好瓜</li></ul></li><li><p>归纳偏好</p><ul><li>假设空间和训练集一致的假设</li><li>学习过程中对某种类型假设的偏好称为归纳偏好</li></ul></li><li>No Free Lunch<ul><li>奥卡姆剃刀：两个模型效果同样好，选择较为简单的</li></ul></li></ul><h3 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h3><ul><li><p>经验误差与过拟合</p><ul><li>错误率率&amp;误差<ul><li>错误率：错份样本的占$E=a/m$</li><li>误差：样本真实输出与预测输出之间的差异<ul><li>训练（经验）误差：训练集上</li><li>测试误差：测试集</li><li>泛化误差：初训练集外所有样本</li></ul></li></ul></li></ul></li><li><p>过拟合</p><ul><li>学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降</li><li>优化目标加正则项</li><li>Early stop</li></ul></li><li><p>欠拟合</p><ul><li>对训练样本的一般性质尚未学好</li><li>决策树：扩展分支</li><li>神经网络：增加训练层数</li></ul></li><li><p>评估方法</p><ul><li>留出法<ul><li>直接将数据集划分为两个互斥集合</li><li>训练/测试集划分要尽可能保持数据分布的一致性</li><li>一般若干次随机划分，重复实验取平均值</li><li>训练/测试样本比例通常为2:1～4:1</li></ul></li><li>交叉验证法<ul><li>将数据集分层采样划分为$k$个大小相似的互斥子集</li></ul></li><li>自助法<ul><li>以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\prime}$，$D\backslash D^{\prime}$用作测试集</li></ul></li></ul></li><li><p>性能度量</p><ul><li><p>性能度量是衡量模型泛化能力的评价标准，反映任务的需求</p><ul><li>回归任务最常用的是“均方误差”： <ul><li>$E(f:D)=\frac{1}{m}\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$</li></ul></li></ul></li><li><p>查准率 $P=\frac{TP}{TP+FP}$</p></li><li><p>查全率 $R=\frac{TP}{TP+FN}$</p></li><li><p>$P-R$曲线：根据学习器的预测结果对样例排序，“最可能”的正例的在前面，排在最后的是“最不可能”是正例的样本，按此顺序把样本作为整理进行预测，每一次计算出当前的P,R然后以P为纵轴，R为横轴作图</p></li><li><p>如何利用多次训练得到了多个混淆矩阵？</p><ul><li><p>macro-F1:<br>$$<br>macro-P=\frac{1}{n}\sum^{n}_{i=1}P_i\<br>macro-R=\frac{1}{n}\sum^{n}_{i=1}R_i\<br>macro-F_1=\frac{2\times macro-P\times macro-R}{macro-P+macro-R}<br>$$<br>也就是平均P,R之后再算</p></li><li><p>micro-F1:<br>$$<br>micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}\<br>micro-R=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}\<br>micro-F1=\frac{2\times micro-P\times micro-R}{micro-P+micro-R}<br>$$</p></li></ul></li></ul></li></ul><ul><li><p>$F1$ measure：$\frac{2\times TP}{N+TP-TN}$</p></li><li><p>AUC预测了排序质量,越高越好；<br>$$<br>AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\cdot(y_{i}+y_{i+1})<br>$$<br>AUC与排序的密切关系:考虑每一个正反例，若正例的预测值小于反例，那么就计算一个“罚分”：<br>$$<br>\mathcal{l}<em>{tank}=\frac{1}{m^+m^-}\sum</em>{x^+\in D^+}\sum_{x^-\in D^-}(\mathbb{I}(f(x^+)&lt;f(x^-))+\frac{1}{2}\mathbb{I}(f(x^+)=f(x^-)))<br>$$</p><p>$$<br>AUC=1-\mathcal{l}_{tank}<br>$$</p></li></ul><ul><li><p>代价敏感错误率:</p><p>损失是不一样大的一些任务里面，比如漏掉一个病人，放进去一个小偷等等，要考虑“非均等代价”</p><p>建立一个二分类代价矩阵里面有预测类别的cost,然后就就可以得到加权的代价敏感的错误率</p><blockquote><p>这部分的重点是用户到底想要什么？标准型是什么？优化目标是什么？</p></blockquote></li></ul><ul><li><p>性能评估</p><ul><li><p>关于性能比较:某种度量取得评估结果之后能不能直接评价优劣？</p><ul><li>测试性能并不等于泛化性能</li><li>测试性能随着测试集的变化而变化</li><li>很多机器学习算法本身有一定的随机性</li><li>直接选取相应评估方式在相应条件下评估并不可靠</li></ul></li><li><p>二项检验</p><ul><li>泛化错误率为$\epsilon$，测试错误率为$\hat{\epsilon}$，嘉定测试样本从样本总体分布中独立采样而来，我们可以使用“二项检验”，对于$\epsilon&lt;epsilon_{0}$进行假设检验。</li><li>假设$\epsilon\leq\epsilon_{0}$，若测试错误率小于</li></ul></li><li><p>$t$检验</p><blockquote><p>统计学的原来的方法：t检验中训练的数据可能不是那么独立，也许是一个“过高”的估计</p></blockquote></li><li><p>交叉验证$t$检验</p><blockquote><p>5*2交叉验证的含义：</p><p>两折：把数据分成两部分，一部分训练一部分测验；</p><p>五次：把数据洗五次，每次做两折；</p><p>目的：减小某一个数据集的误导</p></blockquote></li><li><p>McNemar检验:</p><blockquote><p>关注正确-正确，错误-错误</p></blockquote></li><li><p>多学习器比较:</p><p>使用Friedman+Nemenyi</p><blockquote><p>算法的好坏不具有传递性：算法A比算法B好；算法B比算法C好；不等于A比C好</p></blockquote></li></ul></li><li><p>偏差和方差</p><ul><li><p>对于测试样本$x$，令$y_{D}$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学的模型$f$在$x$上的预测输出。</p></li><li><p>以回归任务为例：</p><ul><li><p>期望预期为：$\bar{f}(x)=\mathbb{E}_{D}[f(x;D)]$；</p></li><li><p>使用样本数目相同的不同训练集产生的方差为$var(x)=\mathbb{E}_{D}[(f(x:D)-\bar{f}(x))^{2}]$；(每次做的浮动范围)</p></li><li><p>噪声为$\varepsilon^{2}=\mathbb{E}<em>{D}[(y</em>{D}-y)^{2}]$: 本真误差</p></li><li><p>偏差$bias^2(x)=(\overline{f}(x)-y)^2$ 期望输出和真实输出的差别</p><p>比较清晰的图示(周老师真nb):</p><p><img src="/picture/image-20210322111149303.png" alt="image-20210322111149303"></p></li></ul></li><li><p>$E(f;D)=bias^{2}(x)+var(x)+\varepsilon^2$</p><blockquote><p>一开始偏差(bias)起到主要的作用，后来是数据造成的扰动(方差)起到主要的作用，然后overfitting一般情况下是在后者气主要作用的时候产生的，因为其实学习的是数据本身的特征</p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;机器学习导论-2-模型评估与选择&quot;&gt;&lt;a href=&quot;#机器学习导论-2-模型评估与选择&quot; class=&quot;headerlink&quot; title=&quot;机器学习导论-2 模型评估与选择&quot;&gt;&lt;/a&gt;机器学习导论-2 模型评估与选择&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论-1 绪论与数学参考</title>
    <link href="http://Tyler-ytr.github.io/2021/03/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA-1/"/>
    <id>http://Tyler-ytr.github.io/2021/03/08/机器学习导论-1/</id>
    <published>2021-03-08T02:18:18.000Z</published>
    <updated>2021-04-13T07:54:18.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习导论-1-绪论与数学参考"><a href="#机器学习导论-1-绪论与数学参考" class="headerlink" title="机器学习导论-1 绪论与数学参考"></a>机器学习导论-1 绪论与数学参考</h2><blockquote><p>二刷机器学习导论</p></blockquote><blockquote><p>参考书: 统计机器学习 PRML(贝叶斯) ESL(统计学派) MLAPP UML </p></blockquote><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><ol><li><p>学习过程</p><ol><li>训练数据，经过</li><li>学习算法训练，得到</li><li>模型(决策树，射精网络，支持向量机，Boosting，贝叶斯网……)，可以判断</li><li>新数据样本，得到结论</li></ol></li><li><p>机器学习的局限性，失效条件:</p><ol><li>特征信息不充分</li><li>样本信息不充分</li></ol></li><li><p>机器学习的理论基础(计算学习理论),概率近似正确(PAC):</p><p>$P(|f(x)-y|\le \epsilon)\ge 1-\delta$</p><p>f(x)是预测值,y是真实值,目的是尽可能贴近真实值也就是$|f(x)-y|\le \epsilon$,然后这件事情有一个概率的保证，一定大于$1-\delta$的概率确保这件事情的完成。一句话总结就是很高的概率得到很好的结果的模型。</p><blockquote><p>如果你能确定百分百正确，就不用整机器学习了</p></blockquote></li></ol><h3 id="数学参考"><a href="#数学参考" class="headerlink" title="数学参考"></a>数学参考</h3><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><ul><li><p>在实数域中，数的大小和两个数之间的距离是通过绝对值来度量的。将数推广到向量就引入了范数。范数（Norm）是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。</p><blockquote><p>在算例子的时候我觉得其实是不同维度到0点的距离</p></blockquote></li></ul><h5 id="向量的范数"><a href="#向量的范数" class="headerlink" title="向量的范数"></a>向量的范数</h5><ul><li><p>范数标准定义:</p><ul><li><strong>正定性:</strong>$||x||\ge 0$,且$||x||= 0$当且仅当$x=0$;</li><li><strong>齐次性:</strong>对任意实数 $\alpha$ ，都有$||\alpha x||=|\alpha|\ ||x||$</li><li><strong>三角不等式:</strong> 对任意$x,y\in R^n$,都有$||x+y|| \le ||x|| + ||y||$</li></ul><p>则称$||x||$为$R^n$上的向量范数</p></li><li><p>范数表达式:<br>$$<br>\begin{align}<br>\left| \left| x \right| \right|<em>{p}\; :=\; \left( \sum</em>{i=1}^{n}{\left| x_{i} \right|^{p} } \right)^{\frac{1}{p} }\tag{1}<br>\end{align}<br>$$</p></li><li><p>L1范数:<br>$$<br>||x||_1 = |x_1| + |x_2| + \dots + |x_n| = \sum_i^n |x_i|<br>$$<br>向量元素绝对值之和</p><p>L2范数:<br>$$<br>||x||_2 = (|x_1|^2 + |x_2|^2+\dots+ |x_n|^2)^{\frac{1}{2} } =\sqrt{ \sum_i^n x_i^2}<br>$$<br>Euclid范数(欧几里得范数，常用计算向量长度)</p><p>Lp范数:<br>$$<br>||x||_p = (|x_1|^p + |x_2|^p+\dots+ |x_n|^p)^{\frac{1}{p} } =\sqrt[p]{ \sum_i^n x_i^p}<br>$$<br><img src="/picture/image-20210308113014539.png" alt="image-20210308113014539"></p><p>Lp的形状随p的变化的图</p><p>L$\infty $范数:<br>$$<br>||x||<em>{\infty} = \max\limits</em>{1\le i\le n} |x_i|<br>$$</p></li></ul><p>  所有向量元素绝对值中的最大值</p><p>  L$-\infty$范数:<br>  $$<br>  ||x||<em>{\infty} = \min\limits</em>{1\le i\le n} |x_i|<br>  $$<br>  所有向量元素绝对值中的最小值</p><p>  L0范数:<br>  $$<br>  ||x||_0 = \sum_i^n I(x_i \ne 0)<br>  $$<br>  也就是非零元素的数量</p><ul><li><p>例子:$x=(1,4,3,0)^T$的常用范数:</p><p>$||x||_0=3$</p><p>$||x||_1=|1|+|4|+|3|+|0|=8$</p><p>$||x||_2=\sqrt{|1|^2+|4|^2+|3|^2+|0|^2}=\sqrt{26}$</p><p>$||x||_{\infty}=|4|=4$</p></li></ul><h5 id="矩阵的范数"><a href="#矩阵的范数" class="headerlink" title="矩阵的范数"></a>矩阵的范数</h5><ul><li><p>推广到矩阵，矩阵相容范数的定义:</p><ul><li><strong>正定性:</strong>$||A||\ge 0$,且$||A||= 0$当且仅当$A=0$;</li><li><strong>齐次性:</strong>对任意实数 $\alpha$ ，都有$||\alpha A||=|\alpha|\ ||A||$</li><li><strong>三角不等式:</strong> 对任意$A,B\in R^{n\times n}$,都有$||A+B|| \le ||A|| + ||B||$</li><li><strong>相容性:</strong>对任意$A,B\in R^{n\times n}$,都有$||AB|| \le ||A||\ ||B||$</li></ul><p>则称$||A||$为$R^{n\times n}$上的一个矩阵范数</p></li><li><p><strong>列范数:</strong><br>$$<br>||A||<em>1 = \max\limits</em>{1\le j\le n} \sum_i^n |a_{ij}|<br>$$<br>$A$的每一列的绝对值的最大值，称作$A$的列范数</p></li><li><p><strong>行范数:</strong><br>$$<br>||A||<em>{\infty} = \max\limits</em>{1\le i\le n} \sum_j^n |a_{ij}|<br>$$<br>$A$的每一行的绝对值的最大值，称作$A$的行范数</p></li><li><p><strong>L2范数:</strong><br>$$<br>||A||<em>2 = \sqrt{\lambda</em>{max} (A^T A)}<br>$$<br>其中$\lambda_{max}$表示$A^TA$的特征值的绝对值的最大值</p></li><li><p><strong>F-范数(Frobenius):</strong><br>$$<br>||A||_F = (\sum_i^n \sum_j^n a_{ij}^2)^{\frac{1}{2} }=(tr(A^TA))^{1/2}<br>$$<br>它相当于矩阵$A$各项元素的绝对值平方的总和,也就是矩阵张成向量之后的L2范数</p></li></ul><h4 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h4><ul><li><p>一阶导数：雅可比矩阵</p><p>假设函数$F:{R_n} \to {R_m}$是一个从欧式n维空间转换到欧式m维空间的函数.这个函数由m个实函数组成:$y1(x1,…,xn), …, ym(x1,…,xn)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵, 这就是所谓的雅可比矩阵：<br>$$<br>\begin{bmatrix} \frac{\partial y_1}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_1}{\partial x_n} \ \vdots &amp; \ddots &amp; \vdots \ \frac{\partial y_m}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_m}{\partial x_n} \end{bmatrix}<br>$$</p></li></ul><p>  此矩阵表示为: ${J_F}({x_1}, \ldots ,{x_n})$,或者$\frac{ {\partial {({y_1}, … ,{y_m})} }  } { {\partial {({x_1}, … ,{x_n})} } }$.</p><blockquote><p>hexo 两个{之间要加空格不然会报错: expected variable end</p></blockquote><p>  如果$p$是$R_n$中的一点，$F$在$p$点可微分，那么这一点的导数由$J_F(p)$给出.在此情况下, 由$F(p)$描述的线性算子即接近点$p$的$F$的最优线性逼近, $x$逼近于$p$:<br>  $$<br>  F({\bf{x} }) \approx F({\bf{p} }) + {J_F}({\bf{p} }) \cdot ({\bf{x} } – {\bf{p} })<br>  $$</p><ul><li><p>二阶导数：海森矩阵</p><p>海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下：<br>$$<br>f({x_1},{x_2} \ldots ,{x_n})<br>$$<br>如果$f$所有的二阶导都存在，那么有：<br>$$<br>H{(f)_{ij} }(x) = {D_i}{D_j}f(x)<br>$$<br>也就是:<br>$$<br>\begin{bmatrix}<br>\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1\,\partial x_n} \  \<br>\frac{\partial^2 f}{\partial x_2\,\partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2\,\partial x_n} \  \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \  \<br>\frac{\partial^2 f}{\partial x_n\,\partial x_1} &amp; \frac{\partial^2 f}{\partial x_n\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}<br>\end{bmatrix}<br>$$</p></li><li><p>链式法则的式子里面有转置的原因可以从维度的角度来思考;</p></li></ul><h4 id="奇异值"><a href="#奇异值" class="headerlink" title="奇异值"></a>奇异值</h4><ul><li><p>共轭:$z=a+bi$,z的共轭$\bar{z}=a-bi$;实数的共轭是他自身;</p></li><li><p>矩阵概念:</p><ul><li><p>对称矩阵:</p><p>$A^T=A$</p></li><li><p>Hermite矩阵，将实数范围讨论的对称矩阵延伸到复数范围:</p><p>其中，用$\bar{A}$表示以$A$的元素的共轭复数为元素构成的矩阵,那么$A^H=(\bar{A}^T)$，这个称作$A$的复共轭转置矩阵;</p><ul><li>特征值都是实数。</li><li>任意两个不同特征值所对应的特征向量正交。</li></ul></li><li><p>正交矩阵:</p><p> $A^TA=E$</p></li><li><p>酉矩阵:</p><p>$A^HA=E$</p><p>这玩意其实就是正交矩阵在复数范围的推广</p></li><li><p>奇异矩阵:</p><p>$|A|=0$称作奇异矩阵，否则称作非奇异矩阵;$A$是可逆矩阵的充要条件是$|A|\neq0$,因此可逆矩阵就是非奇异矩阵</p></li><li><p>正规矩阵:</p><p>$A^HA=AA^H$,如果都是实数矩阵，那么$A^T=A^H,A^TA=AA^T$</p></li><li><p>幂等矩阵:</p><p>$A^2=A$</p></li><li><p>正定矩阵:它是对称矩阵/Hermite矩阵的进一步延伸</p><p>设$A$为n阶Hermite矩阵，如果对任意n维复向量$x$都有$x^HAx\ge 0$,则称A是半正定矩阵;如果对任意n维复向量$x$都有$x^HAx&gt; 0$,则称A是正定矩阵。</p><ul><li>Hermite矩阵$A$为正定（半正定）矩阵 $\leftrightarrow$$A$的所有特征值是正数（非负数）。</li><li>Hermite矩阵$A$为正定矩阵 $\leftrightarrow$存在n阶非奇异矩阵$P$，使得$A=P^HP$</li><li>Hermite矩阵$A$为半正定矩阵$\leftrightarrow $存在n阶矩阵$P$，使得$A=P^HP$</li></ul></li></ul></li><li><p>特征值与特征分解:</p><p>特征值特征向量定义：$\lambda$是特征值,$x$是特征向量,A是方阵<br>$$<br>Ax=\lambda x<br>$$<br>求解走:</p><p>$Ax=\lambda x\rightarrow Ax=\lambda E x\rightarrow (\lambda E-A)x=0\rightarrow|\lambda E-A|=0$解出特征值带入得到特征向量</p><p>特征分解:对于mxm的满秩对称矩阵A<br>$$<br>A=Q\Sigma Q^{-1}=Q\Sigma Q^T<br>$$<br>其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。</p><p>特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。</p></li></ul><h5 id="奇异值与奇异值分解"><a href="#奇异值与奇异值分解" class="headerlink" title="奇异值与奇异值分解"></a>奇异值与奇异值分解</h5><ol><li><p>运用到的理论:</p><ol><li>对于n阶方阵，$Ax=\lambda x$;</li><li>如果$\vec{a}$与$\vec{b}$正交,那么有$\vec{a} \cdot \vec{b} = 0$</li><li>一个内积空间的正交基（orthogonal basis）是元素两两正交的基,基中的元素称为基向量。如果一个正交基的基向量的模长都是单位长度1，则称这正交基为标准正交基或”规范正交基”（Orthonormal basis）；</li><li>A与A的转置矩阵是有相同的特征值,但是他们各自的特征向量没有关系；</li></ol></li><li><p><strong>SVD推导之矩阵分解:</strong></p><p>对于矩阵$A$,有$A^TA = \lambda_{i} v_{i}$(因为$A^TA$肯定是方阵);$\lambda_i$是特征值,$v_i$是特征向量;假设$(v_{i}, v_{j})$是一组正交基，那么有$v_{i}^{T} \cdot v_{j} = 0$，那么:<br>$$<br>\begin{align} (Av_{i}, Av_{j}) &amp;= (Av_{i})^{T} \cdot Av_{j} \ &amp;= v_{i}^{T} A^T Av_{j} \ &amp;= v_{i}^{T} \lambda_{j} v_{j} \ &amp;= \lambda_{j} \color{red}{v_{i}^{T} v_{j} } \ &amp;= 0 \end{align} \tag{1}<br>$$<br>可以得到$Av_{i}, Av_{j}$;根据公式$(1)$可以推导得到$(Av_{i}, Av_{i}) = \lambda_{i} v_{i}^{T} v_{i}=\lambda_{i}$;又因为行列式的性质$|AB|=|A||B|\rightarrow|(Av_{i})^{T} \cdot Av_{i}|=|Av_{i}^{T} ||Av_{i}|=|Av_{i}|^2$,所以有:<br>$$<br>\begin{align} &amp; |Av_{i}|^2 = \lambda_{i} \ &amp; |Av_{i}| = \sqrt{\lambda_{i} } \end{align} \tag{2}<br>$$<br>根据公式(2),有$\frac{Av_{i} }{|Av_{i}|} = \frac{1}{\sqrt{\lambda_{i} } } Av_{i}$，令$\frac{1}{\sqrt{\lambda_{i} } } Av_{i}= u_{i}$,可以得到:<br>$$<br>Av_{i}= \sqrt{\lambda_{i} }u_{i}=\delta_{i}u_{i} \tag{3}<br>$$<br>其中$\delta_{i} = \sqrt{\lambda_{i} }$（这个称作奇异值）,进一步推导成矩阵形式:<br>$$<br>\begin{align} AV &amp;= A(v_{1}, v_{2}, \dots, v_{n} ) \ &amp;= (Av_{1}, Av_{2}, \dots, Av_{n} ) \ &amp;= (\delta_{1}u_{1}, \delta_{2}u_{2}, \dots, \delta_{n}u_{n} ) \ &amp;= U\Sigma \end{align} \tag{4}<br>$$<br>从而得到:<br>$$<br>A = U\Sigma V^T \tag{5}<br>$$</p></li><li><p><strong>SVD推导之矩阵计算:</strong></p><p>已知$A$怎么算$U$和$V$呢？</p><p>首先计算$A$的转置$A^T$,而$A^T$相当于:<br>$$<br>\begin{align} A^T =  V\Sigma^TU^T \end{align} \tag{6}<br>$$<br>然后计算$A^TA$:<br>$$<br>\begin{align} A^TA &amp;= V\Sigma^TU^T U\Sigma V^T \ &amp;= V\Sigma^2V^T \end{align} \tag{7}<br>$$<br>通过公式(7),会发现这不就是特征值分解嘛！！！可以得到$A^TA v_{i} = \lambda_{i}v_{i}$,只需要求出$A^TA$的特征向量就可以得到$V$了</p><p>同理计算$AA^T:$<br>$$<br>\begin{align} A A^T &amp;= U\Sigma V^T V\Sigma^TU^T \ &amp;= U\Sigma^2U^T \end{align} \tag{8}<br>$$</p><p>通过公式(8),可以得到$AA^T u_{i} = \lambda_{i}u_{i}$,只需要求出$AA^T$的特征向量就可以得到$U$了</p><p>$\Sigma$是上面公式(7)或者公式(8)中求到的非零特征值从大到小排列后开根号的值</p></li><li><p>SVD计算例子:</p><p>假设有一个矩阵$A$:<br>$$<br>A=\begin{bmatrix} 1&amp;1\1&amp;1\0&amp;0\end{bmatrix}<br>$$<br>要计算:<br>$$<br>A_{3\times 2}=U_{3\times 3}\Sigma_{3\times2}V^T_{2\times 2}<br>$$<br>中的$U,V,\Sigma$</p><ol><li><p>计算$U$  </p><p>$AA^T=\begin{bmatrix} 2&amp;2&amp;0\2&amp;2&amp;0\0&amp;0&amp;0\end{bmatrix}$,进行特征分解，得到特征值[4,0,0]以及对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T,[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T,[0,0,1]^T$,可以得到：<br>$$<br>U=\begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}&amp;0 \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}&amp;0 \ 0&amp;0&amp;1 \end{bmatrix}<br>$$</p></li></ol></li><li><p>计算$V$  </p><p>$A^TA=\begin{bmatrix} 2&amp;2 \ 2&amp;2 \end{bmatrix}$,进行特征分解,得到特征值[4,0]以及对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T,[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T$,可以得到:<br>$$<br>   V=\begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}} \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\end{bmatrix}<br>$$</p></li><li><p>计算$\Sigma$ </p><p>因为特征值是[4,0]，因此:<br>$$<br>   \Sigma=\begin{bmatrix} 2&amp;0 \ 0&amp;0 \ 0&amp;0 \end{bmatrix}<br>$$<br>   所以$A$的SVD分解是:<br>$$<br>   A=U \Sigma V^T= \begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}&amp;0 \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}&amp;0 \ 0&amp;0&amp;1 \end{bmatrix} \begin{bmatrix} 2&amp;0 \ 0&amp;0 \ 0&amp;0 \end{bmatrix} {\begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}} \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\end{bmatrix}}^T=\begin{bmatrix} 1&amp;1\1&amp;1\0&amp;0\end{bmatrix}<br>$$</p></li><li><p>代码求解方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A=np.array([<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">print(np.linalg.svd(A))</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>以下主要是优化的部分</p></blockquote><h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><blockquote><p>To be done</p></blockquote><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul><li><a href="https://ryannng.github.io/2016/12/23/%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/" target="_blank" rel="noopener">向量范数与矩阵范数</a></li><li><a href="http://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">雅可比矩阵和海森矩阵</a></li><li><a href="https://www.cnblogs.com/pinard/p/10825264.html" target="_blank" rel="noopener">链式法则</a></li><li><a href="https://zhuanlan.zhihu.com/p/120333258" target="_blank" rel="noopener">Hermite矩阵性质</a></li><li><a href="https://blog.csdn.net/Junerror/article/details/80222540" target="_blank" rel="noopener">矩阵特征值求解</a></li><li><a href="https://blog.csdn.net/qq_30232405/article/details/104588293" target="_blank" rel="noopener">矩阵的基本知识</a></li><li><a href="http://www.csuldw.com/2017/03/09/2017-03-09-svd/#mjx-eqn-1" target="_blank" rel="noopener">矩阵的奇异值推导</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;机器学习导论-1-绪论与数学参考&quot;&gt;&lt;a href=&quot;#机器学习导论-1-绪论与数学参考&quot; class=&quot;headerlink&quot; title=&quot;机器学习导论-1 绪论与数学参考&quot;&gt;&lt;/a&gt;机器学习导论-1 绪论与数学参考&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;二
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-5:完善MRI</title>
    <link href="http://Tyler-ytr.github.io/2021/03/06/p4%E5%AD%A6%E4%B9%A0-5/"/>
    <id>http://Tyler-ytr.github.io/2021/03/06/p4学习-5/</id>
    <published>2021-03-06T08:44:38.000Z</published>
    <updated>2021-03-09T06:42:38.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="p4学习-5-完善MRI"><a href="#p4学习-5-完善MRI" class="headerlink" title="p4学习-5:完善MRI"></a>p4学习-5:完善MRI</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><p>这次实验的目的是在基本的L3转发上面拓展一个带内遥测(INT)的阉割版本，这里称作多跳路由检查(Multi-Hop Route Inspection)(MRI)。</p><blockquote><p> 根据维基百科，多跳路由(Multi-hop routing)是无线电网络中的一种通信，其中网络覆盖区域大域单个节点的无线电范围，因此要到达某一个目的地的时候一个节点可以使用其他节点做中继。</p></blockquote><p>MRI允许使用者追踪每一个包经过的路线以及序列的长度，为了支持这个功能需要写一个P4程序，这个程序能够在每一个包的header stack上面附加一个ID以及队列的长度。在收包的目的地，交换机ID的顺序相当于这个包走的路径，每一个ID后面都跟着这个交换机的队列长度。</p><blockquote><p>控制平面已经事先设置好了</p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>mri里面包括了两个自定义的头:<code>mri_t</code>包含了<code>count</code>，用来指示交换机ID的数量;<code>switch_t</code>包含了数据包经过的每个交换机跳的交换机ID和队列深度字段；</p><p>主要挑战是处理用于解析两个headers的递归逻辑；这里使用<code>parser_metada</code>字段的<code>remaining</code>来追踪有多少<code>switch_t</code>头需要来解析;在<code>parse_mri</code>状态,这个字段设置为<code>hdr.mri.count</code>。在<code>parse_swtrace</code>状态将转换到其自身，直到剩余为0。</p><p>MRI自定义报头会携带在IP Options 头里面,其中IP Options头里面的<code>option</code>用于指示选项的类型。 我们将使用特殊的类型31来表示MRI标头的存在。</p><p>除了解析器逻辑外，您还将在sgress中添加一个表，在<code>swtrace</code>中存储交换机ID和队列深度，并执行增加<code>count</code>字段的操作，并附加一个<code>switch_t</code>标头。</p><p>一个完整的<code>mri.p4</code>包含如下组件:</p><ol><li>以太网（<code>ethernet_t</code>），IPv4（<code>ipv4_t</code>），IP选项（<code>ipv4_option_t</code>），MRI（<code>mri_t</code>）和交换机（<code>switch_t</code>）的<strong>header头部类型定义</strong>。</li><li>以太网，IPv4，IP选项，MRI和交换机的<strong>解析器Parsers</strong>，将填充<code>ethernet_t</code>，<code>ipv4_t</code>，<code>ipv4_option_t</code>，<code>mri_t</code>和<code>switch_t</code>。</li><li>使用<code>mark_to_drop()</code>丢弃数据包的<strong>动作action</strong>。</li><li>一个<strong>action动作</strong>（称为<code>ipv4_forward</code>），它将：<ol><li>设置下一跳的出口端口。</li><li>用下一跳的地址更新以太网目标地址。</li><li>用交换机的地址更新以太网源地址。</li><li>减少TTL</li></ol></li><li>一个ingress control:<ol><li>定义一个表，该表将读取IPv4目标地址，并调用<code>drop</code>或<code>ipv4_forward</code>。</li><li>一个应用表的<code>apply</code>模块</li></ol></li><li>在egress部分，将添加交换机ID和队列深度的action动作（<code>add_swtrace</code>）。</li><li>一个egress control,它应用表（<code>swtrace</code>）来存储交换机ID和队列深度并调用<code>add_swtrace</code></li><li>用于选择将字段插入传出数据包的顺序的<strong>deparser。</strong></li><li>实例化</li></ol><p><strong>headers部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F;</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">const bit&lt;8&gt;  UDP_PROTOCOL &#x3D; 0x11;</span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;</span><br><span class="line">const bit&lt;5&gt;  IPV4_OPTION_MRI &#x3D; 31;</span><br><span class="line"></span><br><span class="line">#define MAX_HOPS 9</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line">typedef bit&lt;32&gt; switchID_t;</span><br><span class="line">typedef bit&lt;32&gt; qdepth_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123;</span><br><span class="line">    macAddr_t dstAddr;</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_option_t &#123;</span><br><span class="line">    bit&lt;1&gt; copyFlag;</span><br><span class="line">    bit&lt;2&gt; optClass;</span><br><span class="line">    bit&lt;5&gt; option;</span><br><span class="line">    bit&lt;8&gt; optionLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mri头</span><br><span class="line"></span><br><span class="line">header mri_t &#123;</span><br><span class="line">    bit&lt;16&gt;  count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header switch_t &#123;</span><br><span class="line">    switchID_t  swid;</span><br><span class="line">    qdepth_t    qdepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ingress_metadata_t &#123;</span><br><span class="line">    bit&lt;16&gt;  count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct parser_metadata_t &#123;</span><br><span class="line">    bit&lt;16&gt;  remaining;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123;</span><br><span class="line">    ingress_metadata_t   ingress_metadata;</span><br><span class="line">    parser_metadata_t   parser_metadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t         ethernet;</span><br><span class="line">    ipv4_t             ipv4;</span><br><span class="line">    ipv4_option_t      ipv4_option;</span><br><span class="line">    mri_t              mri;</span><br><span class="line">    switch_t[MAX_HOPS] swtraces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error &#123; IPHeaderTooShort &#125;</span><br></pre></td></tr></table></figure><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="1-先跑不完整的初始版本代码"><a href="#1-先跑不完整的初始版本代码" class="headerlink" title="1 先跑不完整的初始版本代码"></a>1 先跑不完整的初始版本代码</h5><p>先跑一下初始代码看看啥样，以便和之后的做对比</p><ol><li><p>在shell上面跑:</p><blockquote><p>make</p></blockquote><p>这步会:</p><ul><li>编译<code>mri.p4</code></li><li>启动一个 Mininet 实例，其中三个交换机(<code>s1</code>,<code>s2</code>,<code>s3</code>)设置在三角形结构里面。有5个主机.具体见拓扑图部分</li><li>主机被指定成了<code>10.0.1.1</code>, <code>10.0.2.2</code>，其他的也都是(<code>10.0.&lt;Switchid&gt;.&lt;hostID&gt;</code>)这种格式</li><li>控制平面部分的规则是基于<code>sx-runtime.json</code></li></ul></li><li><p>准备做的事情是在<code>h1</code>和<code>h2</code>之间发送低速率的流, 在<code>h11</code>和<code>h22</code>之间发送搞俗的测试流。<code>s1</code>和<code>s2</code>之间会形成一个拥塞因为在<code>topology.json</code>里面把带宽削减到了512kbps。因此如果我们在<code>h2</code>收包胡发现连接里面有很长的队列等待长度。</p><p>拓扑如下:</p><p><img src="/picture/setup.png" alt="Setup"></p></li><li><p>在make打开的Mininet命令行界面开四个窗口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; xterm h1 h11 h2 h22</span><br></pre></td></tr></table></figure></li><li><p>在h2的xterm里面打开收包的服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;receive.py</span><br></pre></td></tr></table></figure></li><li><p>在h22的xterm里面打开iperf UDP 服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s -u</span><br></pre></td></tr></table></figure></li><li><p>在h1的xterm里面使用<code>send.py</code>给h2每秒发一个包，发30秒:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./send.py 10.0.2.2 <span class="string">"P4 is cool"</span> 30</span><br></pre></td></tr></table></figure><p>在h2的xterm里面会收到”P4 is cool “信息</p></li><li><p>在h11的xterm里面，启动iperf客户端发送15秒:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c 10.0.2.22 -t 15 -u</span><br></pre></td></tr></table></figure></li><li><p>在h2端,MRI header没有hop信息(count=0)</p></li><li><p>退出来</p><p> 这里h2虽然接到了信息，但是没有关于这条消息经过的路径的信息。完善的内容就是在<code>mri.p4</code>里面完善MRI逻辑来记录路径信息。</p><ol start="10"><li><p>到目前的实验结果如下:</p><p><img src="/picture/image-20210309103128712.png" alt="h2"></p><p>会发现h2收到的MRI信息里面的count=0;</p><p>h22中因为线路的带宽有限，几次实验发现15秒发不完:</p><p><img src="/picture/image-20210309103437274.png" alt="h22"></p><p>h1和h11里面是发包的提示信息:</p><p>h1如下:</p><p><img src="/picture/image-20210309103534773.png" alt="h1"></p><p>h11如下:</p><p><img src="/picture/image-20210309103620003.png" alt="h11"></p></li></ol></li></ol><h5 id="2-控制平面相关"><a href="#2-控制平面相关" class="headerlink" title="2 控制平面相关"></a>2 控制平面相关</h5><blockquote><p>控制平面相关:P4程序定义了一个数据包处理管道，但是控制数据包的规则是由控制平面插入到管道中的。 当规则与数据包匹配时，将使用控制平面提供的参数作为规则的一部分来调用其动作。在本练习中，控制平面逻辑已经实现。 作为启动Mininet实例的一部分，make脚本将在每个交换机的表中安装数据包处理规则。 这些定义在sX-runtime.json文件中，其中X对应于交换机号。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1-runtime.json部分代码</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"target"</span>: <span class="string">"bmv2"</span>,</span><br><span class="line">  <span class="attr">"p4info"</span>: <span class="string">"build/mri.p4.p4info.txt"</span>,</span><br><span class="line">  <span class="attr">"bmv2_json"</span>: <span class="string">"build/mri.json"</span>,</span><br><span class="line">  <span class="attr">"table_entries"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"table"</span>: <span class="string">"MyEgress.swtrace"</span>,</span><br><span class="line">      <span class="attr">"default_action"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"action_name"</span>: <span class="string">"MyEgress.add_swtrace"</span>,</span><br><span class="line">      <span class="attr">"action_params"</span>: &#123;</span><br><span class="line">         <span class="attr">"swid"</span>: <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"table"</span>: <span class="string">"MyIngress.ipv4_lpm"</span>,</span><br><span class="line">      <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"hdr.ipv4.dstAddr"</span>: [<span class="string">"10.0.1.1"</span>, <span class="number">32</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"action_name"</span>: <span class="string">"MyIngress.ipv4_forward"</span>,</span><br><span class="line">      <span class="attr">"action_params"</span>: &#123;</span><br><span class="line">        <span class="attr">"dstAddr"</span>: <span class="string">"08:00:00:00:01:01"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//..............还有一部分已经省略</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现这里的表项和拓扑图以及P4代码里面的table息息相关，写法也和之前的P4runtime里面的相似</p><h5 id="3-完善MRI"><a href="#3-完善MRI" class="headerlink" title="3 完善MRI"></a>3 完善MRI</h5><p>见前面的代码实现部分</p><h5 id="4-运行解决方案"><a href="#4-运行解决方案" class="headerlink" title="4 运行解决方案"></a>4 运行解决方案</h5><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;p4学习-5-完善MRI&quot;&gt;&lt;a href=&quot;#p4学习-5-完善MRI&quot; class=&quot;headerlink&quot; title=&quot;p4学习-5:完善MRI&quot;&gt;&lt;/a&gt;p4学习-5:完善MRI&lt;/h2&gt;&lt;h4 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#实验目标&quot; cla
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode300-m</title>
    <link href="http://Tyler-ytr.github.io/2021/03/04/leetcode300-m/"/>
    <id>http://Tyler-ytr.github.io/2021/03/04/leetcode300-m/</id>
    <published>2021-03-04T15:31:23.000Z</published>
    <updated>2021-03-06T02:47:10.658Z</updated>
    
    <content type="html"><![CDATA[<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h4><p>难度中等1422收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以设计时间复杂度为 <code>O(n2)</code> 的解决方案吗？</li><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><p><strong>解答 :</strong></p><ol><li><p>$O(n^2)$的方法：</p><p>使用dp[i]表示[0,i]之间的最大子序列长度，根据最大子序列的定义来思考状态转移方程:</p><p>dp[i]=max(dp[i],dp[j]+1 if j&lt;i and nums[j]&lt;nums[i])</p><p>也就是一个循环遍历i，然后里面的循环遍历j，找到一个nums[i]小的然后更新;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _length=len(nums)</span><br><span class="line">        <span class="keyword">if</span> _length &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> _length</span><br><span class="line">        dp=[<span class="number">1</span>]*(_length+<span class="number">1</span>)</span><br><span class="line">        res=dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,_length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            res=max(res,dp[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>$O(NlogN)$的方法:</p><p>贪心加二分，不是很好想;</p><p>这里找的状态时tail[i],表示长度为<code>i+1</code>的<strong>所有</strong>上升子序列的结尾最小值;这里的tail[i]时严格递增的，可以用反证法证明;</p><p>这题就变成了维护tail这个数组，这个数组的长度就是我们要求的结果的长度;如何维护分为以下两步:</p><ul><li><p>扩充数组元素:</p><p>如果遍历nums的时候这个 nums[i]&gt;*(tail.end()),那么就把nums[i]添加到tail数组后面，此时相当于tail数组变长了一位;</p></li><li><p>更新数组里面的元素：</p><p>如果遍历nums的时候这个nums[i]&lt;*(tail.end()),那么就要看tail数组里面第一个大于nums[i]的数，然后把它换成nums[i];</p></li></ul><p>例子解释:</p><blockquote><p>[9,2,3,6,7,4],初始化的时候表示长度的end=1,tail[end]=-1001,下面的[]表示tail数组</p><p>[9] 遍历到9,9&gt;tail[end],tail[end]=9</p><p>[2] 遍历到2,2&lt;tail[end],找到第一个大于2的,只有9,替换</p><p>[2,3] 遍历到3,3&gt;tail[end],添加进去</p><p>[2,3,6] 同理</p><p>[2,3,6,7] 同理</p><p>[2,3,4,7] 遍历到4,4&lt;tail[end],找到第一个大于4的,把它变小成4</p></blockquote><p>直观的来看,tail 数组越紧致,它越容易边长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _length=len(nums)</span><br><span class="line">        tail=[<span class="number">-1001</span>]*(_length+<span class="number">1</span>)</span><br><span class="line">        end=<span class="number">1</span></span><br><span class="line">        tail[end<span class="number">-1</span>]=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,_length):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;tail[end<span class="number">-1</span>]:</span><br><span class="line">                end=end+<span class="number">1</span></span><br><span class="line">                tail[end<span class="number">-1</span>]=nums[i]</span><br><span class="line">            <span class="keyword">elif</span> nums[i]&lt;tail[end<span class="number">-1</span>]:</span><br><span class="line">                left=<span class="number">0</span></span><br><span class="line">                right=end<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                    mid=(left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tail[mid]&lt;nums[i]:</span><br><span class="line">                        left=mid+<span class="number">1</span> <span class="comment"># 中位数不是要找的数</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right=mid</span><br><span class="line">                tail[left]=nums[i]</span><br><span class="line">        <span class="keyword">return</span> end</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;300-最长递增子序列&quot;&gt;&lt;a href=&quot;#300-最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;300. 最长递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-in
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库与泛型编程学习笔记</title>
    <link href="http://Tyler-ytr.github.io/2021/03/04/STL/"/>
    <id>http://Tyler-ytr.github.io/2021/03/04/STL/</id>
    <published>2021-03-04T13:25:17.000Z</published>
    <updated>2021-03-08T13:06:36.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-标准库与泛型编程学习笔记"><a href="#C-标准库与泛型编程学习笔记" class="headerlink" title="C++标准库与泛型编程学习笔记"></a>C++标准库与泛型编程学习笔记</h1><blockquote><p>感谢侯捷老师</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>六大部件</p><ul><li>容器(containers):数据存放在里面</li><li>分配器(Allocators):支持容器的内存管理</li><li>算法(Algorithms):一个个模板函数</li><li>迭代器(Iterators):泛化的指针</li><li>适配器(Adapters):有容器/迭代器/仿函数适配器，可以帮他们进行转换</li><li><p>仿函数(Functors):相似于函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">........</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">6</span>]=&#123;<span class="number">27</span>,<span class="number">210</span>,....&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,allocator&lt;<span class="keyword">int</span>&gt;&gt;vi(ia,ia+<span class="number">6</span>);<span class="comment">//分配器不写会默认帮你搞好;vi是iterator;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count_if(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),notl(bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>)));<span class="comment">//count_if 是算法,not1是function adapter(negator)，表示否定，大于等于40;bind2nd是function adapter(binder),绑定第二参数,这里的作用是有没有小于40;less是function object 仿函数;not1(....)这行称作predicate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>复杂度 略</p></li><li><p>“前闭后开”区间：标准库用 c.begin()指的是头,c.end()指向尾巴的后面一个,因此是[);所以*(c.end())是不行的;</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite=c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;ite!=c.<span class="built_in">end</span>();++ite)&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//range-based for statement C++11</span></span><br><span class="line"><span class="keyword">for</span>(decl:coll)&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子:</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem:vec)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;elem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem:vec)&#123;</span><br><span class="line">    elem*=<span class="number">3</span>;<span class="comment">//使用引用才能变;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//auto的使用;</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;c;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;</span><br><span class="line">ite=::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),target);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">auto</span> ite=::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),target);</span><br></pre></td></tr></table></figure></li></ol><h2 id="容器测试"><a href="#容器测试" class="headerlink" title="容器测试"></a>容器测试</h2><ol><li><p>分类:</p><ol><li><p>Sequence Containers(序列式):</p><p>Array:固定元素大小的数组</p><p>Vector:末端可以扩张的数组</p><p>Deque(/dek/):前后可以扩张的数组,双向队列</p><p>List:双链</p><p>Forward-List:单链,内存小于前者</p></li><li><p>Associative Containers(关联式):</p><p>适合查找</p><p>Set/Multiset:集合,底部用红黑树做;Multiset可以重复</p><p>Map/Multimap:有序的键/值对,后者的key可以重复,底部用红黑树做;</p></li><li><p>Unordered Containers(不定序的元素):</p><p>Unordered set/Multiset:集合,底部基于哈希-拉链法</p><p>Unordered Map/Multimap:有序的键/值对,底部基于哈希-拉链法</p></li></ol></li><li><p>容器速率直观比较:</p><p>(单位是毫秒)</p><ul><li><p>Array:47,187(项目:50万随机数for循环赋值时间和排序+二分查找时间)</p></li><li><p>Vector:3063,2765(项目:100万随机数for循环push_back和排序+二分查找时间）a.size()=1000000,a.capacity()=1048576,因为vector增加的时候会预留空间,长着长着开一个两倍的空间复制进去;这个例子里面用find找元素比排序+二分快,0毫秒</p></li><li><p>List:3265,2312,16(项目:100万随机数for循环push_back和排序+二分查找时间和find的时间),list自带sort</p></li><li><p>forward_list:3204,15,2656(项目:100万随机数,find的时间,sort的时间) ，它也自带sort</p></li><li><p>slist:非标准库里面,#include&lt;ext\slist&gt;里面有;和forward_list使用差不多;</p></li><li><p>deque:2704,15,3110(项目:100万随机数push_back,find函数,使用全局sort)deque的连续是一种假象;它是分段连续,分成一个个buffer,由指针指着;如果buffer用完了就再申请一块buffer;</p></li><li><p>stack: deque其实涵盖了stack和queue;它们两个的底层都是deque;812(项目:30万随机数push)</p></li><li><p>queue:890(项目:30万随机数push)</p><blockquote><p>因为stack,queue是由deque实现的,所以也被称为容器适配器</p></blockquote></li><li><p>multiset:6609,203,0(项目:100万随机数insert放进去和全局find和自己的find)关联式容器找东西非常快</p></li><li><p>multimap:4812,0(项目:&lt;index,100万随机数&gt; insert放进去和自己的find)</p></li><li><p>unordered_multiset:4406,109,0(项目:100万随机数insert进去和全局find和自带find) ;bucket_count()可以看出篮子的个数,篮子一定比元素多;load_factor()可以看出负载因子;</p></li><li><p>unordered_multimap:4313,0(项目:100万随机数insert进去和自带的find)</p></li><li><p>set:3922,0,0(项目:100万随机数insert进去和全局find和自带find)</p></li><li><p>map:4890,0(项目:100万放进去和自带的find)；multiset不能用<code>c[i]=string(buf)</code>只能用insert函数插入,但是map可以；</p></li><li><p>unordered_map,unordered_set:略</p></li><li><p>一些老版本的容器比如slist,hash_set,hash_map.hash_multiset,hash_multimap要另外include;</p></li></ul></li></ol><h2 id="分配器测试"><a href="#分配器测试" class="headerlink" title="分配器测试:"></a>分配器测试:</h2><p>下面都是GNU-C里面的:</p><ol><li><p>分类器使用示例: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typename_Tp,typename_Alloc=<span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;class <span class="built_in">vector</span>:protected_Vector_base&lt;_Tp,_Alloc&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>不同分配器的使用示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用std::allocator意外的allocator需要自行#include&lt;ext\....&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\array_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\mt_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\debug_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\pool_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\bitmap_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\new_allocator.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,allocator&lt;<span class="built_in">string</span>&gt;&gt; c1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::malloc_allocator&lt;<span class="built_in">string</span>&gt;&gt; c2;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::new_allocator&lt;<span class="built_in">string</span>&gt;&gt; c3;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::__pool_allocator&lt;<span class="built_in">string</span>&gt;&gt; c4;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::__mt_allocator&lt;<span class="built_in">string</span>&gt;&gt; c5;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>,__gnu_cxx::bitmap_allocator&lt;<span class="built_in">string</span>&gt;&gt; c6;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>分配器可以分配内存，但是不如malloc/free;new/delete舒服，释放内存很麻烦;比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int*p;</span><br><span class="line">allocator&lt;int&gt;alloc1;</span><br><span class="line">p&#x3D;alloc1.allocate(1);</span><br><span class="line">alloc1.deallocate(p,1);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-标准库与泛型编程学习笔记&quot;&gt;&lt;a href=&quot;#C-标准库与泛型编程学习笔记&quot; class=&quot;headerlink&quot; title=&quot;C++标准库与泛型编程学习笔记&quot;&gt;&lt;/a&gt;C++标准库与泛型编程学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;感谢侯捷老师&lt;
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-4:P4runtime实验</title>
    <link href="http://Tyler-ytr.github.io/2021/03/02/p4%E5%AD%A6%E4%B9%A0-4/"/>
    <id>http://Tyler-ytr.github.io/2021/03/02/p4学习-4/</id>
    <published>2021-03-02T14:06:07.000Z</published>
    <updated>2021-03-05T08:44:52.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="p4学习-4-P4runtime实验"><a href="#p4学习-4-P4runtime实验" class="headerlink" title="p4学习-4:P4runtime实验"></a>p4学习-4:P4runtime实验</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><p>使用P4Runtime而不是来交换机的CLI发送flow entries;P4程序是在basic tunnel里面的程序的基础上写的，改名叫了 <code>advanced_tunnel.p4</code>，并且增加了两个counters(<code>ingressTunnelCounter</code>, <code>egressTunnelCounter</code>)和两个actions(<code>myTunnel_ingress</code>, <code>myTunnel_egress</code>)</p><p>使用启动程序<code>mycontroller.py</code>以及一些 <code>p4runtime_lib</code> 库里面的函数来创建主机1和主机2之间隧道通信所需的表项。</p><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><p>主要是<code>mycontroller.py</code>里面的<code>writeTunnelRules</code>函数的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import P4Runtime lib from parent utils dir</span></span><br><span class="line"><span class="comment"># Probably there's a better way of doing this.</span></span><br><span class="line">sys.path.append(</span><br><span class="line">    os.path.join(os.path.dirname(os.path.abspath(__file__)),</span><br><span class="line">                 <span class="string">'../../utils/'</span>))</span><br><span class="line"><span class="keyword">import</span> p4runtime_lib.bmv2</span><br><span class="line"><span class="keyword">from</span> p4runtime_lib.switch <span class="keyword">import</span> ShutdownAllSwitchConnections</span><br><span class="line"><span class="keyword">import</span> p4runtime_lib.helper</span><br><span class="line"></span><br><span class="line">SWITCH_TO_HOST_PORT = <span class="number">1</span></span><br><span class="line">SWITCH_TO_SWITCH_PORT = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeTunnelRules</span><span class="params">(p4info_helper, ingress_sw, egress_sw, tunnel_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                     dst_eth_addr, dst_ip_addr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Installs three rules:</span></span><br><span class="line"><span class="string">    1) An tunnel ingress rule on the ingress switch in the ipv4_lpm table that encapsulates traffic into a tunnel with the specified ID</span></span><br><span class="line"><span class="string">    ipv4_lpm表的入接口开关上的隧道入接口规则，该规则用指定的ID将流量封装到一个隧道中</span></span><br><span class="line"><span class="string">    2) A transit rule on the ingress switch that forwards traffic based on the specified ID</span></span><br><span class="line"><span class="string">    入口交换机上的一种传输规则，根据指定的ID转发流量</span></span><br><span class="line"><span class="string">    3) An tunnel egress rule on the egress switch that decapsulates traffic with the specified ID and sends it to the host</span></span><br><span class="line"><span class="string">    出口交换机上的一条隧道出口规则，将指定ID的流量解封装后发送给主机</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param p4info_helper: the P4Info helper</span></span><br><span class="line"><span class="string">    :param ingress_sw: the ingress switch connection</span></span><br><span class="line"><span class="string">    :param egress_sw: the egress switch connection</span></span><br><span class="line"><span class="string">    :param tunnel_id: the specified tunnel ID</span></span><br><span class="line"><span class="string">    :param dst_eth_addr: the destination IP to match in the ingress rule</span></span><br><span class="line"><span class="string">    :param dst_ip_addr: the destination Ethernet address to write in the egress rule</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1) Tunnel Ingress Rule</span></span><br><span class="line">    table_entry = p4info_helper.buildTableEntry(</span><br><span class="line">        table_name=<span class="string">"MyIngress.ipv4_lpm"</span>,</span><br><span class="line">        match_fields=&#123;</span><br><span class="line">            <span class="string">"hdr.ipv4.dstAddr"</span>: (dst_ip_addr, <span class="number">32</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        action_name=<span class="string">"MyIngress.myTunnel_ingress"</span>,</span><br><span class="line">        action_params=&#123;</span><br><span class="line">            <span class="string">"dst_id"</span>: tunnel_id,</span><br><span class="line">        &#125;)</span><br><span class="line">    ingress_sw.WriteTableEntry(table_entry)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Installed ingress tunnel rule on %s"</span> % ingress_sw.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2) Tunnel Transit Rule</span></span><br><span class="line">    <span class="comment"># The rule will need to be added to the myTunnel_exact table and match on the tunnel ID (hdr.myTunnel.dst_id). Traffic will need to be forwarded using the myTunnel_forward action on the port connected to the next switch.这条规则是添加到myTunnel_exact table上面的，match的部分是tunnel ID (hdr.myTunnel.dst_id)。流量将会使用myTunnel_forward action转发到连接下一个交换机的端口，这里要观察下面的拓扑图会发现连接交换机(h1,h2)的都是二号端口，文件里面用SWITCH_TO_SWITCH_PORT表示了2号端口</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># For our simple topology, switch 1 and switch 2 are connected using a link attached to port 2 on both switches. We have defined a variable at the top of the file, SWITCH_TO_SWITCH_PORT, that you can use as the output port for this action.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># We will only need a transit rule on the ingress switch because we are using a simple topology. In general, you'll need on transit rule for each switch in the path (except the last switch, which has the egress rule), and you will need to select the port dynamically for each switch based on your topology.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO build the transit rule</span></span><br><span class="line">    <span class="comment"># TODO install the transit rule on the ingress switch</span></span><br><span class="line">    <span class="comment">#print "TODO Install transit tunnel rule"</span></span><br><span class="line">table_entry=p4info_helper.buildTableEntry(</span><br><span class="line">    table_name=<span class="string">"MyIngress.myTunnel_exact"</span>,</span><br><span class="line">        match_fields=&#123;</span><br><span class="line">            <span class="string">"hdr.myTunnel.dst_id"</span>:tunnel_id</span><br><span class="line">        &#125;,</span><br><span class="line">        action_name=<span class="string">"MyIngress.myTunnel_forward"</span>,</span><br><span class="line">        action_params=&#123;</span><br><span class="line">            <span class="string">"port"</span>:SWITCH_TO_SWITCH_PORT</span><br><span class="line">        &#125;)</span><br><span class="line">    ingress_sw.WriteTableEntry(table_entry)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Installed transit tunnel rule on %s"</span> % ingress_sw.name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3) Tunnel Egress Rule</span></span><br><span class="line">    <span class="comment"># For our simple topology, the host will always be located on the SWITCH_TO_HOST_PORT (port 1).</span></span><br><span class="line">    <span class="comment"># In general, you will need to keep track of which port the host is connected to.</span></span><br><span class="line">    table_entry = p4info_helper.buildTableEntry(</span><br><span class="line">        table_name=<span class="string">"MyIngress.myTunnel_exact"</span>,</span><br><span class="line">        match_fields=&#123;</span><br><span class="line">            <span class="string">"hdr.myTunnel.dst_id"</span>: tunnel_id</span><br><span class="line">        &#125;,</span><br><span class="line">        action_name=<span class="string">"MyIngress.myTunnel_egress"</span>,</span><br><span class="line">        action_params=&#123;</span><br><span class="line">            <span class="string">"dstAddr"</span>: dst_eth_addr,</span><br><span class="line">            <span class="string">"port"</span>: SWITCH_TO_HOST_PORT</span><br><span class="line">        &#125;)</span><br><span class="line">    egress_sw.WriteTableEntry(table_entry)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Installed egress tunnel rule on %s"</span> % egress_sw.name</span><br><span class="line">    </span><br><span class="line"><span class="comment">#### 下面的函数省略不表</span></span><br></pre></td></tr></table></figure><p>实际写的时候主要依靠下面的Tunnel Egress Rule规则仿写,主要p4文件里面:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">**************  I N G R E S S   P R O C E S S I N G   *******************</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function">control <span class="title">MyIngress</span><span class="params">(inout headers hdr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  inout metadata meta,</span></span></span><br><span class="line"><span class="function"><span class="params">                  inout <span class="keyword">standard_metadata_t</span> standard_metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) ingressTunnelCounter;</span><br><span class="line">    counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) egressTunnelCounter;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">drop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">action <span class="title">ipv4_forward</span><span class="params">(macAddr_t dstAddr, egressSpec_t port)</span> </span>&#123;</span><br><span class="line">        standard_metadata.egress_spec = port;</span><br><span class="line">        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr = dstAddr;</span><br><span class="line">        hdr.ipv4.ttl = hdr.ipv4.ttl - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">myTunnel_ingress</span><span class="params">(<span class="built_in">bit</span>&lt;<span class="number">16</span>&gt; dst_id)</span> </span>&#123;</span><br><span class="line">        hdr.myTunnel.setValid();</span><br><span class="line">        hdr.myTunnel.dst_id = dst_id;</span><br><span class="line">        hdr.myTunnel.proto_id = hdr.ethernet.etherType;</span><br><span class="line">        hdr.ethernet.etherType = TYPE_MYTUNNEL;</span><br><span class="line">        ingressTunnelCounter.count((<span class="built_in">bit</span>&lt;<span class="number">32</span>&gt;) hdr.myTunnel.dst_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">myTunnel_forward</span><span class="params">(egressSpec_t port)</span> </span>&#123;</span><br><span class="line">        standard_metadata.egress_spec = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">action <span class="title">myTunnel_egress</span><span class="params">(macAddr_t dstAddr, egressSpec_t port)</span> </span>&#123;</span><br><span class="line">        standard_metadata.egress_spec = port;</span><br><span class="line">        hdr.ethernet.dstAddr = dstAddr;</span><br><span class="line">        hdr.ethernet.etherType = hdr.myTunnel.proto_id;</span><br><span class="line">        hdr.myTunnel.setInvalid();</span><br><span class="line">        egressTunnelCounter.count((<span class="built_in">bit</span>&lt;<span class="number">32</span>&gt;) hdr.myTunnel.dst_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key = &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions = &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            myTunnel_ingress;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1024</span>;</span><br><span class="line">        default_action = NoAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table myTunnel_exact &#123;</span><br><span class="line">        key = &#123;</span><br><span class="line">            hdr.myTunnel.dst_id: exact;</span><br><span class="line">        &#125;</span><br><span class="line">        actions = &#123;</span><br><span class="line">            myTunnel_forward;</span><br><span class="line">            myTunnel_egress;</span><br><span class="line">            drop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1024</span>;</span><br><span class="line">        default_action = drop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        <span class="keyword">if</span> (hdr.ipv4.<span class="built_in">isValid</span>() &amp;&amp; !hdr.myTunnel.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">            <span class="comment">// Process only non-tunneled IPv4 packets.</span></span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hdr.myTunnel.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">            <span class="comment">// Process all tunneled packets.</span></span><br><span class="line">            myTunnel_exact.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match_field里面相当于action里面的key部分,具体的值由控制平面也就是函数里面的<code>tunnel_id</code>确定;action_name里面相当于调用了<code>action myTunnel_forward</code>,这个action的参数只有<code>port</code>,又因为题目里面的提示要求port是<code>SWITCH_TO_SWITCH_PORT</code>因此填进去就行了;</p><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="1-跑未完成的代码"><a href="#1-跑未完成的代码" class="headerlink" title="1 跑未完成的代码"></a>1 跑未完成的代码</h5><ol><li><p><code>mycontroller.py</code>里面包含了一些隧道通信需要的规则，在没有完成的情况下先跑p4看看啥样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>这步编译了 <code>advanced_tunnel.p4</code>,</li><li>启动一个Mininet实例，其中三个交换机(<code>s1</code>, <code>s2</code>, <code>s3</code>)配置在一个三角形中，每个交换机连接到一个主机(<code>h1</code>, <code>h2</code>, <code>h3</code>)，并且把<code>10.0.1.1</code>, <code>10.0.2.2</code>, <code>10.0.3.3</code>这些IP配置到对应的主机上</li></ul></li><li><p>现在会看到mininet命令窗口，ping h1 和 h2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; h1 ping h2</span><br></pre></td></tr></table></figure><p>因为交换机上面没有规则，现在还没法接受回应，然后如果ctrl+C就如下图各种丢包；</p><p><img src="/picture/image-20210303234909688.png" alt="image-20210303234909688"></p><p>现在把这个ping留着继续跑然后开另一个shell</p></li><li><p>在另一个shell里面跑:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/tutorials/exercises/p4runtime</span><br><span class="line">./mycontroller.py</span><br></pre></td></tr></table></figure><p>这会安装<code>advanced_tunnel.p4</code>程序到switch上面并且把tunnel ingress规则推进去；这个程序每两秒打印ingress和egress的counters</p><p><img src="/picture/image-20210304163414071.png" alt="image-20210304163414071"></p><p>因为目前没有完成还有一些TODO的部分，所以下面可以看到这些包经过s1的ingress并且让计数器增加；</p></li><li><p>Ctrl-c退出</p><p>目前的交换机是根据目的IP地址将流量映射到隧道(ID)上面，要做的工作是写规则，从而让交换机能够基于隧道(tunnel) ID来转发流量 </p></li></ol><blockquote><p>和前面的对比：之前的都是依靠一些json文件静态的设置表项，这里是动态的；要注意到p4 程序仅仅定义了一个包处理的管道，但是是不包含具体的规则的；</p><p>P4程序定义了包处理管道（规则由控制平面插入），同时定义了交互机的pipeline和控制平面的接口（这部分在advanced_tunnel.p4info）里面；在mycontroller. py里面构建的表项(table entries)会根据名称引用特定的表、键和actions；使用p4info会将名字转换程P4runtime所需要的ID。在P4程序中添加或者重命名的表、键、actions都要反映在 py程序的表项(table entries)里面</p></blockquote><h5 id="2-完善隧道转发"><a href="#2-完善隧道转发" class="headerlink" title="2 完善隧道转发"></a>2 完善隧道转发</h5><ol><li><p>p4runtime_lib库里面的总结,这部分代码在tutorials/utils/p4runtime_lib里面:</p><ul><li><p><code>p4runtime_lib.helper</code></p><ul><li>包含了<code>P4InfoHelper</code> 类能够解析<code>P4Info</code>文件，包括了name,id,alias,match_field(本身/id/name/pb/value)，action_param(本身/id/name/pb)</li><li>提供了实体的名字到ID数字转换的方法(buildTableEnrty函数)</li><li>构建P4Runtime表项的P4依赖于程序的部分。</li></ul></li><li><p><code>p4runtime_lib.switch.py</code></p><ul><li>包括了<code>SwitchConnection</code>类，会获取gRPC的client stub以及给交换机建立连接</li><li>提供了helper方法，能够构建P4Runtime协议的buffer信息以及制作P4Runtime gRPC service calls</li></ul></li><li><p><code>p4runtime_lib.bmv2.py</code></p><ul><li><p>包含了 <code>Bmv2SwitchConnection</code> 类，它拓展了<code>SwitchConnections</code>并且提供了BMv2-specific 设备载荷来装载P4程序</p><blockquote><p> PS:实际上是重载了SwitchConnection 然后多了一个buildDeviceConfig函数能够根据bmv2_json_file来返回设备的配置</p></blockquote></li></ul></li><li><p><code>p4runtime_lib.convert.py</code></p><ul><li>由<code>helper.py</code>调用</li><li>主要提供了一些把数字/字符串编码协议buffer信息需要的格式的方法以及相应的解码方法</li></ul></li></ul></li><li><p><code>mycontroller.py</code>是一个结能的控制平面做了以下的事情</p><ol><li>为P4Runtime服务构建了一个到交换机的 gRPC连接</li><li>把P4程序push给各个交换机</li><li>在h1,h2之间的两个隧道编写了ingress/egress规则</li><li>每两秒读隧道的ingress/egress计数器</li></ol></li><li><p>代码部分主要要做的事情是在 <code>writeTunnelRules</code>函数里面写隧道转发规则，它对应于隧道ID并且能够把包转发到下一跳</p></li><li><p>拓扑图如下:</p><p><img src="/picture/topo_basic_tunnel-1614931073774.png" alt="topology"></p></li></ol><h5 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3 实验结果"></a>3 实验结果</h5><p>先<code>make clean</code>再<code>make</code>，然后<code>h1 ping h2</code>，然后开一个新端口<code>./mycontroller.py</code>，这个时候可以看见ingress,egress的计数都上涨了:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210305163701102.png" alt="py_info" title="">                </div>                <div class="image-caption">py_info</div>            </figure><p>另外ping也能够成功的收到了:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210305163722778.png" alt="mini_info" title="">                </div>                <div class="image-caption">mini_info</div>            </figure><h4 id="额外参考——rpc-grpc学习"><a href="#额外参考——rpc-grpc学习" class="headerlink" title="额外参考——rpc,grpc学习"></a>额外参考——rpc,grpc学习</h4><p>左转参考博客</p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul><li><a href="https://www.cnblogs.com/duanxz/p/3769872.html" target="_blank" rel="noopener">rpc介绍</a></li><li><a href="https://www.shuzhiduo.com/A/n2d9O7yQJD/" target="_blank" rel="noopener">P4 runtime 和 p4 info</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;p4学习-4-P4runtime实验&quot;&gt;&lt;a href=&quot;#p4学习-4-P4runtime实验&quot; class=&quot;headerlink&quot; title=&quot;p4学习-4:P4runtime实验&quot;&gt;&lt;/a&gt;p4学习-4:P4runtime实验&lt;/h2&gt;&lt;h4 id=&quot;实
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode303-s</title>
    <link href="http://Tyler-ytr.github.io/2021/03/01/leetcode303-s/"/>
    <id>http://Tyler-ytr.github.io/2021/03/01/leetcode303-s/</id>
    <published>2021-03-01T12:18:36.000Z</published>
    <updated>2021-03-01T12:36:04.639Z</updated>
    
    <content type="html"><![CDATA[<h4 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></h4><p>难度简单283收藏分享切换为英文接收动态反馈</p><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>104</code> 次 <code>sumRange</code> 方法</li></ul><p><strong>解答：</strong></p><p>使用前缀和方法，前缀和表示的是[0,i)之间的和，比如对于数组 [1,2,3,4,5],presum[0]=0,presum[1]=0+1=1……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)+<span class="number">1</span>):</span><br><span class="line">presum[i+<span class="number">1</span>]=presum[i]+nums[i]</span><br></pre></td></tr></table></figure><p>因此本题解法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        _length=len(nums)</span><br><span class="line">        self.presum=[<span class="number">0</span>]*(_length+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,_length):</span><br><span class="line">            self.presum[i+<span class="number">1</span>]=self.presum[i]+nums[i]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i: int, j: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.presum[j+<span class="number">1</span>]-self.presum[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(i,j)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;303. 区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/probl
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="前缀和" scheme="http://Tyler-ytr.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1176-h</title>
    <link href="http://Tyler-ytr.github.io/2021/02/26/leetcode1176-h/"/>
    <id>http://Tyler-ytr.github.io/2021/02/26/leetcode1176-h/</id>
    <published>2021-02-26T09:05:15.000Z</published>
    <updated>2021-02-26T09:14:39.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1178-猜字谜"><a href="#1178-猜字谜" class="headerlink" title="1178. 猜字谜"></a><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/" target="_blank" rel="noopener">1178. 猜字谜</a></h4><p>难度困难149</p><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li><li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）都不能作为谜底。</li></ul><p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words &#x3D; [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], </span><br><span class="line">puzzles &#x3D; [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]</span><br><span class="line">输出：[1,1,3,2,4,0]</span><br><span class="line">解释：</span><br><span class="line">1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; </span><br><span class="line">1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;</span><br><span class="line">3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;</span><br><span class="line">2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;</span><br><span class="line">4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;</span><br><span class="line">没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#39;g&#39;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^5</code></li><li><code>4 &lt;= words[i].length &lt;= 50</code></li><li><code>1 &lt;= puzzles.length &lt;= 10^4</code></li><li><code>puzzles[i].length == 7</code></li><li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li><li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li></ul><p><strong>解答：</strong></p><p>这题有两个要思考的点，第一个是怎么压缩状态，非常自然的想到二进制，英文字母一共26位，用int完全可以表示，通过这一点可以想到一个朴素的方法（TLE）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int 二进制有32位 英文字母一共26位 出现一次该位为1</span></span><br><span class="line">        <span class="comment">//a最小,z最大</span></span><br><span class="line">        <span class="comment">//如果字谜A包含了wordB,首先A&amp;B==1，判断A中的第一个字母有没有包含在B里面 假设该字母是00010,取反是11101，(11101|B)&amp;(00010)表示有</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result(puzzles.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;wordmap(words.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;puzzlemap(puzzles.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                temp=<span class="number">1</span>&lt;&lt;(<span class="keyword">int</span>)(words[i][j]-<span class="string">'a'</span>);</span><br><span class="line">                wordmap[i]|=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;puzzles.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;puzzles[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                temp=<span class="number">1</span>&lt;&lt;(<span class="keyword">int</span>)(puzzles[i][j]-<span class="string">'a'</span>);</span><br><span class="line">                puzzlemap[i]|=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;puzzles.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="number">1</span>&lt;&lt;(<span class="keyword">int</span>)(puzzles[i][<span class="number">0</span>]-<span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">if</span>((~temp|wordmap[j])&amp;temp)&#123;</span><br><span class="line">                    <span class="keyword">int</span> a=puzzlemap[i];</span><br><span class="line">                    <span class="keyword">int</span> b=wordmap[j];</span><br><span class="line">                    <span class="keyword">if</span>((a&amp;b)==b)&#123;</span><br><span class="line">                        result[i]+=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法就是先将words,puzzles都压缩成二进制串然后一对一比较，后面比较是一个O($N^2$),并且没有利用<code>puzzles[i].length == 7</code>这个条件，因此会TLE；（这是TLE的<a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/xiang-jin-zhu-shi-xiang-jie-po-su-wei-yu-3cr2/" target="_blank" rel="noopener">分析</a>）</p><p>根据<code>puzzles[i].length == 7</code>，然后可以联想到优化的方法，因为长度是固定的，所以它的子集数目也是比较小的，因此可以将words做一个unorderer_map，然后对于pussles压缩之后的每一个子集进行查询即可。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算</span></span><br><span class="line">        <span class="comment">//int 二进制有32位 英文字母一共26位 出现一次该位为1</span></span><br><span class="line">        <span class="comment">//a最小,z最大</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何枚举一个二进制数的子集：</span></span><br><span class="line">        <span class="comment">//也就是10101的子集是10101,10100,10001,10000,00101,00100,00001,00000;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int sub = k;</span></span><br><span class="line"><span class="comment">        do &#123;</span></span><br><span class="line"><span class="comment">            sub = (sub - 1) &amp; k;</span></span><br><span class="line"><span class="comment">        &#125; while(sub != k);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count; </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> &amp;<span class="keyword">word</span>: words) &#123;<span class="comment">//注意</span></span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : <span class="keyword">word</span>)</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>));</span><br><span class="line">            count[mask]+=<span class="number">1</span>;<span class="comment">//如果出现了那么对应的count那么这个count应该为1</span></span><br><span class="line">           <span class="comment">// cout&lt;&lt;count[mask];</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=puzzles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            <span class="built_in">string</span>&amp;puzzle=puzzles[i];</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch:puzzle)&#123;</span><br><span class="line">                k|=(<span class="number">1</span>&lt;&lt;(ch-<span class="string">'a'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sub = k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                sub = (sub - <span class="number">1</span>) &amp; k;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">'a'</span>)) &amp; sub)</span><br><span class="line">                    result[i] += count[sub];</span><br><span class="line">            &#125; <span class="keyword">while</span>(sub != k);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1178-猜字谜&quot;&gt;&lt;a href=&quot;#1178-猜字谜&quot; class=&quot;headerlink&quot; title=&quot;1178. 猜字谜&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-valid-wor
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="位运算" scheme="http://Tyler-ytr.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读一篇论文阅读笔记</title>
    <link href="http://Tyler-ytr.github.io/2021/02/25/how-to-read-a-paper-notes/"/>
    <id>http://Tyler-ytr.github.io/2021/02/25/how-to-read-a-paper-notes/</id>
    <published>2021-02-25T08:59:25.000Z</published>
    <updated>2021-03-01T11:32:18.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="How-to-read-a-paper-阅读笔记"><a href="#How-to-read-a-paper-阅读笔记" class="headerlink" title="How to read a paper 阅读笔记"></a>How to read a paper 阅读笔记</h2><blockquote><p>原文链接:<a href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf" target="_blank" rel="noopener">https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf</a></p><p>由刘恩萌启发</p></blockquote><p><strong>3段方法</strong></p><ol><li><p>1st pass</p><ol><li>仔细阅读标题，abstract和intruduction，结论；浏览section &amp; subsection的标题、数学内容；reference；其他部分一概忽略</li><li>能够回答下面的五个C:<ol><li>Category:(类型：测量/分析/描述……)</li><li>Context:(有关论文？理论基础？…… )</li><li>Correctness:（假设看上去正确吗？……）</li><li>Contributions</li><li>Clarity:（写的咋样……）</li></ol></li><li>通过这些内容决定是否进一步阅读</li></ol></li><li><p>2nd pass</p><ol><li>比第一遍更认真的看，可以记一些笔记在空白处，划重点；看完之后应该能够把握论文内容</li><li>认真看图表，看看有没有错</li><li>标注没读过的相关文献以便进一步了解背景</li><li>如果看完还是懵逼，以下三选一：<ol><li>扔一边不看了</li><li>过一会/看完背景材料再看</li><li>坚持不懈并且进入步骤3</li></ol></li></ol></li><li><p>3rd pass</p><ol><li><p>virtually re-implement:</p><p>标注作者的假设，然后在这些假设基础(虚拟)上重新实现这个工作，通过将重新实现和作者文章的比较，很容易发现它的创新点以及隐藏的错误/假设</p></li><li><p>重点是关注细节，积累对未来工作的想法</p></li><li><p>在这一阶段结束时，能够根据记忆重建整篇文章的结构，并且能够识别出它的优缺点。</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;How-to-read-a-paper-阅读笔记&quot;&gt;&lt;a href=&quot;#How-to-read-a-paper-阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;How to read a paper 阅读笔记&quot;&gt;&lt;/a&gt;How to read a 
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>p4学习-3:P4 basic tunnel实验</title>
    <link href="http://Tyler-ytr.github.io/2021/02/24/p4%E5%AD%A6%E4%B9%A0-3/"/>
    <id>http://Tyler-ytr.github.io/2021/02/24/p4学习-3/</id>
    <published>2021-02-24T08:52:17.000Z</published>
    <updated>2021-03-05T08:01:47.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-3：P4-basic-tunnel实验"><a href="#P4学习-3：P4-basic-tunnel实验" class="headerlink" title="P4学习-3：P4 basic tunnel实验"></a>P4学习-3：P4 basic tunnel实验</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><ol><li><p>在本练习中，我们将向IP添加对基本隧道协议的支持</p><p>你在上一个作业中完成的路由器。基本交换机根据目的IP地址进行转发。您的工作是定义一个新的头类型来封装IP包并修改交换代码，这样它就可以使用一个新的隧道头来决定目的端口。</p><p>新的头类型将包含协议ID，它指示被封装的包的类型，以及用于路由的目的地ID。</p></li><li><p>P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。</p><p>对于本练习，我们已经添加了必要的静态控制平面条目。作为启动Mininet实例的一部分，<code>make run</code>命令将在每个交换机的表中安装包处理规则。这些是在<code>sX-runtime</code>中定义的<code>json files</code>，其中<code>X</code>对应开关号。</p><p>因为控制平面试图访问<code>myTunnel_exact</code>表，而这个表还不存在，所以<code>make run</code>命令不能与启动器代码一起工作。</p><p>PS：这里使用P4Runtime来安装规则，文件内容在<code>sX-runtime.json</code>里面</p></li><li><p>拓扑如下:</p><p><img src="/picture/topo_basic_tunnel.png" alt="pod-topo"></p></li><li><p><code>basic_tunnel.p4</code>文件包含了一个基本的IP路由器的实现，完整的实现版本将能够转发基于自定义封装头的内容，以及如果封装头在数据包中不存在，那么将执行正常的IP转发。工作有以下几个部分:</p><ol><li><strong>NOTE:</strong>添加了一个新的头类型称作<code>myTunnel_t</code> ,包含了<code>proto_id</code> and <code>dst_id</code></li><li><strong>NOTE:</strong><code>myTunnel_t</code> 已经加入了<code>myTunnel_t</code> header</li><li><strong>TODO:</strong>更新解析器，根据以太网头中的<code>etherType</code>字段提取<code>myTunnel</code>头或<code>ipv4</code>头。myTunnel报头对应的etherType是’ 0x1212 ‘。如果<code>proto_id</code> == <code>TYPE_IPV4 &#39;</code>即0x0800)，解析器还应该在<code>myTunnel 头</code>之后提取<code>ipv4</code>头。</li><li><strong>TODO:</strong> 定义了一个新的action称作 <code>myTunnel_forward</code> ，它设置出口端口(即<code>standard_metadata</code>总线的<code>egress_spec</code>字段)到控制平面提供的端口号。</li><li><strong>TODO:</strong>定义一个名为<code>myTunnel_exact</code>的新表，它对<code>myTunnel</code>报头的<code>dst_id</code>字段执行精确匹配。如果表中有匹配项，该表应该调用<code>myTunnel_forward</code>操作，否则它应该调用<code>drop</code>操作。</li><li><strong>TODO:</strong>如果<code>myTunnel</code>报头有效，更新<code>MyIngress</code>控制块中的<code>apply</code>语句，以应用新定义的<code>myTunnel_exact</code>表。否则，如果<code>ipv4</code>报头有效，则调用<code>ipv4_lpm</code>表。</li><li>更新deparser以发出’ ethernet ‘，然后是’ myTunnel ‘，然后是’ ipv4 ‘头。请记住，deparser只会在消息头有效时发出消息头。头的隐式有效性位由解析器在提取时设置。这里不需要检查头的有效性。</li><li>为新定义的表添加静态规则，以便交换机能够正确转发’ dst_id ‘的每个可能值。请参阅下面的图，了解拓扑的端口配置以及我们将如何为主机分配id。在此步骤中，您需要将转发规则添加到“sX-runtime”中。json文件。</li></ol></li></ol><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><p><strong>headers部分：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F;</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NOTE: new type added here</span><br><span class="line">const bit&lt;16&gt; TYPE_MYTUNNEL &#x3D; 0x1212;</span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123;</span><br><span class="line">    macAddr_t dstAddr;</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NOTE: added new header type</span><br><span class="line">header myTunnel_t &#123;&#x2F;&#x2F;新的header type</span><br><span class="line">    bit&lt;16&gt; proto_id; &#x2F;&#x2F;包含了proto_id以及dst_id</span><br><span class="line">    bit&lt;16&gt; dst_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123;</span><br><span class="line">    &#x2F;* empty *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NOTE: Added new header type to headers struct</span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t   ethernet;</span><br><span class="line">    myTunnel_t   myTunnel; &#x2F;&#x2F;新添加的字段</span><br><span class="line">    ipv4_t       ipv4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Parser部分："><a href="#Parser部分：" class="headerlink" title="Parser部分："></a><strong>Parser部分：</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as well</span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ethernet &#123;</span><br><span class="line">        packet.extract(hdr.ethernet);</span><br><span class="line">        transition select(hdr.ethernet.etherType) &#123;</span><br><span class="line">            TYPE_IPV4 : parse_ipv4;</span><br><span class="line">            default : accept;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ipv4 &#123;</span><br><span class="line">        packet.extract(hdr.ipv4);</span><br><span class="line">        transition accept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as well</span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ethernet &#123;</span><br><span class="line">        packet.extract(hdr.ethernet);</span><br><span class="line">        transition select(hdr.ethernet.etherType) &#123;</span><br><span class="line">            TYPE_IPV4 : parse_ipv4;</span><br><span class="line">            TYPE_MYTUNNEL : parse_mytunnel;</span><br><span class="line">            default : accept;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state parse_ipv4 &#123;</span><br><span class="line">        packet.extract(hdr.ipv4);</span><br><span class="line">        transition accept;</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_mytunnel&#123;</span><br><span class="line">    packet.extract(hdr.myTunnel);</span><br><span class="line">    transition select(hdr.myTunnel.proto_id)&#123; &#x2F;&#x2F;满足需求：如果&#96;proto_id &#96; &#x3D;&#x3D; &#96; TYPE_IPV4 &#39;&#96;即0x0800)，解析器还应该在&#96;myTunnel 头&#96;之后提取&#96;ipv4 &#96;头。</span><br><span class="line">    TYPE_IPV4 : parse_ipv4;</span><br><span class="line">    default : accept;</span><br><span class="line">    &#125;</span><br><span class="line">    transition accept;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Ingress部分（以及checksum部分）："><a href="#Ingress部分（以及checksum部分）：" class="headerlink" title="Ingress部分（以及checksum部分）："></a><strong>Ingress部分（以及checksum部分）：</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec &#x3D; port;</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr;</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact</span><br><span class="line">    &#x2F;&#x2F; TODO: also remember to add table entries!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Update control flow</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec &#x3D; port;</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr;</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;&#x2F;&#x2F;最长前缀匹配</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port)</span><br><span class="line">action myTunnel_ford(egressSpec_t port)&#123;</span><br><span class="line">standard_metadata.egress_spec &#x3D; port;&#x2F;&#x2F;设置端口号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact</span><br><span class="line">    table myTunnel_exact&#123;</span><br><span class="line">    key&#x3D;&#123;</span><br><span class="line">    hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配</span><br><span class="line">    &#125;</span><br><span class="line">    actions&#x3D;&#123;</span><br><span class="line">    myTunnel_ford;</span><br><span class="line">    drop;&#x2F;&#x2F;如果表中有匹配项，该表应该调用&#96; myTunnel_forward &#96;操作，否则它应该调用&#96; drop &#96;操作。</span><br><span class="line">    &#125;</span><br><span class="line">    size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; drop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; TODO: also remember to add table entries!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Update control flow</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">        if(hdr.myTunnel.isValid())&#123;&#x2F;&#x2F;模仿ipv4写的</span><br><span class="line">        myTunnel_exact.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: match_kind： 这是match_action table里面的一种类型，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key&#x3D;&#123;</span><br><span class="line">hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的exact就是一种match_kind，<a href="https://github.com/p4lang/p4c" target="_blank" rel="noopener">p4c</a>/<a href="https://github.com/p4lang/p4c/tree/master/p4include" target="_blank" rel="noopener">p4include</a>/core.p4有三种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match_kind &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Match bits exactly.精准匹配</span><br><span class="line">    exact,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Ternary match, using a mask. 把值和一个 mask 比较，比如 0x01020304 符合 mask 0x0F0F0F0F</span><br><span class="line">    ternary,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Longest-prefix match.最长前缀匹配</span><br><span class="line">    lpm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/p4lang/p4c" target="_blank" rel="noopener">p4c</a>/<a href="https://github.com/p4lang/p4c/tree/master/p4include" target="_blank" rel="noopener">p4include</a>/<strong>v1model.p4</strong>里面有一下几种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match_kind &#123;</span><br><span class="line">    &#x2F;&#x2F;检查是否值在一个范围里，比如取 0x01020304 - 0x010203FF 之间的值</span><br><span class="line">    range,</span><br><span class="line">    &#x2F;&#x2F; Either an exact match, or a wildcard (matching any value).精准匹配或者通配</span><br><span class="line">    optional,</span><br><span class="line">    &#x2F;&#x2F; Used for implementing dynamic_action_selection 用于实现dynamic_action_selection</span><br><span class="line">    selector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在include上述两个文件的情况下一共有六种</p><h5 id="Egress部分（以及checksum部分）："><a href="#Egress部分（以及checksum部分）：" class="headerlink" title="Egress部分（以及checksum部分）："></a>Egress部分（以及checksum部分）：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*************   C H E C K S U M    C O M P U T A T I O N   **************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyComputeChecksum(inout headers  hdr, inout metadata meta) &#123;</span><br><span class="line">     apply &#123;</span><br><span class="line">update_checksum(</span><br><span class="line">    hdr.ipv4.isValid(),</span><br><span class="line">            &#123; hdr.ipv4.version,</span><br><span class="line">      hdr.ipv4.ihl,</span><br><span class="line">              hdr.ipv4.diffserv,</span><br><span class="line">              hdr.ipv4.totalLen,</span><br><span class="line">              hdr.ipv4.identification,</span><br><span class="line">              hdr.ipv4.flags,</span><br><span class="line">              hdr.ipv4.fragOffset,</span><br><span class="line">              hdr.ipv4.ttl,</span><br><span class="line">              hdr.ipv4.protocol,</span><br><span class="line">              hdr.ipv4.srcAddr,</span><br><span class="line">              hdr.ipv4.dstAddr &#125;,</span><br><span class="line">            hdr.ipv4.hdrChecksum,</span><br><span class="line">            HashAlgorithm.csum16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Deparser部分:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);</span><br><span class="line">        &#x2F;&#x2F; TODO: emit myTunnel header as well</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);</span><br><span class="line">        &#x2F;&#x2F; TODO: emit myTunnel header as well</span><br><span class="line">        packet.emit(hdr.myTunnel);</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例化部分：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  S W I T C H  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">V1Switch(</span><br><span class="line">MyParser(),</span><br><span class="line">MyVerifyChecksum(),</span><br><span class="line">MyIngress(),</span><br><span class="line">MyEgress(),</span><br><span class="line">MyComputeChecksum(),</span><br><span class="line">MyDeparser()</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><ol><li><p>make run</p><p>这会进行以下几步:</p><ol><li>编译basic_tunnel.p4</li><li>启动一个Mininet实例，其中三个交换机(<code>s1</code>、<code>s2</code>、<code>s3</code>)配置在一个三角形中，每个交换机连接到一个主机(<code>h1</code>、<code>h2</code>和<code>h3</code>)。</li><li>这些主机的ip地址设置为<code>10.0.1.1</code>, <code>10.0.2.2</code>, and <code>10.0.3.3</code>.</li></ol><p>然后进入mininet界面</p></li><li><p>使用mininet的xterm功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; xterm h1 h2</span><br></pre></td></tr></table></figure></li><li><p>在h2的界面输入 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;receive.py</span><br></pre></td></tr></table></figure><p>在h1的界面输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot;</span><br></pre></td></tr></table></figure><p>这是不经过my_tunnel的测试；</p><p>如果您检查接收到的数据包，您应该会看到它由一个以太网报头、一个IP报头、一个TCP报头和消息组成。如果您更改了目的IP地址(例如试图发送到’ 10.0.3.3 ‘)，则该消息不应该被’ h2 ‘接收，而将被’ h3 ‘接收。</p><p>结果如下图:</p><p><img src="/picture/image-20210228215634236.png" alt="image-20210228215634236"></p><p>发给10.0.3.3之后:</p><p>h1有相似的显示，h2没有变化</p></li><li><p>下面测试my_tunnel</p><p>在h1的界面输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot; --dst_id 2</span><br></pre></td></tr></table></figure></li></ol><p>   结果如下图:</p><p>   <img src="/picture/image-20210228215915163.png" alt="image-20210228215915163"></p><p>   数据包在<code>h2</code>处接收。它由一个以太网报头、一个隧道报头、一个IP报头、一个TCP报头和消息组成。隧道报头就是那个###[MyTunnel]在IP报头上面;</p><ol start="5"><li><p>在h1的界面输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;send.py 10.0.3.3 &quot;P4 is cool&quot; --dst_id 2</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="/picture/image-20210228220230000.png" alt="image-20210228220230000"></p><p>即使IP地址是<code>h3</code>的地址，数据包也应该在<code>h2</code>处接收。这是因为当<code>MyTunnel</code>头在包中时，交换机不再使用IP头进行路由。</p><p>一开始我也不理解上面这句话，后来我看了s1-runtime文件，这个文件规定了交换机的静态规则，将这个文件和basic里面的同名文件比较会发现里面多了:</p><p><img src="/picture/image-20210228221250171.png" alt="image-20210228221250171"></p><p>这部分内容结合刚刚./receive代码里面的–dst 2后缀可以得知刚刚那个包在进入交换机s1之后会因为p4的解包触发走myTunnel_forward的规则然后发给S1的2端口，结合拓扑图可以看出确实是发给h2的</p></li></ol><h4 id="解析其他内容"><a href="#解析其他内容" class="headerlink" title="解析其他内容"></a>解析其他内容</h4><h5 id="my-tunnel-py"><a href="#my-tunnel-py" class="headerlink" title="my_tunnel.py"></a>my_tunnel.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">TYPE_MYTUNNEL = <span class="number">0x1212</span></span><br><span class="line">TYPE_IPV4 = <span class="number">0x0800</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTunnel</span><span class="params">(Packet)</span>:</span></span><br><span class="line">    name = <span class="string">"MyTunnel"</span></span><br><span class="line">    fields_desc = [</span><br><span class="line">        ShortField(<span class="string">"pid"</span>, <span class="number">0</span>),</span><br><span class="line">        ShortField(<span class="string">"dst_id"</span>, <span class="number">0</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mysummary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.sprintf(<span class="string">"pid=%pid%, dst_id=%dst_id%"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bind_layers(Ether, MyTunnel, type=TYPE_MYTUNNEL)</span><br><span class="line">bind_layers(MyTunnel, IP, pid=TYPE_IPV4)</span><br></pre></td></tr></table></figure><p>因为原来的scapy只支持ipv4，不支持我们的myTunnel协议，因此需要重新定义，上面的文件就重新定义了MyTunnel；</p><blockquote><p>每一个协议层都是Packet类的子类。协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。一个简单的协议层是被一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为fields_desc的属性中。每一个字段都是一个field类的实例：</p></blockquote><p>上面MyTunnel的协议层有两个字段分别是pid和dst_id，默认值都是0；</p><p>UDP的协议层定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UDP(Packet):</span><br><span class="line">    name &#x3D; &quot;UDP&quot;</span><br><span class="line">    fields_desc &#x3D; [ ShortEnumField(&quot;sport&quot;, 53, UDP_SERVICES),</span><br><span class="line">                    ShortEnumField(&quot;dport&quot;, 53, UDP_SERVICES),</span><br><span class="line">                    ShortField(&quot;len&quot;, None),</span><br><span class="line">                    XShortField(&quot;chksum&quot;, None), ]</span><br></pre></td></tr></table></figure><p>最后两句是绑定协议层;</p><blockquote><p>Scapy在解析协议层时一个很酷的特性是他试图猜测下一层协议是什么。连接两个协议层官方的方法是bind_layers():</p></blockquote><h5 id="send-py"><a href="#send-py" class="headerlink" title="send.py"></a>send.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> sendp, send, get_if_list, get_if_hwaddr, hexdump</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Packet</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Ether, IP, UDP, TCP</span><br><span class="line"><span class="keyword">from</span> myTunnel_header <span class="keyword">import</span> MyTunnel</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_if</span><span class="params">()</span>:</span></span><br><span class="line">    ifs=get_if_list() <span class="comment">#    # type: () -&gt; List[str] """Return a list of interface names""",返回接口(网卡)名字</span></span><br><span class="line">    iface=<span class="literal">None</span> <span class="comment"># "h1-eth0"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> get_if_list():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"eth0"</span> <span class="keyword">in</span> i:</span><br><span class="line">            iface=i</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> iface:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Cannot find eth0 interface"</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> iface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser()<span class="comment">#argsparse是python的命令行解析的标准模块，相当于就是解析./send.py后面的参数</span></span><br><span class="line">    parser.add_argument(<span class="string">'ip_addr'</span>, type=str, help=<span class="string">"The destination IP address to use"</span>)<span class="comment">#type是要传入的参数的数据类型  help是该参数的提示信息,使用python send.py -h可以看到</span></span><br><span class="line">    parser.add_argument(<span class="string">'message'</span>, type=str, help=<span class="string">"The message to include in packet"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--dst_id'</span>, type=int, default=<span class="literal">None</span>, help=<span class="string">'The myTunnel dst_id to use, if unspecified then myTunnel header will not be included in packet'</span>)</span><br><span class="line">    args = parser.parse_args()<span class="comment">##获得传入的参数</span></span><br><span class="line"></span><br><span class="line">    addr = socket.gethostbyname(args.ip_addr)<span class="comment">## 获取ip_addr的主机名</span></span><br><span class="line">    dst_id = args.dst_id<span class="comment">#获得dst_id</span></span><br><span class="line">    iface = get_if()<span class="comment">#获取网卡的名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dst_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):<span class="comment">#包装</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"sending on interface &#123;&#125; to dst_id &#123;&#125;"</span>.format(iface, str(dst_id))</span><br><span class="line">        pkt =  Ether(src=get_if_hwaddr(iface), dst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>)</span><br><span class="line">        pkt = pkt / MyTunnel(dst_id=dst_id) / IP(dst=addr) / args.message</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"sending on interface &#123;&#125; to IP addr &#123;&#125;"</span>.format(iface, str(addr))</span><br><span class="line">        pkt =  Ether(src=get_if_hwaddr(iface), dst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>)</span><br><span class="line">        pkt = pkt / IP(dst=addr) / TCP(dport=<span class="number">1234</span>, sport=random.randint(<span class="number">49152</span>,<span class="number">65535</span>)) / args.message</span><br><span class="line"></span><br><span class="line">    pkt.show2()</span><br><span class="line"><span class="comment">#    hexdump(pkt)</span></span><br><span class="line"><span class="comment">#    print "len(pkt) = ", len(pkt)</span></span><br><span class="line">    sendp(pkt, iface=iface, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>大概流程就是，先分析参数，然后包装成Ether的格式然后用scapy发包;</p><h5 id="receive-py"><a href="#receive-py" class="headerlink" title="receive.py"></a>receive.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> sniff, sendp, hexdump, get_if_list, get_if_hwaddr</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Packet, IPOption</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> ShortField, IntField, LongField, BitField, FieldListField, FieldLenField</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> IP, TCP, UDP, Raw</span><br><span class="line"><span class="keyword">from</span> scapy.layers.inet <span class="keyword">import</span> _IPOption_HDR</span><br><span class="line"><span class="keyword">from</span> myTunnel_header <span class="keyword">import</span> MyTunnel</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_if</span><span class="params">()</span>:</span> <span class="comment"># 获得网卡接口</span></span><br><span class="line">    ifs=get_if_list()</span><br><span class="line">    iface=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> get_if_list():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"eth0"</span> <span class="keyword">in</span> i:</span><br><span class="line">            iface=i</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> iface:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Cannot find eth0 interface"</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> iface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_pkt</span><span class="params">(pkt)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> MyTunnel <span class="keyword">in</span> pkt <span class="keyword">or</span> (TCP <span class="keyword">in</span> pkt <span class="keyword">and</span> pkt[TCP].dport == <span class="number">1234</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"got a packet"</span></span><br><span class="line">        pkt.show2()</span><br><span class="line"><span class="comment">#        hexdump(pkt)</span></span><br><span class="line"><span class="comment">#        print "len(pkt) = ", len(pkt)</span></span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ifaces = filter(<span class="keyword">lambda</span> i: <span class="string">'eth'</span> <span class="keyword">in</span> i, os.listdir(<span class="string">'/sys/class/net/'</span>))</span><br><span class="line">    iface = ifaces[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"sniffing on %s"</span> % iface</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    sniff(iface = iface,</span><br><span class="line">          prn = <span class="keyword">lambda</span> x: handle_pkt(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>首先获得网卡，发出“sniffing on….”信息，并且立刻打出来，然后把收到的包里面的东西立刻打印出来</p><h4 id="原文部分"><a href="#原文部分" class="headerlink" title="原文部分"></a>原文部分</h4><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this exercise, we will add support for a basic tunneling protocol to the IP<br>router that you completed in the previous assignment.  The basic switch<br>forwards based on the destination IP address.  Your jobs is to define a new<br>header type to encapsulate the IP packet and modify the switch code, so that it<br>instead decides the destination port using a new tunnel header.</p><p>The new header type will contain a protocol ID, which indicates the type of<br>packet being encapsulated, along with a destination ID to be used for routing.</p><blockquote><p><strong>Spoiler alert:</strong> There is a reference solution in the <code>solution</code><br>sub-directory. Feel free to compare your implementation to the reference.</p></blockquote><p>The starter code for this assignment is in a file called <code>basic_tunnel.p4</code> and<br>is simply the solution to the IP router from the previous exercise.</p><h3 id="A-note-about-the-control-plane"><a href="#A-note-about-the-control-plane" class="headerlink" title="A note about the control plane"></a>A note about the control plane</h3><p>A P4 program defines a packet-processing pipeline, but the rules within each<br>table are inserted by the control plane. When a rule matches a packet, its<br>action is invoked with parameters supplied by the control plane as part of the<br>rule.</p><p>For this exercise, we have already added the necessary static control plane<br>entries. As part of bringing up the Mininet instance, the <code>make run</code> command<br>will install packet-processing rules in the tables of each switch. These are<br>defined in the <code>sX-runtime.json</code> files, where <code>X</code> corresponds to the switch<br>number.</p><p>Since the control plane tries to access the <code>myTunnel_exact</code> table, and that<br>table does not yet exist, the <code>make run</code> command will not work with the starter<br>code.</p><p><strong>Important:</strong> We use P4Runtime to install the control plane rules. The content<br>of files <code>sX-runtime.json</code> refer to specific names of tables, keys, and<br>actions, as defined in the P4Info file produced by the compiler (look for the<br>file <code>build/basic.p4info</code> after executing <code>make run</code>). Any changes in the P4<br>program that add or rename tables, keys, or actions will need to be reflected<br>in these <code>sX-runtime.json</code> files.</p><h4 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h4><ul><li><a href="https://www.zhihu.com/column/c_1336207793033015296" target="_blank" rel="noopener">P4学习笔记专栏</a></li><li><a href="https://github.com/p4lang/p4c/blob/master/p4include/core.p4" target="_blank" rel="noopener">core.p4库</a></li><li><a href="https://wizardforcel.gitbooks.io/scapy-docs/content/3.html" target="_blank" rel="noopener">scapy中文文档</a></li><li><a href="https://blog.csdn.net/dj1174232716/article/details/49046409" target="_blank" rel="noopener">scapy添加新的协议</a></li><li><a href="https://github.com/secdev/scapy" target="_blank" rel="noopener">scapy源码</a></li><li><a href="https://zhuanlan.zhihu.com/p/56922793" target="_blank" rel="noopener">argparse使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-3：P4-basic-tunnel实验&quot;&gt;&lt;a href=&quot;#P4学习-3：P4-basic-tunnel实验&quot; class=&quot;headerlink&quot; title=&quot;P4学习-3：P4 basic tunnel实验&quot;&gt;&lt;/a&gt;P4学习-3：P4 basi
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode24-m</title>
    <link href="http://Tyler-ytr.github.io/2021/02/24/leetcode24-m/"/>
    <id>http://Tyler-ytr.github.io/2021/02/24/leetcode24-m/</id>
    <published>2021-02-24T08:37:35.000Z</published>
    <updated>2021-02-25T08:18:30.262Z</updated>
    
    <content type="html"><![CDATA[<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><p>难度中等827</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/swap_ex1.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p><ol><li><p>迭代解法：开了一个虚拟节点，然后pid的next是将要交换的第一个节点,pid.next.next是第二个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        temphead=ListNode(<span class="number">0</span>)</span><br><span class="line">        temphead.next=head</span><br><span class="line">        pid=temphead</span><br><span class="line">        <span class="keyword">while</span> pid.next <span class="keyword">and</span> pid.next.next:</span><br><span class="line">            node1=pid.next</span><br><span class="line">            node2=pid.next.next</span><br><span class="line">            </span><br><span class="line">            pid.next=node2</span><br><span class="line">            node1.next=node2.next</span><br><span class="line">            node2.next=node1</span><br><span class="line">            pid=node2.next</span><br><span class="line">        <span class="keyword">return</span> temphead.next</span><br></pre></td></tr></table></figure></li><li><p>递归解法：见里面的注释</p><p>首先思考递归终止条件，然后思考里面的递归过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val&#x3D;0, next&#x3D;None):</span><br><span class="line">#         self.val &#x3D; val</span><br><span class="line">#         self.next &#x3D; next</span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        # 终止条件：head是空或者head.next是空 比如[],[1]</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line">        </span><br><span class="line">        #1,2,3,4</span><br><span class="line">        temp&#x3D;head.next #因为马上要修改</span><br><span class="line">        #1-&gt;2-&gt;3-&gt;4</span><br><span class="line">        #修改好了4-&gt;3</span><br><span class="line">        #所以1-&gt;4-&gt;3</span><br><span class="line">        head.next&#x3D;self.swapPairs(temp.next)</span><br><span class="line">        #temp相当于2,2-&gt;1</span><br><span class="line">        temp.next&#x3D;head</span><br><span class="line">        return temp</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="递归" scheme="http://Tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="链表" scheme="http://Tyler-ytr.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode23-h</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/leetcode23-h/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/leetcode23-h/</id>
    <published>2021-02-23T12:08:25.000Z</published>
    <updated>2021-02-23T14:21:35.442Z</updated>
    
    <content type="html"><![CDATA[<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表</a></h4><p>难度困难1151</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p><strong>解答：</strong></p><ol><li><p>优先队列</p><p><code>heapq</code>是二叉堆，通常用普通列表实现。</p><p><code>heapq</code>模块是在Python中不错的优先级队列实现。由于heapq在技术上只提供最小堆实现，因此必须添加额外步骤来确保排序稳定性，以此来获得“实际”的优先级队列中所含有的预期特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line"></span><br><span class="line">q &#x3D; []</span><br><span class="line"></span><br><span class="line">heapq.heappush(q, (2, &#39;code&#39;))</span><br><span class="line">heapq.heappush(q, (1, &#39;eat&#39;))</span><br><span class="line">heapq.heappush(q, (3, &#39;sleep&#39;))</span><br><span class="line"></span><br><span class="line">while q:</span><br><span class="line">    next_item &#x3D; heapq.heappop(q)</span><br><span class="line">    print(next_item)</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line">#   (1, &#39;eat&#39;)</span><br><span class="line">#   (2, &#39;code&#39;)</span><br><span class="line">#   (3, &#39;sleep&#39;)</span><br></pre></td></tr></table></figure><p><code>queue.PriorityQueue</code>这个优先级队列的实现在内部使用了<code>heapq</code>，时间和空间复杂度与<code>heapq</code>相同。</p><p>区别在于<code>PriorityQueue</code>是同步的，提供了锁语义来支持多个并发的生产者和消费者。</p><p>在不同情况下，锁语义可能会带来帮助，也可能会导致不必要的开销。不管哪种情况，你都可能更喜欢<code>PriorityQueue</code>提供的基于类的接口，而不是使用<code>heapq</code>提供的基于函数的接口。</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from queue import PriorityQueue</span><br><span class="line"></span><br><span class="line">q &#x3D; PriorityQueue()</span><br><span class="line"></span><br><span class="line">q.put((2, &#39;code&#39;))</span><br><span class="line">q.put((1, &#39;eat&#39;))</span><br><span class="line">q.put((3, &#39;sleep&#39;))</span><br><span class="line"></span><br><span class="line">while not q.empty():</span><br><span class="line">    next_item &#x3D; q.get()</span><br><span class="line">    print(next_item)</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line">#   (1, &#39;eat&#39;)</span><br><span class="line">#   (2, &#39;code&#39;)</span><br><span class="line">#   (3, &#39;sleep&#39;)</span><br></pre></td></tr></table></figure><p>   其中PriorityQueue可以自定义比较函数:</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from queue import PriorityQueue</span><br><span class="line">class Job(object):</span><br><span class="line">    def __init__(self, priority, description):</span><br><span class="line">        self.priority &#x3D; priority</span><br><span class="line">        self.description &#x3D; description</span><br><span class="line">        print(&#39;New job:&#39;, description)</span><br><span class="line">        return</span><br><span class="line"> </span><br><span class="line">    def __lt__(self, other):</span><br><span class="line">        return self.priority &lt; other.priority</span><br><span class="line"> &#39;&#39;&#39; 或者使用__cmp__函数</span><br><span class="line">    def __cmp__(self, other):</span><br><span class="line">        if self.priority &lt; other.priority:</span><br><span class="line">            return -1</span><br><span class="line">        elif self.priority &#x3D;&#x3D; other.priority:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            return 1</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">q2 &#x3D; PriorityQueue()</span><br><span class="line"> </span><br><span class="line">q2.put(Job(5, &#39;Mid-level job&#39;))</span><br><span class="line">q2.put(Job(10, &#39;Low-level job&#39;))</span><br><span class="line">q2.put(Job(1, &#39;Important job&#39;)) #数字越小，优先级越高</span><br><span class="line"> </span><br><span class="line">while not q2.empty():</span><br><span class="line">    next_job &#x3D; q2.get() #可根据优先级取序列</span><br><span class="line">    print(&#39;Processing job&#39;, next_job.description)</span><br></pre></td></tr></table></figure><p>   题解:</p><p>   使用heapq解决该问题，每一个链表的第一个节点进入堆进行比较，然后最小的那个取出来扔进新链表，然后最小的那个向后移动一位（80ms）</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        minheap=[]</span><br><span class="line">        <span class="keyword">for</span> index,node <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="keyword">if</span> node!=<span class="literal">None</span>:</span><br><span class="line">                heapq.heappush(minheap,(node.val,index)) <span class="comment">#第几个链表的节点的值</span></span><br><span class="line"></span><br><span class="line">        head=ListNode(<span class="number">-1</span>)</span><br><span class="line">        tail=head</span><br><span class="line">        <span class="keyword">while</span> minheap:</span><br><span class="line">            nodeval,index=heapq.heappop(minheap)</span><br><span class="line">            tail.next=lists[index]</span><br><span class="line">            tail=tail.next</span><br><span class="line">            lists[index]=lists[index].next</span><br><span class="line">            <span class="keyword">if</span> lists[index]!=<span class="literal">None</span>:</span><br><span class="line">                heapq.heappush(minheap,(lists[index].val,index))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>   使用PriorityQueue解决问题，速度慢于heapq(144ms)：</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line">        minheap=PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> index,node <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="keyword">if</span> node!=<span class="literal">None</span>:</span><br><span class="line">               minheap.put((node.val,index)) <span class="comment">#第几个链表的节点的值</span></span><br><span class="line">        head=ListNode(<span class="number">-1</span>)</span><br><span class="line">        tail=head</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> minheap.empty():</span><br><span class="line">            nodeval,index=minheap.get()</span><br><span class="line">            tail.next=lists[index]</span><br><span class="line">            tail=tail.next</span><br><span class="line">            lists[index]=lists[index].next</span><br><span class="line">            <span class="keyword">if</span> lists[index]!=<span class="literal">None</span>:</span><br><span class="line">                minheap.put((lists[index].val,index))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><ol start="2"><li><p>分治</p><p>首先实现合并两个链表，然后分治：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 合并两个链表的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                l1,l2=l2,l1</span><br><span class="line">            l1.next=self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">    <span class="comment">#调用上面的代码合并两个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergetwonode</span><span class="params">(self,node1:ListNode,node2:ListNode)</span>-&gt;ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(node1,node2)</span><br><span class="line">    <span class="comment">#分治</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self,left:int,right:int,lists:List[ListNode])</span>-&gt;ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> left==right:</span><br><span class="line">            <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="keyword">if</span> left&gt;right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid=left+((right-left)//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> self.mergetwonode(self.merge(left,mid,lists),self.merge(mid+<span class="number">1</span>,right,lists))        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(<span class="number">0</span>,len(lists)<span class="number">-1</span>,lists)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;23-合并K个升序链表&quot;&gt;&lt;a href=&quot;#23-合并K个升序链表&quot; class=&quot;headerlink&quot; title=&quot;23. 合并K个升序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-k-so
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="递归" scheme="http://Tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="优先队列" scheme="http://Tyler-ytr.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1052-m</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/leetcode1052-m/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/leetcode1052-m/</id>
    <published>2021-02-23T09:54:13.000Z</published>
    <updated>2021-02-23T09:57:28.305Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">1052. 爱生气的书店老板</a></h4><p>难度中等106</p><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</code></li><li><code>0 &lt;= customers[i] &lt;= 1000</code></li><li><code>0 &lt;= grumpy[i] &lt;= 1</code></li></ul><p><strong>解答:</strong></p><p>分为两部分，第一部分是不用秘密方法得到的满意度，第二部分是使用秘密方法得到的满意度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        base=<span class="number">0</span></span><br><span class="line">        increase=<span class="number">0</span></span><br><span class="line">        maxincrease=<span class="number">0</span></span><br><span class="line">        length=len(customers)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            base=base+customers[i]*(<span class="number">1</span>-grumpy[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,X):</span><br><span class="line">            increase=increase+customers[i]*grumpy[i]</span><br><span class="line">        maxincrease=increase</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X,length):</span><br><span class="line">            increase=increase+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X]</span><br><span class="line">            maxincrease=max(increase,maxincrease)</span><br><span class="line">        <span class="keyword">return</span> maxincrease+base</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1052-爱生气的书店老板&quot;&gt;&lt;a href=&quot;#1052-爱生气的书店老板&quot; class=&quot;headerlink&quot; title=&quot;1052. 爱生气的书店老板&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/grum
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="滑动窗口" scheme="http://Tyler-ytr.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="贪心" scheme="http://Tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论笔记</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/机器学习/</id>
    <published>2021-02-23T09:26:04.000Z</published>
    <updated>2022-02-16T06:24:32.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记"><a href="#机器学习笔记" class="headerlink" title="机器学习笔记"></a>机器学习笔记</h1><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><ol><li><p>学习过程</p><ol><li>训练数据，经过</li><li>学习算法训练，得到</li><li>模型(决策树，射精网络，支持向量机，Boosting，贝叶斯网……)，可以判断</li><li>新数据样本，得到结论</li></ol></li><li><p>机器学习的局限性，失效条件:</p><ol><li>特征信息不充分</li><li>样本信息不充分</li></ol></li><li><p>机器学习的理论基础(计算学习理论),概率近似正确(PAC):</p><p>$P(|f(x)-y|\le \epsilon)\ge 1-\delta$</p><p>f(x)是预测值,y是真实值,目的是尽可能贴近真实值也就是$|f(x)-y|\le \epsilon$,然后这件事情有一个概率的保证，一定大于$1-\delta$的概率确保这件事情的完成。一句话总结就是很高的概率得到很好的结果的模型。</p><blockquote><p>如果你能确定百分百正确，就不用整机器学习了</p></blockquote></li></ol><h3 id="数学参考"><a href="#数学参考" class="headerlink" title="数学参考"></a>数学参考</h3><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><ul><li><p>在实数域中，数的大小和两个数之间的距离是通过绝对值来度量的。将数推广到向量就引入了范数。范数（Norm）是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。</p><blockquote><p>在算例子的时候我觉得其实是不同维度到0点的距离</p></blockquote></li></ul><h5 id="向量的范数"><a href="#向量的范数" class="headerlink" title="向量的范数"></a>向量的范数</h5><ul><li><p>范数标准定义:</p><ul><li><strong>正定性:</strong>$||x||\ge 0$,且$||x||= 0$当且仅当$x=0$;</li><li><strong>齐次性:</strong>对任意实数 $\alpha$ ，都有$||\alpha x||=|\alpha|\ ||x||$</li><li><strong>三角不等式:</strong> 对任意$x,y\in R^n$,都有$||x+y|| \le ||x|| + ||y||$</li></ul><p>则称$||x||$为$R^n$上的向量范数</p></li><li><p>范数表达式:<br>$$<br>\begin{align}<br>\left| \left| x \right| \right|<em>{p}\; :=\; \left( \sum</em>{i=1}^{n}{\left| x_{i} \right|^{p} } \right)^{\frac{1}{p} }\tag{1}<br>\end{align}<br>$$</p></li><li><p>L1范数:<br>$$<br>||x||_1 = |x_1| + |x_2| + \dots + |x_n| = \sum_i^n |x_i|<br>$$<br>向量元素绝对值之和</p><p>L2范数:<br>$$<br>||x||_2 = (|x_1|^2 + |x_2|^2+\dots+ |x_n|^2)^{\frac{1}{2} } =\sqrt{ \sum_i^n x_i^2}<br>$$<br>Euclid范数(欧几里得范数，常用计算向量长度)</p><p>Lp范数:<br>$$<br>||x||_p = (|x_1|^p + |x_2|^p+\dots+ |x_n|^p)^{\frac{1}{p} } =\sqrt[p]{ \sum_i^n x_i^p}<br>$$<br><img src="/picture/image-20210308113014539.png" alt="image-20210308113014539"></p><p>Lp的形状随p的变化的图</p><p>L$\infty $范数:<br>$$<br>||x||<em>{\infty} = \max\limits</em>{1\le i\le n} |x_i|<br>$$</p></li></ul><p>  所有向量元素绝对值中的最大值</p><p>  L$-\infty$范数:<br>  $$<br>  ||x||<em>{\infty} = \min\limits</em>{1\le i\le n} |x_i|<br>  $$<br>  所有向量元素绝对值中的最小值</p><p>  L0范数:<br>  $$<br>  ||x||_0 = \sum_i^n I(x_i \ne 0)<br>  $$<br>  也就是非零元素的数量</p><ul><li><p>例子:$x=(1,4,3,0)^T$的常用范数:</p><p>$||x||_0=3$</p><p>$||x||_1=|1|+|4|+|3|+|0|=8$</p><p>$||x||_2=\sqrt{|1|^2+|4|^2+|3|^2+|0|^2}=\sqrt{26}$</p><p>$||x||_{\infty}=|4|=4$</p></li></ul><h5 id="矩阵的范数"><a href="#矩阵的范数" class="headerlink" title="矩阵的范数"></a>矩阵的范数</h5><ul><li><p>推广到矩阵，矩阵相容范数的定义:</p><ul><li><strong>正定性:</strong>$||A||\ge 0$,且$||A||= 0$当且仅当$A=0$;</li><li><strong>齐次性:</strong>对任意实数 $\alpha$ ，都有$||\alpha A||=|\alpha|\ ||A||$</li><li><strong>三角不等式:</strong> 对任意$A,B\in R^{n\times n}$,都有$||A+B|| \le ||A|| + ||B||$</li><li><strong>相容性:</strong>对任意$A,B\in R^{n\times n}$,都有$||AB|| \le ||A||\ ||B||$</li></ul><p>则称$||A||$为$R^{n\times n}$上的一个矩阵范数</p></li><li><p><strong>列范数:</strong><br>$$<br>||A||<em>1 = \max\limits</em>{1\le j\le n} \sum_i^n |a_{ij}|<br>$$<br>$A$的每一列的绝对值的最大值，称作$A$的列范数</p></li><li><p><strong>行范数:</strong><br>$$<br>||A||<em>{\infty} = \max\limits</em>{1\le i\le n} \sum_j^n |a_{ij}|<br>$$<br>$A$的每一行的绝对值的最大值，称作$A$的行范数</p></li><li><p><strong>L2范数:</strong><br>$$<br>||A||<em>2 = \sqrt{\lambda</em>{max} (A^T A)}<br>$$<br>其中$\lambda_{max}$表示$A^TA$的特征值的绝对值的最大值</p></li><li><p><strong>F-范数(Frobenius):</strong><br>$$<br>||A||_F = (\sum_i^n \sum_j^n a_{ij}^2)^{\frac{1}{2} }=(tr(A^TA))^{1/2}<br>$$<br>它相当于矩阵$A$各项元素的绝对值平方的总和,也就是矩阵张成向量之后的L2范数</p></li></ul><h4 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h4><ul><li><p>一阶导数：雅可比矩阵</p><p>假设函数$F:{R_n} \to {R_m}$是一个从欧式n维空间转换到欧式m维空间的函数.这个函数由m个实函数组成:$y1(x1,…,xn), …, ym(x1,…,xn)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵, 这就是所谓的雅可比矩阵：<br>$$<br>\begin{bmatrix} \frac{\partial y_1}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_1}{\partial x_n} \ \vdots &amp; \ddots &amp; \vdots \ \frac{\partial y_m}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_m}{\partial x_n} \end{bmatrix}<br>$$</p></li></ul><p>  此矩阵表示为: ${J_F}({x_1}, \ldots ,{x_n})$,或者$\frac{ {\partial {({y_1}, … ,{y_m})} }  } { {\partial {({x_1}, … ,{x_n})} } }$.</p><blockquote><p>hexo 两个{之间要加空格不然会报错: expected variable end</p></blockquote><p>  如果$p$是$R_n$中的一点，$F$在$p$点可微分，那么这一点的导数由$J_F(p)$给出.在此情况下, 由$F(p)$描述的线性算子即接近点$p$的$F$的最优线性逼近, $x$逼近于$p$:<br>  $$<br>  F({\bf{x} }) \approx F({\bf{p} }) + {J_F}({\bf{p} }) \cdot ({\bf{x} } – {\bf{p} })<br>  $$</p><ul><li><p>二阶导数：海森矩阵</p><p>海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下：<br>$$<br>f({x_1},{x_2} \ldots ,{x_n})<br>$$<br>如果$f$所有的二阶导都存在，那么有：<br>$$<br>H{(f)_{ij} }(x) = {D_i}{D_j}f(x)<br>$$<br>也就是:<br>$$<br>\begin{bmatrix}<br>\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1\,\partial x_n} \  \<br>\frac{\partial^2 f}{\partial x_2\,\partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2\,\partial x_n} \  \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \  \<br>\frac{\partial^2 f}{\partial x_n\,\partial x_1} &amp; \frac{\partial^2 f}{\partial x_n\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}<br>\end{bmatrix}<br>$$</p></li><li><p>链式法则的式子里面有转置的原因可以从维度的角度来思考;</p></li></ul><h4 id="奇异值"><a href="#奇异值" class="headerlink" title="奇异值"></a>奇异值</h4><ul><li><p>共轭:$z=a+bi$,z的共轭$\bar{z}=a-bi$;实数的共轭是他自身;</p></li><li><p>矩阵概念:</p><ul><li><p>对称矩阵:</p><p>$A^T=A$</p></li><li><p>Hermite矩阵，将实数范围讨论的对称矩阵延伸到复数范围:</p><p>其中，用$\bar{A}$表示以$A$的元素的共轭复数为元素构成的矩阵,那么$A^H=(\bar{A}^T)$，这个称作$A$的复共轭转置矩阵;</p><ul><li>特征值都是实数。</li><li>任意两个不同特征值所对应的特征向量正交。</li></ul></li><li><p>正交矩阵:</p><p>$A^TA=E$</p></li><li><p>酉矩阵:</p><p>$A^HA=E$</p><p>这玩意其实就是正交矩阵在复数范围的推广</p></li><li><p>奇异矩阵:</p><p>$|A|=0$称作奇异矩阵，否则称作非奇异矩阵;$A$是可逆矩阵的充要条件是$|A|\neq0$,因此可逆矩阵就是非奇异矩阵</p></li><li><p>正规矩阵:</p><p>$A^HA=AA^H$,如果都是实数矩阵，那么$A^T=A^H,A^TA=AA^T$</p></li><li><p>幂等矩阵:</p><p>$A^2=A$</p></li><li><p>正定矩阵:它是对称矩阵/Hermite矩阵的进一步延伸</p><p>设$A$为n阶Hermite矩阵，如果对任意n维复向量$x$都有$x^HAx\ge 0$,则称A是半正定矩阵;如果对任意n维复向量$x$都有$x^HAx&gt; 0$,则称A是正定矩阵。</p><ul><li>Hermite矩阵$A$为正定（半正定）矩阵 $\leftrightarrow$$A$的所有特征值是正数（非负数）。</li><li>Hermite矩阵$A$为正定矩阵 $\leftrightarrow$存在n阶非奇异矩阵$P$，使得$A=P^HP$</li><li>Hermite矩阵$A$为半正定矩阵$\leftrightarrow $存在n阶矩阵$P$，使得$A=P^HP$</li></ul></li></ul></li><li><p>特征值与特征分解:</p><p>特征值特征向量定义：$\lambda$是特征值,$x$是特征向量,A是方阵<br>$$<br>Ax=\lambda x<br>$$<br>求解走:</p><p>$Ax=\lambda x\rightarrow Ax=\lambda E x\rightarrow (\lambda E-A)x=0\rightarrow|\lambda E-A|=0$解出特征值带入得到特征向量</p><p>特征分解:对于mxm的满秩对称矩阵A<br>$$<br>A=Q\Sigma Q^{-1}=Q\Sigma Q^T<br>$$<br>其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。</p><p>特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。</p></li></ul><h5 id="奇异值与奇异值分解"><a href="#奇异值与奇异值分解" class="headerlink" title="奇异值与奇异值分解"></a>奇异值与奇异值分解</h5><ol><li><p>运用到的理论:</p><ol><li>对于n阶方阵，$Ax=\lambda x$;</li><li>如果$\vec{a}$与$\vec{b}$正交,那么有$\vec{a} \cdot \vec{b} = 0$</li><li>一个内积空间的正交基（orthogonal basis）是元素两两正交的基,基中的元素称为基向量。如果一个正交基的基向量的模长都是单位长度1，则称这正交基为标准正交基或”规范正交基”（Orthonormal basis）；</li><li>A与A的转置矩阵是有相同的特征值,但是他们各自的特征向量没有关系；</li></ol></li><li><p><strong>SVD推导之矩阵分解:</strong></p><p>对于矩阵$A$,有$A^TA = \lambda_{i} v_{i}$(因为$A^TA$肯定是方阵);$\lambda_i$是特征值,$v_i$是特征向量;假设$(v_{i}, v_{j})$是一组正交基，那么有$v_{i}^{T} \cdot v_{j} = 0$，那么:<br>$$<br>\begin{align} (Av_{i}, Av_{j}) &amp;= (Av_{i})^{T} \cdot Av_{j} \ &amp;= v_{i}^{T} A^T Av_{j} \ &amp;= v_{i}^{T} \lambda_{j} v_{j} \ &amp;= \lambda_{j} \color{red}{v_{i}^{T} v_{j} } \ &amp;= 0 \end{align} \tag{1}<br>$$<br>可以得到$Av_{i}, Av_{j}$;根据公式$(1)$可以推导得到$(Av_{i}, Av_{i}) = \lambda_{i} v_{i}^{T} v_{i}=\lambda_{i}$;又因为行列式的性质$|AB|=|A||B|\rightarrow|(Av_{i})^{T} \cdot Av_{i}|=|Av_{i}^{T} ||Av_{i}|=|Av_{i}|^2$,所以有:<br>$$<br>\begin{align} &amp; |Av_{i}|^2 = \lambda_{i} \ &amp; |Av_{i}| = \sqrt{\lambda_{i} } \end{align} \tag{2}<br>$$<br>根据公式(2),有$\frac{Av_{i} }{|Av_{i}|} = \frac{1}{\sqrt{\lambda_{i} } } Av_{i}$，令$\frac{1}{\sqrt{\lambda_{i} } } Av_{i}= u_{i}$,可以得到:<br>$$<br>Av_{i}= \sqrt{\lambda_{i} }u_{i}=\delta_{i}u_{i} \tag{3}<br>$$<br>其中$\delta_{i} = \sqrt{\lambda_{i} }$（这个称作奇异值）,进一步推导成矩阵形式:<br>$$<br>\begin{align} AV &amp;= A(v_{1}, v_{2}, \dots, v_{n} ) \ &amp;= (Av_{1}, Av_{2}, \dots, Av_{n} ) \ &amp;= (\delta_{1}u_{1}, \delta_{2}u_{2}, \dots, \delta_{n}u_{n} ) \ &amp;= U\Sigma \end{align} \tag{4}<br>$$<br>从而得到:<br>$$<br>A = U\Sigma V^T \tag{5}<br>$$</p></li><li><p><strong>SVD推导之矩阵计算:</strong></p><p>已知$A$怎么算$U$和$V$呢？</p><p>首先计算$A$的转置$A^T$,而$A^T$相当于:<br>$$<br>\begin{align} A^T =  V\Sigma^TU^T \end{align} \tag{6}<br>$$<br>然后计算$A^TA$:<br>$$<br>\begin{align} A^TA &amp;= V\Sigma^TU^T U\Sigma V^T \ &amp;= V\Sigma^2V^T \end{align} \tag{7}<br>$$<br>通过公式(7),会发现这不就是特征值分解嘛！！！可以得到$A^TA v_{i} = \lambda_{i}v_{i}$,只需要求出$A^TA$的特征向量就可以得到$V$了</p><p>同理计算$AA^T:$<br>$$<br>\begin{align} A A^T &amp;= U\Sigma V^T V\Sigma^TU^T \ &amp;= U\Sigma^2U^T \end{align} \tag{8}<br>$$</p><p>通过公式(8),可以得到$AA^T u_{i} = \lambda_{i}u_{i}$,只需要求出$AA^T$的特征向量就可以得到$U$了</p><p>$\Sigma$是上面公式(7)或者公式(8)中求到的非零特征值从大到小排列后开根号的值</p></li><li><p>SVD计算例子:</p><p>假设有一个矩阵$A$:<br>$$<br>A=\begin{bmatrix} 1&amp;1\1&amp;1\0&amp;0\end{bmatrix}<br>$$<br>要计算:<br>$$<br>A_{3\times 2}=U_{3\times 3}\Sigma_{3\times2}V^T_{2\times 2}<br>$$<br>中的$U,V,\Sigma$</p><ol><li><p>计算$U$  </p><p>$AA^T=\begin{bmatrix} 2&amp;2&amp;0\2&amp;2&amp;0\0&amp;0&amp;0\end{bmatrix}$,进行特征分解，得到特征值[4,0,0]以及对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T,[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T,[0,0,1]^T$,可以得到：<br>$$<br>U=\begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}&amp;0 \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}&amp;0 \ 0&amp;0&amp;1 \end{bmatrix}<br>$$</p></li></ol></li><li><p>计算$V$  </p><p>$A^TA=\begin{bmatrix} 2&amp;2 \ 2&amp;2 \end{bmatrix}$,进行特征分解,得到特征值[4,0]以及对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T,[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T$,可以得到:<br>$$<br>   V=\begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}} \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\end{bmatrix}<br>$$</p></li><li><p>计算$\Sigma$ </p><p>因为特征值是[4,0]，因此:<br>$$<br>   \Sigma=\begin{bmatrix} 2&amp;0 \ 0&amp;0 \ 0&amp;0 \end{bmatrix}<br>$$<br>   所以$A$的SVD分解是:<br>$$<br>   A=U \Sigma V^T= \begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}&amp;0 \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}&amp;0 \ 0&amp;0&amp;1 \end{bmatrix} \begin{bmatrix} 2&amp;0 \ 0&amp;0 \ 0&amp;0 \end{bmatrix} {\begin{bmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}} \ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\end{bmatrix}}^T=\begin{bmatrix} 1&amp;1\1&amp;1\0&amp;0\end{bmatrix}<br>$$</p></li><li><p>代码求解方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A=np.array([<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">print(np.linalg.svd(A))</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>以下主要是优化的部分</p></blockquote><h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><blockquote><p>To be done</p></blockquote><h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><ul><li><p>假设空间</p><ul><li>假设满足XX条件的是好瓜</li></ul></li><li><p>版本空间</p><ul><li>有限训练集，已知XX是好瓜</li></ul></li><li><p>归纳偏好</p><ul><li>假设空间和训练集一致的假设</li><li>学习过程中对某种类型假设的偏好称为归纳偏好</li></ul></li><li>No Free Lunch<ul><li>奥卡姆剃刀：两个模型效果同样好，选择较为简单的</li></ul></li></ul><h2 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h2><ul><li>经验误差与过拟合<ul><li>错误率率&amp;误差<ul><li>错误率：错份样本的占$E=a/m$</li><li>误差：样本真实输出与预测输出之间的差异<ul><li>训练（经验）误差：训练集上</li><li>测试误差：测试集</li><li>泛化误差：初训练集外所有样本</li></ul></li></ul></li></ul></li><li>过拟合<ul><li>学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降</li><li>优化目标加正则项</li><li>Early stop</li></ul></li><li>欠拟合<ul><li>对训练样本的一般性质尚未学好</li><li>决策树：扩展分支</li><li>神经网络：增加训练层数</li></ul></li><li>评估方法<ul><li>留出法<ul><li>直接将数据集划分为两个互斥集合</li><li>训练/测试集划分要尽可能保持数据分布的一致性</li><li>一般若干次随机划分，重复实验取平均值</li><li>训练/测试样本比例通常为2:1～4:1</li></ul></li><li>交叉验证法<ul><li>将数据集分层采样划分为$k$个大小相似的互斥子集</li></ul></li><li>自助法<ul><li>以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\prime}$，$D\backslash D^{\prime}$用作测试集</li></ul></li></ul></li><li>性能度量<ul><li>性能度量是衡量模型泛化能力的评价标准，反映任务的需求<ul><li>回归任务最常用的是“均方误差”：<ul><li>$E(f:D)=\frac{1}{m}\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$</li></ul></li></ul></li><li>查准率 $P=\frac{TP}{TP+FP}$</li><li>查全率 $R=\frac{TP}{TP+FN}$</li><li>$P-R$曲线</li><li>$F1$ measure：$\frac{2\times TP}{N+TP-TN}$</li><li>$AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\cdot(y_{i}+y_{i+1})$，预测了排序质量</li><li>代价敏感错误率</li></ul></li><li>性能评估<ul><li>关于性能比较<ul><li>测试性能并不等于泛化性能</li><li>测试性能随着测试集的变化而变化</li><li>很多机器学习算法本身有一定的随机性</li><li>直接选取相应评估方式在相应条件下评估并不可靠</li></ul></li><li>二项检验<ul><li>泛化错误率为$\epsilon$，测试错误率为$\hat{\epsilon}$，嘉定测试样本从样本总体分布中独立采样而来，我们可以使用“二项检验”，对于$\epsilon&lt;epsilon_{0}$进行假设检验。</li><li>假设$\epsilon\leq\epsilon_{0}$，若测试错误率小于</li></ul></li><li>$t$检验</li><li>交叉验证$t$检验</li></ul></li><li>偏差和方差<ul><li>对于测试样本$x$，令$y_{D}$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学的模型$f$在$x$上的预测输出。</li><li>以回归任务为例：<ul><li>期望预期为：$\bar{f}(x)=\mathbb{E}_{D}[f(x;D)]$；</li><li>使用样本数目相同的不同训练集产生的方差为$var(x)=\mathbb{E}_{D}[(f(x:D)-\bar{f}(x))^{2}]$；</li><li>噪声为$\varepsilon^{2}=\mathbb{E}<em>{D}[(y</em>{D}-y)^{2}]$</li></ul></li><li>$E(f;D)=bias^{2}(x)+var(x)+\varepsilon^2$</li></ul></li></ul><h1 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><ul><li>线性模型一般形式$f(x)=w_1x_1+w_2x_2+\cdots+w_dx_d+b$</li><li><p>向量形式$f(x)=w^{T}x+b$</p></li><li><p>区分猫狗的例子</p><ul><li>按照像素行堆叠或列堆叠，成为一个向量</li><li>乘以单位，对于二分类问题，单位就是一个向量</li></ul></li><li>Perceptron感知机<ul><li>对于线性分类器，误分类则$-y_{1}(w\cdot x_i)+b&gt;0$</li><li>定义损失函数$L(w,b)=-\sum_{x_{i}\in M}y_{i}(w\cdot x_{i}+b)$</li><li>梯度$\bigtriangledown_{w}L(w,b)=-\sum_{x_{i}\in M}y_{i}x_{i}$</li><li>$\bigtriangledown_{b}L(w,b)=-\sum_{x_{i}\in M}y_{i}$</li></ul></li><li>梯度下降法<ul><li>一阶方法</li><li>考虑无约束优化$min_{x}f(x)$，$f(x+\Delta x)\approx f(x)+\Delta x^{T}\bigtriangledown f(x)$</li><li>$\Delta x^{T}\bigtriangledown f(x)&lt;0$</li><li>$\Delta x=-\gamma \bigtriangledown f(x)$</li><li>$\gamma$使用二分查找法进行查找</li></ul></li><li>优点<ul><li>形式简单，易于建模</li><li>可解释性</li><li>非线性模型的基础<ul><li>引入层级结构或高维映射</li></ul></li></ul></li><li>缺陷<ul><li>解决不了$x^{2}$问题</li></ul></li></ul><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><ul><li><p>目的：学得一个线性模型以尽可能准确地预测实值输出标记</p></li><li><p>离散属性处理</p><ul><li>有“序”关系<ul><li>连续化为连续值</li></ul></li><li>无“序”关系</li></ul></li><li>单一属性的线性回归目标<ul><li>$f(x)=wx_{i}+b$使得$f(x_{i})\simeq y_{i}$</li></ul></li><li><p>参数/模型估计：最小二乘法（Least square method）</p><ul><li>$(w^{<em>},b^{</em>})=arg\ min_{(w,b)}\sum_{i=1}^{m}(f(x_{i})-y_i)^2$</li><li>最小化均方误差$E_{(w,b)}$</li></ul></li><li><p>多元线性回归</p><ul><li>$f(\hat{x_{i}})=\hat{x_{i}}^{T}(X^{T}X)^{-1}$</li><li>$X^{T}X$不满秩，进行正则化</li></ul></li><li>广义线性模型<ul><li>一般形式：$y=g^{-1}(w^{T}x+b)$<ul><li>$g$为联系函数(link function)</li></ul></li></ul></li></ul><h2 id="二分类问题"><a href="#二分类问题" class="headerlink" title="二分类问题"></a>二分类问题</h2><ul><li>预测值与输出标记$z=w^{T}x+b$</li><li>寻找函数将分类标记与线性回归模型输出联系起来</li><li>最理想的模型——单位阶跃函数</li><li><p>替代函数——对数几率函数（logistic function）</p><ul><li><strong>$y=\frac{1}{1+e^{-z}}$</strong></li><li>运行对数几率函数$y=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-(w^{T}x+b)}}$</li><li>对数几率</li></ul></li><li><p>样本作为正例的相对可能性的对数$\ln\frac{y}{1-y}=\ln\frac{p(y=1|x)}{p(y=0|x)}=w^{T}x+b$</p></li><li><p>极大似然法</p></li><li><p>给定数据集${(x_{i}, y_{i})}^{m}_{i=1}$</p></li><li><p>最大化样本属于其真实标记的概率</p></li><li><p>线性判别分析（Linear Discriminant Analysis）</p><ul><li>最大化目标$J=\frac{|w^{T}\mu_{0}-w^{T}\mu_{1}|^{2}<em>{2}}{w^{T}\sum</em>{0}w+w^{T}\sum_{1}w}=\frac{w^{T}(\mu_{0}-\mu_{1})(\mu_{0}-\mu_{1})^{T}w}{w^{T}(\sum_{0}+\sum_{1})w}$</li><li>类间散度矩阵，类内散度矩阵</li><li>广义瑞丽商$J=\frac{w^{T}S_{b}w}{w^{T}S_{w}w}$</li><li>拉格朗日乘子法<ul><li>$\bigtriangledown f(x^{<em>})+\lambda \Delta g(x^{</em>})=0$</li><li>$L(x,\lambda)=f(x)+\lambda g(x)$.</li></ul></li></ul></li></ul><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><ul><li>多分类学习方法<ul><li>二分类学习方法推广到多类</li><li>利用二分类学习器解决多分类问题<ul><li>对问题进行拆分，为拆出的每个二分类任务训练一个分类器</li><li>对于每个分类器的预测结果进行集成以获得最终的多分类结果</li></ul></li><li>拆分策略<ul><li>一对一（OVO）<ul><li>$N$个类别两两配对，$N(N-1)/2$个二类任务</li><li>各个二类任务学习分类器，$N(N-1)/2$个二类分类器</li></ul></li><li>一对其余（OVR）</li><li>多对多（MVM）<ul><li>若干类作为正类，若干类作为反类</li><li>输出纠错码（Error Correcting Output Code, ECOC）</li></ul></li></ul></li><li>类别不平衡问题$(class\ imbalance)$<ul><li>不同类别训练样例数相差很大情况（正类为小类）</li><li>类别平衡正例预测$\frac{y}{1-y}&gt;1\Rightarrow \frac{y}{1-y}&gt;\frac{m^{+}}{m^{-}}$正负类比例</li></ul></li><li>再缩放<ul><li>欠采样$(undersampling)$<ul><li>去除一些反例使正反例数目接近</li></ul></li><li>过采样$(oversampling)$<ul><li>增加一些正例使正反例数目接近</li></ul></li><li>阈值移动$(threshold-moving)$</li></ul></li></ul></li></ul><h1 id="Chapter4-决策树"><a href="#Chapter4-决策树" class="headerlink" title="Chapter4 决策树"></a>Chapter4 决策树</h1><h2 id="4-1-基本流程"><a href="#4-1-基本流程" class="headerlink" title="4.1 基本流程"></a>4.1 基本流程</h2><h4 id="决策树基于树结构来进行预测"><a href="#决策树基于树结构来进行预测" class="headerlink" title="决策树基于树结构来进行预测"></a>决策树基于树结构来进行预测</h4><ul><li><p>如果用决策树来进行分来,起码该模型一定意义上是可以理解的</p><h4 id="树结构的return"><a href="#树结构的return" class="headerlink" title="树结构的return"></a>树结构的return</h4><h5 id="1-当前节点包含的样本全部属于同一类别-没必要分类"><a href="#1-当前节点包含的样本全部属于同一类别-没必要分类" class="headerlink" title="(1)当前节点包含的样本全部属于同一类别(没必要分类)"></a>(1)当前节点包含的样本全部属于同一类别(没必要分类)</h5><h5 id="2-当前的属性集为空-或所有样本所有属性上取值相同-没法分类"><a href="#2-当前的属性集为空-或所有样本所有属性上取值相同-没法分类" class="headerlink" title="(2)当前的属性集为空,或所有样本所有属性上取值相同(没法分类)"></a>(2)当前的属性集为空,或所有样本所有属性上取值相同(没法分类)</h5><h5 id="3-当前节点包含的样本集合为空-emptyset"><a href="#3-当前节点包含的样本集合为空-emptyset" class="headerlink" title="(3)当前节点包含的样本集合为空($ \emptyset $)"></a>(3)当前节点包含的样本集合为空($ \emptyset $)</h5><h2 id="4-2划分选择"><a href="#4-2划分选择" class="headerlink" title="4.2划分选择"></a>4.2划分选择</h2></li><li><p>希望决策树的分支节点包含的样本尽可能属于同一类别,即节点的”纯度”(purity)越来越高</p></li><li><p>经典的属性划分方法:<br>1)信息增益,<br>2)增益率,<br>3)基尼指数</p><h5 id="划分选择-信息增益"><a href="#划分选择-信息增益" class="headerlink" title="划分选择-信息增益"></a>划分选择-信息增益</h5></li><li><p>“信息熵”是度量样本集合纯度最常用的一种指标</p><h6 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h6></li><li><p>$$Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k$$</p></li><li><p>推导:$$\int P(x)f(x)dx\rightarrow E_{x - p}(f(x))\rightarrow E_{x-p} (log_2 \frac{1}{p_k})$$</p><ul><li><p>(log2可以表示用二进制表示,$\frac{1}{p_k}$可以显示信息(概率越低越刺激))</p></li><li><p>计算信息熵的约定:若p=0,则Ent=0</p></li><li><p>Ent(D)的值越小,纯度越大</p><h6 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h6></li></ul></li><li><p>$$Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^{v}|}{|D|}Ent(D^{v})$$</p></li><li><p>算出信息增益之后,可以确定树的每一层应该对应哪些划分属性</p><h6 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h6></li><li><p>信息增益对可取值数目较多的属性有所偏好</p><h5 id="划分选择-增益率"><a href="#划分选择-增益率" class="headerlink" title="划分选择-增益率"></a>划分选择-增益率</h5></li><li><p>增益率：$$Gain_ ratio (D,a)=\frac{Gain(D,a)}{IV(a)}$$<br>其中    $$IV(a)=-\sum _{v=1}^{V}\frac{D^v}{D}log_2 \frac{D^v}{D}$$</p><h6 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h6></li><li><p>增益率准则对可取值数目较少的属性有所偏好</p><h5 id="划分选择-基尼指数"><a href="#划分选择-基尼指数" class="headerlink" title="划分选择-基尼指数"></a>划分选择-基尼指数</h5><p> $$ Gini(D)=\sum_{k=1}^{|y|}\sum _{k’\neq k}p_kp_{k’}=1-\sum_{k=1}^{|y|}p_k^{2}$$</p></li><li><p>Gini越小纯度越高</p></li></ul><h2 id="4-3剪枝处理"><a href="#4-3剪枝处理" class="headerlink" title="4.3剪枝处理"></a>4.3剪枝处理</h2><ul><li><p>为了对抗过拟合</p></li><li><p>基本策略</p><ul><li>预剪枝</li><li>后剪枝</li></ul></li><li><p>判断决策树泛化性能是否提升的办法</p><ul><li>留出法<br>#####预剪枝</li></ul></li><li><p>优点</p><ul><li>降低过拟合风险</li><li>显著减少训练时间和测试时间开销</li></ul></li><li><p>缺点</p><ul><li>欠拟合风险<br>#####后剪枝</li></ul></li><li><p>优点</p><ul><li>比预剪枝保留了更多的分支,欠拟合风险小,泛化性能往往由于预剪枝决策树</li></ul></li><li><p>缺点</p><ul><li>时间开销<h2 id="4-4连续与缺失值"><a href="#4-4连续与缺失值" class="headerlink" title="4.4连续与缺失值"></a>4.4连续与缺失值</h2><h5 id="连续与缺失值-连续值处理"><a href="#连续与缺失值-连续值处理" class="headerlink" title="连续与缺失值-连续值处理"></a>连续与缺失值-连续值处理</h5></li></ul></li><li><p>连续属性离散化(二分法)</p></li><li><p>缺失值处理</p><ul><li>面临两个问题 如何划分,如何测试</li></ul></li></ul><h2 id="4-5多变量决策树"><a href="#4-5多变量决策树" class="headerlink" title="4.5多变量决策树"></a>4.5多变量决策树</h2><h1 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h1><h2 id="5-1-神经网络模型与发展史"><a href="#5-1-神经网络模型与发展史" class="headerlink" title="5.1 神经网络模型与发展史"></a>5.1 神经网络模型与发展史</h2><ul><li>第一阶段<ul><li>M-P模型</li><li>Hebb学习规则:类似于巴普洛夫,if input and output 同时激活或者失活, 那么这两个神经元的链接应该被加强,else 应该减弱</li><li>感知机网络</li><li>自适应神经元,最小均方学习算法</li><li>GG 1: 单层的神经网络不能解决非线性问题,多层神经网络算力不足的时候就输了</li></ul></li><li>第二阶段<ul><li>Hopfield 网络</li><li>反向传播算法</li><li>SVM与统计学习理论</li></ul></li><li>第三阶段<ul><li>DBN深度信念网络</li></ul></li><li>神经元模型<ul><li>M-P神经元模型<ul><li>输入:来自其他n个神经元传递过来的输入信号</li><li>处理:输入信号通过带权重的连接进行传递,神经元接收到的总输入值将与神经元的阈值进行比较</li><li>输出:通过激活函数的处理以得到输出:$y=f(\sum _{i=1}^{n}w_ix_i-<br>\theta)$</li><li>扯一点signmoid(x)=$\frac{1}{1+e^{-x}}$<br>$y’=\frac{1}{1+e^{-x}}’=\frac{1}{1+e^{-x}}\times \frac{e^{-x}}{1+e^{-x}}=y(1-y)$</li></ul></li></ul></li></ul><h2 id="5-2-感知机与多层网络"><a href="#5-2-感知机与多层网络" class="headerlink" title="5.2 感知机与多层网络"></a>5.2 感知机与多层网络</h2><ul><li>感知机<ul><li>由两层神经元组成,输入层接受外界输入信号传递个输出层,输出层是M-神经元</li><li>与或非</li><li>多层感知机</li><li>多层前馈神经网络<ul><li>定义:每层神经元与下一层神经元全互联</li><li>前馈:输入层接受外界输入,隐含层与输出层神经元对信号进行加工,最终结果由输出层神经元输出</li></ul></li></ul></li></ul><h2 id="5-3-误差逆传播算法"><a href="#5-3-误差逆传播算法" class="headerlink" title="5.3 误差逆传播算法"></a>5.3 误差逆传播算法</h2><ul><li>误差逆传播算法(BP)<ul><li>前向计算:<ul><li>$b_h=f(\beta _h -y_h ),\beta <em>h=\sum</em>{i=1}^{d}v_{ih}x_i$</li><li>$\hat{y}_i^{k}=f(a_j-\theta _j),\alpha_h=\sum_{i=1}^{d} w_{hj}b_{h}$ </li><li>$E_k=\frac{1}{2}\sum_{j=1}^{l}(\hat{y}<em>{j}^{k}-\hat{y}</em>{j}^{k})^{2}$</li></ul></li><li>参数数目<ul><li>权重:$v_{ih},w_{hj}$, 阈值:$\theta <em>{j}$,$y</em>{h}$ (i=1,…,d,h=1,…,q,j=1,…,l)<br>因此网络中需要(d+l+1)q+l个参数需要优化</li></ul></li><li>参数优化<ul><li>BP是迭代学习算法,在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计,任意的参数v的更新估计式为<br>$$v\leftarrow v+\Delta v$$</li><li>梯度咋整? 梯度消失咋整?</li><li>因为本质上还是函数的复合,因此不能用线性函数做传递函数</li></ul></li></ul></li><li>一些BP算法<ul><li>标准BP算法:每来一个样本,就扔到bp网络中,然后前馈得到误差,得到误差之后就逆传递回来更新网络……</li><li>累计BP算法:用平均误差更新权值,一定意义上可以减少震荡</li><li>实际应用: Mini BP 一块一块更新</li></ul></li><li>多层前馈网络:<ul><li>局限:<ul><li>可能遭遇过拟合</li><li>到底搞几层？</li></ul></li><li>解决过拟合策略：<ul><li>正则化</li><li>早停</li></ul></li></ul></li></ul><h2 id="5-4-全局最小与局部极小"><a href="#5-4-全局最小与局部极小" class="headerlink" title="5.4 全局最小与局部极小"></a>5.4 全局最小与局部极小</h2><ul><li>策略<ul><li>使用”模拟退火”</li><li>随机梯度下降</li><li>遗传算法 </li></ul></li></ul><h2 id="5-5-其他常见神经网络"><a href="#5-5-其他常见神经网络" class="headerlink" title="5.5 其他常见神经网络"></a>5.5 其他常见神经网络</h2><ul><li>RBF网络:单隐层,激活函数与输入向量有关:<br>$$\phi(x)=\sum^{q}_{i=1}w_i\rho(x,c_i)$$<br>$\rho(x,c_i)$是径向基函数：<br>$$\rho(x,c_i)=e^{-\beta_i ||x-c_i||^{2}}$$</li><li>ART网络：自适应谐振理论<br>竞争性学习网络,输出神经元互相竞争,遵循胜者通吃原则<br>比较层,识别层(???)</li><li>SOM网络：获取数据内在的结构</li><li>级联相关,或则隐层节点的构造</li><li>Elman网络：递归神经网络 </li></ul><h1 id="Chapter-6-支持向量机"><a href="#Chapter-6-支持向量机" class="headerlink" title="Chapter 6: 支持向量机"></a>Chapter 6: 支持向量机</h1><h1 id="传奇——一刀999"><a href="#传奇——一刀999" class="headerlink" title="传奇——一刀999"></a>传奇——一刀999</h1><p>神经网络(1989-1994)(BP算法)———–&gt;支持向量机 (1995-2005)(核方法,统计学习)(Vapnik)———&gt; 神经网络(2006-今)(深度学习)</p><table><thead><tr><th>支持向量机</th><th style="text-align:left">灵活（核方法）</th><th>能力很强</th><th>数学理论坚实</th><th>全局最优解</th><th>不需要人工调参</th></tr></thead><tbody><tr><td>神经网络</td><td style="text-align:left">更灵活</td><td>能力很强</td><td>理论不清,来自认知</td><td>局部最优解</td><td>非常依赖人工调参</td></tr><tr><td>支持向量机(SVM)</td><td style="text-align:left">计算开销大</td><td>领域知识嵌入困难(对现象的认识)</td><td>服务于科学界</td><td></td><td></td></tr><tr><td>神经网络(NN)</td><td style="text-align:left">可大可小</td><td>领域知识无处不在</td><td>服务于工业界</td><td></td></tr></tbody></table><h2 id="6-1-间隔与支持向量"><a href="#6-1-间隔与支持向量" class="headerlink" title="6.1 间隔与支持向量"></a>6.1 间隔与支持向量</h2><ul><li><p>最大间隔: 寻找参数$w$,b,使得$\nu=\frac{2}{||w||}$ 最大 </p><ul><li><p>$$arg~max_{w,b}~\frac{2}{||w||}$$    </p><p>s.t. $y_i(w^{T}x_i+b)\geq 1,i=1,2,…,m$</p></li><li><p>$$arg~min~\frac{1}{2}||w||^{2}$$</p><p>s.t. $y_i(w^{T}x_i+b) \geq 1,i=1,2,…,m$</p></li></ul></li></ul><h2 id="6-2-对偶问题"><a href="#6-2-对偶问题" class="headerlink" title="6.2 对偶问题"></a>6.2 对偶问题</h2><ul><li><p>拉格朗日乘子法</p><ul><li>三步</li></ul></li><li><p>解的稀疏性</p><ul><li><p>最终模型:$f(x)=w^Tx+b=\sum_{i=1}^{m}a_iy_ix_{i}^{T}x+b$</p></li><li><p>KKT条件:</p><p>$${<br>\begin{cases}<br>a_i\geq 0\<br>y_if(x_i)\geq 1\a_i(y_if(x_i)-1)=0\end{cases}}$$</p></li></ul></li><li><p>SMO-求解方法,选两个固定搞，因为两个有闭式解；</p></li></ul><h2 id="6-3-核函数"><a href="#6-3-核函数" class="headerlink" title="6.3 核函数"></a>6.3 核函数</h2><ul><li><p>从低维映射到高维可以用线性的方式进行分类，只要维数足够高，高维的空间总可以线性的来分类；</p></li><li><p>将x映射到$\phi(x)$转换前面的最终模型为:$f(x)=w^Tx+b=\sum_{i=1}^{m}a_iy_i\phi(x)_{i}^{T}\phi(x)+b$</p><p>定义核函数:$k(x_i,x_j)=\phi(x_i)^{T}\phi(x_j)$</p><p>定义核矩阵:$$K= {\left[  \begin{matrix}    k(x_1,x_1) &amp; k(x_1,x_2) &amp; … &amp; k(x_1,x_n)\  k(x_2,x_1) &amp; k(x_2,x_2) &amp; … &amp; k(x_2,y_n) \   …&amp;… &amp; … &amp; ..  \   k(x_n,x_1) &amp; k(x_n,x_2) &amp; … &amp; k(x_n,y_n)  \end{matrix}  \right]} $$</p></li></ul><h2 id="6-4-软间隔与正则化"><a href="#6-4-软间隔与正则化" class="headerlink" title="6.4 软间隔与正则化"></a>6.4 软间隔与正则化</h2><ul><li>黑人问号，谜の调参(C)</li></ul><h2 id="6-5-支持向量回归"><a href="#6-5-支持向量回归" class="headerlink" title="6.5 支持向量回归"></a>6.5 支持向量回归</h2><ul><li>因为听不懂所以自闭了 感觉大概推了一个神奇的二次回归吧</li></ul><h2 id="6-6-核方法"><a href="#6-6-核方法" class="headerlink" title="6.6 核方法"></a>6.6 核方法</h2><ul><li>表示定理：对于任意单调增函数$\Omega$和任意非负损失函数l,优化问题……</li></ul><h1 id="Chapter-7-贝叶斯"><a href="#Chapter-7-贝叶斯" class="headerlink" title="Chapter 7 :贝叶斯"></a>Chapter 7 :贝叶斯</h1><h2 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a>7.1 贝叶斯决策论</h2><p>概率框架下实施决策的基本理论：</p><ul><li><p>条件风险</p><ul><li>$R(c_i|x)=\sum_{j=1}^{N}\lambda _{ij}P(c_j|x)$</li></ul></li><li><p>贝叶斯判定准则</p><ul><li>$h^{*}(x)=argmin_{c\in \gamma} ~R(c|x)$</li><li>$h^*(x)$:贝叶斯最优分类器,</li><li>反应了机器学习所能产生的模型精度的理论上限</li></ul></li><li><p>P(c|x)在现实中通常难以直接获得</p></li><li><p>两种基本策略：</p><ul><li>判别式模型：直接对P(c|x)建模<ul><li>决策树</li><li>BP神经网络</li><li>SVM</li></ul></li><li>生成式模型：先对联合概率分布P(x,c)建模,再由此获得P(c|x)<ul><li>$P(c|x)=\frac{P(x.c)}{P(x)}$</li></ul></li></ul></li><li><p>贝叶斯定理</p><ul><li><p>后验概率与联合概率分布的关系：</p><p>$P(c|x)=\frac{P=(x,c)}{P(x)}$</p></li><li><p>$P(c|x)=\frac{P(c)P(x|c)}{P(x)}=\frac{P(c)P(x|c)}{\int P(c)P(x|c)~dc}$</p><p>P(c):先验概率(人群中得病概率为1/1000000)</p><p>P(x):证据</p><p>P(c|x):后验概率(医院看到了症状之后判断的概率)  </p><p>P(x|c): likehood 似然(重点在另外的变量$\theta$上) ,likehood function目的是求$\theta$ </p><p>Prob(重点在变量上面) </p></li></ul></li></ul><h2 id="7-2极大似然估计"><a href="#7-2极大似然估计" class="headerlink" title="7.2极大似然估计"></a>7.2极大似然估计</h2><p>fenleiqifenleiqi（不太懂 <a href="https://blog.csdn.net/chenjianbo88/article/details/52398181" target="_blank" rel="noopener">https://blog.csdn.net/chenjianbo88/article/details/52398181</a></p><h2 id="7-3-朴素贝叶斯分类器-naive-Bayes-classifier"><a href="#7-3-朴素贝叶斯分类器-naive-Bayes-classifier" class="headerlink" title="7.3 朴素贝叶斯分类器(naive Bayes classifier)"></a>7.3 朴素贝叶斯分类器(naive Bayes classifier)</h2><p>假定属性独立地对分类结果发生影响</p><p>$$P(c|x)=\frac{P(c)P(x|c)}{P(x)}=\frac{P(c)}{P(x)}\Pi^{d}_{i=1}P(x_i|c)$$</p><ul><li>P(c)=$\frac{D_c}{D}$</li><li>$P(x_i|c)=\frac{D_{c,x_i}}{D_c}$</li><li>拉普拉斯修正(为了解决某一个属性值在训练集中没有与某个类同时出现过就凉了 所以要假设出现了一次)<ul><li>$\hat{P(c)}=\frac{|D_c|+1}{|D|+N}$</li><li>$\hat{P(x_i|c)}=\frac{|D+{c_i,x_i}|+1}{|D_c|+N_i}$</li></ul></li><li>hint: 连续的分布用概率密度来代替,(一般用高斯分布)</li></ul><h2 id="7-4-半朴素贝叶斯分类器"><a href="#7-4-半朴素贝叶斯分类器" class="headerlink" title="7.4 半朴素贝叶斯分类器"></a>7.4 半朴素贝叶斯分类器</h2><p>One - Dependent Esitimator</p><ul><li><p>SPODE</p><p>超父带你飞</p></li><li><p>TAN</p><ul><li><p>计算条件互信息</p><p>$I(x_i,x_j|y)=\sum _{x_i,x_j;c\in \gamma}P(x_i,x_j|c)log\frac{P(x_i,x_j|c)}{P(x_i|c)P(x_j|c)}$</p></li><li><p>建完全图,权重设为上面的I</p></li><li><p>构建最大带权生成树,挑选根变量,将变置为有向</p></li><li><p>加入类别节点y,增加从y到每一个属性的有向边</p></li></ul></li><li><p>AODE</p></li></ul><h2 id="7-5-贝叶斯网"><a href="#7-5-贝叶斯网" class="headerlink" title="7.5 贝叶斯网"></a>7.5 贝叶斯网</h2><p>（概率论知识反应不能,To be continued</p><ul><li>V型例子:各位的智商x1 考试难度x2  最后的考试成绩x4,考完结果出来x1,x2就不独立了</li><li>道德图(从marriage的梗里面获得)</li><li></li></ul><h1 id="Chap-8-集成学习"><a href="#Chap-8-集成学习" class="headerlink" title="Chap 8 集成学习"></a>Chap 8 集成学习</h1><p>​    </p><p>​    </p><blockquote><p>PS：使用<a href="https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</a> 里面的方法解决了博客的数学公式显示问题</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习笔记&quot;&gt;&lt;a href=&quot;#机器学习笔记&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记&quot;&gt;&lt;/a&gt;机器学习笔记&lt;/h1&gt;&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ML" scheme="http://Tyler-ytr.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>数学期望</title>
    <link href="http://Tyler-ytr.github.io/2021/02/23/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"/>
    <id>http://Tyler-ytr.github.io/2021/02/23/数学期望/</id>
    <published>2021-02-23T09:24:41.000Z</published>
    <updated>2021-02-23T09:26:15.447Z</updated>
    
    <content type="html"><![CDATA[<ul><li>离散型:$\sum _{k=1}^{\infty}x_kp_k$,需要它绝对收敛;</li><li>连续型:$\int_{-\infty}^{\infty}xp(x)dx$,同样需要它绝对收敛,如果$\int_{-\infty}^{\infty}|x|p(x)dx$发散,则X的数学期望不存在</li><li>Gamma函数:<br>$$\Gamma(x)=\int_{0}^{+\infty}t^{x-1}e^{-t}$$<ul><li>$\Gamma(1)=1$</li><li>$\Gamma(x+1)=x\Gamma(x)$</li><li>$\Gamma(n)=(n-1)!$</li></ul></li><li>高斯积分:<ul><li>$\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}$</li></ul></li><li>$C_{n}^{k}=\frac{n!}{k!(n-k)!}$</li><li>$\int \frac{1}{1+x^2}=arctanx$</li></ul><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><ul><li>概率与数学期望及方差:<ul><li>0-1分布:$X~B(1,p)$,$0&lt;p&lt;1$:<ul><li>E(x)=0<em>(1-p)+1</em>p=p</li><li>D(X)=pq</li></ul></li><li>二项分布:$X~B(n,p)$,$0&lt;p&lt;1$<ul><li>$P{X=k}=C_{n}^kp^k(1-p)^{n-k},(k=0,1,…,n)$</li><li>$E(X)=np$<ul><li>$E(X)$的证明注意$\sum^{n-1}<em>{s=0}C^{s}</em>{n-1}p^s(1-p)^{n-1-s}=1$</li></ul></li><li>$D(x)=npq$</li></ul></li><li>几何分布:<ul><li>P(X=k)=$p(1-p)^{k-1}$</li><li>E(x)=</li></ul></li><li>泊松分布:X~$P(\lambda),\lambda&gt;0$<ul><li>$P{X=k}=\frac{\lambda^{k}}{k!}e^{-\lambda}$</li><li>E(X)=$\lambda$<ul><li>$E(x)$的证明注意$\sum_{m=0}^{\infty}\frac{\lambda^m}{m!}e^{-\lambda}=1$(这是因为泊松分布概率的加和为1)</li><li>D(X)=$\lambda$</li></ul></li></ul></li><li>均匀分布:X~$U(a,b)$<ul><li>$\begin{aligned}p(x)&amp;=\frac{1}{b-a},a&lt;x&lt;b;\&amp;=0,<del>~</del>~~~others;\end{aligned}$</li><li>E(x)=$\frac{a+b}{2}$</li></ul></li><li>指数分布:X~E($\lambda$)$\lambda&gt;0$,<ul><li>p(x)=$\lambda e^{-\lambda x}$,x&gt;0;</li><li>E(x)=$\frac{1}{\lambda}$</li></ul></li><li>正态分布:X~N($\mu,\sigma^2$)<ul><li>p(x)=$\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;\infty$</li><li>E(x)=$\mu$</li><li>$\mu$:平均值;$\sigma^2$:X取值的离散程度</li></ul></li><li>代换:<ul><li>一维<ul><li>E(Y)=E[g(X)]=$\sum_{k=1}^{\infty}g(x_k)p_k$(离散)</li><li>E(Y)=E[g(X)]=$\int_{-\infty}^{+\infty}g(x)p(x)dx$</li></ul></li><li>二维<ul><li>E(Z)=E[g(X,Y)]=$\sum_{j=1}^{\infty}\sum_{i=1}^{\infty}g(x_i,y_i)p_{ij}$(离散型)</li><li>E(Z)=E[g(X,Y)]=$\int_{j=1}^{\infty}\int_{i=1}^{\infty}g(x,y)p_{x,y}dxdy$(连续型)</li></ul></li><li>边缘密度:E(g(X,Y)),g(X,Y)=x,E(x)=$\int_{j=1}^{\infty}\int_{i=1}^{\infty}xp_{x,y}dxdy$</li><li>性质:<ul><li>E(X+Y)=E(X)+E(Y)</li><li>if X,Y互相独立:E(XY)=E(X)E(Y)</li><li>设C是常数:E(C)=C</li><li>设k是常数:E(kx)=kE(x)</li></ul></li></ul></li></ul></li></ul><h1 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h1><ul><li>D(X)=E{[X-E(X)]$^2$}<ul><li>D(X)=$\sum_{k=1}^{+\infty}[x_k-E(X)]^2p_k$</li><li>D(X)=$\int_{-infty}^{+\infty}[x_k-E(X)]^2p_k$</li><li>D(x)=E($X^2$)-$[E(x)]^2$</li></ul></li><li>性质:<ul><li>D(C)=0;</li><li>C是常数<ul><li>D(CX)=$C^2$D(X)</li><li>D(X+C)=D(X)</li></ul></li><li>D(X),D(Y)存在:<ul><li>if 不独立:D($X\pm Y$)=$D(X)\pm +D(y)\pm 2E{(X-E(X))(Y-E(Y))}$</li><li>else:D($X\pm Y$)=$D(X)\pm +D(y)$</li></ul></li><li>切比雪夫不等式:<ul><li>$P{|X-E(X)|\geq \varepsilon }\leq \frac{D(X)}{\varepsilon ^2 }$</li><li>$P{|X-E(X)|&lt;&gt; \varepsilon }\geq 1- \frac{D(X)}{\varepsilon ^2 }$</li></ul></li><li>D(X)=0  $\Leftrightarrow $ P{X=C}=1</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;离散型:$\sum _{k=1}^{\infty}x_kp_k$,需要它绝对收敛;&lt;/li&gt;
&lt;li&gt;连续型:$\int_{-\infty}^{\infty}xp(x)dx$,同样需要它绝对收敛,如果$\int_{-\infty}^{\infty}|x|p(x)
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://Tyler-ytr.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="概率论" scheme="http://Tyler-ytr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-2:P4 basic实验</title>
    <link href="http://Tyler-ytr.github.io/2021/02/21/p4%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://Tyler-ytr.github.io/2021/02/21/p4学习-2/</id>
    <published>2021-02-21T09:12:26.000Z</published>
    <updated>2021-02-25T08:18:32.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-2：P4-basic实验"><a href="#P4学习-2：P4-basic实验" class="headerlink" title="P4学习-2：P4 basic实验"></a>P4学习-2：P4 basic实验</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><ol><li><p>写一个P4程序完成基本的IPV4转发，也就是交换机需要:1.更新源和目的MAC地址 2. 在IP报头中减少 time-to-live(TTL)  3.将数据包转发到适当的端口</p><p>交换机有一个简单的table,控制平面将根据基本的规则更新它。每个规则将一个IP地址映射到下一跳的MAC地址和输出端口。我们已经定义了控制平面规则，所以你只需要实现你的P4程序的数据平面逻辑。</p></li><li><p>拓扑如下:</p><p><img src="/picture/pod-topo.png" alt="pod-topo"></p></li><li><p>实验basic.p4给了一个p4程序，关键部分被TODO代替，这个程序主要由以下部分组成:</p><ol><li><p>Ethernet (<code>ethernet_t</code>) and IPv4 (<code>ipv4_t</code>)两个header type的类型定义</p></li><li><p><strong>TODO</strong>：用于以太网和IPv4的Parser,它通过解析数据包填充了上述两个header;</p></li><li><p>一个丢包的动作，用了<code>mark_to_drop()</code></p></li><li><p><strong>TODO</strong>：一个动作（<code>ipv4_forward</code>）：</p><ol><li>设置下一跳的出口端口。</li><li>更新以太网目的地址为下一跳地址。</li><li>将以太网源地址更新为交换机地址。</li><li>TTL衰减。</li></ol></li><li><p><strong>TODO:</strong> 一个control:</p><ol><li>定义一个表，该表将读取IPv4目的地址，并调用<code>drop</code> 或者<code>ipv4_forward</code></li><li>应用这个表的一个 <code>apply</code>  block </li></ol></li><li><p>选择字段插入出数据包的顺序的Deparser。</p></li><li><p>实例化部分</p><blockquote><p>通常，包还需要校验和验证和重新计算控件的实例。这些对于本教程来说不是必需的，它们将被空控件的实例化所取代。</p></blockquote></li></ol></li></ol><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><p>本部分根据上面对程序的描述一一进行分析：</p><h5 id="headers部分"><a href="#headers部分" class="headerlink" title="headers部分:"></a>headers部分:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F; # 声明语言是p4-16</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123; # header数据结构相当于c语言里面的 packed struct,它有一个隐藏的参数validity，如果解析正确那么是true，可以通过isValid()获得，比如hdr.ipv4.isValid();</span><br><span class="line">    macAddr_t dstAddr;# macAddr_t是typedef bit&lt;48&gt; 的自定义类型</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;#4bit的数据</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123; #struct数据结构相当于python里面的 dictionary</span><br><span class="line">    &#x2F;* empty *&#x2F; #这个实验用不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t   ethernet;</span><br><span class="line">    ipv4_t       ipv4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中V1model的结构如下图所示:</p><p> <img src="/picture/image-20210222224801495.png" alt="image-20210222224801495"></p><p> 总的来说这是一个模板，大致由下图组成:</p><p> <img src="/picture/image-20210222224659076.png" alt="image-20210222224659076"></p><p> 主要由HEADERS,PARSER,CHECKSUMVERFICATION,INGRESSPROCESSING,EGRESSPROCESSING,CHECKSUM UPDATE,DEPARSER,SWITCH组成;大概实例化的解释如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">V1Switch(</span><br><span class="line">MyParser(),    &#x2F;&#x2F; 解析数据包，提取包头 </span><br><span class="line">MyVerifyChecksum(),  &#x2F;&#x2F; 校验和验证</span><br><span class="line">MyIngress(),   &#x2F;&#x2F; 输入处理</span><br><span class="line">MyEgress(),    &#x2F;&#x2F; 输出处理</span><br><span class="line">MyComputeChecksum(),  &#x2F;&#x2F; 计算新的校验和</span><br><span class="line">MyDeparser()   &#x2F;&#x2F; 逆解析器</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h5 id="Parser部分"><a href="#Parser部分" class="headerlink" title="Parser部分"></a>Parser部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        &#x2F;* TODO: add parser logic *&#x2F;</span><br><span class="line">        transition accept;#表示接受，也就是程序终止</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr, #out相当于输出的数据,然后它的type是headers</span><br><span class="line">                inout metadata meta, #inout同时作为输入和输出值，类似 c++ 里面的引用</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;#转移到解析以太包头阶段</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_ethernet&#123;</span><br><span class="line">    packet.extract(hdr.ethernet); #把packet提取到hdr的ethernet里面，这里的过程可以理解为根据ethernet的长度截取一段数据</span><br><span class="line">    transition select(hdr.ethernet.etherType)&#123;#根据etherType的值选择进入的状态</span><br><span class="line">    TYPE_IPV4: parse_ipv4;#是IPV4包，进入解析ipv4的状态</span><br><span class="line">    default: accept;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_ipv4&#123;</span><br><span class="line">    packet.extract(hdr.ipv4); #接着解析ipv4部分，这里可以理解为指针又往前移动了</span><br><span class="line">    transition accept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Ingress部分"><a href="#Ingress部分" class="headerlink" title="Ingress部分"></a>Ingress部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        &#x2F;* TODO: fill out code in action body *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;* TODO: fix ingress control logic</span><br><span class="line">         *  - ipv4_lpm should be applied only when IPv4 header is valid</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ipv4_lpm.apply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec&#x3D;port; #egress_spec可以在输入代码中指定一个值来控制数据包将去哪个输出端口</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;  #原数据包的源地址改为目的地址</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr; #目的地址改为控制面传入的新的地址</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;       #ttl要减去1</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;# 隐藏的参数，判断解析是否成功</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:standard_metadata是<a href="https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4" target="_blank" rel="noopener">v1model.p4</a>里面定义的数据结构，在<a href="https://github.com/p4lang/behavioral-model/blob/main/docs/simple_switch.md" target="_blank" rel="noopener">simple_switch</a>的README里面进行了详细的解释,simple_switch是p4语言的一种架构，它大概的定义如下,其中v1m表示v1model,p4-16的一种模型，sm14是p4-14里面定义的模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ingress_port (sm14, v1m) - For new packets, the number of the ingress port on which the packet arrived to the device. Read only.</span><br><span class="line">packet_length (sm14, v1m) - For new packets from a port, or recirculated packets, the length of the packet in bytes. For cloned or resubmitted packets, you may need to include this in a list of fields to preserve, otherwise its value will become 0.</span><br><span class="line">egress_spec (sm14, v1m) - Can be assigned a value in ingress code to control which output port a packet will go to. The P4_14 primitive drop, and the v1model primitive action mark_to_drop, have the side effect of assigning an implementation specific value DROP_PORT to this field (511 decimal for simple_switch by default, but can be changed through the --drop-port target-specific command-line option), such that if egress_spec has that value at the end of ingress processing, the packet will be dropped and not stored in the packet buffer, nor sent to egress processing. See the &quot;after-ingress pseudocode&quot; for relative priority of this vs. other possible packet operations at end of ingress. If your P4 program assigns a value of DROP_PORT to egress_spec, it will still behave according to the &quot;after-ingress pseudocode&quot;, even if you never call mark_to_drop (P4_16) or drop (P4_14).</span><br><span class="line">egress_port (sm14, v1m) - Only intended to be accessed during egress processing, read only. The output port this packet is destined to.</span><br><span class="line">egress_instance (sm14) - Renamed egress_rid in simple_switch. See egress_rid below.</span><br><span class="line">instance_type (sm14, v1m) - Contains a value that can be read by your P4 code. In ingress code, the value can be used to distinguish whether the packet is newly arrived from a port (NORMAL), it was the result of a resubmit primitive action (RESUBMIT), or it was the result of a recirculate primitive action (RECIRC). In egress processing, can be used to determine whether the packet was produced as the result of an ingress-to-egress clone primitive action (INGRESS_CLONE), egress-to-egress clone primitive action (EGRESS_CLONE), multicast replication specified during ingress processing (REPLICATION), or none of those, so a normal unicast packet from ingress (NORMAL). Until such time as similar constants are pre-defined for you, you may copy this list of constants into your code.</span><br><span class="line">parser_status (sm14) or parser_error (v1m) - parser_status is the name in the P4_14 language specification. It has been renamed to parser_error in v1model. The value 0 (sm14) or error.NoError (P4_16 + v1model) means no error. Otherwise, the value indicates what error occurred during parsing.</span><br><span class="line">parser_error_location (sm14) - Not present in v1model.p4, and not implemented in simple_switch.</span><br><span class="line">checksum_error (v1m) - Read only. 1 if a call to the verify_checksum primitive action finds a checksum error, otherwise 0. Calls to verify_checksum should be in the VerifyChecksum control in v1model, which is executed after the parser and before ingress.</span><br></pre></td></tr></table></figure><h5 id="Egress部分"><a href="#Egress部分" class="headerlink" title="Egress部分"></a>Egress部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Checksum-部分"><a href="#Checksum-部分" class="headerlink" title="Checksum 部分"></a>Checksum 部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*************   C H E C K S U M    C O M P U T A T I O N   **************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123;</span><br><span class="line">     apply &#123;</span><br><span class="line">update_checksum(</span><br><span class="line">    hdr.ipv4.isValid(),</span><br><span class="line">            &#123; hdr.ipv4.version,</span><br><span class="line">      hdr.ipv4.ihl,</span><br><span class="line">              hdr.ipv4.diffserv,</span><br><span class="line">              hdr.ipv4.totalLen,</span><br><span class="line">              hdr.ipv4.identification,</span><br><span class="line">              hdr.ipv4.flags,</span><br><span class="line">              hdr.ipv4.fragOffset,</span><br><span class="line">              hdr.ipv4.ttl,</span><br><span class="line">              hdr.ipv4.protocol,</span><br><span class="line">              hdr.ipv4.srcAddr,</span><br><span class="line">              hdr.ipv4.dstAddr &#125;,</span><br><span class="line">            hdr.ipv4.hdrChecksum,</span><br><span class="line">            HashAlgorithm.csum16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;# 内置函数</span><br></pre></td></tr></table></figure><h5 id="Deparser部分"><a href="#Deparser部分" class="headerlink" title="Deparser部分"></a>Deparser部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;* TODO: add deparser logic *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);#按照顺序封装,emit的含义是发射</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例化部分"><a href="#实例化部分" class="headerlink" title="实例化部分"></a>实例化部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  S W I T C H  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">V1Switch(</span><br><span class="line">MyParser(),</span><br><span class="line">MyVerifyChecksum(),</span><br><span class="line">MyIngress(),</span><br><span class="line">MyEgress(),</span><br><span class="line">MyComputeChecksum(),</span><br><span class="line">MyDeparser()</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果:"></a>实验结果:</h4><p>pingall测试:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20210223225105957.png" alt="image-20210223225105957" title="">                </div>                <div class="image-caption">image-20210223225105957</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-2：P4-basic实验&quot;&gt;&lt;a href=&quot;#P4学习-2：P4-basic实验&quot; class=&quot;headerlink&quot; title=&quot;P4学习-2：P4 basic实验&quot;&gt;&lt;/a&gt;P4学习-2：P4 basic实验&lt;/h2&gt;&lt;h4 id=&quot;实验目标&quot;
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-1:介绍与参考资料</title>
    <link href="http://Tyler-ytr.github.io/2021/02/18/p4%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://Tyler-ytr.github.io/2021/02/18/p4学习-1/</id>
    <published>2021-02-18T03:08:37.000Z</published>
    <updated>2021-03-13T03:37:30.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-1：介绍与参考资料"><a href="#P4学习-1：介绍与参考资料" class="headerlink" title="P4学习-1：介绍与参考资料"></a>P4学习-1：介绍与参考资料</h2><h4 id="实验前"><a href="#实验前" class="headerlink" title="实验前"></a>实验前</h4><ol><li><p>P4的PISA(Protocol-Independent Switch Architecture)结构：</p><p>Programmable  Parser—&gt;Programmable Match-Action Pipeline—&gt; Programmable Deparser；</p><p>Parser作用:程序员声明应该被识别的头和它们在包中的顺序</p><p>Match-Action作用:程序员定义表和精确的处理算法</p><p>Deparser作用:程序员声明输出的包怎样输出到总线上</p><p><img src="/picture/image-20210220162023603.png" alt="image-20210220162023603"></p><p>整个结构都是流水线架构，一个来自外部的网络数据包经过层层流程首先被Parser解析出headers,然后进入Match-Action Table进行匹配和操作，这些headsers可以被添加/修改/删除；然后进入Deparser组装好流入外部网络，因为是流水线，所以Match-Action部分是不可以回头的 ；</p></li><li><p>实验部分——文件结构:(主要参考博客)</p><p> tutorials的文件结构:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tutorials&#x2F;</span><br><span class="line">├── exercises   # 存放各种练习</span><br><span class="line">├── utils       # 工具脚本目录</span><br><span class="line">└── vm          # 用于vagrant构建虚拟机的目录，可以无视</span><br></pre></td></tr></table></figure><p> 例子的文件结构:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 我们切换进入 exercises&#x2F;basic_tunnel 这个例子</span><br><span class="line">basic</span><br><span class="line">├── basic_tunnel.p4   # 要编写的p4代码</span><br><span class="line">├── build      # 生成文件的目录</span><br><span class="line">├── logs       # 日志文件， 在调试的时候真的非常重要！</span><br><span class="line">├── Makefile   ### 通过Makefile 来调用utils下的脚本!</span><br><span class="line">├── pcaps      # 生成的pcap包，可以使用wireshark等工具来分析</span><br><span class="line">├── README.md  # 详细的指导</span><br><span class="line">├── receive.py ## 利用scapy写的抓取和分析数据包的工具</span><br><span class="line">├── s1-runtime.json  #</span><br><span class="line">├── s2-runtime.json  # 在运行同时加载入交换机的控制面代码，这里有争议，稍后再谈</span><br><span class="line">├── s3-runtime.json  #</span><br><span class="line">├── send.py    ## 利用scapy写的构建和发送数据包的工具</span><br><span class="line">├── solution   # 这里有这个例子的示例代码（答案）</span><br><span class="line">└── topology.json  # 描述拓扑的json文件</span><br></pre></td></tr></table></figure><blockquote><p>这部分摘自参考资料的博客，实际情况有所不同</p></blockquote><p> Makefile会调用前面提到的utils下面的Makefile脚本，运行P4代码;</p><p> 使用make run 启动;</p><p> 调用<code>make run</code>，我们可以运行当前目录下（以basic目录为例）的代码，它将执行以下几个步骤:</p><ul><li>编译basic.p4 代码，生成basic.json</li><li>解析topology.json， 并且构建相应的mininet仿真拓扑，按照该拓扑启动一台或者多台BMv2交换机，以及一些host</li><li>启动BMv2的同时会将p4代码编译产生的json文件导入</li><li>启动BMv2后会解析 sN-runtime.json 文件(s1,s2,s3……)，将其载入 交换机sN流表之中</li><li>进入mininet命令行，同时开始记录log以及搜集pcap文件</li></ul></li><li><p>P4的参考手册:<a href="https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html" target="_blank" rel="noopener">https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html</a></p></li></ol><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://www.sdnlab.com/22512.html" target="_blank" rel="noopener">https://www.sdnlab.com/22512.html</a></li><li>P4官方tutorial(<a href="https://github.com/p4lang/tutorials" target="_blank" rel="noopener">https://github.com/p4lang/tutorials</a>)</li><li><a href="https://www.zhihu.com/column/c_1336207793033015296" target="_blank" rel="noopener">P4学习笔记专栏</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-1：介绍与参考资料&quot;&gt;&lt;a href=&quot;#P4学习-1：介绍与参考资料&quot; class=&quot;headerlink&quot; title=&quot;P4学习-1：介绍与参考资料&quot;&gt;&lt;/a&gt;P4学习-1：介绍与参考资料&lt;/h2&gt;&lt;h4 id=&quot;实验前&quot;&gt;&lt;a href=&quot;#实验
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode21-s</title>
    <link href="http://Tyler-ytr.github.io/2021/02/14/leetcode21-s/"/>
    <id>http://Tyler-ytr.github.io/2021/02/14/leetcode21-s/</id>
    <published>2021-02-14T09:46:54.000Z</published>
    <updated>2021-02-14T09:51:48.658Z</updated>
    
    <content type="html"><![CDATA[<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><p>难度简单1530</p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/merge_ex1.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                l1,l2=l2,l1</span><br><span class="line">            l1.next=self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21. 合并两个有序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="递归" scheme="http://Tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>p4安装</title>
    <link href="http://Tyler-ytr.github.io/2021/02/07/p4%E5%AE%89%E8%A3%85/"/>
    <id>http://Tyler-ytr.github.io/2021/02/07/p4安装/</id>
    <published>2021-02-07T08:25:10.000Z</published>
    <updated>2021-03-04T01:28:45.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="P4环境配置"><a href="#P4环境配置" class="headerlink" title="P4环境配置"></a>P4环境配置</h4><blockquote><p>因为之后使用的时候PI那块还是有问题，建议谨做参考，安装还是最好用一用官方的tuorials里面的虚拟机脚本</p></blockquote><h5 id="0-准备"><a href="#0-准备" class="headerlink" title="0.准备"></a>0.准备</h5><ul><li><p>基础环境ubuntu 18.04 LTS</p></li><li><p>使用trojan终端代理，不然一些下载太慢了</p></li><li><p>ubuntu换源到阿里云</p></li><li><p>在~目录新建P4目录并且加入环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir P4</span><br><span class="line">cd P4</span><br><span class="line">echo&quot;P4_HOME&#x3D;$(pwd)&quot;&gt;&gt; ~&#x2F;.bashrc</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y cmake g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev libboost-graph-dev llvm pkg-config python python-scapy python-ipaddr python-ply tcpdump doxygen graphviz texlive</span><br><span class="line">sudo apt-get install g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev pkg-config python python-scapy python-ipaddr tcpdump cmake## 两个参考里面的可能有重复</span><br></pre></td></tr></table></figure><p>下面都是在P4文件夹进行的工作</p><blockquote><p>所有的make都巨慢，合理安排好时间</p></blockquote></li></ul><h5 id="1-安装依赖库protocol"><a href="#1-安装依赖库protocol" class="headerlink" title="1. 安装依赖库protocol"></a>1. 安装依赖库protocol</h5><ul><li><p>参考了这个依赖库github的C++环境的<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/README.md" target="_blank" rel="noopener">README</a>;</p></li><li><p>安装依赖并且git clone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf.git</span><br><span class="line">cd protobuf</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">.&#x2F;autogen.sh</span><br></pre></td></tr></table></figure><blockquote><p>其中 git submodule update –init –recursive 必做，这会下载好相应的googletest文件，忽略这一步会在make check报错</p></blockquote></li><li><p>然后build以及安装，下面步骤耗时较长:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig # refresh shared library cache.更新共享库</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-安装PI以及它的依赖"><a href="#2-安装PI以及它的依赖" class="headerlink" title="2. 安装PI以及它的依赖"></a>2. 安装PI以及它的依赖</h5><ul><li><p>参考PI的 github网站<a href="https://github.com/p4lang/PI" target="_blank" rel="noopener">https://github.com/p4lang/PI</a> 安装</p></li><li><p>首先安装gRPC V1.17.2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;grpc.git</span><br><span class="line">cd grpc&#x2F;</span><br><span class="line">git checkout tags&#x2F;v1.17.2</span><br><span class="line">git submodule update --init --recursive # 这步耗时较长，一定要代理</span><br><span class="line">make #也可以make -j4 表示用四个核make,j后面这个数量可以自己设定</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br><span class="line"># Install gRPC Python Package 这步安装挺慢的</span><br><span class="line">sudo pip install grpcio</span><br></pre></td></tr></table></figure></li><li><p>然后安装PI –with-proto,（To include <code>p4runtime.proto</code> in the build, please run <code>configure</code> with <code>--with-proto</code>.）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --with-proto</span><br><span class="line">make </span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-安装bmv2"><a href="#3-安装bmv2" class="headerlink" title="3. 安装bmv2"></a>3. 安装bmv2</h5><ul><li><p>建议先阅读原来的github库(<a href="https://github.com/p4lang/behavioral-model" target="_blank" rel="noopener">https://github.com/p4lang/behavioral-model</a>)</p></li><li><p>安装操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;P4</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;behavioral-model.git</span><br><span class="line">cd behavioral-model</span><br><span class="line">sudo .&#x2F;install_deps.sh #脚本安装依赖库</span><br></pre></td></tr></table></figure><blockquote><p>终端代理的好处在于这些脚本如果不是终端代理下载会异常慢以至于不得不手动转换到gitee安装</p><p>安装依赖库因为要编译其他第三方库也异常的慢</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  .&#x2F;autogen.sh</span><br><span class="line">  .&#x2F;configure --enable-debugger --with-pi</span><br><span class="line">  make</span><br><span class="line">  sudo make install</span><br><span class="line">  sudo sudo ldconfig</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-安装p4c"><a href="#4-安装p4c" class="headerlink" title="4. 安装p4c"></a>4. 安装p4c</h5><ul><li><p>下载库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;P4</span><br><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;p4c.git</span><br><span class="line">cd p4c</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make -j4 #4线程编译</span><br><span class="line">sudo make install</span><br><span class="line">cd ..&#x2F;..</span><br></pre></td></tr></table></figure><blockquote><p>这步如果make -j4后面make check 会花很多时间然后有可能报错</p></blockquote></li></ul><h5 id="5-下载p4-tutorials"><a href="#5-下载p4-tutorials" class="headerlink" title="5. 下载p4 tutorials"></a>5. 下载p4 tutorials</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;tutorials</span><br></pre></td></tr></table></figure><p>目前的目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P4</span><br><span class="line">|——behavioral-model # BMv2 软件交换机</span><br><span class="line">|——grpc  # 作为BMv2的依赖</span><br><span class="line">|——mininet # 网络仿真</span><br><span class="line">|——p4c #p4c编译器</span><br><span class="line">|——PI # PI P4 runtime库</span><br><span class="line">|——protobuf # 依赖</span><br><span class="line">|——tutorials #教程</span><br></pre></td></tr></table></figure><h5 id="6-解决实验出现的bug"><a href="#6-解决实验出现的bug" class="headerlink" title="6. 解决实验出现的bug"></a>6. 解决实验出现的bug</h5><p>在做实验的时候出现了陆陆续续的bug，还需要:</p><ol><li><p>No module named psutil</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;p&#x2F;psutil&#x2F;psutil-2.1.3.tar.gz </span><br><span class="line">    tar -zxvf psutil-2.1.3.tar.gz</span><br><span class="line">    cd psutil-2.1.3</span><br><span class="line">    python setup.py install</span><br></pre></td></tr></table></figure></li><li><p>No module named google.protobuf.internal</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install protobuf</span><br></pre></td></tr></table></figure></li><li><p>根据<a href="https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc" target="_blank" rel="noopener">https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc</a> 安装simple_switch_grpc</p></li><li><p>安装之后还是P4 switch s1 did not start correctly，根据issue<a href="https://github.com/p4lang/tutorials/issues/107" target="_blank" rel="noopener">https://github.com/p4lang/tutorials/issues/107</a> ，还需要：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p> 至此可以编译basic实验</p></li><li><p>安装之后进行P4runtime的时候出现报错 ：No module named rpc 尚未解决 因此建议还是使用官方的vagrant</p></li></ol><blockquote><p> PS: 最后发现其实最标准的安装操作是根据tutorials（<a href="https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢" target="_blank" rel="noopener">https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢</a></p></blockquote><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><ul><li><a href="https://p4.org/p4/getting-started-with-p4.html" target="_blank" rel="noopener">https://p4.org/p4/getting-started-with-p4.html</a></li><li><a href="https://www.jianshu.com/p/2878192ba3f7" target="_blank" rel="noopener">https://www.jianshu.com/p/2878192ba3f7</a></li><li><a href="https://www.sdnlab.com/22512.html" target="_blank" rel="noopener">https://www.sdnlab.com/22512.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;P4环境配置&quot;&gt;&lt;a href=&quot;#P4环境配置&quot; class=&quot;headerlink&quot; title=&quot;P4环境配置&quot;&gt;&lt;/a&gt;P4环境配置&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;因为之后使用的时候PI那块还是有问题，建议谨做参考，安装还是最好用一用官方的tuo
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型2</title>
    <link href="http://Tyler-ytr.github.io/2020/10/09/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B2/"/>
    <id>http://Tyler-ytr.github.io/2020/10/09/深度探索C-对象模型2/</id>
    <published>2020-10-09T03:13:38.000Z</published>
    <updated>2020-10-09T03:15:26.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度探索c-对象模型2"><a href="#深度探索c-对象模型2" class="headerlink" title="深度探索c++对象模型2"></a>深度探索c++对象模型2</h2><p>这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”和“程序效率”的冲击</p><h4 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h4><ul><li><p>带有默认构造函数的Member Class Object</p><p>总结而言就是，如果对象a中依次有对象b，c，d，如果程序员仅仅初始化了c（10），那么编译器会调用b，d的默认构造函数，顺序是b，c（10），d；另外，对于对象g，假设里面只有int c;string d;编译器的隐式默认构造函数是不会帮忙解决这两者的初始化问题的，也就是这个构造函数是trivial的</p></li><li><p>带有默认构造函数的Base Class</p><p>一个类的构造函数，需要调用一些基类的构造函数（必要之默认构造函数），你自定义的构造函数，编译器会帮你补上调用那些构造函数的部分；先调用基类的默认构造函数然后调用成员类的默认构造函数</p></li><li><p>带有一个Virtual Function 的 Class</p><p>以下两种情况，需要编译器合成出default constructor</p><ul><li>class声明（或者继承）一个virtual constructor</li><li>class派生自一个继承串链，其中有一个或者更多的virtual base classes<br>以上两种情况如果缺乏用户声明的constructor，那么编译器会详细记录合成一个default constructor 的必要信息。主要有以下两种扩张行动：</li><li>一个虚函数表会被编译器产生出来，存放着类的虚函数地址</li><li>一个vptr会被编译器合成出来，包含着虚函数表的地址</li></ul></li><li><p>带有一个Virtual Base Class 的 Class</p><p>C继承A、B，A虚继承X，B虚继承X；根据不同编译器，在构造这些对象的时候会有类似指针的东西指向虚继承的类里面的成员，这些都是编译器在类对象构造期间完成的；对于这样的类所定义的每一个构造函数，编译器会安插那些“允许每一个virtual base class的执行期存取操作”的代码。如果class没有声明任何的constructors,编译器必须为它合成一个default constructor。；</p></li><li><p>总结：</p><p>上面四种情况，会造成：编译器必须为没有声明构造函数的类合成一个默认构造函数“，这些合成物被称为隐式非平凡默认构造函数(implicit nontrivial default constructors)。除此之外都是隐式平凡构造函数，实际上不会被合成出来。</p><p>在合成出来的这些构造函数里面，只有base class subobjects和member class objects会被初始化，其他的都不会。</p></li></ul><h4 id="Copy-Constructor-的构造操作"><a href="#Copy-Constructor-的构造操作" class="headerlink" title="Copy Constructor 的构造操作"></a>Copy Constructor 的构造操作</h4><ul><li><p>下面三种情况，会以一个object的内容作为另一个class object的初值</p><ul><li><p>显式地以一个对象的内容作为另一个类对象的初值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">X xx&#x3D;x;</span><br></pre></td></tr></table></figure></li><li><p>当对象被当做参数交给某一个函数的时候</p></li><li><p>当函数传回一个类对象的时候</p></li></ul><p>如果类的设计者显式定义了一个拷贝构造函数，就会调用它</p></li><li><p>默认的拷贝构造函数</p><p>当类没有提供一个显示的拷贝构造函数时候使用，用递归的方式实行member initialization，比每一个内建的活着派生的data member的值从一个object拷贝到另一个上面。</p><p>下面讨论的是隐式的拷贝构造函数编译器是否会合成一个default copy constructor的问题。根据C++标准，决定一个copy constructor 是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。（只有nontrivial的实例才会被合成于程序里面。）</p></li><li><p>bitwise copy semantics（位逐次拷贝）</p><p>什么时候一个class不展现出所谓的位逐次拷贝呢？</p><ul><li>一个class中有一个成员变量的class里面声明了一个copy constructor</li><li>这个class继承自一个基类，然后这个基类里面有一个copy constructor</li><li>当class声明了一个或者多个virtual functions（考虑vptr的拷贝问题）</li><li>当class派生自一个继承串链，其中有一个或者多个virtual base classes（发生在一个class object 以其derived classes的某一个对象作为初值的时候，编译器需要安插一些代码来设定virtual base class pointer/offset 的初值）</li></ul></li></ul><h4 id="程序转化语义学（Program-Transformation-Semantics）"><a href="#程序转化语义学（Program-Transformation-Semantics）" class="headerlink" title="程序转化语义学（Program Transformation Semantics）"></a>程序转化语义学（Program Transformation Semantics）</h4><ul><li><p>主要从初始化，参数初始化，返回值初始化三个角度探讨了拷贝构造函数的应用及应用的伪码；</p></li><li><p>显示初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo_bar()&#123;</span><br><span class="line">X x1(x0);</span><br><span class="line">X x2&#x3D;x0;</span><br><span class="line">X x3&#x3D;X(x0);</span><br></pre></td></tr></table></figure></li></ul><p>转换成的可能的伪码：<br>    <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/Pwv3q8xTrLdlOkE.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><br>    其中：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1.X::X(x0);</span><br></pre></td></tr></table></figure></code></pre><p>//表现为对一下copy constructor 的调用：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X::x(const X&amp; xx);</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>参数初始化：<br>对于一下子调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(X x0);</span><br><span class="line">X xx;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">foo(xx)</span><br></pre></td></tr></table></figure><p>可能的伪码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">__temp0.X::X(xx);</span><br><span class="line">foo(__temp0);</span><br></pre></td></tr></table></figure></li><li><p>返回值的初始化：<br>对于以下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X bar()&#123;</span><br><span class="line">x xx;</span><br><span class="line">&#x2F;&#x2F;....</span><br><span class="line">return xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为如下伪码：<br><img src="/picture/9afNxvP82DGHIso.jpg" alt="Alt"></p></li><li><p>NRV优化：</p><p>NRV(name returned value)优化大致如下，我觉得是通过把返回的临时变量变成一个引用形参来实现的；</p><p><img src="/picture/972snfWXvIZRYDM.jpg" alt="Alt"></p><p>NRV优化需要一个copy constructor,（最好是内联的提高效率)</p></li><li><p>最后探讨了copy constructor 要还是不要的问题，我觉得它的含义是，从速度角度来看，如果存在NRV优化的可能性，以及传值的要求，那么实现拷贝构造函数可以帮助实现这一点；</p></li></ul><p>同时实现拷贝构造函数准备使用memcpy，memset的时候要注意是否有虚函数或者含有虚基类，防止错误的改变内部的vtpr;</p><p>比如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/grnbpALH8OlUXVj.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/kgviWzxyEhc314V.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><h4 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h4><ul><li><p>必须使用成员初始化表的四种情况：</p><ol><li>当初始化一个reference member</li><li>当初始化一个const member;</li><li>当调用一个base class 的constructor，而它拥有一组参数的时候;</li><li>当调用一个member class的constructor，而它拥有一组参数的时候；</li></ol></li><li><p>使用的注意点：</p><ol><li>顺序问题，成员初始化表的初始化顺序是声明的顺序，因此如下代码会有bug:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">public:</span><br><span class="line">X(int val):j(val),i(j)&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实际执行的时候是先i(j)然后j(val)的；</p><p>另外成员初始化表在显式代码的前面，因此</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">public:</span><br><span class="line">X(int val):j(val)&#123;</span><br><span class="line">i&#x3D;j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  是合法的；</p><ul><li>本书不太建议在成员初始化表里面调用一个member function进行初始化，主要因为不清楚具体的依赖关系的问题；当然如下图的伪代码，这是合法的：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/ShYNvKdqGUbQTPt.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><p>- </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深度探索c-对象模型2&quot;&gt;&lt;a href=&quot;#深度探索c-对象模型2&quot; class=&quot;headerlink&quot; title=&quot;深度探索c++对象模型2&quot;&gt;&lt;/a&gt;深度探索c++对象模型2&lt;/h2&gt;&lt;p&gt;这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
      <category term="深度探索C++对象模型" scheme="http://Tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_478_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/25/leetcode478-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/25/leetcode478-m/</id>
    <published>2020-09-25T09:13:45.000Z</published>
    <updated>2020-09-25T09:20:28.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="478-在圆内随机生成点"><a href="#478-在圆内随机生成点" class="headerlink" title="478. 在圆内随机生成点"></a><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/" target="_blank" rel="noopener">478. 在圆内随机生成点</a></h4><p>难度中等37</p><p>给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 <code>randPoint</code> 。</p><p>说明:</p><ol><li>输入值和输出值都将是<a href="https://baike.baidu.com/item/浮点数/6162520" target="_blank" rel="noopener">浮点数</a>。</li><li>圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。</li><li>圆周上的点也认为是在圆中。</li><li><code>randPoint</code> 返回一个包含随机点的x坐标和y坐标的大小为2的数组。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[1,0,0],[],[],[]]</span><br><span class="line">输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[10,5,-7.5],[],[],[]]</span><br><span class="line">输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span><br></pre></td></tr></table></figure><p><strong>输入语法说明：</strong></p><p>输入是两个列表：调用成员函数名和调用的参数。<code>Solution</code> 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。<code>randPoint</code> 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。</p><p>C++11新特性,随机数库,不香嘛？</p><p><a href="https://blog.csdn.net/qq_23225317/article/details/79787543" target="_blank" rel="noopener">https://blog.csdn.net/qq_23225317/article/details/79787543</a></p><p>基本语法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::random_device rd;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line"><span class="comment">//e.seed(time(0));</span></span><br><span class="line"><span class="comment">//随机整数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="comment">//随机实数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">u2</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;u2(e)&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line"><span class="comment">//正态分布</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test normal distribution:\n"</span>;</span><br><span class="line">e.seed(time(<span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="built_in">std</span>::normal_distribution&lt;&gt; <span class="title">n</span><span class="params">(<span class="number">4</span>, <span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">vals</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">250</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v = lround(n(e));</span><br><span class="line">    <span class="keyword">if</span>(v &lt; vals.<span class="built_in">size</span>()) vals[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vals.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">string</span>(vals[i], <span class="string">'*'</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test normal distribution done.\n"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//伯努利分布</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test bernoulli distribution:\n"</span>;</span><br><span class="line">e.seed(time(<span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="built_in">std</span>::bernoulli_distribution <span class="title">b</span><span class="params">(<span class="number">0.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">bers</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b(e)) bers[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">else</span> bers[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"True: "</span>&lt;&lt;bers[<span class="number">1</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"False: "</span>&lt;&lt;bers[<span class="number">0</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test bernoulli distribution done.\n"</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/solution/zai-yuan-nei-sui-ji-sheng-cheng-dian-by-617076674/" target="_blank" rel="noopener">某一个题解</a>:</p><p>相信大部分人都没有看懂，我就来通俗地解释一下吧。</p><p>确定圆内一点，需要有相对于圆心的距离r，以及相对于圆心的角度angle。</p><p>一开始的想法，我们在[0, radius]中等概率取r，在[0, 2π)中等概率取angle即可实现圆内的随机分布。</p><p>事实上，这是不对的。</p><p>在[0, 2π)中等概率取angle，相对于把一个圆分成了无数个扇形，点落在每个扇形上的概率均相等。</p><p>假设某个扇形的圆心角是theta，那么该扇形的面积是0.5 <em> theta </em> radius ^ 2，分布在该扇形区域上的概率是theta / 2π，只要每个扇形的圆心角相等，扇形面积就是相等的，点在扇形中也是等概率的。</p><p>在[0, radius]中等概率取r，相当于把一个圆分成了无数个环形，点落在每个环形上的概率均相等。</p><p>假设某个环形的内径是r1，外径是r2，那么该环形的面积是π * (r2 ^ 2 - r1 ^ 2)。可见每个环形的面积是不一样的，显然每个环形上的点密度是不一样的。这样做会造成靠近圆心的点分布比较密集，远离圆心的点分布比较稀疏。</p><p>那么，如何取r使得点落在圆内任意区域的概率均相等呢？这样做显然会使得落在每个环形上的概率均不同，且环形面积较大的概率高，环形面积较小的概率小。</p><p>根据环形面积的计算公式：π * (r2 ^ 2 - r1 ^ 2)，落在该环形面积上的概率应为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)。</p><p>在[0, radius]中如何分布概率密度函数f(x)，可以使得f(x)其在[r1, r2]上的积分值为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)呢？</p><p>取f(x) = 2x / (radius ^ 2)可以满足上述条件，即半径r在[0, radius]上的概率密度函数应为f(x) = 2x / (radius ^ 2)，故只需要在[0, radius ^ 2]范围内等概率取r ^ 2，再开根号即得r值。（求一下导数即可，x ^ 2的导数是2x）</p><p>时间复杂度是和空间复杂度均是O(1)。</p><p><img src="/picture/image-jizuobiao.png" alt="image-20200925171304597"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">double</span> x_center,y_center;</span><br><span class="line">    <span class="keyword">double</span> _2pi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//极坐标:x=rcos(\theta),y=rsin(\theta)</span></span><br><span class="line">    Solution(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;radius=radius;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x_center=x_center;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y_center=y_center;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_2pi=<span class="built_in">acos</span>(<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(radius&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            random_device rd;</span><br><span class="line">            <span class="function">default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line">            uniform_real_distribution&lt;<span class="keyword">double</span>&gt;u1(<span class="number">0</span>,radius*radius);</span><br><span class="line">            uniform_real_distribution&lt;<span class="keyword">double</span>&gt;u2(<span class="number">0</span>,_2pi);<span class="comment">//acos(-1)*2=2\pi</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> r=<span class="built_in">sqrt</span>(u1(e));</span><br><span class="line">            <span class="keyword">double</span> theta=u2(e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> x=x_center+r*<span class="built_in">cos</span>(theta);</span><br><span class="line">            <span class="keyword">double</span> y=y_center+r*<span class="built_in">sin</span>(theta);</span><br><span class="line">            result.push_back(x);</span><br><span class="line">            result.push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * vector&lt;double&gt; param_1 = obj-&gt;randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;478-在圆内随机生成点&quot;&gt;&lt;a href=&quot;#478-在圆内随机生成点&quot; class=&quot;headerlink&quot; title=&quot;478. 在圆内随机生成点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generat
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
      <category term="随机采样" scheme="http://Tyler-ytr.github.io/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_18_m 四数之和</title>
    <link href="http://Tyler-ytr.github.io/2020/09/25/leetcode18-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/25/leetcode18-m/</id>
    <published>2020-09-25T08:19:56.000Z</published>
    <updated>2020-09-25T08:20:46.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><p>难度中等572</p><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数109,251</p><p>提交次数284,303</p><p>双指针法;主要要注意的是几个边界以及怎么去重的方法;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针法;</span></span><br><span class="line">        <span class="comment">//比O(n^4)的暴力减少了一些重复的内容;</span></span><br><span class="line">        <span class="comment">//算法是:固定a,b=a+1,然后c,d双指针遍历;然后b++……;然后b结束外层循环a++;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>&lt;<span class="number">4</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=<span class="built_in">size</span><span class="number">-4</span>;++a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;nums[a]==nums[a<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=a+<span class="number">1</span>;b&lt;=<span class="built_in">size</span><span class="number">-3</span>;++b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b&gt;a+<span class="number">1</span>&amp;&amp;nums[b]==nums[b<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                c=b+<span class="number">1</span>;</span><br><span class="line">                d=<span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(c&lt;d)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[a]+nums[b]+nums[c]+nums[d]&lt;target)&#123;</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[a]+nums[b]+nums[c]+nums[d]&gt;target)&#123;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.push_back(&#123;nums[a],nums[b],nums[c],nums[d]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c+<span class="number">1</span>])&#123;</span><br><span class="line">                            c++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d<span class="number">-1</span>])&#123;</span><br><span class="line">                            d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;18-四数之和&quot;&gt;&lt;a href=&quot;#18-四数之和&quot; class=&quot;headerlink&quot; title=&quot;18. 四数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic_knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>HDU_4734 F(x)</title>
    <link href="http://Tyler-ytr.github.io/2020/09/20/HDU-4734/"/>
    <id>http://Tyler-ytr.github.io/2020/09/20/HDU-4734/</id>
    <published>2020-09-20T12:19:26.000Z</published>
    <updated>2020-09-20T12:20:13.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-x"><a href="#F-x" class="headerlink" title="F(x)"></a><a href="https://vjudge.net/problem/HDU-4734" target="_blank" rel="noopener">F(x)</a></h2><p>For a decimal number x with n digits (AnAn-1An-2 … A2A1), we define its weight as F(x) = An <em> 2n-1 + An-1 </em> 2n-2 + … + A2 <em> 2 + A1 </em> 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A).</p><p>Input</p><p>The first line has a number T (T &lt;= 10000) , indicating the number of test cases.<br>For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109)</p><p>Output</p><p>For every case,you should output “Case #t: “ at first, without quotes. The <em>t</em> is the case number starting from 1. Then output the answer.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 100</span><br><span class="line">1 10</span><br><span class="line">5 100</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 2</span><br><span class="line">Case #3: 13</span><br></pre></td></tr></table></figure><p>最开始的思路肯定是搜索</p><p>首先是对数位的搜索</p><p>然后开始思考另外有什么状态是需要往下面传的，那么就只有前面数的和了，因此是二维的，第一维度是数位，第二个维度是sum;</p><p>然后思考记忆化,最直观的就是第二维度就是sum,但是这样子的话每一次都需要根据all进行修改;比较特别的是dp里面的sum记录的是all-sum的值,这样做可以有效的利用memset优化;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">12</span>][<span class="number">5005</span>];<span class="comment">//dp[pos][sum]:对于位置pos的数位,这里的sum存储的是all-当前pos前缀和的差;</span></span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> all;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">//计算F(a)的值</span></span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> able[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">while</span>(a)&#123;</span><br><span class="line">able[pos++]=a%<span class="number">10</span>;</span><br><span class="line">a/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//int now=1;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">result+=(able[i]&lt;&lt;i);</span><br><span class="line"><span class="comment">//now*=2;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"result:"&lt;&lt;result&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pos:当前的数位,sum 当前的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(pos&lt;0)return 1;合法;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sum,<span class="keyword">bool</span> limit)</span></span>&#123;<span class="comment">//这里的sum表示的是到目前数位的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>)<span class="keyword">return</span> sum&lt;=all;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;all)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!limit&amp;&amp;dp[pos][all-sum]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][all-sum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up=limit?cur[pos]:<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;++i)&#123;</span><br><span class="line"></span><br><span class="line">ans+=dfs(pos<span class="number">-1</span>,sum+i*(<span class="number">1</span>&lt;&lt;pos),limit&amp;&amp;cur[pos]==i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit)dp[pos][all-sum]=ans;</span><br><span class="line"><span class="comment">//cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;sum&lt;&lt;" "&lt;&lt;limit&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">//memset(cur,0,sizeof(cur));</span></span><br><span class="line"> all=f(a);</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line">cur[pos++]=b%<span class="number">10</span>;</span><br><span class="line">b/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i=pos-1;i&gt;=0;--i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;cur[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">int</span> result=dfs(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="comment">//cin&gt;&gt;a&gt;&gt;b;</span></span><br><span class="line"><span class="keyword">int</span> result=solve(a,b);</span><br><span class="line"><span class="comment">//printf("Case #%d: %d",i+1,result);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,i+<span class="number">1</span>,result);</span><br><span class="line"><span class="comment">//cout&lt;&lt;"Case #"&lt;&lt;i+1&lt;&lt;": "&lt;&lt;result&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;F-x&quot;&gt;&lt;a href=&quot;#F-x&quot; class=&quot;headerlink&quot; title=&quot;F(x)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-4734&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>HDU_2089 不要62</title>
    <link href="http://Tyler-ytr.github.io/2020/09/19/HDU-2089/"/>
    <id>http://Tyler-ytr.github.io/2020/09/19/HDU-2089/</id>
    <published>2020-09-19T12:40:05.000Z</published>
    <updated>2020-09-19T12:41:16.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a><a href="https://vjudge.net/problem/HDU-2089" target="_blank" rel="noopener">不要62</a></h2><p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p><p>Input</p><p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p><p>Output</p><p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 100</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80</span><br></pre></td></tr></table></figure><p>经典的数位dp题目,数位dp我参考了<a href="https://blog.csdn.net/wust_zzwh/article/details/52100392" target="_blank" rel="noopener">数位dp总结 之 从入门到模板</a>进行学习;总的来说的思想是对每一个数位进行枚举,然后辅之以记忆化搜索,以下是我根据板子做出来的结果;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos:数位,pre:前一位什么数,state:前一位是不是6,如果是6那么就是1,否则是0;limit:防止超过最大数;为true的时候表示上一个到顶了;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> state,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//枚举合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!limit&amp;&amp;dp[pos][state]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][state];<span class="comment">//记忆化;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up=limit?a[pos]:<span class="number">9</span>;<span class="comment">//如果limit成功,那么前面的没有到顶,因此可以到9,否则只能到这个数位的值,比如231,前面枚举到3的时候,最后一位只有1可以;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//计数;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">4</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(pre==<span class="number">6</span>&amp;&amp;i==<span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">ans+=dfs(pos<span class="number">-1</span>,i,i==<span class="number">6</span>,i==up&amp;&amp;limit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit)dp[pos][state]=ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//分解数位</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">a[pos]=n%<span class="number">10</span>;</span><br><span class="line">n/=<span class="number">10</span>;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result=dfs(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r &amp;&amp;(l!=<span class="number">0</span>||r!=<span class="number">0</span>))&#123;</span><br><span class="line"><span class="keyword">int</span> result=solve(r)-solve(l<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不要62&quot;&gt;&lt;a href=&quot;#不要62&quot; class=&quot;headerlink&quot; title=&quot;不要62&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-2089&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型1</title>
    <link href="http://Tyler-ytr.github.io/2020/09/10/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B1/"/>
    <id>http://Tyler-ytr.github.io/2020/09/10/深度探索C-对象模型1/</id>
    <published>2020-09-10T02:08:08.000Z</published>
    <updated>2020-09-10T02:30:37.240Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深度探索c-对象模型1"><a href="#深度探索c-对象模型1" class="headerlink" title="深度探索c++对象模型1"></a>深度探索c++对象模型1</h4><ul><li>C++的主要额外负担：<ul><li>virtual function 机制</li><li>virtual base class 用以实现“多次出现在继承体系中的base class，又一个单一而被共享的实例”</li><li>多重继承下的额外负担</li></ul></li></ul><h5 id="1-1-C-对象模式"><a href="#1-1-C-对象模式" class="headerlink" title="1.1 C++对象模式"></a>1.1 C++对象模式</h5><ul><li><p>C++对象模型</p><ul><li>非静态成员变量存放在每一个class object里面，静态成员变量存放在个别的class object 之外；静态函数，非静态函数成员放在个别的class object之外，虚函数特殊对待：<ul><li>每一个class 产生出一堆指向virtual function 的指针，放在表格中，这个表格称之为虚函数表（virtual table）</li><li>每一个class object被安插一个指针，指向相关的virtual table。通常这个指针称为$vtpr$.$vtpr$的设定由每一个class的constructor，destructor和copy assignment运算符自动完成。每一个class所关联的$tyle_info$ object(用来支持runtime type identification)也经由虚函数表纸出来，通常放在表格的第一个slot里面。<br>例子如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/nGapT7QCPUdiFhS.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></li></ul></li></ul></li><li><p>C++继承</p><ul><li>使用所谓的base table 模型。每一个class object内涵一个bptr,被初始化，指向它的base class table，然后这个表就如同虚函数表一样指向继承的类的对象，如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/u4XH1PLQEbrGwfv.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></li></ul></li><li><p>什么时候一个人应该使用struct 取代class？当它让一个人感觉比较好的时候（狗头）<br>聚合（composition）而非继承才是把C++和C结合起来的好方法。<br>struct在C++中的一个合理用途，是当你要传递一个“复杂的class object的全部或者部分”到某一个C函数去的时候，struct声明可以将数据封装起来，并且保证拥有与C兼容的空间布局，然而这种保证只在聚合（composition）的情况下存在。如果是继承的话，可能会因为内存布局原因无法实现想要的结果。</p></li><li><p>C++以下列方法支持多态：</p><ul><li>经过一组隐式的转化操作，比如把一个派生类的指针转化为一个指向它的public base type的指针：<br>shape *ps=new circle ();</li><li>经由virtual function机制：<br>ps-&gt;rotate（）</li><li>经由$dynamic_cast$和typeid运算符：<br>$if(circle <em>pc=dynami_cast &lt; circle</em>&gt;(ps))$</li></ul></li><li><p>需要多少内存才能够表现一个class object：</p><ul><li>非静态成员变量的总和大小</li><li>加上任何由于alignment（对齐）的需求而填补（padding）上去的空间</li><li>加上为了支持virtual而内部产生的任何额外负担</li></ul></li><li><p>关于指针：<br>不同类型的指针从内存需求的观点来看没有什么不同，“指向不同类型之各指针‘间的差异，既不在其指针表示法的不同，也不再其内容的不同，而是在其所寻址出来的object类型不同。也就是说，“指针类型”会教导编译器如何解释某一个特定地址的内存内容及其大小。</p></li><li><p>最后一部分内容讨论了多态发生的条件，我认为总结下来就是引用和指针可能触发多态，通过虚函数来实现。然后将子对象赋值给父类对象一般会导致切割，来放置数据溢出。</p></li><li><p>具体问题：</p><ul><li><p>一个Bear指针和一个ZooAnimal指针有什么不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal *pz&#x3D;&amp;b;</span><br><span class="line">Bear *pb&#x3D;&amp;;</span><br></pre></td></tr></table></figure><p>它们每一个都指向Bear object 的第一个type，它们的区别是：pb所涵盖的地址包含整个 Bear object但是pz所涵盖的地址之包含Bear object中的ZooAnimal subobject.<br>内存布局如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/hozFU6gL9ubjs54.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;深度探索c-对象模型1&quot;&gt;&lt;a href=&quot;#深度探索c-对象模型1&quot; class=&quot;headerlink&quot; title=&quot;深度探索c++对象模型1&quot;&gt;&lt;/a&gt;深度探索c++对象模型1&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++的主要额外负担：&lt;ul&gt;
&lt;li&gt;virtua
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
      <category term="深度探索C++对象模型" scheme="http://Tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode22-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode22-m/</id>
    <published>2020-09-07T01:28:58.000Z</published>
    <updated>2020-09-07T01:33:35.089Z</updated>
    
    <content type="html"><![CDATA[<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h4><p>难度中等1252收藏分享切换为英文关注反馈</p><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><p>通过次数166,462</p><p>提交次数218,996</p><p>一道经典的回溯算法的题目,lcnit表示左边括号的数目,rcnt表示右括号的数目;结束的条件是temp.size()==2*n,也就是满足长度;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="built_in">string</span> temp,<span class="keyword">int</span> lcnt,<span class="keyword">int</span> rcnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==maxn*<span class="number">2</span>)&#123;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lcnt&lt;maxn)&#123;</span><br><span class="line">            temp.push_back(<span class="string">'('</span>);</span><br><span class="line">            back_track(temp,lcnt+<span class="number">1</span>,rcnt);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rcnt&lt;lcnt)&#123;</span><br><span class="line">            temp.push_back(<span class="string">')'</span>);</span><br><span class="line">            back_track(temp,lcnt,rcnt+<span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        maxn=n;</span><br><span class="line">        back_track(temp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;22-括号生成&quot;&gt;&lt;a href=&quot;#22-括号生成&quot; class=&quot;headerlink&quot; title=&quot;22. 括号生成&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="栈" scheme="http://Tyler-ytr.github.io/tags/%E6%A0%88/"/>
    
      <category term="数据结构" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode134_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode134-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode134-m/</id>
    <published>2020-09-07T01:26:14.000Z</published>
    <updated>2020-09-07T01:28:25.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h4><p>难度中等243</p><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong> </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><hr><p>参考了一个数形结合的<a href="https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/" target="_blank" rel="noopener">题解</a></p><p>注意最小值的初始化问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> success=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tempsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tempsum=tempsum+gas[i]-cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tempsum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            success=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在起码可以环绕一圈，开始找起始点</span></span><br><span class="line">       <span class="comment">//我觉得如果可以跑的话就是一个逃税过程，如何逃掉更多的税呢？因为起始点起始相当于少交一次前面的税</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> gassum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> costsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_result=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           gassum+=gas[i];</span><br><span class="line">           costsum+=cost[i];</span><br><span class="line">            temp=gassum-costsum;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;min_result)&#123;</span><br><span class="line">                min_result=temp;</span><br><span class="line">                min_ans=i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (min_ans+<span class="number">1</span>)%n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;134-加油站&quot;&gt;&lt;a href=&quot;#134-加油站&quot; class=&quot;headerlink&quot; title=&quot;134. 加油站&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/gas-station/&quot; target=&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="贪心" scheme="http://Tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>poj2386</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/poj2386/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/poj2386/</id>
    <published>2020-09-07T01:24:14.000Z</published>
    <updated>2020-09-07T01:25:41.937Z</updated>
    
    <content type="html"><![CDATA[<p>Lake Counting</p><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 65536K</th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 59523</td><td></td><td><strong>Accepted:</strong> 28958</td></tr></tbody></table><p>Description</p><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.</p><p>Given a diagram of Farmer John’s field, determine how many ponds he has.</p><p>Input</p><p>* Line 1: Two space-separated integers: N and M</p><p>* Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.</p><p>Output</p><p>* Line 1: The number of ponds in Farmer John’s field.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>Hint</p><p>OUTPUT DETAILS:</p><p>There are three ponds: one in the upper left, one in the lower left,and one along the right side.</p><p>Source</p><p><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2004+November" target="_blank" rel="noopener">USACO 2004 November</a></p><p>题目大意: 计算出相连的’W’有多少块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> mapa[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    mapa[x][y]=<span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">int</span> tempx;</span><br><span class="line">    <span class="keyword">int</span> tempy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">            tempx=x+i;</span><br><span class="line">            tempy=y+j;</span><br><span class="line">            <span class="keyword">if</span>(tempx&gt;=<span class="number">0</span>&amp;&amp;tempx&lt;N&amp;&amp;tempy&gt;=<span class="number">0</span>&amp;&amp;tempy&lt;M&amp;&amp;mapa[tempx][tempy]==<span class="string">'W'</span>)&#123;</span><br><span class="line">                dfs(tempx,tempy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">  <span class="comment">// vector&lt;vector&lt;char&gt; &gt; map(N,(vector&lt;char&gt; (M)));</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">           <span class="keyword">char</span> temp;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">           mapa[i][j]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"here"&lt;&lt;endl;</span></span><br><span class="line">   <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(mapa[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">               dfs(i,j);</span><br><span class="line"><span class="comment">//               cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//               for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line"><span class="comment">//                   for(int j=0;j&lt;M;j++)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                       cout&lt;&lt;mapa[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//                   &#125;</span></span><br><span class="line"><span class="comment">//                   cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//               &#125;</span></span><br><span class="line">               cnt+=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lake Counting&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000MS&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Memory Limit:&lt;/strong&gt; 65536K&lt;/
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>poj1321 棋盘问题</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/poj1321/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/poj1321/</id>
    <published>2020-09-07T01:22:23.000Z</published>
    <updated>2020-09-07T01:23:35.759Z</updated>
    
    <content type="html"><![CDATA[<h4 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h4><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 10000K</th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 96005</td><td></td><td><strong>Accepted:</strong> 43758</td></tr></tbody></table><p>Description</p><p>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><p>Input</p><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p><p>Output</p><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Source</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;<span class="built_in">map</span>;</span><br><span class="line"><span class="comment">//vector&lt;bool&gt;line;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">clear</span>();</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> K;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;<span class="built_in">line</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == K) &#123;<span class="comment">//注意出递归的条件是cnt==K也就是找到这么多个</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=N)&#123;<span class="comment">//这里是为了防止遍历的行数超过边界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">line</span>[i]&amp;&amp;<span class="built_in">map</span>[j][i]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">true</span>;</span><br><span class="line">                cnt+=<span class="number">1</span>;</span><br><span class="line">                backtrace(j+<span class="number">1</span>,<span class="built_in">line</span>);</span><br><span class="line">                cnt-=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrace(j+<span class="number">1</span>,<span class="built_in">line</span>);<span class="comment">//遍历下一行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//vector&lt;string&gt;map;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;<span class="built_in">line</span>(<span class="number">9</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;<span class="built_in">cin</span>&gt;&gt;t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;t==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            N=n;</span><br><span class="line">            K=t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> a;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">                <span class="built_in">map</span>.push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtrace(<span class="number">0</span>,<span class="built_in">line</span>);</span><br><span class="line">           <span class="comment">// N=n;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">//                for(int j=0;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">//                cout&lt;&lt;map[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//cout结果;</span></span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:leetcode刷题表示所有的OJ题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;棋盘问题&quot;&gt;&lt;a href=&quot;#棋盘问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘问题&quot;&gt;&lt;/a&gt;棋盘问题&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000MS&lt;/th&gt;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode491_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode491-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode491-m/</id>
    <published>2020-09-07T01:18:16.000Z</published>
    <updated>2020-09-07T01:19:09.615Z</updated>
    
    <content type="html"><![CDATA[<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/" target="_blank" rel="noopener">491. 递增子序列</a></h4><p>难度中等88</p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p>通过次数7,099</p><p>提交次数14,688</p><p>使用回溯算法进行dfs;主要要和那道全排列进行比较和区分;</p><p>使用set可以减少重复(我感觉剪枝更快但是不好写)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            temp.push_back(nums[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+pos&gt;nums.<span class="built_in">size</span>()<span class="number">-1</span>||nums[i+pos]&lt;temp.back())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[pos+i]);</span><br><span class="line">                result.insert(temp);</span><br><span class="line">                dfs(nums,temp,pos+i);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//感觉是回溯算法做的;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">            dfs(nums,temp,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it=result.<span class="built_in">begin</span>();it!=result.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            ans.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;491-递增子序列&quot;&gt;&lt;a href=&quot;#491-递增子序列&quot; class=&quot;headerlink&quot; title=&quot;491. 递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-subse
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode386_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode386-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode386-m/</id>
    <published>2020-09-07T01:14:51.000Z</published>
    <updated>2020-09-07T01:15:17.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://leetcode-cn.com/problems/lexicographical-numbers/" target="_blank" rel="noopener">386. 字典序排数</a></h4><p>难度中等74</p><p>给定一个整数 <em>n</em>, 返回从 <em>1</em> 到 <em>n</em> 的字典顺序。</p><p>例如，</p><p>给定 <em>n</em> =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p><p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 <em>n</em> 小于等于 5,000,000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur*<span class="number">10</span>+i&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dfs(cur*<span class="number">10</span>+i,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;++i)</span><br><span class="line">        dfs(i,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;386-字典序排数&quot;&gt;&lt;a href=&quot;#386-字典序排数&quot; class=&quot;headerlink&quot; title=&quot;386. 字典序排数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lexicographical-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode133_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode133-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode133-m/</id>
    <published>2020-09-07T01:12:57.000Z</published>
    <updated>2020-09-10T02:39:57.631Z</updated>
    
    <content type="html"><![CDATA[<h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><p>难度中等155</p><p>给你无向 <strong><a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/133_clone_graph_question-1599441241258.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/graph-1599441241260.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/graph-1-1599441241260.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<a href="https://baike.baidu.com/item/简单图/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><p>使用dfs+字典/哈希表 即可;重点需要学会的是C++map/unorder_map的使用count查询的操作,count返回0表示没有,1表示有;</p><p>递归+数组版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node*used[<span class="number">101</span>];</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素;</span></span><br><span class="line">        <span class="comment">//也可以不用Map 用一个Node*数组来表示;</span></span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(used[node-&gt;val])<span class="keyword">return</span> used[node-&gt;val];</span><br><span class="line">        Node*p=<span class="keyword">new</span> Node(node-&gt;val);<span class="comment">//创建拷贝结点;</span></span><br><span class="line">        used[node-&gt;val]=p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt;tp=node-&gt;neighbors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            p-&gt;neighbors.push_back(cloneGraph(tp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归+unorder_map版本;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;used;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素;</span></span><br><span class="line">        <span class="comment">//也可以不用Map 用一个Node*数组来表示;</span></span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(used.count(node))<span class="keyword">return</span> used[node];</span><br><span class="line">        Node*p=<span class="keyword">new</span> Node(node-&gt;val);<span class="comment">//创建拷贝结点;</span></span><br><span class="line">        used[node]=p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt;tp=node-&gt;neighbors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            p-&gt;neighbors.push_back(cloneGraph(tp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>map版本用map替换unorder_map即可;</p><p>其中速度:map慢于unorder_map慢于数组;</p><p>原因:(摘自一个<a href="https://leetcode-cn.com/problems/clone-graph/solution/dfsjie-ti-by-xiao-luo-ai-xue-xi/" target="_blank" rel="noopener">题解</a>):</p><p>map：</p><p>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高<br>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p><p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p><p>unordered_map：</p><p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><p>深度优先遍历的递归写法<br>1.发现新节点<br>1.如果没有操作该节点，就操作该节点，并将该节点的visit置1<br>1.1接着对该节点的neibor挨个遍历dfs函数<br>2.如果有操作就返回该节点或者pass</p><p>非递归版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;unordered_map&lt;Node*, Node*&gt;used;</span><br><span class="line">    Node* cloneGraph(Node* node) &#123;</span><br><span class="line">        if(!node)return node;</span><br><span class="line">        stack&lt;Node*&gt;S;</span><br><span class="line">        S.push(node);&#x2F;&#x2F;等同于 stack &lt;Node*&gt;S(&#123;node&#125;);</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt;used;</span><br><span class="line">        used[node] &#x3D; new Node(node-&gt;val);</span><br><span class="line">        Node* tmp;</span><br><span class="line">        while(!S.empty())&#123;</span><br><span class="line">            tmp &#x3D; S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            Node* r &#x3D; used[tmp];</span><br><span class="line">            vector&lt;Node*&gt;n&#x3D;tmp-&gt;neighbors;</span><br><span class="line">            for(int i&#x3D;0;i&lt;n.size();++i)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果这个节点之前已经遍历到，就把他的复制加到链表中</span><br><span class="line">            &#x2F;&#x2F;没有遍历过就复刻该节点，加入map，加入neighbor</span><br><span class="line">                Node*cur&#x3D;n[i];</span><br><span class="line">                if(!used.count(cur))&#123;</span><br><span class="line">                    Node*t&#x3D;new Node(cur-&gt;val);</span><br><span class="line">                    used[cur]&#x3D;t;</span><br><span class="line">                    S.push(cur);</span><br><span class="line">                &#125;</span><br><span class="line">                r-&gt;neighbors.push_back(used[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return used[node];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;133-克隆图&quot;&gt;&lt;a href=&quot;#133-克隆图&quot; class=&quot;headerlink&quot; title=&quot;133. 克隆图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/clone-graph/&quot; target=&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode131_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode131-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode131-m/</id>
    <published>2020-09-07T01:10:18.000Z</published>
    <updated>2020-09-07T01:10:48.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><p>难度中等471</p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><p>dfs 递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> higher)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> temp=root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;=lower||temp&gt;=higher)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,LONG_MIN,LONG_MAX);</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;98. 验证二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-bina
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode98_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode98-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode98-m/</id>
    <published>2020-09-07T01:05:19.000Z</published>
    <updated>2020-09-07T01:05:49.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><p>难度中等471</p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><p>dfs 递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> higher)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> temp=root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;=lower||temp&gt;=higher)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,LONG_MIN,LONG_MAX);</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;98. 验证二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-bina
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode51_h</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode51-h/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode51-h/</id>
    <published>2020-09-07T01:00:57.000Z</published>
    <updated>2020-09-10T02:41:34.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></h4><p>难度困难377</p><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/8-queens-1599440478541.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//行列; 本质上还是回溯法</span></span><br><span class="line">    <span class="comment">//逐个行来扫描,这一行确定了之后就删除一些状态</span></span><br><span class="line">   <span class="comment">//三个需要验证的合法性:</span></span><br><span class="line">   <span class="comment">//列,两个对角线:</span></span><br><span class="line">   <span class="comment">//line,incline1,incline2</span></span><br><span class="line">   <span class="comment">//按行遍历,如果这列ok 就line[i]=1</span></span><br><span class="line">   <span class="comment">//0x0x</span></span><br><span class="line">   <span class="comment">//x1xx (1,1)(0,0)(2,2)(3,3) 发现abs(j-i)是相同的;因此j-i+N 相同(这样确保大于0))</span></span><br><span class="line">   <span class="comment">//0x0x (1,1)(0,2)(3,0) 发现对角线上面i+j是相同的</span></span><br><span class="line">   <span class="comment">//xxx0</span></span><br><span class="line">   <span class="comment">//所以每次更新的时候都是line[i]=true,incline[i+j]=true,incline[j-i+N]=true;</span></span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;result;<span class="comment">//用来保存;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp;track,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;<span class="built_in">line</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;incline1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;incline2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==N)&#123;</span><br><span class="line">            <span class="comment">//递归结束</span></span><br><span class="line">            <span class="built_in">string</span> a=<span class="string">""</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;N;p++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(track[p][k])&#123;</span><br><span class="line">                        a.push_back(<span class="string">'Q'</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        a.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                b.push_back(a);</span><br><span class="line">                a.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">line</span>[i]&amp;&amp;!incline1[i+j]&amp;&amp;!incline2[j-i+N])&#123;</span><br><span class="line">                    <span class="built_in">line</span>[i]=<span class="literal">true</span>;</span><br><span class="line">                    incline1[i+j]=<span class="literal">true</span>;</span><br><span class="line">                    incline2[j-i+N]=<span class="literal">true</span>;</span><br><span class="line">                    track[j][i]=<span class="literal">true</span>;</span><br><span class="line">                    place(j+<span class="number">1</span>,track,<span class="built_in">line</span>,incline1,incline2);</span><br><span class="line">                    <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">                    incline1[i+j]=<span class="literal">false</span>;</span><br><span class="line">                    incline2[j-i+N]=<span class="literal">false</span>;</span><br><span class="line">                    track[j][i]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;incline1(<span class="number">2</span>*n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;incline2(<span class="number">2</span>*n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;<span class="built_in">line</span>(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">track</span><span class="params">(n,<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        N=n;</span><br><span class="line">        place(<span class="number">0</span>,track,<span class="built_in">line</span>,incline1,incline2);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;51-N皇后&quot;&gt;&lt;a href=&quot;#51-N皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N皇后&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="回溯法" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode46_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode46-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode46-m/</id>
    <published>2020-09-07T00:59:34.000Z</published>
    <updated>2020-09-07T01:00:11.014Z</updated>
    
    <content type="html"><![CDATA[<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46 Permutations"></a>46 Permutations</h4><p>Medium</p><p>333697Add to ListShare</p><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;<span class="comment">//表示这个解遇到过了;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;track,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//index记录vis的编号;</span></span><br><span class="line">        <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.push_back(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没有访问过;</span></span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                track.push_back(nums[i]);</span><br><span class="line">                backtrace(nums,track,index+<span class="number">1</span>);</span><br><span class="line">                track.pop_back();</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        backtrace(nums,track,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;46-Permutations&quot;&gt;&lt;a href=&quot;#46-Permutations&quot; class=&quot;headerlink&quot; title=&quot;46 Permutations&quot;&gt;&lt;/a&gt;46 Permutations&lt;/h4&gt;&lt;p&gt;Medium&lt;/p&gt;
&lt;p&gt;3336
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="回溯法" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124_h</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode124-h/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode124-h/</id>
    <published>2020-09-07T00:58:16.000Z</published>
    <updated>2020-09-07T00:59:07.992Z</updated>
    
    <content type="html"><![CDATA[<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h4><p>难度困难510</p><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//用一个maxm来缓存对于某一个根节点的状态;</span></span><br><span class="line"> <span class="comment">//dfs过程中返回给上层应该是最大的一边;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxm=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="built_in">max</span>(<span class="number">0</span>,dfs(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right=<span class="built_in">max</span>(<span class="number">0</span>,dfs(root-&gt;right));</span><br><span class="line">        maxm=<span class="built_in">max</span>(maxm,root-&gt;val+left+right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left+root-&gt;val,right+root-&gt;val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs解决该题,使用maxm缓存最大的结点处于的状态;dfs到某一个结点的时候,该节点返回给上一层:该节点值,该结点值+左值,该节点的值+右值的最大值;</p><p>对于空节点,返回0,表示对原来的结点没有贡献;</p><p>对于负值,和0比较取max的步骤表示如果有一边是负的那么就不做贡献,和空节点没有区别;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;124-二叉树中的最大路径和&quot;&gt;&lt;a href=&quot;#124-二叉树中的最大路径和&quot; class=&quot;headerlink&quot; title=&quot;124. 二叉树中的最大路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/b
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode690_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode690-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode690-s/</id>
    <published>2020-09-07T00:56:33.000Z</published>
    <updated>2020-09-07T00:57:39.829Z</updated>
    
    <content type="html"><![CDATA[<h4 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">690. 员工的重要性</a></h4><p>难度简单88</p><p>给定一个保存员工信息的数据结构，它包含了员工<strong>唯一的id</strong>，<strong>重要度</strong> 和 <strong>直系下属的id</strong>。</p><p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于<strong>并不是直系</strong>下属，因此没有体现在员工1的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出: 11</span><br><span class="line">解释:</span><br><span class="line">员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 &#x3D; 11。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>一个员工最多有一个<strong>直系</strong>领导，但是可以有多个<strong>直系</strong>下属</li><li>员工数量不超过2000。</li></ol><p>通过次数13,683</p><p>提交次数23,456</p><p>重要的是先进行的hash操作,运用了unorder_map结构体,极大的简化了dfs的操作;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> importance;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Employee*&gt;mp;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        result+=mp[id]-&gt;importance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp[id]-&gt;subordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            dfs(mp[id]-&gt;subordinates[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希:</span></span><br><span class="line">        <span class="keyword">for</span>(Employee* tmp:employees)&#123;</span><br><span class="line">            mp[tmp-&gt;id]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行dfs;</span></span><br><span class="line">        dfs(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BFS版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    int importance;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//     unordered_map&lt;int, Employee*&gt; mp;</span></span><br><span class="line"><span class="comment">//     int ans = 0;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span></span><br><span class="line"><span class="comment">//         for (auto&amp; e : employees) </span></span><br><span class="line"><span class="comment">//             mp[e-&gt;id] = e;</span></span><br><span class="line"><span class="comment">//         dfs(id);</span></span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     void dfs(int id) &#123;</span></span><br><span class="line"><span class="comment">//         ans += mp[id]-&gt;importance;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; mp[id]-&gt;subordinates.size(); ++i) </span></span><br><span class="line"><span class="comment">//             dfs(mp[id]-&gt;subordinates[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Employee*&gt;mp;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希:</span></span><br><span class="line">        <span class="keyword">for</span>(Employee* tmp:employees)&#123;</span><br><span class="line">            mp[tmp-&gt;id]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行bfs</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(id);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            result+=mp[temp]-&gt;importance;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp[temp]-&gt;subordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">                q.push(mp[temp]-&gt;subordinates[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;690-员工的重要性&quot;&gt;&lt;a href=&quot;#690-员工的重要性&quot; class=&quot;headerlink&quot; title=&quot;690. 员工的重要性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/employee-impo
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode199-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode199-m/</id>
    <published>2020-09-07T00:53:29.000Z</published>
    <updated>2020-09-07T00:54:31.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h4><p>难度中等186</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><p>通过次数29,576</p><p>提交次数46,105</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="comment">//    1</span></span><br><span class="line">        <span class="comment">//2        3</span></span><br><span class="line">        <span class="comment">//   5         4</span></span><br><span class="line">        <span class="comment">//广度优先搜索，当q里面只有最右边一个元素的时候把这个元素加入到输出的队列里面;</span></span><br><span class="line">       <span class="comment">// if(root==nullptr)&#123;return NULL&#125;;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> result;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;<span class="comment">//先进先出</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">           <span class="comment">// TreeNode*temp=q.front();</span></span><br><span class="line">        <span class="comment">//关键点: 用len记录q的size;通过这个来获得最右侧的点;</span></span><br><span class="line">            <span class="keyword">int</span> len=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode*temp=q.front();</span><br><span class="line">                <span class="keyword">if</span>(i==len<span class="number">-1</span>)&#123;</span><br><span class="line">                    result.push_back(temp-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;199-二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199. 二叉树的右视图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tre
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode101_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode101-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode101-s/</id>
    <published>2020-09-07T00:51:12.000Z</published>
    <updated>2020-09-07T00:53:08.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h4><p>难度简单 </p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><p>BFS的板子题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">                root = q.front(); q.pop();</span><br><span class="line">                v[i] = root ? root-&gt;val : INT_MIN;</span><br><span class="line">                <span class="keyword">if</span>(root) &#123; q.push(root-&gt;left); q.push(root-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否回文</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="built_in">size</span>/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i] != v[<span class="built_in">size</span><span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;101-对称二叉树&quot;&gt;&lt;a href=&quot;#101-对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;101. 对称二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/symmetric-tree/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode200_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode200-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode200-m/</id>
    <published>2020-09-07T00:49:14.000Z</published>
    <updated>2020-09-07T00:50:53.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>难度中等515</p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><p>解法1:BFS 遍历每一个点,遇到1就bfs并且把bfs到的1变成0;记录bfs的次数即可：</p><p>测试数据竟然有空集，这样会导致int maxn=map[0].size();//列数; 出现runtime error神必报错我tm……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//感觉可以bfs</span></span><br><span class="line">        <span class="comment">//遍历map的每一个点,如果map[i][j]是1,进行bfs,遇到1的变成0;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;<span class="built_in">map</span>(grid);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//m*n;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxm=<span class="built_in">map</span>.<span class="built_in">size</span>();<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">if</span>(maxm==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//对付空集的神必特判</span></span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="built_in">map</span>[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列数;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxm;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    cnt+=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">                    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp;</span><br><span class="line">                    temp.first=i;</span><br><span class="line">                    temp.second=j;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                    <span class="built_in">map</span>[i][j]=<span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;cur=q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        <span class="keyword">int</span> tempi=cur.first;</span><br><span class="line">                        <span class="keyword">int</span> tempj=cur.second;</span><br><span class="line">                        <span class="keyword">if</span>(tempi<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">map</span>[tempi<span class="number">-1</span>][tempj]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi<span class="number">-1</span>;</span><br><span class="line">                            temp2.second=tempj;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi<span class="number">-1</span>][tempj]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempi+<span class="number">1</span>&lt;maxm&amp;&amp;<span class="built_in">map</span>[tempi+<span class="number">1</span>][tempj]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi+<span class="number">1</span>;</span><br><span class="line">                            temp2.second=tempj;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi+<span class="number">1</span>][tempj]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempj<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">map</span>[tempi][tempj<span class="number">-1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi;</span><br><span class="line">                            temp2.second=tempj<span class="number">-1</span>;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi][tempj<span class="number">-1</span>]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempj+<span class="number">1</span>&lt;maxn&amp;&amp;<span class="built_in">map</span>[tempi][tempj+<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi;</span><br><span class="line">                            temp2.second=tempj+<span class="number">1</span>;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi][tempj+<span class="number">1</span>]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;200-岛屿数量&quot;&gt;&lt;a href=&quot;#200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;200. 岛屿数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode705_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode705-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode705-s/</id>
    <published>2020-09-06T08:26:54.000Z</published>
    <updated>2020-09-06T08:27:25.744Z</updated>
    
    <content type="html"><![CDATA[<h4 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705. 设计哈希集合"></a><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></h4><p>难度简单40</p><p>不使用任何内建的哈希表库设计一个哈希集合</p><p>具体地说，你的设计应该包含以下的功能</p><ul><li><code>add(value)</code>：向哈希集合中插入一个值。</li><li><code>contains(value)</code> ：返回哈希集合中是否存在这个值。</li><li><code>remove(value)</code>：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);         </span><br><span class="line">hashSet.add(2);         </span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; 返回 true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; 返回 false (未找到)</span><br><span class="line">hashSet.add(2);          </span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; 返回 true</span><br><span class="line">hashSet.remove(2);          </span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; 返回  false (已经被删除)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>所有的值都在 <code>[0, 1000000]</code>的范围内。</li><li>操作的总数目在<code>[1, 10000]</code>范围内。</li><li>不要使用内建的哈希集合库。</li></ul><p>通过次数11,949</p><p>提交次数21,319</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node* next;</span><br><span class="line">        Node(<span class="keyword">int</span> val):val(val),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; arr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">101</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet() &#123;</span><br><span class="line">        arr=<span class="built_in">vector</span>&lt;Node*&gt;(len,<span class="keyword">new</span> Node(<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">        Node*temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)<span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span>(!(temp-&gt;next))&#123;</span><br><span class="line">                    Node*node=<span class="keyword">new</span> Node(key);</span><br><span class="line">                    temp-&gt;next=node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 temp = temp -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp-&gt;val=key;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         int haval = key % len;</span></span><br><span class="line"><span class="comment">//         Node* temp = arr[haval];</span></span><br><span class="line"><span class="comment">//         if(temp -&gt; val != -1)&#123;</span></span><br><span class="line"><span class="comment">//             while(temp)&#123;</span></span><br><span class="line"><span class="comment">//                 if(temp -&gt; val == key)&#123;</span></span><br><span class="line"><span class="comment">//                     temp -&gt; val = -1;</span></span><br><span class="line"><span class="comment">//                     return;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 temp = temp -&gt; next;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">        Node*temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)&#123;</span><br><span class="line">                    temp-&gt;val=<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">       Node* temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;705-设计哈希集合&quot;&gt;&lt;a href=&quot;#705-设计哈希集合&quot; class=&quot;headerlink&quot; title=&quot;705. 设计哈希集合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/design-hashse
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://Tyler-ytr.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode67_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode67-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode67-s/</id>
    <published>2020-09-06T08:25:13.000Z</published>
    <updated>2020-09-06T08:25:28.838Z</updated>
    
    <content type="html"><![CDATA[<h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></h4><p>难度简单398</p><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li></ul><p>模拟题,用j来从后往前遍历;</p><p>一开始搞错的原因是因为忘记在result.push_back之后加上temp=0了,佛佛佛</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m=b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="built_in">max</span>(n,m);</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;<span class="comment">//处理进位</span></span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n-j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp+=(<span class="keyword">int</span>)(a[n-j<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m-j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp+=(<span class="keyword">int</span>)(b[m-j<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        temp+=out;</span><br><span class="line">        out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            temp-=<span class="number">2</span>;</span><br><span class="line">            out=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        temp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(out==<span class="number">1</span>)&#123;</span><br><span class="line">        result.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=result.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            res=res+<span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;res=res+<span class="string">'0'</span>;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;67-二进制求和&quot;&gt;&lt;a href=&quot;#67-二进制求和&quot; class=&quot;headerlink&quot; title=&quot;67. 二进制求和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-binary/&quot; target
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode14_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode14-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode14-s/</id>
    <published>2020-09-06T07:58:44.000Z</published>
    <updated>2020-09-06T08:24:53.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h4><p>难度简单1079</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p>模拟题实锤,纵向比较,重点是要掌握string的substr方法;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//纵向扫描;</span></span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length=strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i]!=c||i==strs[j].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,cnt); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;14-最长公共前缀&quot;&gt;&lt;a href=&quot;#14-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;14. 最长公共前缀&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-p
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode892_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode892-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode892-s/</id>
    <published>2020-09-06T07:56:59.000Z</published>
    <updated>2020-09-06T07:58:20.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a><a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">892. 三维形体的表面积</a></h4><p>难度简单90</p><p>在 <code>N * N</code> 的网格上，我们放置一些 <code>1 * 1 * 1</code> 的立方体。</p><p>每个值 <code>v = grid[i][j]</code> 表示 <code>v</code> 个正方体叠放在对应单元格 <code>(i, j)</code> 上。</p><p>请你返回最终形体的表面积。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= N &lt;= 50</code></li><li><code>0 &lt;= grid[i][j] &lt;= 50</code></li></ul><hr><p>一道模拟题，题目意思很难懂</p><p>第一个示例的意思是 0,0这个位置有一个高度为2的立方体；</p><p>第二个示例的意思是 0,0 高度为1;0,1 高度为2…………</p><p>主要解法是找到一个求解表面积的公式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    result+=<span class="number">2</span>+<span class="number">4</span>*grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i<span class="number">-1</span>][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result-=<span class="built_in">min</span>(grid[i<span class="number">-1</span>][j],grid[i][j])*<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(grid[i][j<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result-=<span class="built_in">min</span>(grid[i][j<span class="number">-1</span>],grid[i][j])*<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;892-三维形体的表面积&quot;&gt;&lt;a href=&quot;#892-三维形体的表面积&quot; class=&quot;headerlink&quot; title=&quot;892. 三维形体的表面积&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/surface
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>DNS刷新</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/DNS%E5%88%B7%E6%96%B0/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/DNS刷新/</id>
    <published>2020-09-04T06:56:33.000Z</published>
    <updated>2020-09-10T02:36:02.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS刷新"><a href="#DNS刷新" class="headerlink" title="DNS刷新"></a>DNS刷新</h2><p>垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中心的工程师打完电话之后发现是自己电脑DNS的问题，因此bing搜索，发现了如下的方法进行DNS的刷新:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netsh int ip reset </span><br><span class="line">netsh winsock reset</span><br><span class="line">ipconfig&#x2F;flushdns </span><br><span class="line">重启</span><br></pre></td></tr></table></figure><p>然后报错从dns probe finished no Internet变成了<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200904150200196.png" alt="image-20200904150200196" title="">                </div>                <div class="image-caption">image-20200904150200196</div>            </figure></p><p>佛了</p><p>面对不知道咋整的东西，那就选择重装系列：</p><p>右击<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200904184552395.png" alt="image-20200904184552395" title="">                </div>                <div class="image-caption">image-20200904184552395</div>            </figure>然后点击网络重置 好像就行了？！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DNS刷新&quot;&gt;&lt;a href=&quot;#DNS刷新&quot; class=&quot;headerlink&quot; title=&quot;DNS刷新&quot;&gt;&lt;/a&gt;DNS刷新&lt;/h2&gt;&lt;p&gt;垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows配置" scheme="http://Tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于windows密钥登录服务器</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/cmd_vs_rsa/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/cmd_vs_rsa/</id>
    <published>2020-09-04T06:56:33.000Z</published>
    <updated>2020-09-04T07:05:55.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于windows密钥登录服务器"><a href="#关于windows密钥登录服务器" class="headerlink" title="关于windows密钥登录服务器"></a>关于windows密钥登录服务器</h2><p>前言:windows的权限管理太屑了</p><p>参考<a href="https://blog.csdn.net/joshua2011/article/details/90208741" target="_blank" rel="noopener">https://blog.csdn.net/joshua2011/article/details/90208741</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于windows密钥登录服务器&quot;&gt;&lt;a href=&quot;#关于windows密钥登录服务器&quot; class=&quot;headerlink&quot; title=&quot;关于windows密钥登录服务器&quot;&gt;&lt;/a&gt;关于windows密钥登录服务器&lt;/h2&gt;&lt;p&gt;前言:windows的权限管
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows配置" scheme="http://Tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>wishlist_together</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/wishlist-together/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/wishlist-together/</id>
    <published>2020-09-04T02:18:35.000Z</published>
    <updated>2020-09-04T02:19:22.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-wishlist"><a href="#2020-wishlist" class="headerlink" title="2020 wishlist"></a>2020 wishlist</h2><ul><li>一起去鬼屋</li><li>一起去迪士尼</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2020-wishlist&quot;&gt;&lt;a href=&quot;#2020-wishlist&quot; class=&quot;headerlink&quot; title=&quot;2020 wishlist&quot;&gt;&lt;/a&gt;2020 wishlist&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一起去鬼屋&lt;/li&gt;
&lt;li&gt;一起去迪士
      
    
    </summary>
    
      <category term="wishlist" scheme="http://Tyler-ytr.github.io/categories/wishlist/"/>
    
    
      <category term="wishlist" scheme="http://Tyler-ytr.github.io/tags/wishlist/"/>
    
  </entry>
  
  <entry>
    <title>leetcode4_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/</id>
    <published>2020-08-31T14:55:42.000Z</published>
    <updated>2020-08-31T14:58:35.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>难度困难2695</p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    #二分法,对于arr1,arr2,k:令x=k<span class="comment">//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小;</span></span><br><span class="line">    #注意处理边界</span><br><span class="line">    def findkthelement(self,arr1:List[<span class="keyword">int</span>],arr2:List[<span class="keyword">int</span>],k)-&gt;<span class="keyword">float</span>:</span><br><span class="line">        len1=len(arr1)</span><br><span class="line">        len2=len(arr2)</span><br><span class="line">        <span class="keyword">if</span> len1&gt;len2:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr2,arr1,k)</span><br><span class="line">            ##确保arr1是短的一边;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr1:</span><br><span class="line">            #arr1为空,递归结束</span><br><span class="line">            <span class="keyword">return</span> arr2[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            #返回最小的元素</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(arr1[<span class="number">0</span>],arr2[<span class="number">0</span>])</span><br><span class="line">        x=k<span class="comment">//2</span></span><br><span class="line">        i=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len1)<span class="number">-1</span>) #arr1的边界;因为是数组所以要减一,代表有i+<span class="number">1</span>个元素</span><br><span class="line">        j=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len2)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr1[i]&lt;arr2[j]:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1[i+<span class="number">1</span>:],arr2,k-i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1,arr2[j+<span class="number">1</span>:],k-j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    def findMedianSortedArrays(self, nums1: List[<span class="keyword">int</span>], nums2: List[<span class="keyword">int</span>]) -&gt; <span class="keyword">float</span>:</span><br><span class="line">        len1=len(nums1)</span><br><span class="line">        len2=len(nums2)</span><br><span class="line">        #考虑中位数的奇偶问题</span><br><span class="line">        mid1=(len1+len2+<span class="number">1</span>)<span class="comment">//2</span></span><br><span class="line">        mid2=(len1+len2+<span class="number">2</span>)<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span>(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;4. 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/m
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="二分" scheme="http://Tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode990_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/</id>
    <published>2020-08-31T14:28:06.000Z</published>
    <updated>2020-08-31T14:28:32.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></h4><p>难度中等73</p><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li><li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">            p[x]=find_set(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//图的连通性问题---并查集</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//==就合并;</span></span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1!=fx2)&#123;</span><br><span class="line">                    p[fx1]=p[fx2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1==fx2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        parent.resize(26);</span><br><span class="line">        iota(parent.begin(), parent.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int index) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; parent[index]) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[index] &#x3D; find(parent[index]);</span><br><span class="line">        return parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int index1, int index2) &#123;</span><br><span class="line">        parent[find(index1)] &#x3D; find(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        UnionFind uf;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                uf.unite(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;990-等式方程的可满足性&quot;&gt;&lt;a href=&quot;#990-等式方程的可满足性&quot; class=&quot;headerlink&quot; title=&quot;990. 等式方程的可满足性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sati
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode547_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/</id>
    <published>2020-08-31T14:23:59.000Z</published>
    <updated>2020-09-10T02:42:05.980Z</updated>
    
    <content type="html"><![CDATA[<h4 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></h4><p>难度中等255</p><p>班上有 <strong>N</strong> 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 <strong>N * N</strong> 的矩阵 <strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>N 在[1,200]的范围内。</li><li>对于所有学生，有M[i][i] = 1。</li><li>如果有M[i][j] = 1，则有M[j][i] = 1。</li></ol><p>通过次数47,496</p><p>提交次数83,180</p><p><strong>并查集版本</strong></p><p>改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前;</p><p>还有就是find函数的条件是$x==f[x]$ 别搞错了;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dis_set</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">//int f[205];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f;</span><br><span class="line">        dis_set(<span class="keyword">int</span> x)&#123;</span><br><span class="line">           <span class="comment">// this-&gt;n=205;</span></span><br><span class="line">            <span class="comment">//f.resize(this-&gt;n);</span></span><br><span class="line">            <span class="comment">//iota(f.begin(),f.end(),0);</span></span><br><span class="line">            n=x;</span><br><span class="line">            f.resize(x+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;n;i++)&#123;</span><br><span class="line">                f[i]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==f[x])&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">                f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">                <span class="keyword">return</span> f[x];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> roota=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> rootb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(roota==rootb)<span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">this</span>-&gt;n--;</span><br><span class="line">            f[roota]=rootb;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">struct dis_set <span class="title">cur</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[<span class="number">0</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    cur.unite(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.count();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[id]==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vis[id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M[id].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[id][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                dfs(i,M);               </span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        vis.resize(n);</span><br><span class="line">       <span class="comment">// iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i,M);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> bfs 版本的解法:</p><p>注意vis[j]=1那句,很重要;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200617203349985-1598883847362.png" alt="image-20200617203349985" title="">                </div>                <div class="image-caption">image-20200617203349985</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line">        <span class="comment">//还可以用bfs做;同样用vis记录没有访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">                Q.push(i);</span><br><span class="line">                <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> top=Q.front();</span><br><span class="line">                    Q.pop();</span><br><span class="line">                    vis[top]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[top].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[top][j]==<span class="number">1</span>&amp;&amp;vis[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                            Q.push(j);</span><br><span class="line">                             vis[j]=<span class="number">1</span>;<span class="comment">//这句很重要,如果没有这句会慢很多;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;547-朋友圈&quot;&gt;&lt;a href=&quot;#547-朋友圈&quot; class=&quot;headerlink&quot; title=&quot;547. 朋友圈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/friend-circles/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode94_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/</id>
    <published>2020-08-31T14:11:42.000Z</published>
    <updated>2020-09-10T02:42:55.622Z</updated>
    
    <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>难度中等614</p><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>通过次数210,162</p><p>提交次数290,172</p><p>递归版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sol(root-&gt;left,nums);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        sol(root-&gt;right,nums);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        sol(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代版本如下:</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt;S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line"></span><br><span class="line">    TreeNode*cur=root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!S.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            S.push(cur);</span><br><span class="line">            cur=cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=S.top();</span><br><span class="line">        result.push_back(cur-&gt;val);</span><br><span class="line">        S.pop();</span><br><span class="line">        cur=cur-&gt;right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。</span></span><br><span class="line"><span class="comment">        # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。</span></span><br><span class="line"><span class="comment">        # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200809090152414-1598883215929.png" alt="image-20200809090152414" title="">                </div>                <div class="image-caption">image-20200809090152414</div>            </figure><p>以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tre
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="树" scheme="http://Tyler-ytr.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题51_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9851-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题51-h/</id>
    <published>2020-08-31T14:10:23.000Z</published>
    <updated>2020-09-10T02:43:42.369Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></h4><p>难度困难90</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure><p>当然二重for循环暴力可以解决，但是会超时；</p><p>实际上是一道二分思想的归并排序题目</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200424130136282-1598883032345.png" alt="image-20200424130136282" title="">                </div>                <div class="image-caption">image-20200424130136282</div>            </figure><p>对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;temp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> tempresult=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int mid=(l+r)/2;</span></span><br><span class="line">        <span class="keyword">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);<span class="comment">//防止l,r过大的时候溢出</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)&gt;&gt;1; 最快</span></span><br><span class="line">        tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">                tempresult+=mid-i+<span class="number">1</span>;<span class="comment">//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line">        <span class="keyword">return</span> tempresult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//居然是归并排序</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">            temp.resize((<span class="keyword">int</span>)nums.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            result=mergesort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题51-数组中的逆序对&quot;&gt;&lt;a href=&quot;#面试题51-数组中的逆序对&quot; class=&quot;headerlink&quot; title=&quot;面试题51. 数组中的逆序对&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode912_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/</id>
    <published>2020-08-31T13:27:52.000Z</published>
    <updated>2020-08-31T13:28:22.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></h4><p>难度中等98</p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p>排序算法复习题</p><p>归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;//左指针偶遇右指针</span><br><span class="line">        int mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(nums,l,mid);</span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        // 现在l-mid mid+<span class="number">1</span>-r是有序的</span><br><span class="line">        //考虑合并的情况</span><br><span class="line">        int i=l;</span><br><span class="line">        int j=mid+<span class="number">1</span>;</span><br><span class="line">        int cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        temp.resize((int)nums.size(), <span class="number">0</span>);</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, (int)nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=nums[r];</span><br><span class="line">        <span class="keyword">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=pivot)&#123;</span><br><span class="line">                i=i+<span class="number">1</span>;<span class="comment">//扩展比pivot小的边界;</span></span><br><span class="line">                swap(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i+<span class="number">1</span>],nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomized_partiton</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        swap(nums[r],nums[i]);<span class="comment">//选择pivot然后存放到最右端;</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=randomized_partiton(nums,l,r);</span><br><span class="line">            quicksort(nums,l,pos<span class="number">-1</span>);</span><br><span class="line">            quicksort(nums,pos+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆排序（不稳定排序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxheapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;<span class="comment">//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1)</span></span><br><span class="line">       <span class="keyword">for</span>(;(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>&lt;=len;)&#123;       </span><br><span class="line">            <span class="keyword">int</span> lson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> largest;</span><br><span class="line">            <span class="keyword">if</span>(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123;</span><br><span class="line">                largest=lson;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                largest=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123;</span><br><span class="line">                largest=rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=largest)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">                nums[i]=nums[largest];</span><br><span class="line">                nums[largest]=temp;</span><br><span class="line">                i=largest;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildmaxheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            maxheapify(nums,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        buildmaxheap(nums,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">            len-=<span class="number">1</span>;</span><br><span class="line">            maxheapify(nums,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        heapsort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//另外关于排序算法</p><p>线性时间但是有限制的有:</p><p>计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\Theta(n+k)$</p><p>基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort</p><p>桶排序:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;912-排序数组&quot;&gt;&lt;a href=&quot;#912-排序数组&quot; class=&quot;headerlink&quot; title=&quot;912. 排序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot; tar
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/</id>
    <published>2020-08-31T13:26:51.000Z</published>
    <updated>2020-08-31T13:27:18.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>难度中等365</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><p>通过次数85,540</p><p>提交次数241,065</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">long</span> <span class="keyword">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>) &#123;<span class="comment">//此处等价于if(power%2==1)</span></span><br><span class="line">            result = result * base;</span><br><span class="line">        &#125;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;<span class="comment">//此处等价于power=power/2</span></span><br><span class="line">        base = (base * base) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp=n;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> fastPower(x,temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/fastPower(x,-temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;50-Pow-x-n&quot;&gt;&lt;a href=&quot;#50-Pow-x-n&quot; class=&quot;headerlink&quot; title=&quot;50. Pow(x, n)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/&quot; ta
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode914_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/</id>
    <published>2020-08-31T13:25:40.000Z</published>
    <updated>2020-08-31T13:26:10.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">914. 卡牌分组</a></h4><p>难度简单100</p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= deck.length &lt;= 10000</code></li><li><code>0 &lt;= deck[i] &lt; 10000</code></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10002</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">10002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD1</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num1%num2==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next1=num2;</span><br><span class="line"> <span class="keyword">int</span> next2=num1%num2;</span><br><span class="line"><span class="keyword">return</span> GCD1(next1,next2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deck.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt[deck[i]]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> g=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g==<span class="number">-1</span>)&#123;</span><br><span class="line">                    g=cnt[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    g=GCD1(g,cnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g&gt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;914-卡牌分组&quot;&gt;&lt;a href=&quot;#914-卡牌分组&quot; class=&quot;headerlink&quot; title=&quot;914. 卡牌分组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/x-of-a-kind-in-a-de
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode312_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/</id>
    <published>2020-08-31T13:23:43.000Z</published>
    <updated>2020-09-10T02:41:12.851Z</updated>
    
    <content type="html"><![CDATA[<h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h4><p>难度困难318</p><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 <code>i</code> 时，你可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>说明:</strong></p><ul><li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><p>这题需要考虑的有两点:</p><p>第一点是状态的寻找和转移</p><p>第二点是如何进行递推;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200620172037074-1598880235219.png" alt="image-20200620172037074" title="">                </div>                <div class="image-caption">image-20200620172037074</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \in [i+1,j-1] 这里k表示最后一次戳哪一个气球;</span></span><br><span class="line">        <span class="comment">//注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历;</span></span><br><span class="line">        <span class="comment">//另外还需要在左端和右端都添加虚假的气球;</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;points(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        points[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        points[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            points[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n + <span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n+<span class="number">2</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)&#123;</span><br><span class="line">                    maxn=<span class="built_in">max</span>(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                dp[i][j]=maxn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;312-戳气球&quot;&gt;&lt;a href=&quot;#312-戳气球&quot; class=&quot;headerlink&quot; title=&quot;312. 戳气球&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/burst-balloons/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU2513 切蛋糕</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU2513/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU2513/</id>
    <published>2020-08-31T13:21:36.000Z</published>
    <updated>2020-09-21T05:43:43.149Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th></tr></thead><tbody><tr><td><strong><a href="http://acm.hdu.edu.cn/discuss/public/post/reply.php?postid=40764&amp;messageid=1&amp;deep=0" target="_blank" rel="noopener">多校联合训练的常见问题回答（FAQ）</a></strong></td></tr><tr><td>Cake slicing<strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583  Accepted Submission(s): 305 **</strong>  Problem DescriptionA rectangular cake with a grid of m<em>n unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts  For example, assume that the cake has a grid of 3</em>4 unit squares on its top, and there are three cherries on the top, as shown in the figure below. <img src="/picture/C150-1009-1.jpg" alt="img"> One allowable slicing is as follows. <img src="/picture/C150-1009-2.jpg" alt="img"> For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is <img src="/picture/C150-1009-3.jpg" alt="img"> In this case, the total length of the cutting edges is 3+2=5.  Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges.   InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks.   OutputOutput an integer indicating the least total length of the cutting edges.                                                       Sample Input<code>3 4 3 1 2 2 3 3 2</code>                                                                                                                        Sample Output<code>Case 1: 5</code>  Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ECJTU+2008+Autumn+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ECJTU 2008 Autumn Contest</a></td></tr></tbody></table><p>【题意】</p><p>有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底)</p><p>我参考了网上的博客,思路如下:</p><p>这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200620162927557.png" alt="image-20200620162927557" title="">                </div>                <div class="image-caption">image-20200620162927557</div>            </figure></p><p>因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> MAXN=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y,x,sum;<span class="comment">//y*x矩阵；sum个樱桃;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,<span class="keyword">int</span> l)</span></span>&#123;<span class="comment">//以i,j为左上角,k,l为右下角</span></span><br><span class="line">    <span class="keyword">if</span>(dp[i][j][k][l]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line">    &#125;<span class="comment">//如果之前计算过了,直接返回;</span></span><br><span class="line">    <span class="comment">//统计区域里面的樱桃数量;</span></span><br><span class="line">    <span class="keyword">int</span> cherry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;=k;++a)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;=l;++b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[a][b]==<span class="number">1</span>)&#123;</span><br><span class="line">                cherry+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果樱桃数量==1,那么不需要切割,返回0;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">1</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是0,那么这是一个不应该取得解,返回INF;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=MAXN;</span><br><span class="line">        <span class="keyword">return</span> MAXN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则需要切割;横着切或者纵着切;</span></span><br><span class="line">    <span class="keyword">int</span> minn=MAXN;</span><br><span class="line">    <span class="comment">//横着切:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;k;++a)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,a,l)+Dp(a+<span class="number">1</span>,j,k,l)+l-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纵着切割:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;l;++b)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,k,b)+Dp(i,b+<span class="number">1</span>,k,l)+k-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][j][k][l]=minn;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;y,&amp;x,&amp;sum))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p,q;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;q);</span><br><span class="line">            m[p][q]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dp(<span class="number">1</span>,<span class="number">1</span>,y,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cnt,dp[<span class="number">1</span>][<span class="number">1</span>][y][x]);</span><br><span class="line">        cnt+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/discuss/public/post/reply.php?postid=4
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>面试题08_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9808-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题08-m/</id>
    <published>2020-08-31T13:20:30.000Z</published>
    <updated>2020-08-31T13:20:49.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h4><p>难度中等82</p><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//没有优化的版本:</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(val.<span class="built_in">size</span>(),temp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//不管用几种硬币组成0元只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;<span class="comment">//只用一种硬币(1)当然只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>+dp[i][j-val[i]]% <span class="number">1000000007</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n]% <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//降维到一维的版本:</span></span><br><span class="line">        <span class="comment">//dp[j]=dp[j]+dp[j-val[i]];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[j]=dp[j]%<span class="number">1000000007</span>+dp[j-val[i]]%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题-08-11-硬币&quot;&gt;&lt;a href=&quot;#面试题-08-11-硬币&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.11. 硬币&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-lc
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1014_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/</id>
    <published>2020-08-31T13:19:15.000Z</published>
    <updated>2020-08-31T13:19:39.158Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">1014. 最佳观光组合</a></h4><p>难度中等124</p><p>给定正整数数组 <code>A</code>，<code>A[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的距离为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 50000</code></li><li><code>1 &lt;= A[i] &lt;= 1000</code></li></ol><p>通过次数17,154</p><p>提交次数32,791</p><p>主要注意优化的这种思路,真的挺妙的;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//A[i]+i+A[j]-j</span></span><br><span class="line">        <span class="comment">//原始解法:</span></span><br><span class="line">        <span class="comment">//对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2)</span></span><br><span class="line">        <span class="comment">//优化:</span></span><br><span class="line">        <span class="comment">//tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp=A[<span class="number">0</span>]+<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxn=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(tmp+A[i]-i,maxn);</span><br><span class="line">            tmp=<span class="built_in">max</span>(tmp,A[i]+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1014-最佳观光组合&quot;&gt;&lt;a href=&quot;#1014-最佳观光组合&quot; class=&quot;headerlink&quot; title=&quot;1014. 最佳观光组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-sight
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode837_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/</id>
    <published>2020-08-31T13:18:28.000Z</published>
    <updated>2020-08-31T13:18:44.193Z</updated>
    
    <content type="html"><![CDATA[<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p>难度中等190</p><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>K</code> 分时抽取数字。 抽取时，她从 <code>[1, W]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>W</code> 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 <code>K</code> 分时，她就停止抽取数字。 爱丽丝的分数不超过 <code>N</code> 的概率是多少？</p><p><strong>示例</strong> <strong>1**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>2**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>3**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li><li><code>1 &lt;= W &lt;= 10000</code></li><li>如果答案与正确答案的误差不超过 <code>10^-5</code>，则该答案将被视为正确答案通过。</li><li>此问题的判断限制时间已经减少。</li></ol><p>这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[x]: 得到x分之后继续游戏,成功的概率;</span></span><br><span class="line">        <span class="comment">//dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W</span></span><br><span class="line">        <span class="comment">//初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1</span></span><br><span class="line">        <span class="comment">//结果:dp[0]</span></span><br><span class="line">        <span class="comment">//优化:发现 dp[x]和dp[x-1]之间的关系:</span></span><br><span class="line">        <span class="comment">//Wdp[x-1]=dp[x]+...+dp[x+w-1]</span></span><br><span class="line">        <span class="comment">//Wdp[x]=dp[x+1].....dp[x+w]</span></span><br><span class="line">        <span class="comment">//W (dp[x]-dp[x-1])=-dp[x]+dp[x+w]</span></span><br><span class="line">        <span class="comment">//(W+1)dp[x]-dp[x+w]=Wdp[x-1]</span></span><br><span class="line">        <span class="comment">//dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k</span></span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="built_in">max</span>(N,K+W+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;dp(maxn,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=W;i++)&#123;</span><br><span class="line">            dp[K<span class="number">-1</span>]+=dp[i+K<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[K<span class="number">-1</span>]/=W;</span><br><span class="line">        <span class="comment">//dp[K - 1] = 1.0 * min(N - K + 1, W) / W;</span></span><br><span class="line">        <span class="comment">//dp[K-1]=((W+1)*dp[K]-dp[K+W])/W;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=((W+<span class="number">1</span>)*dp[i+<span class="number">1</span>]-dp[i+W+<span class="number">1</span>])/W;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;837-新21点&quot;&gt;&lt;a href=&quot;#837-新21点&quot; class=&quot;headerlink&quot; title=&quot;837. 新21点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/new-21-game/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode416_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/</id>
    <published>2020-08-31T13:17:48.000Z</published>
    <updated>2020-08-31T13:18:02.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h4><p>难度中等218</p><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure><hr><p>01背包问题 具体解体思路见注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//背包问题</span></span><br><span class="line">        <span class="comment">//背包的容量是总和的一半</span></span><br><span class="line">        <span class="comment">//dp[i][j] 表示取了前i个数剩余容积为j时候的最大值</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> V=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只取0号数字的时候的初始化：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums[<span class="number">0</span>];i&lt;=V;i++)&#123;<span class="comment">//注意越界问题</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=nums[<span class="number">0</span>];<span class="comment">//因为只能取一次nums[0];</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//dp状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[n<span class="number">-1</span>][V]!=V)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;416-分割等和子集&quot;&gt;&lt;a href=&quot;#416-分割等和子集&quot; class=&quot;headerlink&quot; title=&quot;416. 分割等和子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode221_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/</id>
    <published>2020-08-31T13:16:52.000Z</published>
    <updated>2020-09-10T02:40:38.559Z</updated>
    
    <content type="html"><![CDATA[<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h4><p>难度中等428</p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>神必的dp</p><p>主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度;</p><p>状态转移方程比较难像:</p><p>$dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$</p><p>解释如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200531160513652.png" alt="image-20200531160513652" title="">                </div>                <div class="image-caption">image-20200531160513652</div>            </figure><p>为了代码的美观减少一次特判,应该要在左边和上边多加一列:</p><p>0 0 0 …..</p><p>0  matrix</p><p>0 </p><p>…</p><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#重点是神必的状态转移方程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        height=len(matrix)</span><br><span class="line">        width=len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(width+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(height+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#dp初始化,并且在外面多套了一层;</span></span><br><span class="line">        <span class="comment">#dp[i,j]表示以i,j为右下角的矩形的最大宽度;</span></span><br><span class="line">        <span class="comment"># 0 0 0 0 ....</span></span><br><span class="line">        <span class="comment"># 0 matrix</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment">#转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1</span></span><br><span class="line">        maxedge=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(dp[i][j],dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">                maxedge=max(maxedge,dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> maxedge*maxedge</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;221-最大正方形&quot;&gt;&lt;a href=&quot;#221-最大正方形&quot; class=&quot;headerlink&quot; title=&quot;221. 最大正方形&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximal-square/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode213_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/</id>
    <published>2020-08-31T13:16:12.000Z</published>
    <updated>2020-08-31T13:16:24.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>难度中等284</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;dp1(nums.size(),0);</span><br><span class="line">        vector&lt;int&gt;dp2(nums.size(),0);</span><br><span class="line">        dp1[0]&#x3D;nums[0];</span><br><span class="line"></span><br><span class="line">        dp1[1]&#x3D;max(nums[0],nums[1]);</span><br><span class="line">        </span><br><span class="line">        if(nums.size()&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(nums.size()&#x3D;&#x3D;3)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123;</span><br><span class="line">            dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int result1&#x3D;dp1[nums.size()-2];</span><br><span class="line"></span><br><span class="line">        dp2[1]&#x3D;nums[1];</span><br><span class="line">        dp2[2]&#x3D;max(nums[1],nums[2]);</span><br><span class="line">        for(int i&#x3D;3;i&lt;nums.size();i++)&#123;</span><br><span class="line">            dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int result2&#x3D;dp2[nums.size()-1];</span><br><span class="line">        return max(result1,result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;213-打家劫舍-II&quot;&gt;&lt;a href=&quot;#213-打家劫舍-II&quot; class=&quot;headerlink&quot; title=&quot;213. 打家劫舍 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robb
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode198_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/</id>
    <published>2020-08-31T13:15:12.000Z</published>
    <updated>2020-08-31T13:15:36.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>难度简单875</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p>原始版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:第0间-第i间房子偷窃的最高金额;</span></span><br><span class="line">        <span class="comment">//dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        <span class="comment">//dp[0]=nums[0]</span></span><br><span class="line">        <span class="comment">//dp[1]=max(nums[0],nums[1])</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(len,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;++i)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//滚动数组优化;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>滚动数组优化版本;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额;</span><br><span class="line">        &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span><br><span class="line">        &#x2F;&#x2F;初始化:</span><br><span class="line">        &#x2F;&#x2F;dp[0]&#x3D;nums[0]</span><br><span class="line">        &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1])</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int len&#x3D;nums.size();</span><br><span class="line">        int first&#x3D;nums[0];</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return first;</span><br><span class="line">            &#x2F;&#x2F;return dp[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int sec&#x3D;max(nums[1],nums[0]);</span><br><span class="line">        int result&#x3D;sec;</span><br><span class="line">        for(int i&#x3D;2;i&lt;len;i++)&#123;</span><br><span class="line">            result&#x3D;max(sec,first+nums[i]);</span><br><span class="line">            first&#x3D;sec;</span><br><span class="line">            sec&#x3D;result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;198-打家劫舍&quot;&gt;&lt;a href=&quot;#198-打家劫舍&quot; class=&quot;headerlink&quot; title=&quot;198. 打家劫舍&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot; targ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/</id>
    <published>2020-08-31T13:10:02.000Z</published>
    <updated>2020-08-31T13:13:23.891Z</updated>
    
    <content type="html"><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>难度中等537</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:i个结点的时候二叉搜索树的个数</span></span><br><span class="line">        <span class="comment">//空树只有一种情况:dp[0]=1</span></span><br><span class="line">        <span class="comment">//dp[1]=1</span></span><br><span class="line">        <span class="comment">//dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-bin
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode64_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/</id>
    <published>2020-08-31T13:09:13.000Z</published>
    <updated>2020-08-31T13:09:41.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>难度中等486</p><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]:到i,j 的最小路径和;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(grid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m=dp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n=dp[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/</id>
    <published>2020-08-31T13:04:05.000Z</published>
    <updated>2020-09-10T02:42:28.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>难度中等560</p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/robot_maze.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#x2F;&#x2F;dp[0][0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;dp[0][1]&#x3D;1&#39;</span><br><span class="line">        &#x2F;&#x2F;dp[1][0]&#x3D;1;</span><br><span class="line">        if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt;tmp(m,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n,tmp);</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            dp[0][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][0]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;m;j++)&#123;</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode53_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/</id>
    <published>2020-08-31T13:03:25.000Z</published>
    <updated>2020-08-31T13:03:46.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><p>水题:</p><p>dp[i]表示第i个之前的连续子数组的最大和</p><p>dp[i]=max(dp[i],dp[i-1]+dp[i]) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnum;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums)</span></span>;</span><br><span class="line">        maxnum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;53-最大子序和&quot;&gt;&lt;a href=&quot;#53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. 最大子序和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode32_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/</id>
    <published>2020-08-31T13:01:40.000Z</published>
    <updated>2020-08-31T13:02:23.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><p>难度困难784</p><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>通过次数74,856</p><p>提交次数233,569</p><p>题解见注释:主要是要两两字符判断;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度;</span></span><br><span class="line">        <span class="comment">//对于...............():</span></span><br><span class="line">        <span class="comment">//dp[i]=dp[i-2]+2;</span></span><br><span class="line">        <span class="comment">//对于...............)):</span></span><br><span class="line">        <span class="comment">//dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) </span></span><br><span class="line">        <span class="comment">//判断s[i-dp[i-1]-1],如果是(:</span></span><br><span class="line">        <span class="comment">//dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.length();;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i]=<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                        dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>+dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]; </span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;32-最长有效括号&quot;&gt;&lt;a href=&quot;#32-最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32. 最长有效括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-pa
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/</id>
    <published>2020-08-31T13:00:48.000Z</published>
    <updated>2020-08-31T13:01:10.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>难度中等</p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><p>这题目可以使用动态规划</p><p>我觉得很棒的一个<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> len=s.length();</span><br><span class="line">       <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[j][i]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][i]=dp[j+<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=i-j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;maxl)&#123;</span><br><span class="line">                        maxl=temp;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5. 最长回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HDU_1284</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU-1284/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU-1284/</id>
    <published>2020-08-31T12:58:32.000Z</published>
    <updated>2020-08-31T12:59:37.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 15976  Accepted Submission(s): 9546<br>**</strong></p><p>Problem Description</p><p>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。</p><p>Input</p><p>每行只有一个正整数N，N小于32768。</p><p>Output</p><p>对应每个输入，输出兑换方法数。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2934</span><br><span class="line">12553</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">718831</span><br><span class="line">13137761</span><br></pre></td></tr></table></figure><p>Author</p><p>SmallBeer(CML)</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%BA%BC%B5%E7ACM%BC%AF%D1%B5%B6%D3%D1%B5%C1%B7%C8%FC%A3%A8VII%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">杭电ACM集训队训练赛（VII）</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//相当于3件物品，容量为N的背包，第i件物品的重量是i</span></span><br><span class="line"><span class="comment">//初始化: dp[0][0]=1</span></span><br><span class="line"><span class="comment">//dp[i][j]表示用前i件物品组成j的方案数量</span></span><br><span class="line"><span class="comment">//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;</span></span><br><span class="line"><span class="comment">//滚动数组优化：</span></span><br><span class="line"><span class="comment">//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">33000</span>;<span class="comment">//32468</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;maxn;j++)&#123;</span><br><span class="line">            dp[j]+=dp[j-i];</span><br><span class="line">          <span class="comment">//  printf("%lld\n",dp[j]);</span></span><br><span class="line">           <span class="comment">// dp[j]+=max(dp[j],dp[j-i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf("here");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    scanf("%d",&amp;temp);</span></span><br><span class="line"><span class="comment">//        printf("%lld",dp[temp]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,dp[temp]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;钱币兑换问题&quot;&gt;&lt;a href=&quot;#钱币兑换问题&quot; class=&quot;headerlink&quot; title=&quot;钱币兑换问题&quot;&gt;&lt;/a&gt;钱币兑换问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Time Limit: 2000/1000 MS (Java/Other
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode19_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/</id>
    <published>2020-08-31T03:12:38.000Z</published>
    <updated>2020-08-31T12:50:14.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h4><p>难度中等947收藏分享切换为英文关注反馈</p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗</p><p>快慢指针的想法来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* l;</span><br><span class="line">        ListNode*r;</span><br><span class="line">        l=head;</span><br><span class="line">        r=head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(cnt=<span class="number">0</span>;cnt&lt;n;cnt++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;r-&gt;val&lt;&lt;endl;      </span></span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;l-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        l-&gt;next=l-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;19-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode16_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/</id>
    <published>2020-08-31T03:11:14.000Z</published>
    <updated>2020-08-31T12:50:07.255Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><p>难度中等530</p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p>通过次数141,122</p><p>提交次数308,415</p><p>和leetcode15相似,主要思路还是排序+双指针</p><p>我使用了minA维护了当前的最小值,然后使用res记录和;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#排序: -4 -1 1 2</span></span><br><span class="line">        <span class="comment">#minA 对于遍历到的每一个i,维护minA;</span></span><br><span class="line">        <span class="comment">#每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回;</span></span><br><span class="line"></span><br><span class="line">        n=len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> NULL</span><br><span class="line">        minA=sys.maxsize <span class="comment"># INT最大值</span></span><br><span class="line">        res=minA</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-2</span>):</span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                cur=nums[i]+nums[L]+nums[R]</span><br><span class="line">                <span class="keyword">if</span> cur==target:</span><br><span class="line">                    minA=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> cur</span><br><span class="line">                <span class="keyword">elif</span> cur&lt;target:</span><br><span class="line">                    tempres=target-cur</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tempres=cur-target</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur        </span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-close
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode15_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/</id>
    <published>2020-08-31T03:06:50.000Z</published>
    <updated>2020-08-31T12:50:01.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>难度中等2455</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数293,697</p><p>提交次数1,016,765</p><p>还是看了题解,排序太香了！</p><p>主要操作是排序使用双指针进行检查;同时记得去重;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#从i遍历到n-2,使用双指针维护和探查;</span></span><br><span class="line">        <span class="comment">#记得去重,也就是对于相同的找最后的;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#去重</span></span><br><span class="line">            </span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="number">0</span>):</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]):</span><br><span class="line">                        L=L+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L&lt; R <span class="keyword">and</span> nums[R]==nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R=R<span class="number">-1</span></span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R]&lt;<span class="number">0</span>:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      咸鱼leetcode刷题ing
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Winter plan</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/</id>
    <published>2020-01-22T09:17:23.000Z</published>
    <updated>2020-01-22T09:23:27.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>需要完成的目标:</p><ul><li>线性代数复习</li><li>学习cs224n</li><li>刷leetcode</li><li>算法竞赛入门经典</li></ul></li><li><p>目前进度:</p><ul><li>线性代数: <ul><li>1.22 </li></ul></li><li>cs224n<ul><li>1.22 </li></ul></li><li>leetcode<ul><li>1.22 </li></ul></li><li>算法竞赛入门经典</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要完成的目标:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性代数复习&lt;/li&gt;
&lt;li&gt;学习cs224n&lt;/li&gt;
&lt;li&gt;刷leetcode&lt;/li&gt;
&lt;li&gt;算法竞赛入门经典&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前进度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线
      
    
    </summary>
    
      <category term="个人计划" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="flag" scheme="http://Tyler-ytr.github.io/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu教程</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/</id>
    <published>2020-01-22T08:28:15.000Z</published>
    <updated>2021-02-25T08:13:34.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;</li><li>重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜</li></ul><h2 id="复活操作"><a href="#复活操作" class="headerlink" title="复活操作"></a>复活操作</h2><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><ul><li>管理员权限,换源,安装vim  <pre><code>  sudo passwd(修改sudo密码)  sudo apt-get update  sudo apt-get install vim  </code></pre></li><li>更换国内源,这里我选择的是<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华源</a>用下面的命令打开文件,并且注释里面的所有内容,<br> <pre><code> sudo vim /etc/apt/sources.list<br></code></pre> <ul><li>然后粘贴下面的内容到打开的文件里面<br><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br></code></pre><br>如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下;</li></ul></li><li>安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇<a href="https://blog.csdn.net/qq_33159059/article/details/85019467" target="_blank" rel="noopener">博客</a></li><li>然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义<pre><code>suapt-get install build-essentialapt-get install man                # on-line reference manualapt-get install gcc-doc            # manual for GCCapt-get install gdb                # GNU debuggerapt-get install git                # reversion control systemapt-get install libreadline-dev    # a library to use compile the project laterapt-get install libsdl2-dev        # a library to use compile the project laterapt-get install qemu-system-x86    # QEMU</code></pre></li><li>安装chrome:请使用bing搜索;用gmail同步很香;</li></ul><h4 id="科学的看世界"><a href="#科学的看世界" class="headerlink" title="科学的看世界"></a>科学的看世界</h4><ul><li>我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) <pre><code> mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json </code></pre></li><li>将下面的内容根据自己的配置放进去:<pre><code>{  "server":"my_server_ip",  "server_port":53450,  "local_address": "127.0.0.1",  "local_port":1080,  "password":"密码",  "timeout":300,  "method":"aes-256-gcm",  "fast_open": false}</code></pre></li><li>然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;<br>自己测试一下有没有问题;</li><li>感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)：<ul><li>先写一个自启动脚本：<pre><code> touch ~/.ssstart.shvim ~/.ssstart.sh</code></pre>内容是:<pre><code>#!/bin/bashss-local -c ~/shadowsocks/shadowsocks.json </code></pre></li><li>然后在终端里面起别名:<br><pre><code>vim ~/.bashrc<br>在末尾添加:<br>alias ss=’. ~/.ssstart.sh’<br>:wq 保存,退出<br>在终端里面:<br>source ~/.bashrc<br>(如果是zsh:source ~/.zshrc)<br></code></pre><br>尝试一下在终端输入ss,它lei了;</li></ul></li><li><p>因为后面的netdata需要<strong>终端</strong>翻墙,我也就尝试了一下,如果没有需求可以跳过这一步:</p><ul><li>主要参考的是谷歌出来的<a href="http://www.totorocyx.me/2018/10/02/ubuntu_shadowsocks/" target="_blank" rel="noopener">网站</a></li><li>首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装</li><li><p>下面尝试全局代理(我也不确定能不能成功)：</p><ul><li>sudo pip install genpac</li><li>选择安装配置文件的目录,我选择的是:<pre><code>/home/larryytr/shadowsocks</code></pre></li><li>然后执行以下命令:<pre><code>sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a></code></pre></li><li>下面是一句搬运,我没有遇到过:<pre><code>注意：如果报错“fetch gfwlist fail.online: <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a><br></pre></code></li><li>执行完之后,目录下面会有一个autoproxy.pac文件。</li><li><p>然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写：</p><pre><code>file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改)</code></pre></li></ul></li><li><p>然后使得终端也能使用代理。我们需要<strong>privoxy</strong>代理工具:</p><ul><li><p>安装很自然:sudo apt-get install privoxy</p></li><li><p>然后编辑配置文件<pre><code>sudo vim /etc/privoxy/config </pre></code></p></li><li><p>在文档中搜索(vim 使用/搜索)“<strong>listen-address</strong>”（即监听地址），找到如下一行：<strong>listen-address localhost:8118</strong> 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“<strong>forward-socks5t</strong>”，找到如下一行：<strong>forward-socks5t / 127.0.0.1:1080</strong> . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure></li><li><p>最后，再配置/etc/profile：<pre><code></p><pre><code># 先进入编辑模式</code></pre><p>sudo vim /etc/profile</p><pre><code># 在末尾添加以下三行：</code></pre><p>export http_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export https_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export ftp_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a></p><pre><code># 退出之后记得执行source /etc/profile</code></pre><p></code></pre></p></li><li><p>验证是否成功:curl <a href="http://www.google.com或wget" target="_blank" rel="noopener">www.google.com或wget</a> <a href="http://www.google.com判断是否可以访问" target="_blank" rel="noopener">www.google.com判断是否可以访问</a></p></li><li><p>HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！</p></li></ul></li></ul></li></ul><h4 id="优化美化"><a href="#优化美化" class="headerlink" title="优化美化"></a>优化美化</h4><ul><li>官网安装网易云</li><li>官网安装vscode</li><li>配置zsh,tmux,vim:</li></ul><h5 id="zsh安装与美化"><a href="#zsh安装与美化" class="headerlink" title="zsh安装与美化"></a>zsh安装与美化</h5><ul><li>学习了:<a href="https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/" target="_blank" rel="noopener">https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/</a><br><a href="https://segmentfault.com/a/1190000013612471这两篇教程" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013612471这两篇教程</a>;</li><li>感谢何伟的配置文件;</li><li>相应的setting请参考我的github<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>.</li><li>安装zsh:<pre><code>sudo apt-get updatesudo apt-get install zshchsh -s /bin/zsh (设置zsh为默认)</code></pre></li><li>重启你的ubuntu</li><li>安装oh-my-zsh插件:<pre><code> wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre></li><li>不改theme一无所有</li><li>准备使用powerline主题  </li><li>首先安装powerline字体：<pre><code>git clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts</code></pre></li><li>安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久)</li><li>安装powerline: sudo apt install powerline </li><li>我的配置见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting .zshrc</li><li>颜色选择困难请: <pre><code>for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f”</code></pre></li><li>改完请source ~/.zshrc</li></ul><h5 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h5><ul><li>tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程;</li><li>我使用了何伟的配置,具体见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting</li><li>我又加了一个插件使得tmux在重启之后状态可以恢复:<ul><li>主要参考这个<a href="https://zhuanlan.zhihu.com/p/24660412" target="_blank" rel="noopener">知乎教程</a></li><li><pre><code>git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp</code></pre></li><li>在~/.tmux.conf.local里面加上:<pre><code>run-shell ~/tmux_tmp/resurrect.tmux</code></pre></li><li>最后载入这个配置：<pre><code>tmux source-file ~/.tmux.conf<br></code></pre></li></ul></li></ul><h5 id="vim的美化"><a href="#vim的美化" class="headerlink" title="vim的美化"></a>vim的美化</h5><ul><li>使用啦懒人vim: spf13-vim美化</li><li>请看<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh</li><li>我的配置同样在<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting里面;</li><li>这个时候的vim没有办法和系统剪切版交互,我根据<a href="https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html" target="_blank" rel="noopener">https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html</a> 下载了其他一些插件:<br><pre><code>sudo apt-get install vim-scripts vim-gtk vim-gnome</pre></code><br>这样 vim –version|grep “cliboard” 会看到 +clipboard;<br>然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！</li></ul><h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容:"></a>其他内容:</h4><ul><li>OSlab还需要:<ul><li>sudo apt-get install curl</li><li>sudo apt-get install gcc-multilib</li></ul></li><li>git 配置请搜索廖雪峰</li><li>ctags 可以参考Mengzelev的<a href="https://mengzelev.github.io/2018/10/04/pa-inspirations/" target="_blank" rel="noopener">博客</a></li><li>感谢xnr给我推荐的network来查看linux的运行情况<ul><li>这是netdata的官方网站:<a href="https://github.com/netdata/netdata#user-base" target="_blank" rel="noopener">https://github.com/netdata/netdata#user-base</a></li><li>但是由于GFW,安装会出现报错,事实上需要终端翻墙才行</li><li>可以通过这篇<a href="https://blog.csdn.net/zhangvalue/article/details/80270169" target="_blank" rel="noopener">教程</a><br><pre><code> sudo apt-get install net-tools<br>  ifconfig<br></code></pre><br>查看inet 之后的内容来得知自己的server_ip</li><li>成功之后,进入 <a href="http://127.0.0.1:19999/" target="_blank" rel="noopener">http://127.0.0.1:19999/</a> (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验</li><li>相应配置可以参考这篇<a href="https://cloud.tencent.com/developer/article/1181577" target="_blank" rel="noopener">博客</a>或者自己搜索</li></ul></li><li>OSlab的kvm bug处理方法：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1479558" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=1479558</a><pre><code>chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content:KERNEL=="kvm", GROUP="kvm", MODE="0666"</code></pre></li><li>texlive 安装<pre><code>sudo apt install texlive-full</code></pre>相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting)vscode的保存即编译请<pre><code>Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾；</code></pre></li><li>ubuntu的截图:我参考了这篇<a href="https://blog.csdn.net/qq_17448289/article/details/56480805" target="_blank" rel="noopener">博客</a><ul><li>打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+</li><li>显然的配置好按键,然后在命令里面写<pre><code>gnome-screenshot -a</code></pre></li><li>hint:上面的命令终端输入也有效<br>截屏的图在文件夹的图片(picture)里面;</li></ul></li></ul><h4 id="ubuntu-jupyter-lab配置"><a href="#ubuntu-jupyter-lab配置" class="headerlink" title="ubuntu jupyter lab配置"></a>ubuntu jupyter lab配置</h4><p>在服务器上面配置了jupyter lab;</p><p>主要借鉴了:<a href="https://cloud.tencent.com/developer/article/1769288?from=information.detail.jupyter%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1769288?from=information.detail.jupyter%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8</a></p><ul><li><p>安装anaconda</p></li><li><p>使用python生成密钥;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from notebook.auth import passwd                                        </span><br><span class="line"></span><br><span class="line">In [2]: passwd()                                                                </span><br><span class="line">Enter password: </span><br><span class="line">Verify password: </span><br><span class="line">Out[2]: &#39;sha1:salt:hashed-password&#39;#这里输出的东西就是密钥，复制好之后填</span><br><span class="line"></span><br><span class="line">In [3]: exit()</span><br></pre></td></tr></table></figure></li><li><p>生成配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure></li><li><p>修改它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~<span class="regexp">/.jupyter/</span>jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>在末尾加上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.allow_remote_access &#x3D; True   # 允许外部访问</span><br><span class="line">c.NotebookApp.ip&#x3D;&#39;*&#39;                       # 设置所有ip皆可访问</span><br><span class="line">c.NotebookApp.password &#x3D; u&#39;sha1:salt:hashed-password&#39;  # 使用刚才生成的密钥</span><br><span class="line">c.NotebookApp.open_browser &#x3D; False       # 禁止自动打开浏览器</span><br><span class="line">c.NotebookApp.port &#x3D; 2021                # 任意指定一个不冲突的端口，</span><br><span class="line">c.NotebookApp.notebook_dir &#x3D; &#39;&#x2F;home&#x2F;ubuntu&#x2F;JupyterProject&#x2F;&#39; #默认文件路径,这里用户名要改成自己的</span><br><span class="line">c.NotebookApp.allow_root &#x3D; True          # 允许root身份运行jupyter notebook</span><br></pre></td></tr></table></figure></li><li><p>记得在安全组里面打开这个</p></li><li><p>在服务器端输入jupyter notebook, 然后本地浏览器输入 服务器地址:2021就行啦(比如 122.52.187.69:2021)(这个服务器是随意打的)</p></li></ul><h4 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h4><ul><li>有空再研究怎么换主题;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;&lt;/li&gt;
&lt;li&gt;重装很多次的原因是因为
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
