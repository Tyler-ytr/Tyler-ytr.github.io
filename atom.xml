<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tyler-yin&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/9cf7a8e81293a5a77561848afbba692b</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Tyler-ytr.github.io/"/>
  <updated>2021-02-22T16:32:40.966Z</updated>
  <id>http://Tyler-ytr.github.io/</id>
  
  <author>
    <name>Tyler-yin</name>
    <email>ytrpossible@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>p4学习-2:P4 basic实验</title>
    <link href="http://Tyler-ytr.github.io/2021/02/21/p4%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://Tyler-ytr.github.io/2021/02/21/p4学习-2/</id>
    <published>2021-02-21T09:12:26.000Z</published>
    <updated>2021-02-22T16:32:40.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-2：P4-basic实验"><a href="#P4学习-2：P4-basic实验" class="headerlink" title="P4学习-2：P4 basic实验"></a>P4学习-2：P4 basic实验</h2><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><ol><li><p>写一个P4程序完成基本的IPV4转发，也就是交换机需要:1.更新源和目的MAC地址 2. 在IP报头中减少 time-to-live(TTL)  3.将数据包转发到适当的端口</p><p>交换机有一个简单的table,控制平面将根据基本的规则更新它。每个规则将一个IP地址映射到下一跳的MAC地址和输出端口。我们已经定义了控制平面规则，所以你只需要实现你的P4程序的数据平面逻辑。</p></li><li><p>拓扑如下:</p><p><img src="/picture/pod-topo.png" alt="pod-topo"></p></li><li><p>实验basic.p4给了一个p4程序，关键部分被TODO代替，这个程序主要由以下部分组成:</p><ol><li><p>Ethernet (<code>ethernet_t</code>) and IPv4 (<code>ipv4_t</code>)两个header type的类型定义</p></li><li><p><strong>TODO</strong>：用于以太网和IPv4的Parser,它通过解析数据包填充了上述两个header;</p></li><li><p>一个丢包的动作，用了<code>mark_to_drop()</code></p></li><li><p><strong>TODO</strong>：一个动作（<code>ipv4_forward</code>）：</p><ol><li>设置下一跳的出口端口。</li><li>更新以太网目的地址为下一跳地址。</li><li>将以太网源地址更新为交换机地址。</li><li>TTL衰减。</li></ol></li><li><p><strong>TODO:</strong> 一个control:</p><ol><li>定义一个表，该表将读取IPv4目的地址，并调用<code>drop</code> 或者<code>ipv4_forward</code></li><li>应用这个表的一个 <code>apply</code>  block </li></ol></li><li><p>选择字段插入出数据包的顺序的Deparser。</p></li><li><p>实例化部分</p><blockquote><p>通常，包还需要校验和验证和重新计算控件的实例。这些对于本教程来说不是必需的，它们将被空控件的实例化所取代。</p></blockquote></li></ol></li></ol><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><p>本部分根据上面对程序的描述一一进行分析：</p><h5 id="headers部分"><a href="#headers部分" class="headerlink" title="headers部分:"></a>headers部分:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* -*- P4_16 -*- *&#x2F; # 声明语言是p4-16</span><br><span class="line">#include &lt;core.p4&gt;</span><br><span class="line">#include &lt;v1model.p4&gt;</span><br><span class="line"></span><br><span class="line">const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;</span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** H E A D E R S  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">typedef bit&lt;9&gt;  egressSpec_t;</span><br><span class="line">typedef bit&lt;48&gt; macAddr_t;</span><br><span class="line">typedef bit&lt;32&gt; ip4Addr_t;</span><br><span class="line"></span><br><span class="line">header ethernet_t &#123; # header数据结构相当于c语言里面的 packed struct,它有一个隐藏的参数validity，如果解析正确那么是true，可以通过isValid()获得，比如hdr.ipv4.isValid();</span><br><span class="line">    macAddr_t dstAddr;# macAddr_t是typedef bit&lt;48&gt; 的自定义类型</span><br><span class="line">    macAddr_t srcAddr;</span><br><span class="line">    bit&lt;16&gt;   etherType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header ipv4_t &#123;</span><br><span class="line">    bit&lt;4&gt;    version;#4bit的数据</span><br><span class="line">    bit&lt;4&gt;    ihl;</span><br><span class="line">    bit&lt;8&gt;    diffserv;</span><br><span class="line">    bit&lt;16&gt;   totalLen;</span><br><span class="line">    bit&lt;16&gt;   identification;</span><br><span class="line">    bit&lt;3&gt;    flags;</span><br><span class="line">    bit&lt;13&gt;   fragOffset;</span><br><span class="line">    bit&lt;8&gt;    ttl;</span><br><span class="line">    bit&lt;8&gt;    protocol;</span><br><span class="line">    bit&lt;16&gt;   hdrChecksum;</span><br><span class="line">    ip4Addr_t srcAddr;</span><br><span class="line">    ip4Addr_t dstAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct metadata &#123; #struct数据结构相当于python里面的 dictionary</span><br><span class="line">    &#x2F;* empty *&#x2F; #这个实验用不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct headers &#123;</span><br><span class="line">    ethernet_t   ethernet;</span><br><span class="line">    ipv4_t       ipv4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中V1model的结构如下图所示:</p><p> <img src="/picture/image-20210222224801495.png" alt="image-20210222224801495"></p><p> 总的来说这是一个模板，大致由下图组成:</p><p> <img src="/picture/image-20210222224659076-1614011557453.png" alt="image-20210222224659076"></p><p> 主要由HEADERS,PARSER,CHECKSUMVERFICATION,INGRESSPROCESSING,EGRESSPROCESSING,CHECKSUM UPDATE,DEPARSER,SWITCH组成;大概实例化的解释如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">V1Switch(</span><br><span class="line">MyParser(),    &#x2F;&#x2F; 解析数据包，提取包头 </span><br><span class="line">MyVerifyChecksum(),  &#x2F;&#x2F; 校验和验证</span><br><span class="line">MyIngress(),   &#x2F;&#x2F; 输入处理</span><br><span class="line">MyEgress(),    &#x2F;&#x2F; 输出处理</span><br><span class="line">MyComputeChecksum(),  &#x2F;&#x2F; 计算新的校验和</span><br><span class="line">MyDeparser()   &#x2F;&#x2F; 逆解析器</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure><h5 id="Parser部分"><a href="#Parser部分" class="headerlink" title="Parser部分"></a>Parser部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr,</span><br><span class="line">                inout metadata meta,</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        &#x2F;* TODO: add parser logic *&#x2F;</span><br><span class="line">        transition accept;#表示接受，也就是程序终止</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*********************** P A R S E R  ***********************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">parser MyParser(packet_in packet,</span><br><span class="line">                out headers hdr, #out相当于输出的数据,然后它的type是headers</span><br><span class="line">                inout metadata meta, #inout同时作为输入和输出值，类似 c++ 里面的引用</span><br><span class="line">                inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line"></span><br><span class="line">    state start &#123;</span><br><span class="line">        transition parse_ethernet;#转移到解析以太包头阶段</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_ethernet&#123;</span><br><span class="line">    packet.extract(hdr.ethernet); #把packet提取到hdr的ethernet里面，这里的过程可以理解为根据ethernet的长度截取一段数据</span><br><span class="line">    transition select(hdr.ethernet.etherType)&#123;#根据etherType的值选择进入的状态</span><br><span class="line">    TYPE_IPV4: parse_ipv4;#是IPV4包，进入解析ipv4的状态</span><br><span class="line">    default: accept;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state parse_ipv4&#123;</span><br><span class="line">    packet.extract(hdr.ipv4); #接着解析ipv4部分，这里可以理解为指针又往前移动了</span><br><span class="line">    transition accept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Ingress部分"><a href="#Ingress部分" class="headerlink" title="Ingress部分"></a>Ingress部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">************   C H E C K S U M    V E R I F I C A T I O N   *************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123;   </span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        &#x2F;* TODO: fill out code in action body *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;* TODO: fix ingress control logic</span><br><span class="line">         *  - ipv4_lpm should be applied only when IPv4 header is valid</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ipv4_lpm.apply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">**************  I N G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyIngress(inout headers hdr,</span><br><span class="line">                  inout metadata meta,</span><br><span class="line">                  inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    action drop() &#123;</span><br><span class="line">        mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123;</span><br><span class="line">        standard_metadata.egress_spec&#x3D;port; #egress_spec可以在输入代码中指定一个值来控制数据包将去哪个输出端口</span><br><span class="line">        hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr;  #原数据包的源地址改为目的地址</span><br><span class="line">        hdr.ethernet.dstAddr &#x3D; dstAddr; #目的地址改为控制面传入的新的地址</span><br><span class="line">        hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1;       #ttl要减去1</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table ipv4_lpm &#123;</span><br><span class="line">        key &#x3D; &#123;</span><br><span class="line">            hdr.ipv4.dstAddr: lpm;</span><br><span class="line">        &#125;</span><br><span class="line">        actions &#x3D; &#123;</span><br><span class="line">            ipv4_forward;</span><br><span class="line">            drop;</span><br><span class="line">            NoAction;</span><br><span class="line">        &#125;</span><br><span class="line">        size &#x3D; 1024;</span><br><span class="line">        default_action &#x3D; NoAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    apply &#123;</span><br><span class="line">        if (hdr.ipv4.isValid()) &#123;# 隐藏的参数，判断解析是否成功</span><br><span class="line">            ipv4_lpm.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:standard_metadata是<a href="https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4" target="_blank" rel="noopener">v1model.p4</a>里面定义的数据结构，在<a href="https://github.com/p4lang/behavioral-model/blob/main/docs/simple_switch.md" target="_blank" rel="noopener">simple_switch</a>的README里面进行了详细的解释,simple_switch是p4语言的一种架构，它大概的定义如下,其中v1m表示v1model,p4-16的一种模型，sm14是p4-14里面定义的模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ingress_port (sm14, v1m) - For new packets, the number of the ingress port on which the packet arrived to the device. Read only.</span><br><span class="line">packet_length (sm14, v1m) - For new packets from a port, or recirculated packets, the length of the packet in bytes. For cloned or resubmitted packets, you may need to include this in a list of fields to preserve, otherwise its value will become 0.</span><br><span class="line">egress_spec (sm14, v1m) - Can be assigned a value in ingress code to control which output port a packet will go to. The P4_14 primitive drop, and the v1model primitive action mark_to_drop, have the side effect of assigning an implementation specific value DROP_PORT to this field (511 decimal for simple_switch by default, but can be changed through the --drop-port target-specific command-line option), such that if egress_spec has that value at the end of ingress processing, the packet will be dropped and not stored in the packet buffer, nor sent to egress processing. See the &quot;after-ingress pseudocode&quot; for relative priority of this vs. other possible packet operations at end of ingress. If your P4 program assigns a value of DROP_PORT to egress_spec, it will still behave according to the &quot;after-ingress pseudocode&quot;, even if you never call mark_to_drop (P4_16) or drop (P4_14).</span><br><span class="line">egress_port (sm14, v1m) - Only intended to be accessed during egress processing, read only. The output port this packet is destined to.</span><br><span class="line">egress_instance (sm14) - Renamed egress_rid in simple_switch. See egress_rid below.</span><br><span class="line">instance_type (sm14, v1m) - Contains a value that can be read by your P4 code. In ingress code, the value can be used to distinguish whether the packet is newly arrived from a port (NORMAL), it was the result of a resubmit primitive action (RESUBMIT), or it was the result of a recirculate primitive action (RECIRC). In egress processing, can be used to determine whether the packet was produced as the result of an ingress-to-egress clone primitive action (INGRESS_CLONE), egress-to-egress clone primitive action (EGRESS_CLONE), multicast replication specified during ingress processing (REPLICATION), or none of those, so a normal unicast packet from ingress (NORMAL). Until such time as similar constants are pre-defined for you, you may copy this list of constants into your code.</span><br><span class="line">parser_status (sm14) or parser_error (v1m) - parser_status is the name in the P4_14 language specification. It has been renamed to parser_error in v1model. The value 0 (sm14) or error.NoError (P4_16 + v1model) means no error. Otherwise, the value indicates what error occurred during parsing.</span><br><span class="line">parser_error_location (sm14) - Not present in v1model.p4, and not implemented in simple_switch.</span><br><span class="line">checksum_error (v1m) - Read only. 1 if a call to the verify_checksum primitive action finds a checksum error, otherwise 0. Calls to verify_checksum should be in the VerifyChecksum control in v1model, which is executed after the parser and before ingress.</span><br></pre></td></tr></table></figure><h5 id="Egress部分"><a href="#Egress部分" class="headerlink" title="Egress部分"></a>Egress部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">****************  E G R E S S   P R O C E S S I N G   *******************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyEgress(inout headers hdr,</span><br><span class="line">                 inout metadata meta,</span><br><span class="line">                 inout standard_metadata_t standard_metadata) &#123;</span><br><span class="line">    apply &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Checksum-部分"><a href="#Checksum-部分" class="headerlink" title="Checksum 部分"></a>Checksum 部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">*************   C H E C K S U M    C O M P U T A T I O N   **************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123;</span><br><span class="line">     apply &#123;</span><br><span class="line">update_checksum(</span><br><span class="line">    hdr.ipv4.isValid(),</span><br><span class="line">            &#123; hdr.ipv4.version,</span><br><span class="line">      hdr.ipv4.ihl,</span><br><span class="line">              hdr.ipv4.diffserv,</span><br><span class="line">              hdr.ipv4.totalLen,</span><br><span class="line">              hdr.ipv4.identification,</span><br><span class="line">              hdr.ipv4.flags,</span><br><span class="line">              hdr.ipv4.fragOffset,</span><br><span class="line">              hdr.ipv4.ttl,</span><br><span class="line">              hdr.ipv4.protocol,</span><br><span class="line">              hdr.ipv4.srcAddr,</span><br><span class="line">              hdr.ipv4.dstAddr &#125;,</span><br><span class="line">            hdr.ipv4.hdrChecksum,</span><br><span class="line">            HashAlgorithm.csum16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;# 内置函数</span><br></pre></td></tr></table></figure><h5 id="Deparser部分"><a href="#Deparser部分" class="headerlink" title="Deparser部分"></a>Deparser部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        &#x2F;* TODO: add deparser logic *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  D E P A R S E R  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">control MyDeparser(packet_out packet, in headers hdr) &#123;</span><br><span class="line">    apply &#123;</span><br><span class="line">        packet.emit(hdr.ethernet);#按照顺序封装,emit的含义是发射</span><br><span class="line">        packet.emit(hdr.ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例化部分"><a href="#实例化部分" class="headerlink" title="实例化部分"></a>实例化部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*************************************************************************</span><br><span class="line">***********************  S W I T C H  *******************************</span><br><span class="line">*************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">V1Switch(</span><br><span class="line">MyParser(),</span><br><span class="line">MyVerifyChecksum(),</span><br><span class="line">MyIngress(),</span><br><span class="line">MyEgress(),</span><br><span class="line">MyComputeChecksum(),</span><br><span class="line">MyDeparser()</span><br><span class="line">) main;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-2：P4-basic实验&quot;&gt;&lt;a href=&quot;#P4学习-2：P4-basic实验&quot; class=&quot;headerlink&quot; title=&quot;P4学习-2：P4 basic实验&quot;&gt;&lt;/a&gt;P4学习-2：P4 basic实验&lt;/h2&gt;&lt;h4 id=&quot;实验目标&quot;
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>p4学习-1.md</title>
    <link href="http://Tyler-ytr.github.io/2021/02/18/p4%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://Tyler-ytr.github.io/2021/02/18/p4学习-1/</id>
    <published>2021-02-18T03:08:37.000Z</published>
    <updated>2021-02-22T15:34:14.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P4学习-1："><a href="#P4学习-1：" class="headerlink" title="P4学习-1："></a>P4学习-1：</h2><h4 id="实验前"><a href="#实验前" class="headerlink" title="实验前"></a>实验前</h4><ol><li><p>P4的PISA(Protocol-Independent Switch Architecture)结构：</p><p>Programmable  Parser—&gt;Programmable Match-Action Pipeline—&gt; Programmable Deparser；</p><p>Parser作用:程序员声明应该被识别的头和它们在包中的顺序</p><p>Match-Action作用:程序员定义表和精确的处理算法</p><p>Deparser作用:程序员声明输出的包怎样输出到总线上</p><p><img src="picture/image-20210220162023603.png" alt="image-20210220162023603"></p><p>整个结构都是流水线架构，一个来自外部的网络数据包经过层层流程首先被Parser解析出headers,然后进入Match-Action Table进行匹配和操作，这些headsers可以被添加/修改/删除；然后进入Deparser组装好流入外部网络，因为是流水线，所以Match-Action部分是不可以回头的 ；</p></li><li><p>实验部分——文件结构:(主要参考博客)</p><p> tutorials的文件结构:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tutorials&#x2F;</span><br><span class="line">├── exercises   # 存放各种练习</span><br><span class="line">├── utils       # 工具脚本目录</span><br><span class="line">└── vm          # 用于vagrant构建虚拟机的目录，可以无视</span><br></pre></td></tr></table></figure><p> 例子的文件结构:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 我们切换进入 exercises&#x2F;basic_tunnel 这个例子</span><br><span class="line">basic</span><br><span class="line">├── basic_tunnel.p4   # 要编写的p4代码</span><br><span class="line">├── build      # 生成文件的目录</span><br><span class="line">├── logs       # 日志文件， 在调试的时候真的非常重要！</span><br><span class="line">├── Makefile   ### 通过Makefile 来调用utils下的脚本!</span><br><span class="line">├── pcaps      # 生成的pcap包，可以使用wireshark等工具来分析</span><br><span class="line">├── README.md  # 详细的指导</span><br><span class="line">├── receive.py ## 利用scapy写的抓取和分析数据包的工具</span><br><span class="line">├── s1-runtime.json  #</span><br><span class="line">├── s2-runtime.json  # 在运行同时加载入交换机的控制面代码，这里有争议，稍后再谈</span><br><span class="line">├── s3-runtime.json  #</span><br><span class="line">├── send.py    ## 利用scapy写的构建和发送数据包的工具</span><br><span class="line">├── solution   # 这里有这个例子的示例代码（答案）</span><br><span class="line">└── topology.json  # 描述拓扑的json文件</span><br></pre></td></tr></table></figure><blockquote><p>这部分摘自参考资料的博客，实际情况有所不同</p></blockquote><p> Makefile会调用前面提到的utils下面的Makefile脚本，运行P4代码;</p><p> 使用make run 启动;</p><p> 调用<code>make run</code>，我们可以运行当前目录下（以basic目录为例）的代码，它将执行以下几个步骤:</p><ul><li>编译basic.p4 代码，生成basic.json</li><li>解析topology.json， 并且构建相应的mininet仿真拓扑，按照该拓扑启动一台或者多台BMv2交换机，以及一些host</li><li>启动BMv2的同时会将p4代码编译产生的json文件导入</li><li>启动BMv2后会解析 sN-runtime.json 文件(s1,s2,s3……)，将其载入 交换机sN流表之中</li><li>进入mininet命令行，同时开始记录log以及搜集pcap文件</li></ul></li><li><p>P4的参考手册:<a href="https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html" target="_blank" rel="noopener">https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html</a></p></li></ol><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://www.sdnlab.com/22512.html" target="_blank" rel="noopener">https://www.sdnlab.com/22512.html</a></li><li>P4官方tutorial(<a href="https://github.com/p4lang/tutorials" target="_blank" rel="noopener">https://github.com/p4lang/tutorials</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P4学习-1：&quot;&gt;&lt;a href=&quot;#P4学习-1：&quot; class=&quot;headerlink&quot; title=&quot;P4学习-1：&quot;&gt;&lt;/a&gt;P4学习-1：&lt;/h2&gt;&lt;h4 id=&quot;实验前&quot;&gt;&lt;a href=&quot;#实验前&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="p4语言学习" scheme="http://Tyler-ytr.github.io/categories/p4%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode21-s</title>
    <link href="http://Tyler-ytr.github.io/2021/02/14/leetcode21-s/"/>
    <id>http://Tyler-ytr.github.io/2021/02/14/leetcode21-s/</id>
    <published>2021-02-14T09:46:54.000Z</published>
    <updated>2021-02-14T09:51:48.658Z</updated>
    
    <content type="html"><![CDATA[<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><p>难度简单1530</p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/merge_ex1.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                l1,l2=l2,l1</span><br><span class="line">            l1.next=self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21. 合并两个有序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="递归" scheme="http://Tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>p4安装</title>
    <link href="http://Tyler-ytr.github.io/2021/02/07/p4%E5%AE%89%E8%A3%85/"/>
    <id>http://Tyler-ytr.github.io/2021/02/07/p4安装/</id>
    <published>2021-02-07T08:25:10.000Z</published>
    <updated>2021-02-21T17:15:25.805Z</updated>
    
    <content type="html"><![CDATA[<h4 id="P4环境配置"><a href="#P4环境配置" class="headerlink" title="P4环境配置"></a>P4环境配置</h4><h5 id="0-准备"><a href="#0-准备" class="headerlink" title="0.准备"></a>0.准备</h5><ul><li><p>基础环境ubuntu 18.04 LTS</p></li><li><p>使用trojan终端代理，不然一些下载太慢了</p></li><li><p>ubuntu换源到阿里云</p></li><li><p>在~目录新建P4目录并且加入环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir P4</span><br><span class="line">cd P4</span><br><span class="line">echo&quot;P4_HOME&#x3D;$(pwd)&quot;&gt;&gt; ~&#x2F;.bashrc</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y cmake g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev libboost-graph-dev llvm pkg-config python python-scapy python-ipaddr python-ply tcpdump doxygen graphviz texlive</span><br><span class="line">sudo apt-get install g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev pkg-config python python-scapy python-ipaddr tcpdump cmake## 两个参考里面的可能有重复</span><br></pre></td></tr></table></figure><p>下面都是在P4文件夹进行的工作</p><blockquote><p>所有的make都巨慢，合理安排好时间</p></blockquote></li></ul><h5 id="1-安装依赖库protocol"><a href="#1-安装依赖库protocol" class="headerlink" title="1. 安装依赖库protocol"></a>1. 安装依赖库protocol</h5><ul><li><p>参考了这个依赖库github的C++环境的<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/README.md" target="_blank" rel="noopener">README</a>;</p></li><li><p>安装依赖并且git clone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf.git</span><br><span class="line">cd protobuf</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">.&#x2F;autogen.sh</span><br></pre></td></tr></table></figure><blockquote><p>其中 git submodule update –init –recursive 必做，这会下载好相应的googletest文件，忽略这一步会在make check报错</p></blockquote></li><li><p>然后build以及安装，下面步骤耗时较长:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig # refresh shared library cache.更新共享库</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-安装PI以及它的依赖"><a href="#2-安装PI以及它的依赖" class="headerlink" title="2. 安装PI以及它的依赖"></a>2. 安装PI以及它的依赖</h5><ul><li><p>参考PI的 github网站<a href="https://github.com/p4lang/PI" target="_blank" rel="noopener">https://github.com/p4lang/PI</a> 安装</p></li><li><p>首先安装gRPC V1.17.2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;grpc.git</span><br><span class="line">cd grpc&#x2F;</span><br><span class="line">git checkout tags&#x2F;v1.17.2</span><br><span class="line">git submodule update --init --recursive # 这步耗时较长，一定要代理</span><br><span class="line">make #也可以make -j4 表示用四个核make,j后面这个数量可以自己设定</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br><span class="line"># Install gRPC Python Package 这步安装挺慢的</span><br><span class="line">sudo pip install grpcio</span><br></pre></td></tr></table></figure></li><li><p>然后安装PI –with-proto,（To include <code>p4runtime.proto</code> in the build, please run <code>configure</code> with <code>--with-proto</code>.）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --with-proto</span><br><span class="line">make </span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-安装bmv2"><a href="#3-安装bmv2" class="headerlink" title="3. 安装bmv2"></a>3. 安装bmv2</h5><ul><li><p>建议先阅读原来的github库(<a href="https://github.com/p4lang/behavioral-model" target="_blank" rel="noopener">https://github.com/p4lang/behavioral-model</a>)</p></li><li><p>安装操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;P4</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;behavioral-model.git</span><br><span class="line">cd behavioral-model</span><br><span class="line">sudo .&#x2F;install_deps.sh #脚本安装依赖库</span><br></pre></td></tr></table></figure><blockquote><p>终端代理的好处在于这些脚本如果不是终端代理下载会异常慢以至于不得不手动转换到gitee安装</p><p>安装依赖库因为要编译其他第三方库也异常的慢</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  .&#x2F;autogen.sh</span><br><span class="line">  .&#x2F;configure --enable-debugger --with-pi</span><br><span class="line">  make</span><br><span class="line">  sudo make install</span><br><span class="line">  sudo sudo ldconfig</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-安装p4c"><a href="#4-安装p4c" class="headerlink" title="4. 安装p4c"></a>4. 安装p4c</h5><ul><li><p>下载库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;P4</span><br><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;p4c.git</span><br><span class="line">cd p4c</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make -j4 #4线程编译</span><br><span class="line">sudo make install</span><br><span class="line">cd ..&#x2F;..</span><br></pre></td></tr></table></figure><blockquote><p>这步如果make -j4后面make check 会花很多时间然后有可能报错</p></blockquote></li></ul><h5 id="5-下载p4-tutorials"><a href="#5-下载p4-tutorials" class="headerlink" title="5. 下载p4 tutorials"></a>5. 下载p4 tutorials</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;tutorials</span><br></pre></td></tr></table></figure><p>目前的目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P4</span><br><span class="line">|——behavioral-model # BMv2 软件交换机</span><br><span class="line">|——grpc  # 作为BMv2的依赖</span><br><span class="line">|——mininet # 网络仿真</span><br><span class="line">|——p4c #p4c编译器</span><br><span class="line">|——PI # PI P4 runtime库</span><br><span class="line">|——protobuf # 依赖</span><br><span class="line">|——tutorials #教程</span><br></pre></td></tr></table></figure><h5 id="6-解决实验出现的bug"><a href="#6-解决实验出现的bug" class="headerlink" title="6. 解决实验出现的bug"></a>6. 解决实验出现的bug</h5><p>在做实验的时候出现了陆陆续续的bug，还需要:</p><ol><li><p>No module named psutil</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;p&#x2F;psutil&#x2F;psutil-2.1.3.tar.gz </span><br><span class="line">    tar -zxvf psutil-2.1.3.tar.gz</span><br><span class="line">    cd psutil-2.1.3</span><br><span class="line">    python setup.py install</span><br></pre></td></tr></table></figure></li><li><p>No module named google.protobuf.internal</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install protobuf</span><br></pre></td></tr></table></figure></li><li><p>根据<a href="https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc" target="_blank" rel="noopener">https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc</a> 安装simple_switch_grpc</p></li><li><p>安装之后还是P4 switch s1 did not start correctly，根据issue<a href="https://github.com/p4lang/tutorials/issues/107" target="_blank" rel="noopener">https://github.com/p4lang/tutorials/issues/107</a> ，还需要：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p> 至此可以编译basic实验</p></li></ol><blockquote><p> PS: 最后发现其实最标准的安装操作是根据tutorials（<a href="https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢" target="_blank" rel="noopener">https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢</a></p></blockquote><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><ul><li><a href="https://p4.org/p4/getting-started-with-p4.html" target="_blank" rel="noopener">https://p4.org/p4/getting-started-with-p4.html</a></li><li><a href="https://www.jianshu.com/p/2878192ba3f7" target="_blank" rel="noopener">https://www.jianshu.com/p/2878192ba3f7</a></li><li><a href="https://www.sdnlab.com/22512.html" target="_blank" rel="noopener">https://www.sdnlab.com/22512.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;P4环境配置&quot;&gt;&lt;a href=&quot;#P4环境配置&quot; class=&quot;headerlink&quot; title=&quot;P4环境配置&quot;&gt;&lt;/a&gt;P4环境配置&lt;/h4&gt;&lt;h5 id=&quot;0-准备&quot;&gt;&lt;a href=&quot;#0-准备&quot; class=&quot;headerlink&quot; title=&quot;0
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="p4" scheme="http://Tyler-ytr.github.io/tags/p4/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型2</title>
    <link href="http://Tyler-ytr.github.io/2020/10/09/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B2/"/>
    <id>http://Tyler-ytr.github.io/2020/10/09/深度探索C-对象模型2/</id>
    <published>2020-10-09T03:13:38.000Z</published>
    <updated>2020-10-09T03:15:26.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度探索c-对象模型2"><a href="#深度探索c-对象模型2" class="headerlink" title="深度探索c++对象模型2"></a>深度探索c++对象模型2</h2><p>这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”和“程序效率”的冲击</p><h4 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h4><ul><li><p>带有默认构造函数的Member Class Object</p><p>总结而言就是，如果对象a中依次有对象b，c，d，如果程序员仅仅初始化了c（10），那么编译器会调用b，d的默认构造函数，顺序是b，c（10），d；另外，对于对象g，假设里面只有int c;string d;编译器的隐式默认构造函数是不会帮忙解决这两者的初始化问题的，也就是这个构造函数是trivial的</p></li><li><p>带有默认构造函数的Base Class</p><p>一个类的构造函数，需要调用一些基类的构造函数（必要之默认构造函数），你自定义的构造函数，编译器会帮你补上调用那些构造函数的部分；先调用基类的默认构造函数然后调用成员类的默认构造函数</p></li><li><p>带有一个Virtual Function 的 Class</p><p>以下两种情况，需要编译器合成出default constructor</p><ul><li>class声明（或者继承）一个virtual constructor</li><li>class派生自一个继承串链，其中有一个或者更多的virtual base classes<br>以上两种情况如果缺乏用户声明的constructor，那么编译器会详细记录合成一个default constructor 的必要信息。主要有以下两种扩张行动：</li><li>一个虚函数表会被编译器产生出来，存放着类的虚函数地址</li><li>一个vptr会被编译器合成出来，包含着虚函数表的地址</li></ul></li><li><p>带有一个Virtual Base Class 的 Class</p><p>C继承A、B，A虚继承X，B虚继承X；根据不同编译器，在构造这些对象的时候会有类似指针的东西指向虚继承的类里面的成员，这些都是编译器在类对象构造期间完成的；对于这样的类所定义的每一个构造函数，编译器会安插那些“允许每一个virtual base class的执行期存取操作”的代码。如果class没有声明任何的constructors,编译器必须为它合成一个default constructor。；</p></li><li><p>总结：</p><p>上面四种情况，会造成：编译器必须为没有声明构造函数的类合成一个默认构造函数“，这些合成物被称为隐式非平凡默认构造函数(implicit nontrivial default constructors)。除此之外都是隐式平凡构造函数，实际上不会被合成出来。</p><p>在合成出来的这些构造函数里面，只有base class subobjects和member class objects会被初始化，其他的都不会。</p></li></ul><h4 id="Copy-Constructor-的构造操作"><a href="#Copy-Constructor-的构造操作" class="headerlink" title="Copy Constructor 的构造操作"></a>Copy Constructor 的构造操作</h4><ul><li><p>下面三种情况，会以一个object的内容作为另一个class object的初值</p><ul><li><p>显式地以一个对象的内容作为另一个类对象的初值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">X xx&#x3D;x;</span><br></pre></td></tr></table></figure></li><li><p>当对象被当做参数交给某一个函数的时候</p></li><li><p>当函数传回一个类对象的时候</p></li></ul><p>如果类的设计者显式定义了一个拷贝构造函数，就会调用它</p></li><li><p>默认的拷贝构造函数</p><p>当类没有提供一个显示的拷贝构造函数时候使用，用递归的方式实行member initialization，比每一个内建的活着派生的data member的值从一个object拷贝到另一个上面。</p><p>下面讨论的是隐式的拷贝构造函数编译器是否会合成一个default copy constructor的问题。根据C++标准，决定一个copy constructor 是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。（只有nontrivial的实例才会被合成于程序里面。）</p></li><li><p>bitwise copy semantics（位逐次拷贝）</p><p>什么时候一个class不展现出所谓的位逐次拷贝呢？</p><ul><li>一个class中有一个成员变量的class里面声明了一个copy constructor</li><li>这个class继承自一个基类，然后这个基类里面有一个copy constructor</li><li>当class声明了一个或者多个virtual functions（考虑vptr的拷贝问题）</li><li>当class派生自一个继承串链，其中有一个或者多个virtual base classes（发生在一个class object 以其derived classes的某一个对象作为初值的时候，编译器需要安插一些代码来设定virtual base class pointer/offset 的初值）</li></ul></li></ul><h4 id="程序转化语义学（Program-Transformation-Semantics）"><a href="#程序转化语义学（Program-Transformation-Semantics）" class="headerlink" title="程序转化语义学（Program Transformation Semantics）"></a>程序转化语义学（Program Transformation Semantics）</h4><ul><li><p>主要从初始化，参数初始化，返回值初始化三个角度探讨了拷贝构造函数的应用及应用的伪码；</p></li><li><p>显示初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo_bar()&#123;</span><br><span class="line">X x1(x0);</span><br><span class="line">X x2&#x3D;x0;</span><br><span class="line">X x3&#x3D;X(x0);</span><br></pre></td></tr></table></figure></li></ul><p>转换成的可能的伪码：<br>    <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/Pwv3q8xTrLdlOkE.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><br>    其中：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1.X::X(x0);</span><br></pre></td></tr></table></figure></code></pre><p>//表现为对一下copy constructor 的调用：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X::x(const X&amp; xx);</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>参数初始化：<br>对于一下子调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(X x0);</span><br><span class="line">X xx;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">foo(xx)</span><br></pre></td></tr></table></figure><p>可能的伪码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">__temp0.X::X(xx);</span><br><span class="line">foo(__temp0);</span><br></pre></td></tr></table></figure></li><li><p>返回值的初始化：<br>对于以下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X bar()&#123;</span><br><span class="line">x xx;</span><br><span class="line">&#x2F;&#x2F;....</span><br><span class="line">return xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为如下伪码：<br><img src="/picture/9afNxvP82DGHIso.jpg" alt="Alt"></p></li><li><p>NRV优化：</p><p>NRV(name returned value)优化大致如下，我觉得是通过把返回的临时变量变成一个引用形参来实现的；</p><p><img src="/picture/972snfWXvIZRYDM.jpg" alt="Alt"></p><p>NRV优化需要一个copy constructor,（最好是内联的提高效率)</p></li><li><p>最后探讨了copy constructor 要还是不要的问题，我觉得它的含义是，从速度角度来看，如果存在NRV优化的可能性，以及传值的要求，那么实现拷贝构造函数可以帮助实现这一点；</p></li></ul><p>同时实现拷贝构造函数准备使用memcpy，memset的时候要注意是否有虚函数或者含有虚基类，防止错误的改变内部的vtpr;</p><p>比如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/grnbpALH8OlUXVj.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/kgviWzxyEhc314V.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><h4 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h4><ul><li><p>必须使用成员初始化表的四种情况：</p><ol><li>当初始化一个reference member</li><li>当初始化一个const member;</li><li>当调用一个base class 的constructor，而它拥有一组参数的时候;</li><li>当调用一个member class的constructor，而它拥有一组参数的时候；</li></ol></li><li><p>使用的注意点：</p><ol><li>顺序问题，成员初始化表的初始化顺序是声明的顺序，因此如下代码会有bug:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">public:</span><br><span class="line">X(int val):j(val),i(j)&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实际执行的时候是先i(j)然后j(val)的；</p><p>另外成员初始化表在显式代码的前面，因此</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">public:</span><br><span class="line">X(int val):j(val)&#123;</span><br><span class="line">i&#x3D;j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  是合法的；</p><ul><li>本书不太建议在成员初始化表里面调用一个member function进行初始化，主要因为不清楚具体的依赖关系的问题；当然如下图的伪代码，这是合法的：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/ShYNvKdqGUbQTPt.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure><p>- </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深度探索c-对象模型2&quot;&gt;&lt;a href=&quot;#深度探索c-对象模型2&quot; class=&quot;headerlink&quot; title=&quot;深度探索c++对象模型2&quot;&gt;&lt;/a&gt;深度探索c++对象模型2&lt;/h2&gt;&lt;p&gt;这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度探索C++对象模型" scheme="http://Tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_478_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/25/leetcode478-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/25/leetcode478-m/</id>
    <published>2020-09-25T09:13:45.000Z</published>
    <updated>2020-09-25T09:20:28.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="478-在圆内随机生成点"><a href="#478-在圆内随机生成点" class="headerlink" title="478. 在圆内随机生成点"></a><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/" target="_blank" rel="noopener">478. 在圆内随机生成点</a></h4><p>难度中等37</p><p>给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 <code>randPoint</code> 。</p><p>说明:</p><ol><li>输入值和输出值都将是<a href="https://baike.baidu.com/item/浮点数/6162520" target="_blank" rel="noopener">浮点数</a>。</li><li>圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。</li><li>圆周上的点也认为是在圆中。</li><li><code>randPoint</code> 返回一个包含随机点的x坐标和y坐标的大小为2的数组。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[1,0,0],[],[],[]]</span><br><span class="line">输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[10,5,-7.5],[],[],[]]</span><br><span class="line">输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span><br></pre></td></tr></table></figure><p><strong>输入语法说明：</strong></p><p>输入是两个列表：调用成员函数名和调用的参数。<code>Solution</code> 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。<code>randPoint</code> 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。</p><p>C++11新特性,随机数库,不香嘛？</p><p><a href="https://blog.csdn.net/qq_23225317/article/details/79787543" target="_blank" rel="noopener">https://blog.csdn.net/qq_23225317/article/details/79787543</a></p><p>基本语法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::random_device rd;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line"><span class="comment">//e.seed(time(0));</span></span><br><span class="line"><span class="comment">//随机整数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="comment">//随机实数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">u2</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;u2(e)&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line"><span class="comment">//正态分布</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test normal distribution:\n"</span>;</span><br><span class="line">e.seed(time(<span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="built_in">std</span>::normal_distribution&lt;&gt; <span class="title">n</span><span class="params">(<span class="number">4</span>, <span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">vals</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">250</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v = lround(n(e));</span><br><span class="line">    <span class="keyword">if</span>(v &lt; vals.<span class="built_in">size</span>()) vals[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vals.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">string</span>(vals[i], <span class="string">'*'</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test normal distribution done.\n"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//伯努利分布</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test bernoulli distribution:\n"</span>;</span><br><span class="line">e.seed(time(<span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="built_in">std</span>::bernoulli_distribution <span class="title">b</span><span class="params">(<span class="number">0.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">bers</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b(e)) bers[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">else</span> bers[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"True: "</span>&lt;&lt;bers[<span class="number">1</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"False: "</span>&lt;&lt;bers[<span class="number">0</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test bernoulli distribution done.\n"</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/solution/zai-yuan-nei-sui-ji-sheng-cheng-dian-by-617076674/" target="_blank" rel="noopener">某一个题解</a>:</p><p>相信大部分人都没有看懂，我就来通俗地解释一下吧。</p><p>确定圆内一点，需要有相对于圆心的距离r，以及相对于圆心的角度angle。</p><p>一开始的想法，我们在[0, radius]中等概率取r，在[0, 2π)中等概率取angle即可实现圆内的随机分布。</p><p>事实上，这是不对的。</p><p>在[0, 2π)中等概率取angle，相对于把一个圆分成了无数个扇形，点落在每个扇形上的概率均相等。</p><p>假设某个扇形的圆心角是theta，那么该扇形的面积是0.5 <em> theta </em> radius ^ 2，分布在该扇形区域上的概率是theta / 2π，只要每个扇形的圆心角相等，扇形面积就是相等的，点在扇形中也是等概率的。</p><p>在[0, radius]中等概率取r，相当于把一个圆分成了无数个环形，点落在每个环形上的概率均相等。</p><p>假设某个环形的内径是r1，外径是r2，那么该环形的面积是π * (r2 ^ 2 - r1 ^ 2)。可见每个环形的面积是不一样的，显然每个环形上的点密度是不一样的。这样做会造成靠近圆心的点分布比较密集，远离圆心的点分布比较稀疏。</p><p>那么，如何取r使得点落在圆内任意区域的概率均相等呢？这样做显然会使得落在每个环形上的概率均不同，且环形面积较大的概率高，环形面积较小的概率小。</p><p>根据环形面积的计算公式：π * (r2 ^ 2 - r1 ^ 2)，落在该环形面积上的概率应为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)。</p><p>在[0, radius]中如何分布概率密度函数f(x)，可以使得f(x)其在[r1, r2]上的积分值为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)呢？</p><p>取f(x) = 2x / (radius ^ 2)可以满足上述条件，即半径r在[0, radius]上的概率密度函数应为f(x) = 2x / (radius ^ 2)，故只需要在[0, radius ^ 2]范围内等概率取r ^ 2，再开根号即得r值。（求一下导数即可，x ^ 2的导数是2x）</p><p>时间复杂度是和空间复杂度均是O(1)。</p><p><img src="/picture/image-jizuobiao.png" alt="image-20200925171304597"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">double</span> x_center,y_center;</span><br><span class="line">    <span class="keyword">double</span> _2pi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//极坐标:x=rcos(\theta),y=rsin(\theta)</span></span><br><span class="line">    Solution(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;radius=radius;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x_center=x_center;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y_center=y_center;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_2pi=<span class="built_in">acos</span>(<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(radius&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            random_device rd;</span><br><span class="line">            <span class="function">default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line">            uniform_real_distribution&lt;<span class="keyword">double</span>&gt;u1(<span class="number">0</span>,radius*radius);</span><br><span class="line">            uniform_real_distribution&lt;<span class="keyword">double</span>&gt;u2(<span class="number">0</span>,_2pi);<span class="comment">//acos(-1)*2=2\pi</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> r=<span class="built_in">sqrt</span>(u1(e));</span><br><span class="line">            <span class="keyword">double</span> theta=u2(e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> x=x_center+r*<span class="built_in">cos</span>(theta);</span><br><span class="line">            <span class="keyword">double</span> y=y_center+r*<span class="built_in">sin</span>(theta);</span><br><span class="line">            result.push_back(x);</span><br><span class="line">            result.push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * vector&lt;double&gt; param_1 = obj-&gt;randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;478-在圆内随机生成点&quot;&gt;&lt;a href=&quot;#478-在圆内随机生成点&quot; class=&quot;headerlink&quot; title=&quot;478. 在圆内随机生成点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generat
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
      <category term="随机采样" scheme="http://Tyler-ytr.github.io/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_18_m 四数之和</title>
    <link href="http://Tyler-ytr.github.io/2020/09/25/leetcode18-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/25/leetcode18-m/</id>
    <published>2020-09-25T08:19:56.000Z</published>
    <updated>2020-09-25T08:20:46.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><p>难度中等572</p><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数109,251</p><p>提交次数284,303</p><p>双指针法;主要要注意的是几个边界以及怎么去重的方法;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针法;</span></span><br><span class="line">        <span class="comment">//比O(n^4)的暴力减少了一些重复的内容;</span></span><br><span class="line">        <span class="comment">//算法是:固定a,b=a+1,然后c,d双指针遍历;然后b++……;然后b结束外层循环a++;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>&lt;<span class="number">4</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=<span class="built_in">size</span><span class="number">-4</span>;++a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;nums[a]==nums[a<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=a+<span class="number">1</span>;b&lt;=<span class="built_in">size</span><span class="number">-3</span>;++b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b&gt;a+<span class="number">1</span>&amp;&amp;nums[b]==nums[b<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                c=b+<span class="number">1</span>;</span><br><span class="line">                d=<span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(c&lt;d)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[a]+nums[b]+nums[c]+nums[d]&lt;target)&#123;</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[a]+nums[b]+nums[c]+nums[d]&gt;target)&#123;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.push_back(&#123;nums[a],nums[b],nums[c],nums[d]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c+<span class="number">1</span>])&#123;</span><br><span class="line">                            c++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d<span class="number">-1</span>])&#123;</span><br><span class="line">                            d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;18-四数之和&quot;&gt;&lt;a href=&quot;#18-四数之和&quot; class=&quot;headerlink&quot; title=&quot;18. 四数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic_knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>HDU_4734 F(x)</title>
    <link href="http://Tyler-ytr.github.io/2020/09/20/HDU-4734/"/>
    <id>http://Tyler-ytr.github.io/2020/09/20/HDU-4734/</id>
    <published>2020-09-20T12:19:26.000Z</published>
    <updated>2020-09-20T12:20:13.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-x"><a href="#F-x" class="headerlink" title="F(x)"></a><a href="https://vjudge.net/problem/HDU-4734" target="_blank" rel="noopener">F(x)</a></h2><p>For a decimal number x with n digits (AnAn-1An-2 … A2A1), we define its weight as F(x) = An <em> 2n-1 + An-1 </em> 2n-2 + … + A2 <em> 2 + A1 </em> 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A).</p><p>Input</p><p>The first line has a number T (T &lt;= 10000) , indicating the number of test cases.<br>For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109)</p><p>Output</p><p>For every case,you should output “Case #t: “ at first, without quotes. The <em>t</em> is the case number starting from 1. Then output the answer.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 100</span><br><span class="line">1 10</span><br><span class="line">5 100</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 2</span><br><span class="line">Case #3: 13</span><br></pre></td></tr></table></figure><p>最开始的思路肯定是搜索</p><p>首先是对数位的搜索</p><p>然后开始思考另外有什么状态是需要往下面传的，那么就只有前面数的和了，因此是二维的，第一维度是数位，第二个维度是sum;</p><p>然后思考记忆化,最直观的就是第二维度就是sum,但是这样子的话每一次都需要根据all进行修改;比较特别的是dp里面的sum记录的是all-sum的值,这样做可以有效的利用memset优化;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">12</span>][<span class="number">5005</span>];<span class="comment">//dp[pos][sum]:对于位置pos的数位,这里的sum存储的是all-当前pos前缀和的差;</span></span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> all;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">//计算F(a)的值</span></span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> able[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">while</span>(a)&#123;</span><br><span class="line">able[pos++]=a%<span class="number">10</span>;</span><br><span class="line">a/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//int now=1;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">result+=(able[i]&lt;&lt;i);</span><br><span class="line"><span class="comment">//now*=2;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"result:"&lt;&lt;result&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pos:当前的数位,sum 当前的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(pos&lt;0)return 1;合法;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sum,<span class="keyword">bool</span> limit)</span></span>&#123;<span class="comment">//这里的sum表示的是到目前数位的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>)<span class="keyword">return</span> sum&lt;=all;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;all)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!limit&amp;&amp;dp[pos][all-sum]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][all-sum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up=limit?cur[pos]:<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;++i)&#123;</span><br><span class="line"></span><br><span class="line">ans+=dfs(pos<span class="number">-1</span>,sum+i*(<span class="number">1</span>&lt;&lt;pos),limit&amp;&amp;cur[pos]==i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit)dp[pos][all-sum]=ans;</span><br><span class="line"><span class="comment">//cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;sum&lt;&lt;" "&lt;&lt;limit&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">//memset(cur,0,sizeof(cur));</span></span><br><span class="line"> all=f(a);</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line">cur[pos++]=b%<span class="number">10</span>;</span><br><span class="line">b/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i=pos-1;i&gt;=0;--i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;cur[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">int</span> result=dfs(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="comment">//cin&gt;&gt;a&gt;&gt;b;</span></span><br><span class="line"><span class="keyword">int</span> result=solve(a,b);</span><br><span class="line"><span class="comment">//printf("Case #%d: %d",i+1,result);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,i+<span class="number">1</span>,result);</span><br><span class="line"><span class="comment">//cout&lt;&lt;"Case #"&lt;&lt;i+1&lt;&lt;": "&lt;&lt;result&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;F-x&quot;&gt;&lt;a href=&quot;#F-x&quot; class=&quot;headerlink&quot; title=&quot;F(x)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-4734&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>HDU_2089 不要62</title>
    <link href="http://Tyler-ytr.github.io/2020/09/19/HDU-2089/"/>
    <id>http://Tyler-ytr.github.io/2020/09/19/HDU-2089/</id>
    <published>2020-09-19T12:40:05.000Z</published>
    <updated>2020-09-19T12:41:16.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a><a href="https://vjudge.net/problem/HDU-2089" target="_blank" rel="noopener">不要62</a></h2><p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p><p>Input</p><p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p><p>Output</p><p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 100</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80</span><br></pre></td></tr></table></figure><p>经典的数位dp题目,数位dp我参考了<a href="https://blog.csdn.net/wust_zzwh/article/details/52100392" target="_blank" rel="noopener">数位dp总结 之 从入门到模板</a>进行学习;总的来说的思想是对每一个数位进行枚举,然后辅之以记忆化搜索,以下是我根据板子做出来的结果;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos:数位,pre:前一位什么数,state:前一位是不是6,如果是6那么就是1,否则是0;limit:防止超过最大数;为true的时候表示上一个到顶了;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> state,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//枚举合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!limit&amp;&amp;dp[pos][state]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][state];<span class="comment">//记忆化;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up=limit?a[pos]:<span class="number">9</span>;<span class="comment">//如果limit成功,那么前面的没有到顶,因此可以到9,否则只能到这个数位的值,比如231,前面枚举到3的时候,最后一位只有1可以;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//计数;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">4</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(pre==<span class="number">6</span>&amp;&amp;i==<span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">ans+=dfs(pos<span class="number">-1</span>,i,i==<span class="number">6</span>,i==up&amp;&amp;limit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!limit)dp[pos][state]=ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//分解数位</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">a[pos]=n%<span class="number">10</span>;</span><br><span class="line">n/=<span class="number">10</span>;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result=dfs(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r &amp;&amp;(l!=<span class="number">0</span>||r!=<span class="number">0</span>))&#123;</span><br><span class="line"><span class="keyword">int</span> result=solve(r)-solve(l<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不要62&quot;&gt;&lt;a href=&quot;#不要62&quot; class=&quot;headerlink&quot; title=&quot;不要62&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-2089&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型1</title>
    <link href="http://Tyler-ytr.github.io/2020/09/10/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B1/"/>
    <id>http://Tyler-ytr.github.io/2020/09/10/深度探索C-对象模型1/</id>
    <published>2020-09-10T02:08:08.000Z</published>
    <updated>2020-09-10T02:30:37.240Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深度探索c-对象模型1"><a href="#深度探索c-对象模型1" class="headerlink" title="深度探索c++对象模型1"></a>深度探索c++对象模型1</h4><ul><li>C++的主要额外负担：<ul><li>virtual function 机制</li><li>virtual base class 用以实现“多次出现在继承体系中的base class，又一个单一而被共享的实例”</li><li>多重继承下的额外负担</li></ul></li></ul><h5 id="1-1-C-对象模式"><a href="#1-1-C-对象模式" class="headerlink" title="1.1 C++对象模式"></a>1.1 C++对象模式</h5><ul><li><p>C++对象模型</p><ul><li>非静态成员变量存放在每一个class object里面，静态成员变量存放在个别的class object 之外；静态函数，非静态函数成员放在个别的class object之外，虚函数特殊对待：<ul><li>每一个class 产生出一堆指向virtual function 的指针，放在表格中，这个表格称之为虚函数表（virtual table）</li><li>每一个class object被安插一个指针，指向相关的virtual table。通常这个指针称为$vtpr$.$vtpr$的设定由每一个class的constructor，destructor和copy assignment运算符自动完成。每一个class所关联的$tyle_info$ object(用来支持runtime type identification)也经由虚函数表纸出来，通常放在表格的第一个slot里面。<br>例子如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/nGapT7QCPUdiFhS.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></li></ul></li></ul></li><li><p>C++继承</p><ul><li>使用所谓的base table 模型。每一个class object内涵一个bptr,被初始化，指向它的base class table，然后这个表就如同虚函数表一样指向继承的类的对象，如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/u4XH1PLQEbrGwfv.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></li></ul></li><li><p>什么时候一个人应该使用struct 取代class？当它让一个人感觉比较好的时候（狗头）<br>聚合（composition）而非继承才是把C++和C结合起来的好方法。<br>struct在C++中的一个合理用途，是当你要传递一个“复杂的class object的全部或者部分”到某一个C函数去的时候，struct声明可以将数据封装起来，并且保证拥有与C兼容的空间布局，然而这种保证只在聚合（composition）的情况下存在。如果是继承的话，可能会因为内存布局原因无法实现想要的结果。</p></li><li><p>C++以下列方法支持多态：</p><ul><li>经过一组隐式的转化操作，比如把一个派生类的指针转化为一个指向它的public base type的指针：<br>shape *ps=new circle ();</li><li>经由virtual function机制：<br>ps-&gt;rotate（）</li><li>经由$dynamic_cast$和typeid运算符：<br>$if(circle <em>pc=dynami_cast &lt; circle</em>&gt;(ps))$</li></ul></li><li><p>需要多少内存才能够表现一个class object：</p><ul><li>非静态成员变量的总和大小</li><li>加上任何由于alignment（对齐）的需求而填补（padding）上去的空间</li><li>加上为了支持virtual而内部产生的任何额外负担</li></ul></li><li><p>关于指针：<br>不同类型的指针从内存需求的观点来看没有什么不同，“指向不同类型之各指针‘间的差异，既不在其指针表示法的不同，也不再其内容的不同，而是在其所寻址出来的object类型不同。也就是说，“指针类型”会教导编译器如何解释某一个特定地址的内存内容及其大小。</p></li><li><p>最后一部分内容讨论了多态发生的条件，我认为总结下来就是引用和指针可能触发多态，通过虚函数来实现。然后将子对象赋值给父类对象一般会导致切割，来放置数据溢出。</p></li><li><p>具体问题：</p><ul><li><p>一个Bear指针和一个ZooAnimal指针有什么不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal *pz&#x3D;&amp;b;</span><br><span class="line">Bear *pb&#x3D;&amp;;</span><br></pre></td></tr></table></figure><p>它们每一个都指向Bear object 的第一个type，它们的区别是：pb所涵盖的地址包含整个 Bear object但是pz所涵盖的地址之包含Bear object中的ZooAnimal subobject.<br>内存布局如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/hozFU6gL9ubjs54.jpg" alt="Alt" title="">                </div>                <div class="image-caption">Alt</div>            </figure></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;深度探索c-对象模型1&quot;&gt;&lt;a href=&quot;#深度探索c-对象模型1&quot; class=&quot;headerlink&quot; title=&quot;深度探索c++对象模型1&quot;&gt;&lt;/a&gt;深度探索c++对象模型1&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++的主要额外负担：&lt;ul&gt;
&lt;li&gt;virtua
      
    
    </summary>
    
      <category term="阅读笔记" scheme="http://Tyler-ytr.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度探索C++对象模型" scheme="http://Tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="C++" scheme="http://Tyler-ytr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode22-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode22-m/</id>
    <published>2020-09-07T01:28:58.000Z</published>
    <updated>2020-09-07T01:33:35.089Z</updated>
    
    <content type="html"><![CDATA[<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h4><p>难度中等1252收藏分享切换为英文关注反馈</p><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><p>通过次数166,462</p><p>提交次数218,996</p><p>一道经典的回溯算法的题目,lcnit表示左边括号的数目,rcnt表示右括号的数目;结束的条件是temp.size()==2*n,也就是满足长度;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="built_in">string</span> temp,<span class="keyword">int</span> lcnt,<span class="keyword">int</span> rcnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==maxn*<span class="number">2</span>)&#123;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lcnt&lt;maxn)&#123;</span><br><span class="line">            temp.push_back(<span class="string">'('</span>);</span><br><span class="line">            back_track(temp,lcnt+<span class="number">1</span>,rcnt);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rcnt&lt;lcnt)&#123;</span><br><span class="line">            temp.push_back(<span class="string">')'</span>);</span><br><span class="line">            back_track(temp,lcnt,rcnt+<span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        maxn=n;</span><br><span class="line">        back_track(temp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;22-括号生成&quot;&gt;&lt;a href=&quot;#22-括号生成&quot; class=&quot;headerlink&quot; title=&quot;22. 括号生成&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="栈" scheme="http://Tyler-ytr.github.io/tags/%E6%A0%88/"/>
    
      <category term="数据结构" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode134_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode134-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode134-m/</id>
    <published>2020-09-07T01:26:14.000Z</published>
    <updated>2020-09-07T01:28:25.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h4><p>难度中等243</p><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong> </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><hr><p>参考了一个数形结合的<a href="https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/" target="_blank" rel="noopener">题解</a></p><p>注意最小值的初始化问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> success=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tempsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tempsum=tempsum+gas[i]-cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tempsum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            success=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在起码可以环绕一圈，开始找起始点</span></span><br><span class="line">       <span class="comment">//我觉得如果可以跑的话就是一个逃税过程，如何逃掉更多的税呢？因为起始点起始相当于少交一次前面的税</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> gassum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> costsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_result=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           gassum+=gas[i];</span><br><span class="line">           costsum+=cost[i];</span><br><span class="line">            temp=gassum-costsum;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;min_result)&#123;</span><br><span class="line">                min_result=temp;</span><br><span class="line">                min_ans=i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (min_ans+<span class="number">1</span>)%n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;134-加油站&quot;&gt;&lt;a href=&quot;#134-加油站&quot; class=&quot;headerlink&quot; title=&quot;134. 加油站&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/gas-station/&quot; target=&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="贪心" scheme="http://Tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>poj2386</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/poj2386/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/poj2386/</id>
    <published>2020-09-07T01:24:14.000Z</published>
    <updated>2020-09-07T01:25:41.937Z</updated>
    
    <content type="html"><![CDATA[<p>Lake Counting</p><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 65536K</th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 59523</td><td></td><td><strong>Accepted:</strong> 28958</td></tr></tbody></table><p>Description</p><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.</p><p>Given a diagram of Farmer John’s field, determine how many ponds he has.</p><p>Input</p><p>* Line 1: Two space-separated integers: N and M</p><p>* Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.</p><p>Output</p><p>* Line 1: The number of ponds in Farmer John’s field.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>Hint</p><p>OUTPUT DETAILS:</p><p>There are three ponds: one in the upper left, one in the lower left,and one along the right side.</p><p>Source</p><p><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2004+November" target="_blank" rel="noopener">USACO 2004 November</a></p><p>题目大意: 计算出相连的’W’有多少块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> mapa[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    mapa[x][y]=<span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">int</span> tempx;</span><br><span class="line">    <span class="keyword">int</span> tempy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">            tempx=x+i;</span><br><span class="line">            tempy=y+j;</span><br><span class="line">            <span class="keyword">if</span>(tempx&gt;=<span class="number">0</span>&amp;&amp;tempx&lt;N&amp;&amp;tempy&gt;=<span class="number">0</span>&amp;&amp;tempy&lt;M&amp;&amp;mapa[tempx][tempy]==<span class="string">'W'</span>)&#123;</span><br><span class="line">                dfs(tempx,tempy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">  <span class="comment">// vector&lt;vector&lt;char&gt; &gt; map(N,(vector&lt;char&gt; (M)));</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">           <span class="keyword">char</span> temp;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">           mapa[i][j]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"here"&lt;&lt;endl;</span></span><br><span class="line">   <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(mapa[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">               dfs(i,j);</span><br><span class="line"><span class="comment">//               cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//               for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line"><span class="comment">//                   for(int j=0;j&lt;M;j++)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                       cout&lt;&lt;mapa[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//                   &#125;</span></span><br><span class="line"><span class="comment">//                   cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//               &#125;</span></span><br><span class="line">               cnt+=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lake Counting&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000MS&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Memory Limit:&lt;/strong&gt; 65536K&lt;/
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>poj1321 棋盘问题</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/poj1321/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/poj1321/</id>
    <published>2020-09-07T01:22:23.000Z</published>
    <updated>2020-09-07T01:23:35.759Z</updated>
    
    <content type="html"><![CDATA[<h4 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h4><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 10000K</th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 96005</td><td></td><td><strong>Accepted:</strong> 43758</td></tr></tbody></table><p>Description</p><p>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><p>Input</p><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p><p>Output</p><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Source</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;<span class="built_in">map</span>;</span><br><span class="line"><span class="comment">//vector&lt;bool&gt;line;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">clear</span>();</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> K;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;<span class="built_in">line</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == K) &#123;<span class="comment">//注意出递归的条件是cnt==K也就是找到这么多个</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=N)&#123;<span class="comment">//这里是为了防止遍历的行数超过边界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">line</span>[i]&amp;&amp;<span class="built_in">map</span>[j][i]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">true</span>;</span><br><span class="line">                cnt+=<span class="number">1</span>;</span><br><span class="line">                backtrace(j+<span class="number">1</span>,<span class="built_in">line</span>);</span><br><span class="line">                cnt-=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrace(j+<span class="number">1</span>,<span class="built_in">line</span>);<span class="comment">//遍历下一行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//vector&lt;string&gt;map;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;<span class="built_in">line</span>(<span class="number">9</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;<span class="built_in">cin</span>&gt;&gt;t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;t==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            N=n;</span><br><span class="line">            K=t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> a;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">                <span class="built_in">map</span>.push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtrace(<span class="number">0</span>,<span class="built_in">line</span>);</span><br><span class="line">           <span class="comment">// N=n;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">//                for(int j=0;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">//                cout&lt;&lt;map[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//cout结果;</span></span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:leetcode刷题表示所有的OJ题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;棋盘问题&quot;&gt;&lt;a href=&quot;#棋盘问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘问题&quot;&gt;&lt;/a&gt;棋盘问题&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000MS&lt;/th&gt;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode491_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode491-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode491-m/</id>
    <published>2020-09-07T01:18:16.000Z</published>
    <updated>2020-09-07T01:19:09.615Z</updated>
    
    <content type="html"><![CDATA[<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/" target="_blank" rel="noopener">491. 递增子序列</a></h4><p>难度中等88</p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p>通过次数7,099</p><p>提交次数14,688</p><p>使用回溯算法进行dfs;主要要和那道全排列进行比较和区分;</p><p>使用set可以减少重复(我感觉剪枝更快但是不好写)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            temp.push_back(nums[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+pos&gt;nums.<span class="built_in">size</span>()<span class="number">-1</span>||nums[i+pos]&lt;temp.back())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[pos+i]);</span><br><span class="line">                result.insert(temp);</span><br><span class="line">                dfs(nums,temp,pos+i);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//感觉是回溯算法做的;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">            dfs(nums,temp,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it=result.<span class="built_in">begin</span>();it!=result.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            ans.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;491-递增子序列&quot;&gt;&lt;a href=&quot;#491-递增子序列&quot; class=&quot;headerlink&quot; title=&quot;491. 递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-subse
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode386_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode386-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode386-m/</id>
    <published>2020-09-07T01:14:51.000Z</published>
    <updated>2020-09-07T01:15:17.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://leetcode-cn.com/problems/lexicographical-numbers/" target="_blank" rel="noopener">386. 字典序排数</a></h4><p>难度中等74</p><p>给定一个整数 <em>n</em>, 返回从 <em>1</em> 到 <em>n</em> 的字典顺序。</p><p>例如，</p><p>给定 <em>n</em> =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p><p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 <em>n</em> 小于等于 5,000,000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur*<span class="number">10</span>+i&gt;n)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dfs(cur*<span class="number">10</span>+i,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;++i)</span><br><span class="line">        dfs(i,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;386-字典序排数&quot;&gt;&lt;a href=&quot;#386-字典序排数&quot; class=&quot;headerlink&quot; title=&quot;386. 字典序排数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lexicographical-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode133_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode133-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode133-m/</id>
    <published>2020-09-07T01:12:57.000Z</published>
    <updated>2020-09-10T02:39:57.631Z</updated>
    
    <content type="html"><![CDATA[<h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><p>难度中等155</p><p>给你无向 <strong><a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/133_clone_graph_question-1599441241258.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/graph-1599441241260.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/graph-1-1599441241260.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<a href="https://baike.baidu.com/item/简单图/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><p>使用dfs+字典/哈希表 即可;重点需要学会的是C++map/unorder_map的使用count查询的操作,count返回0表示没有,1表示有;</p><p>递归+数组版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node*used[<span class="number">101</span>];</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素;</span></span><br><span class="line">        <span class="comment">//也可以不用Map 用一个Node*数组来表示;</span></span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(used[node-&gt;val])<span class="keyword">return</span> used[node-&gt;val];</span><br><span class="line">        Node*p=<span class="keyword">new</span> Node(node-&gt;val);<span class="comment">//创建拷贝结点;</span></span><br><span class="line">        used[node-&gt;val]=p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt;tp=node-&gt;neighbors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            p-&gt;neighbors.push_back(cloneGraph(tp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归+unorder_map版本;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;used;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素;</span></span><br><span class="line">        <span class="comment">//也可以不用Map 用一个Node*数组来表示;</span></span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(used.count(node))<span class="keyword">return</span> used[node];</span><br><span class="line">        Node*p=<span class="keyword">new</span> Node(node-&gt;val);<span class="comment">//创建拷贝结点;</span></span><br><span class="line">        used[node]=p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt;tp=node-&gt;neighbors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            p-&gt;neighbors.push_back(cloneGraph(tp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>map版本用map替换unorder_map即可;</p><p>其中速度:map慢于unorder_map慢于数组;</p><p>原因:(摘自一个<a href="https://leetcode-cn.com/problems/clone-graph/solution/dfsjie-ti-by-xiao-luo-ai-xue-xi/" target="_blank" rel="noopener">题解</a>):</p><p>map：</p><p>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高<br>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p><p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p><p>unordered_map：</p><p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><p>深度优先遍历的递归写法<br>1.发现新节点<br>1.如果没有操作该节点，就操作该节点，并将该节点的visit置1<br>1.1接着对该节点的neibor挨个遍历dfs函数<br>2.如果有操作就返回该节点或者pass</p><p>非递归版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;unordered_map&lt;Node*, Node*&gt;used;</span><br><span class="line">    Node* cloneGraph(Node* node) &#123;</span><br><span class="line">        if(!node)return node;</span><br><span class="line">        stack&lt;Node*&gt;S;</span><br><span class="line">        S.push(node);&#x2F;&#x2F;等同于 stack &lt;Node*&gt;S(&#123;node&#125;);</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt;used;</span><br><span class="line">        used[node] &#x3D; new Node(node-&gt;val);</span><br><span class="line">        Node* tmp;</span><br><span class="line">        while(!S.empty())&#123;</span><br><span class="line">            tmp &#x3D; S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            Node* r &#x3D; used[tmp];</span><br><span class="line">            vector&lt;Node*&gt;n&#x3D;tmp-&gt;neighbors;</span><br><span class="line">            for(int i&#x3D;0;i&lt;n.size();++i)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果这个节点之前已经遍历到，就把他的复制加到链表中</span><br><span class="line">            &#x2F;&#x2F;没有遍历过就复刻该节点，加入map，加入neighbor</span><br><span class="line">                Node*cur&#x3D;n[i];</span><br><span class="line">                if(!used.count(cur))&#123;</span><br><span class="line">                    Node*t&#x3D;new Node(cur-&gt;val);</span><br><span class="line">                    used[cur]&#x3D;t;</span><br><span class="line">                    S.push(cur);</span><br><span class="line">                &#125;</span><br><span class="line">                r-&gt;neighbors.push_back(used[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return used[node];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;133-克隆图&quot;&gt;&lt;a href=&quot;#133-克隆图&quot; class=&quot;headerlink&quot; title=&quot;133. 克隆图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/clone-graph/&quot; target=&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode131_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode131-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode131-m/</id>
    <published>2020-09-07T01:10:18.000Z</published>
    <updated>2020-09-07T01:10:48.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><p>难度中等471</p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><p>dfs 递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> higher)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> temp=root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;=lower||temp&gt;=higher)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,LONG_MIN,LONG_MAX);</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;98. 验证二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-bina
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode98_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode98-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode98-m/</id>
    <published>2020-09-07T01:05:19.000Z</published>
    <updated>2020-09-07T01:05:49.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><p>难度中等471</p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><p>dfs 递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> higher)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> temp=root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;=lower||temp&gt;=higher)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,LONG_MIN,LONG_MAX);</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;98. 验证二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-bina
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode51_h</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode51-h/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode51-h/</id>
    <published>2020-09-07T01:00:57.000Z</published>
    <updated>2020-09-10T02:41:34.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></h4><p>难度困难377</p><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/8-queens-1599440478541.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//行列; 本质上还是回溯法</span></span><br><span class="line">    <span class="comment">//逐个行来扫描,这一行确定了之后就删除一些状态</span></span><br><span class="line">   <span class="comment">//三个需要验证的合法性:</span></span><br><span class="line">   <span class="comment">//列,两个对角线:</span></span><br><span class="line">   <span class="comment">//line,incline1,incline2</span></span><br><span class="line">   <span class="comment">//按行遍历,如果这列ok 就line[i]=1</span></span><br><span class="line">   <span class="comment">//0x0x</span></span><br><span class="line">   <span class="comment">//x1xx (1,1)(0,0)(2,2)(3,3) 发现abs(j-i)是相同的;因此j-i+N 相同(这样确保大于0))</span></span><br><span class="line">   <span class="comment">//0x0x (1,1)(0,2)(3,0) 发现对角线上面i+j是相同的</span></span><br><span class="line">   <span class="comment">//xxx0</span></span><br><span class="line">   <span class="comment">//所以每次更新的时候都是line[i]=true,incline[i+j]=true,incline[j-i+N]=true;</span></span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;result;<span class="comment">//用来保存;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp;track,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;<span class="built_in">line</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;incline1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;incline2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==N)&#123;</span><br><span class="line">            <span class="comment">//递归结束</span></span><br><span class="line">            <span class="built_in">string</span> a=<span class="string">""</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;N;p++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(track[p][k])&#123;</span><br><span class="line">                        a.push_back(<span class="string">'Q'</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        a.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                b.push_back(a);</span><br><span class="line">                a.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">line</span>[i]&amp;&amp;!incline1[i+j]&amp;&amp;!incline2[j-i+N])&#123;</span><br><span class="line">                    <span class="built_in">line</span>[i]=<span class="literal">true</span>;</span><br><span class="line">                    incline1[i+j]=<span class="literal">true</span>;</span><br><span class="line">                    incline2[j-i+N]=<span class="literal">true</span>;</span><br><span class="line">                    track[j][i]=<span class="literal">true</span>;</span><br><span class="line">                    place(j+<span class="number">1</span>,track,<span class="built_in">line</span>,incline1,incline2);</span><br><span class="line">                    <span class="built_in">line</span>[i]=<span class="literal">false</span>;</span><br><span class="line">                    incline1[i+j]=<span class="literal">false</span>;</span><br><span class="line">                    incline2[j-i+N]=<span class="literal">false</span>;</span><br><span class="line">                    track[j][i]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;incline1(<span class="number">2</span>*n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;incline2(<span class="number">2</span>*n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;<span class="built_in">line</span>(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">track</span><span class="params">(n,<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        N=n;</span><br><span class="line">        place(<span class="number">0</span>,track,<span class="built_in">line</span>,incline1,incline2);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;51-N皇后&quot;&gt;&lt;a href=&quot;#51-N皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N皇后&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="回溯法" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode46_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode46-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode46-m/</id>
    <published>2020-09-07T00:59:34.000Z</published>
    <updated>2020-09-07T01:00:11.014Z</updated>
    
    <content type="html"><![CDATA[<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46 Permutations"></a>46 Permutations</h4><p>Medium</p><p>333697Add to ListShare</p><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;<span class="comment">//表示这个解遇到过了;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;track,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//index记录vis的编号;</span></span><br><span class="line">        <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.push_back(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没有访问过;</span></span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                track.push_back(nums[i]);</span><br><span class="line">                backtrace(nums,track,index+<span class="number">1</span>);</span><br><span class="line">                track.pop_back();</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        backtrace(nums,track,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;46-Permutations&quot;&gt;&lt;a href=&quot;#46-Permutations&quot; class=&quot;headerlink&quot; title=&quot;46 Permutations&quot;&gt;&lt;/a&gt;46 Permutations&lt;/h4&gt;&lt;p&gt;Medium&lt;/p&gt;
&lt;p&gt;3336
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="回溯法" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124_h</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode124-h/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode124-h/</id>
    <published>2020-09-07T00:58:16.000Z</published>
    <updated>2020-09-07T00:59:07.992Z</updated>
    
    <content type="html"><![CDATA[<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h4><p>难度困难510</p><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//用一个maxm来缓存对于某一个根节点的状态;</span></span><br><span class="line"> <span class="comment">//dfs过程中返回给上层应该是最大的一边;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxm=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="built_in">max</span>(<span class="number">0</span>,dfs(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right=<span class="built_in">max</span>(<span class="number">0</span>,dfs(root-&gt;right));</span><br><span class="line">        maxm=<span class="built_in">max</span>(maxm,root-&gt;val+left+right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left+root-&gt;val,right+root-&gt;val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs解决该题,使用maxm缓存最大的结点处于的状态;dfs到某一个结点的时候,该节点返回给上一层:该节点值,该结点值+左值,该节点的值+右值的最大值;</p><p>对于空节点,返回0,表示对原来的结点没有贡献;</p><p>对于负值,和0比较取max的步骤表示如果有一边是负的那么就不做贡献,和空节点没有区别;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;124-二叉树中的最大路径和&quot;&gt;&lt;a href=&quot;#124-二叉树中的最大路径和&quot; class=&quot;headerlink&quot; title=&quot;124. 二叉树中的最大路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/b
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode690_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode690-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode690-s/</id>
    <published>2020-09-07T00:56:33.000Z</published>
    <updated>2020-09-07T00:57:39.829Z</updated>
    
    <content type="html"><![CDATA[<h4 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">690. 员工的重要性</a></h4><p>难度简单88</p><p>给定一个保存员工信息的数据结构，它包含了员工<strong>唯一的id</strong>，<strong>重要度</strong> 和 <strong>直系下属的id</strong>。</p><p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于<strong>并不是直系</strong>下属，因此没有体现在员工1的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出: 11</span><br><span class="line">解释:</span><br><span class="line">员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 &#x3D; 11。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>一个员工最多有一个<strong>直系</strong>领导，但是可以有多个<strong>直系</strong>下属</li><li>员工数量不超过2000。</li></ol><p>通过次数13,683</p><p>提交次数23,456</p><p>重要的是先进行的hash操作,运用了unorder_map结构体,极大的简化了dfs的操作;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> importance;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Employee*&gt;mp;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        result+=mp[id]-&gt;importance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp[id]-&gt;subordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            dfs(mp[id]-&gt;subordinates[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希:</span></span><br><span class="line">        <span class="keyword">for</span>(Employee* tmp:employees)&#123;</span><br><span class="line">            mp[tmp-&gt;id]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行dfs;</span></span><br><span class="line">        dfs(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BFS版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    int importance;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//     unordered_map&lt;int, Employee*&gt; mp;</span></span><br><span class="line"><span class="comment">//     int ans = 0;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span></span><br><span class="line"><span class="comment">//         for (auto&amp; e : employees) </span></span><br><span class="line"><span class="comment">//             mp[e-&gt;id] = e;</span></span><br><span class="line"><span class="comment">//         dfs(id);</span></span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     void dfs(int id) &#123;</span></span><br><span class="line"><span class="comment">//         ans += mp[id]-&gt;importance;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; mp[id]-&gt;subordinates.size(); ++i) </span></span><br><span class="line"><span class="comment">//             dfs(mp[id]-&gt;subordinates[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Employee*&gt;mp;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希:</span></span><br><span class="line">        <span class="keyword">for</span>(Employee* tmp:employees)&#123;</span><br><span class="line">            mp[tmp-&gt;id]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行bfs</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(id);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            result+=mp[temp]-&gt;importance;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp[temp]-&gt;subordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">                q.push(mp[temp]-&gt;subordinates[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;690-员工的重要性&quot;&gt;&lt;a href=&quot;#690-员工的重要性&quot; class=&quot;headerlink&quot; title=&quot;690. 员工的重要性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/employee-impo
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode199-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode199-m/</id>
    <published>2020-09-07T00:53:29.000Z</published>
    <updated>2020-09-07T00:54:31.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h4><p>难度中等186</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><p>通过次数29,576</p><p>提交次数46,105</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="comment">//    1</span></span><br><span class="line">        <span class="comment">//2        3</span></span><br><span class="line">        <span class="comment">//   5         4</span></span><br><span class="line">        <span class="comment">//广度优先搜索，当q里面只有最右边一个元素的时候把这个元素加入到输出的队列里面;</span></span><br><span class="line">       <span class="comment">// if(root==nullptr)&#123;return NULL&#125;;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> result;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;<span class="comment">//先进先出</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">           <span class="comment">// TreeNode*temp=q.front();</span></span><br><span class="line">        <span class="comment">//关键点: 用len记录q的size;通过这个来获得最右侧的点;</span></span><br><span class="line">            <span class="keyword">int</span> len=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode*temp=q.front();</span><br><span class="line">                <span class="keyword">if</span>(i==len<span class="number">-1</span>)&#123;</span><br><span class="line">                    result.push_back(temp-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;199-二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199. 二叉树的右视图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tre
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode101_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode101-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode101-s/</id>
    <published>2020-09-07T00:51:12.000Z</published>
    <updated>2020-09-07T00:53:08.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h4><p>难度简单 </p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><p>BFS的板子题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">                root = q.front(); q.pop();</span><br><span class="line">                v[i] = root ? root-&gt;val : INT_MIN;</span><br><span class="line">                <span class="keyword">if</span>(root) &#123; q.push(root-&gt;left); q.push(root-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否回文</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="built_in">size</span>/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i] != v[<span class="built_in">size</span><span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;101-对称二叉树&quot;&gt;&lt;a href=&quot;#101-对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;101. 对称二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/symmetric-tree/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode200_m</title>
    <link href="http://Tyler-ytr.github.io/2020/09/07/leetcode200-m/"/>
    <id>http://Tyler-ytr.github.io/2020/09/07/leetcode200-m/</id>
    <published>2020-09-07T00:49:14.000Z</published>
    <updated>2020-09-07T00:50:53.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>难度中等515</p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><p>解法1:BFS 遍历每一个点,遇到1就bfs并且把bfs到的1变成0;记录bfs的次数即可：</p><p>测试数据竟然有空集，这样会导致int maxn=map[0].size();//列数; 出现runtime error神必报错我tm……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//感觉可以bfs</span></span><br><span class="line">        <span class="comment">//遍历map的每一个点,如果map[i][j]是1,进行bfs,遇到1的变成0;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;<span class="built_in">map</span>(grid);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//m*n;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxm=<span class="built_in">map</span>.<span class="built_in">size</span>();<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">if</span>(maxm==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//对付空集的神必特判</span></span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="built_in">map</span>[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列数;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxm;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    cnt+=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">                    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp;</span><br><span class="line">                    temp.first=i;</span><br><span class="line">                    temp.second=j;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                    <span class="built_in">map</span>[i][j]=<span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;cur=q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        <span class="keyword">int</span> tempi=cur.first;</span><br><span class="line">                        <span class="keyword">int</span> tempj=cur.second;</span><br><span class="line">                        <span class="keyword">if</span>(tempi<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">map</span>[tempi<span class="number">-1</span>][tempj]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi<span class="number">-1</span>;</span><br><span class="line">                            temp2.second=tempj;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi<span class="number">-1</span>][tempj]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempi+<span class="number">1</span>&lt;maxm&amp;&amp;<span class="built_in">map</span>[tempi+<span class="number">1</span>][tempj]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi+<span class="number">1</span>;</span><br><span class="line">                            temp2.second=tempj;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi+<span class="number">1</span>][tempj]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempj<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">map</span>[tempi][tempj<span class="number">-1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi;</span><br><span class="line">                            temp2.second=tempj<span class="number">-1</span>;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi][tempj<span class="number">-1</span>]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tempj+<span class="number">1</span>&lt;maxn&amp;&amp;<span class="built_in">map</span>[tempi][tempj+<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp2;</span><br><span class="line">                            temp2.first=tempi;</span><br><span class="line">                            temp2.second=tempj+<span class="number">1</span>;</span><br><span class="line">                            q.push(temp2);</span><br><span class="line">                            <span class="built_in">map</span>[tempi][tempj+<span class="number">1</span>]=<span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;200-岛屿数量&quot;&gt;&lt;a href=&quot;#200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;200. 岛屿数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode705_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode705-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode705-s/</id>
    <published>2020-09-06T08:26:54.000Z</published>
    <updated>2020-09-06T08:27:25.744Z</updated>
    
    <content type="html"><![CDATA[<h4 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705. 设计哈希集合"></a><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></h4><p>难度简单40</p><p>不使用任何内建的哈希表库设计一个哈希集合</p><p>具体地说，你的设计应该包含以下的功能</p><ul><li><code>add(value)</code>：向哈希集合中插入一个值。</li><li><code>contains(value)</code> ：返回哈希集合中是否存在这个值。</li><li><code>remove(value)</code>：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);         </span><br><span class="line">hashSet.add(2);         </span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; 返回 true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; 返回 false (未找到)</span><br><span class="line">hashSet.add(2);          </span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; 返回 true</span><br><span class="line">hashSet.remove(2);          </span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; 返回  false (已经被删除)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>所有的值都在 <code>[0, 1000000]</code>的范围内。</li><li>操作的总数目在<code>[1, 10000]</code>范围内。</li><li>不要使用内建的哈希集合库。</li></ul><p>通过次数11,949</p><p>提交次数21,319</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node* next;</span><br><span class="line">        Node(<span class="keyword">int</span> val):val(val),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; arr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">101</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet() &#123;</span><br><span class="line">        arr=<span class="built_in">vector</span>&lt;Node*&gt;(len,<span class="keyword">new</span> Node(<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">        Node*temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)<span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span>(!(temp-&gt;next))&#123;</span><br><span class="line">                    Node*node=<span class="keyword">new</span> Node(key);</span><br><span class="line">                    temp-&gt;next=node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 temp = temp -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp-&gt;val=key;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         int haval = key % len;</span></span><br><span class="line"><span class="comment">//         Node* temp = arr[haval];</span></span><br><span class="line"><span class="comment">//         if(temp -&gt; val != -1)&#123;</span></span><br><span class="line"><span class="comment">//             while(temp)&#123;</span></span><br><span class="line"><span class="comment">//                 if(temp -&gt; val == key)&#123;</span></span><br><span class="line"><span class="comment">//                     temp -&gt; val = -1;</span></span><br><span class="line"><span class="comment">//                     return;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 temp = temp -&gt; next;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">        Node*temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)&#123;</span><br><span class="line">                    temp-&gt;val=<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> addr=key%len;</span><br><span class="line">       Node* temp=arr[addr];</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;val==key)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;705-设计哈希集合&quot;&gt;&lt;a href=&quot;#705-设计哈希集合&quot; class=&quot;headerlink&quot; title=&quot;705. 设计哈希集合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/design-hashse
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://Tyler-ytr.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode67_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode67-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode67-s/</id>
    <published>2020-09-06T08:25:13.000Z</published>
    <updated>2020-09-06T08:25:28.838Z</updated>
    
    <content type="html"><![CDATA[<h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></h4><p>难度简单398</p><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li></ul><p>模拟题,用j来从后往前遍历;</p><p>一开始搞错的原因是因为忘记在result.push_back之后加上temp=0了,佛佛佛</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m=b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="built_in">max</span>(n,m);</span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;<span class="comment">//处理进位</span></span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n-j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp+=(<span class="keyword">int</span>)(a[n-j<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m-j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp+=(<span class="keyword">int</span>)(b[m-j<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        temp+=out;</span><br><span class="line">        out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            temp-=<span class="number">2</span>;</span><br><span class="line">            out=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        temp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(out==<span class="number">1</span>)&#123;</span><br><span class="line">        result.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=result.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            res=res+<span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;res=res+<span class="string">'0'</span>;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;67-二进制求和&quot;&gt;&lt;a href=&quot;#67-二进制求和&quot; class=&quot;headerlink&quot; title=&quot;67. 二进制求和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-binary/&quot; target
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode14_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode14-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode14-s/</id>
    <published>2020-09-06T07:58:44.000Z</published>
    <updated>2020-09-06T08:24:53.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h4><p>难度简单1079</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p>模拟题实锤,纵向比较,重点是要掌握string的substr方法;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//纵向扫描;</span></span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length=strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i]!=c||i==strs[j].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,cnt); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;14-最长公共前缀&quot;&gt;&lt;a href=&quot;#14-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;14. 最长公共前缀&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-p
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode892_s</title>
    <link href="http://Tyler-ytr.github.io/2020/09/06/leetcode892-s/"/>
    <id>http://Tyler-ytr.github.io/2020/09/06/leetcode892-s/</id>
    <published>2020-09-06T07:56:59.000Z</published>
    <updated>2020-09-06T07:58:20.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a><a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">892. 三维形体的表面积</a></h4><p>难度简单90</p><p>在 <code>N * N</code> 的网格上，我们放置一些 <code>1 * 1 * 1</code> 的立方体。</p><p>每个值 <code>v = grid[i][j]</code> 表示 <code>v</code> 个正方体叠放在对应单元格 <code>(i, j)</code> 上。</p><p>请你返回最终形体的表面积。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= N &lt;= 50</code></li><li><code>0 &lt;= grid[i][j] &lt;= 50</code></li></ul><hr><p>一道模拟题，题目意思很难懂</p><p>第一个示例的意思是 0,0这个位置有一个高度为2的立方体；</p><p>第二个示例的意思是 0,0 高度为1;0,1 高度为2…………</p><p>主要解法是找到一个求解表面积的公式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    result+=<span class="number">2</span>+<span class="number">4</span>*grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i<span class="number">-1</span>][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result-=<span class="built_in">min</span>(grid[i<span class="number">-1</span>][j],grid[i][j])*<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(grid[i][j<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result-=<span class="built_in">min</span>(grid[i][j<span class="number">-1</span>],grid[i][j])*<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;892-三维形体的表面积&quot;&gt;&lt;a href=&quot;#892-三维形体的表面积&quot; class=&quot;headerlink&quot; title=&quot;892. 三维形体的表面积&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/surface
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="模拟" scheme="http://Tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于windows密钥登录服务器</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/cmd_vs_rsa/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/cmd_vs_rsa/</id>
    <published>2020-09-04T06:56:33.000Z</published>
    <updated>2020-09-04T07:05:55.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于windows密钥登录服务器"><a href="#关于windows密钥登录服务器" class="headerlink" title="关于windows密钥登录服务器"></a>关于windows密钥登录服务器</h2><p>前言:windows的权限管理太屑了</p><p>参考<a href="https://blog.csdn.net/joshua2011/article/details/90208741" target="_blank" rel="noopener">https://blog.csdn.net/joshua2011/article/details/90208741</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于windows密钥登录服务器&quot;&gt;&lt;a href=&quot;#关于windows密钥登录服务器&quot; class=&quot;headerlink&quot; title=&quot;关于windows密钥登录服务器&quot;&gt;&lt;/a&gt;关于windows密钥登录服务器&lt;/h2&gt;&lt;p&gt;前言:windows的权限管
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows配置" scheme="http://Tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>DNS刷新</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/DNS%E5%88%B7%E6%96%B0/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/DNS刷新/</id>
    <published>2020-09-04T06:56:33.000Z</published>
    <updated>2020-09-10T02:36:02.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS刷新"><a href="#DNS刷新" class="headerlink" title="DNS刷新"></a>DNS刷新</h2><p>垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中心的工程师打完电话之后发现是自己电脑DNS的问题，因此bing搜索，发现了如下的方法进行DNS的刷新:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netsh int ip reset </span><br><span class="line">netsh winsock reset</span><br><span class="line">ipconfig&#x2F;flushdns </span><br><span class="line">重启</span><br></pre></td></tr></table></figure><p>然后报错从dns probe finished no Internet变成了<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200904150200196.png" alt="image-20200904150200196" title="">                </div>                <div class="image-caption">image-20200904150200196</div>            </figure></p><p>佛了</p><p>面对不知道咋整的东西，那就选择重装系列：</p><p>右击<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200904184552395.png" alt="image-20200904184552395" title="">                </div>                <div class="image-caption">image-20200904184552395</div>            </figure>然后点击网络重置 好像就行了？！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DNS刷新&quot;&gt;&lt;a href=&quot;#DNS刷新&quot; class=&quot;headerlink&quot; title=&quot;DNS刷新&quot;&gt;&lt;/a&gt;DNS刷新&lt;/h2&gt;&lt;p&gt;垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中
      
    
    </summary>
    
      <category term="电脑配置" scheme="http://Tyler-ytr.github.io/categories/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="windows配置" scheme="http://Tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>wishlist_together</title>
    <link href="http://Tyler-ytr.github.io/2020/09/04/wishlist-together/"/>
    <id>http://Tyler-ytr.github.io/2020/09/04/wishlist-together/</id>
    <published>2020-09-04T02:18:35.000Z</published>
    <updated>2020-09-04T02:19:22.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-wishlist"><a href="#2020-wishlist" class="headerlink" title="2020 wishlist"></a>2020 wishlist</h2><ul><li>一起去鬼屋</li><li>一起去迪士尼</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2020-wishlist&quot;&gt;&lt;a href=&quot;#2020-wishlist&quot; class=&quot;headerlink&quot; title=&quot;2020 wishlist&quot;&gt;&lt;/a&gt;2020 wishlist&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一起去鬼屋&lt;/li&gt;
&lt;li&gt;一起去迪士
      
    
    </summary>
    
      <category term="wishlist" scheme="http://Tyler-ytr.github.io/categories/wishlist/"/>
    
    
      <category term="wishlist" scheme="http://Tyler-ytr.github.io/tags/wishlist/"/>
    
  </entry>
  
  <entry>
    <title>leetcode4_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode4-h/</id>
    <published>2020-08-31T14:55:42.000Z</published>
    <updated>2020-08-31T14:58:35.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>难度困难2695</p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    #二分法,对于arr1,arr2,k:令x=k<span class="comment">//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小;</span></span><br><span class="line">    #注意处理边界</span><br><span class="line">    def findkthelement(self,arr1:List[<span class="keyword">int</span>],arr2:List[<span class="keyword">int</span>],k)-&gt;<span class="keyword">float</span>:</span><br><span class="line">        len1=len(arr1)</span><br><span class="line">        len2=len(arr2)</span><br><span class="line">        <span class="keyword">if</span> len1&gt;len2:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr2,arr1,k)</span><br><span class="line">            ##确保arr1是短的一边;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr1:</span><br><span class="line">            #arr1为空,递归结束</span><br><span class="line">            <span class="keyword">return</span> arr2[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            #返回最小的元素</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(arr1[<span class="number">0</span>],arr2[<span class="number">0</span>])</span><br><span class="line">        x=k<span class="comment">//2</span></span><br><span class="line">        i=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len1)<span class="number">-1</span>) #arr1的边界;因为是数组所以要减一,代表有i+<span class="number">1</span>个元素</span><br><span class="line">        j=<span class="keyword">int</span>(<span class="built_in">min</span>(x,len2)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr1[i]&lt;arr2[j]:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1[i+<span class="number">1</span>:],arr2,k-i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findkthelement(arr1,arr2[j+<span class="number">1</span>:],k-j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    def findMedianSortedArrays(self, nums1: List[<span class="keyword">int</span>], nums2: List[<span class="keyword">int</span>]) -&gt; <span class="keyword">float</span>:</span><br><span class="line">        len1=len(nums1)</span><br><span class="line">        len2=len(nums2)</span><br><span class="line">        #考虑中位数的奇偶问题</span><br><span class="line">        mid1=(len1+len2+<span class="number">1</span>)<span class="comment">//2</span></span><br><span class="line">        mid2=(len1+len2+<span class="number">2</span>)<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span>(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;4. 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/m
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="二分" scheme="http://Tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode990_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode990-m/</id>
    <published>2020-08-31T14:28:06.000Z</published>
    <updated>2020-08-31T14:28:32.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></h4><p>难度中等73</p><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li><li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">            p[x]=find_set(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//图的连通性问题---并查集</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//==就合并;</span></span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1!=fx2)&#123;</span><br><span class="line">                    p[fx1]=p[fx2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> x2=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> fx1=find_set(x1);</span><br><span class="line">                <span class="keyword">int</span> fx2=find_set(x2);</span><br><span class="line">                <span class="keyword">if</span>(fx1==fx2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        parent.resize(26);</span><br><span class="line">        iota(parent.begin(), parent.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int index) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; parent[index]) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[index] &#x3D; find(parent[index]);</span><br><span class="line">        return parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int index1, int index2) &#123;</span><br><span class="line">        parent[find(index1)] &#x3D; find(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        UnionFind uf;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                uf.unite(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123;</span><br><span class="line">                int index1 &#x3D; str[0] - &#39;a&#39;;</span><br><span class="line">                int index2 &#x3D; str[3] - &#39;a&#39;;</span><br><span class="line">                if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;990-等式方程的可满足性&quot;&gt;&lt;a href=&quot;#990-等式方程的可满足性&quot; class=&quot;headerlink&quot; title=&quot;990. 等式方程的可满足性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sati
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode547_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode547-m/</id>
    <published>2020-08-31T14:23:59.000Z</published>
    <updated>2020-09-10T02:42:05.980Z</updated>
    
    <content type="html"><![CDATA[<h4 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></h4><p>难度中等255</p><p>班上有 <strong>N</strong> 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 <strong>N * N</strong> 的矩阵 <strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>N 在[1,200]的范围内。</li><li>对于所有学生，有M[i][i] = 1。</li><li>如果有M[i][j] = 1，则有M[j][i] = 1。</li></ol><p>通过次数47,496</p><p>提交次数83,180</p><p><strong>并查集版本</strong></p><p>改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前;</p><p>还有就是find函数的条件是$x==f[x]$ 别搞错了;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dis_set</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">//int f[205];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f;</span><br><span class="line">        dis_set(<span class="keyword">int</span> x)&#123;</span><br><span class="line">           <span class="comment">// this-&gt;n=205;</span></span><br><span class="line">            <span class="comment">//f.resize(this-&gt;n);</span></span><br><span class="line">            <span class="comment">//iota(f.begin(),f.end(),0);</span></span><br><span class="line">            n=x;</span><br><span class="line">            f.resize(x+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;n;i++)&#123;</span><br><span class="line">                f[i]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==f[x])&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">                f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">                <span class="keyword">return</span> f[x];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> roota=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> rootb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(roota==rootb)<span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">this</span>-&gt;n--;</span><br><span class="line">            f[roota]=rootb;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">struct dis_set <span class="title">cur</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[<span class="number">0</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    cur.unite(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.count();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[id]==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vis[id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M[id].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[id][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                dfs(i,M);               </span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        vis.resize(n);</span><br><span class="line">       <span class="comment">// iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i,M);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> bfs 版本的解法:</p><p>注意vis[j]=1那句,很重要;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200617203349985-1598883847362.png" alt="image-20200617203349985" title="">                </div>                <div class="image-caption">image-20200617203349985</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我感觉可以并查集,然后对每一个同学查询?</span></span><br><span class="line">        <span class="comment">//实际上还可以用dfs做,用vis记录已经访问过的结点;</span></span><br><span class="line">        <span class="comment">//还可以用bfs做;同样用vis记录没有访问过的结点;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span>  cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">                Q.push(i);</span><br><span class="line">                <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> top=Q.front();</span><br><span class="line">                    Q.pop();</span><br><span class="line">                    vis[top]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M[top].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[top][j]==<span class="number">1</span>&amp;&amp;vis[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                            Q.push(j);</span><br><span class="line">                             vis[j]=<span class="number">1</span>;<span class="comment">//这句很重要,如果没有这句会慢很多;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;547-朋友圈&quot;&gt;&lt;a href=&quot;#547-朋友圈&quot; class=&quot;headerlink&quot; title=&quot;547. 朋友圈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/friend-circles/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="BFS" scheme="http://Tyler-ytr.github.io/tags/BFS/"/>
    
      <category term="搜索" scheme="http://Tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="图论" scheme="http://Tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="http://Tyler-ytr.github.io/tags/DFS/"/>
    
      <category term="union-find" scheme="http://Tyler-ytr.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>leetcode94_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode94-m/</id>
    <published>2020-08-31T14:11:42.000Z</published>
    <updated>2020-09-10T02:42:55.622Z</updated>
    
    <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>难度中等614</p><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>通过次数210,162</p><p>提交次数290,172</p><p>递归版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sol(root-&gt;left,nums);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        sol(root-&gt;right,nums);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        sol(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代版本如下:</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt;S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line"></span><br><span class="line">    TreeNode*cur=root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!S.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            S.push(cur);</span><br><span class="line">            cur=cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=S.top();</span><br><span class="line">        result.push_back(cur-&gt;val);</span><br><span class="line">        S.pop();</span><br><span class="line">        cur=cur-&gt;right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。</span></span><br><span class="line"><span class="comment">        # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。</span></span><br><span class="line"><span class="comment">        # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200809090152414-1598883215929.png" alt="image-20200809090152414" title="">                </div>                <div class="image-caption">image-20200809090152414</div>            </figure><p>以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tre
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="树" scheme="http://Tyler-ytr.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题51_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9851-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题51-h/</id>
    <published>2020-08-31T14:10:23.000Z</published>
    <updated>2020-09-10T02:43:42.369Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></h4><p>难度困难90</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure><p>当然二重for循环暴力可以解决，但是会超时；</p><p>实际上是一道二分思想的归并排序题目</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200424130136282-1598883032345.png" alt="image-20200424130136282" title="">                </div>                <div class="image-caption">image-20200424130136282</div>            </figure><p>对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;temp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> tempresult=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int mid=(l+r)/2;</span></span><br><span class="line">        <span class="keyword">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);<span class="comment">//防止l,r过大的时候溢出</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)&gt;&gt;1; 最快</span></span><br><span class="line">        tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">                tempresult+=mid-i+<span class="number">1</span>;<span class="comment">//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line">        <span class="keyword">return</span> tempresult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//居然是归并排序</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">            temp.resize((<span class="keyword">int</span>)nums.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            result=mergesort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题51-数组中的逆序对&quot;&gt;&lt;a href=&quot;#面试题51-数组中的逆序对&quot; class=&quot;headerlink&quot; title=&quot;面试题51. 数组中的逆序对&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode912_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode912-m/</id>
    <published>2020-08-31T13:27:52.000Z</published>
    <updated>2020-08-31T13:28:22.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></h4><p>难度中等98</p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p>排序算法复习题</p><p>归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;//左指针偶遇右指针</span><br><span class="line">        int mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(nums,l,mid);</span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        // 现在l-mid mid+<span class="number">1</span>-r是有序的</span><br><span class="line">        //考虑合并的情况</span><br><span class="line">        int i=l;</span><br><span class="line">        int j=mid+<span class="number">1</span>;</span><br><span class="line">        int cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">                temp[cnt++]=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++]=nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[cnt++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">            temp[cnt++]=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = temp[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        temp.resize((int)nums.size(), <span class="number">0</span>);</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, (int)nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=nums[r];</span><br><span class="line">        <span class="keyword">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=pivot)&#123;</span><br><span class="line">                i=i+<span class="number">1</span>;<span class="comment">//扩展比pivot小的边界;</span></span><br><span class="line">                swap(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i+<span class="number">1</span>],nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomized_partiton</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        swap(nums[r],nums[i]);<span class="comment">//选择pivot然后存放到最右端;</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=randomized_partiton(nums,l,r);</span><br><span class="line">            quicksort(nums,l,pos<span class="number">-1</span>);</span><br><span class="line">            quicksort(nums,pos+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆排序（不稳定排序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxheapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;<span class="comment">//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1)</span></span><br><span class="line">       <span class="keyword">for</span>(;(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>&lt;=len;)&#123;       </span><br><span class="line">            <span class="keyword">int</span> lson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rson=(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> largest;</span><br><span class="line">            <span class="keyword">if</span>(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123;</span><br><span class="line">                largest=lson;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                largest=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123;</span><br><span class="line">                largest=rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=largest)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">                nums[i]=nums[largest];</span><br><span class="line">                nums[largest]=temp;</span><br><span class="line">                i=largest;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildmaxheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            maxheapify(nums,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=(<span class="keyword">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        buildmaxheap(nums,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">            len-=<span class="number">1</span>;</span><br><span class="line">            maxheapify(nums,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        heapsort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//另外关于排序算法</p><p>线性时间但是有限制的有:</p><p>计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\Theta(n+k)$</p><p>基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort</p><p>桶排序:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;912-排序数组&quot;&gt;&lt;a href=&quot;#912-排序数组&quot; class=&quot;headerlink&quot; title=&quot;912. 排序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot; tar
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="排序" scheme="http://Tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode50-m/</id>
    <published>2020-08-31T13:26:51.000Z</published>
    <updated>2020-08-31T13:27:18.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>难度中等365</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><p>通过次数85,540</p><p>提交次数241,065</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">long</span> <span class="keyword">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>) &#123;<span class="comment">//此处等价于if(power%2==1)</span></span><br><span class="line">            result = result * base;</span><br><span class="line">        &#125;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;<span class="comment">//此处等价于power=power/2</span></span><br><span class="line">        base = (base * base) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp=n;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> fastPower(x,temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/fastPower(x,-temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;50-Pow-x-n&quot;&gt;&lt;a href=&quot;#50-Pow-x-n&quot; class=&quot;headerlink&quot; title=&quot;50. Pow(x, n)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/&quot; ta
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode914_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode914-s/</id>
    <published>2020-08-31T13:25:40.000Z</published>
    <updated>2020-08-31T13:26:10.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">914. 卡牌分组</a></h4><p>难度简单100</p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= deck.length &lt;= 10000</code></li><li><code>0 &lt;= deck[i] &lt; 10000</code></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10002</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">10002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD1</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num1%num2==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next1=num2;</span><br><span class="line"> <span class="keyword">int</span> next2=num1%num2;</span><br><span class="line"><span class="keyword">return</span> GCD1(next1,next2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deck.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt[deck[i]]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> g=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g==<span class="number">-1</span>)&#123;</span><br><span class="line">                    g=cnt[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    g=GCD1(g,cnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g&gt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;914-卡牌分组&quot;&gt;&lt;a href=&quot;#914-卡牌分组&quot; class=&quot;headerlink&quot; title=&quot;914. 卡牌分组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/x-of-a-kind-in-a-de
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="http://Tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode312_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode312-h/</id>
    <published>2020-08-31T13:23:43.000Z</published>
    <updated>2020-09-10T02:41:12.851Z</updated>
    
    <content type="html"><![CDATA[<h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h4><p>难度困难318</p><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 <code>i</code> 时，你可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>说明:</strong></p><ul><li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><p>这题需要考虑的有两点:</p><p>第一点是状态的寻找和转移</p><p>第二点是如何进行递推;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200620172037074-1598880235219.png" alt="image-20200620172037074" title="">                </div>                <div class="image-caption">image-20200620172037074</div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \in [i+1,j-1] 这里k表示最后一次戳哪一个气球;</span></span><br><span class="line">        <span class="comment">//注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历;</span></span><br><span class="line">        <span class="comment">//另外还需要在左端和右端都添加虚假的气球;</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;points(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        points[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        points[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            points[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n + <span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n+<span class="number">2</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)&#123;</span><br><span class="line">                    maxn=<span class="built_in">max</span>(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                dp[i][j]=maxn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;312-戳气球&quot;&gt;&lt;a href=&quot;#312-戳气球&quot; class=&quot;headerlink&quot; title=&quot;312. 戳气球&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/burst-balloons/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU2513 切蛋糕</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU2513/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU2513/</id>
    <published>2020-08-31T13:21:36.000Z</published>
    <updated>2020-09-21T05:43:43.149Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th></tr></thead><tbody><tr><td><strong><a href="http://acm.hdu.edu.cn/discuss/public/post/reply.php?postid=40764&amp;messageid=1&amp;deep=0" target="_blank" rel="noopener">多校联合训练的常见问题回答（FAQ）</a></strong></td></tr><tr><td>Cake slicing<strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583  Accepted Submission(s): 305 **</strong>  Problem DescriptionA rectangular cake with a grid of m<em>n unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts  For example, assume that the cake has a grid of 3</em>4 unit squares on its top, and there are three cherries on the top, as shown in the figure below. <img src="/picture/C150-1009-1.jpg" alt="img"> One allowable slicing is as follows. <img src="/picture/C150-1009-2.jpg" alt="img"> For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is <img src="/picture/C150-1009-3.jpg" alt="img"> In this case, the total length of the cutting edges is 3+2=5.  Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges.   InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks.   OutputOutput an integer indicating the least total length of the cutting edges.                                                       Sample Input<code>3 4 3 1 2 2 3 3 2</code>                                                                                                                        Sample Output<code>Case 1: 5</code>  Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ECJTU+2008+Autumn+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ECJTU 2008 Autumn Contest</a></td></tr></tbody></table><p>【题意】</p><p>有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底)</p><p>我参考了网上的博客,思路如下:</p><p>这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200620162927557.png" alt="image-20200620162927557" title="">                </div>                <div class="image-caption">image-20200620162927557</div>            </figure></p><p>因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> MAXN=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y,x,sum;<span class="comment">//y*x矩阵；sum个樱桃;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,<span class="keyword">int</span> l)</span></span>&#123;<span class="comment">//以i,j为左上角,k,l为右下角</span></span><br><span class="line">    <span class="keyword">if</span>(dp[i][j][k][l]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line">    &#125;<span class="comment">//如果之前计算过了,直接返回;</span></span><br><span class="line">    <span class="comment">//统计区域里面的樱桃数量;</span></span><br><span class="line">    <span class="keyword">int</span> cherry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;=k;++a)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;=l;++b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[a][b]==<span class="number">1</span>)&#123;</span><br><span class="line">                cherry+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果樱桃数量==1,那么不需要切割,返回0;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">1</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是0,那么这是一个不应该取得解,返回INF;</span></span><br><span class="line">    <span class="keyword">if</span>(cherry==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i][j][k][l]=MAXN;</span><br><span class="line">        <span class="keyword">return</span> MAXN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则需要切割;横着切或者纵着切;</span></span><br><span class="line">    <span class="keyword">int</span> minn=MAXN;</span><br><span class="line">    <span class="comment">//横着切:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;k;++a)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,a,l)+Dp(a+<span class="number">1</span>,j,k,l)+l-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纵着切割:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;l;++b)&#123;</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,Dp(i,j,k,b)+Dp(i,b+<span class="number">1</span>,k,l)+k-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][j][k][l]=minn;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j][k][l];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;y,&amp;x,&amp;sum))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p,q;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;q);</span><br><span class="line">            m[p][q]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dp(<span class="number">1</span>,<span class="number">1</span>,y,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cnt,dp[<span class="number">1</span>][<span class="number">1</span>][y][x]);</span><br><span class="line">        cnt+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/discuss/public/post/reply.php?postid=4
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://Tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>面试题08_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%9808-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/面试题08-m/</id>
    <published>2020-08-31T13:20:30.000Z</published>
    <updated>2020-08-31T13:20:49.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h4><p>难度中等82</p><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//没有优化的版本:</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(val.<span class="built_in">size</span>(),temp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//不管用几种硬币组成0元只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;<span class="comment">//只用一种硬币(1)当然只有一种方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>+dp[i][j-val[i]]% <span class="number">1000000007</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]% <span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n]% <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//完全背包问题: 25 10 5 1 4个物品</span></span><br><span class="line">        <span class="comment">//dp[0][0]=1</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] </span></span><br><span class="line">        <span class="comment">//dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k]</span></span><br><span class="line">        <span class="comment">//上下相减:</span></span><br><span class="line">        <span class="comment">//dp[i][j]-dp[i][j-val[i]]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//因此:</span></span><br><span class="line">        <span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-val[i]];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//降维到一维的版本:</span></span><br><span class="line">        <span class="comment">//dp[j]=dp[j]+dp[j-val[i]];</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;val.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=val[i])</span><br><span class="line">                    dp[j]=dp[j]%<span class="number">1000000007</span>+dp[j-val[i]]%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题-08-11-硬币&quot;&gt;&lt;a href=&quot;#面试题-08-11-硬币&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.11. 硬币&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-lc
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1014_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode1014-m/</id>
    <published>2020-08-31T13:19:15.000Z</published>
    <updated>2020-08-31T13:19:39.158Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">1014. 最佳观光组合</a></h4><p>难度中等124</p><p>给定正整数数组 <code>A</code>，<code>A[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的距离为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 50000</code></li><li><code>1 &lt;= A[i] &lt;= 1000</code></li></ol><p>通过次数17,154</p><p>提交次数32,791</p><p>主要注意优化的这种思路,真的挺妙的;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//A[i]+i+A[j]-j</span></span><br><span class="line">        <span class="comment">//原始解法:</span></span><br><span class="line">        <span class="comment">//对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2)</span></span><br><span class="line">        <span class="comment">//优化:</span></span><br><span class="line">        <span class="comment">//tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp=A[<span class="number">0</span>]+<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxn=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(tmp+A[i]-i,maxn);</span><br><span class="line">            tmp=<span class="built_in">max</span>(tmp,A[i]+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1014-最佳观光组合&quot;&gt;&lt;a href=&quot;#1014-最佳观光组合&quot; class=&quot;headerlink&quot; title=&quot;1014. 最佳观光组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-sight
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode837_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode837-m/</id>
    <published>2020-08-31T13:18:28.000Z</published>
    <updated>2020-08-31T13:18:44.193Z</updated>
    
    <content type="html"><![CDATA[<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p>难度中等190</p><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>K</code> 分时抽取数字。 抽取时，她从 <code>[1, W]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>W</code> 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 <code>K</code> 分时，她就停止抽取数字。 爱丽丝的分数不超过 <code>N</code> 的概率是多少？</p><p><strong>示例</strong> <strong>1**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>2**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>3**</strong>：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li><li><code>1 &lt;= W &lt;= 10000</code></li><li>如果答案与正确答案的误差不超过 <code>10^-5</code>，则该答案将被视为正确答案通过。</li><li>此问题的判断限制时间已经减少。</li></ol><p>这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[x]: 得到x分之后继续游戏,成功的概率;</span></span><br><span class="line">        <span class="comment">//dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W</span></span><br><span class="line">        <span class="comment">//初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1</span></span><br><span class="line">        <span class="comment">//结果:dp[0]</span></span><br><span class="line">        <span class="comment">//优化:发现 dp[x]和dp[x-1]之间的关系:</span></span><br><span class="line">        <span class="comment">//Wdp[x-1]=dp[x]+...+dp[x+w-1]</span></span><br><span class="line">        <span class="comment">//Wdp[x]=dp[x+1].....dp[x+w]</span></span><br><span class="line">        <span class="comment">//W (dp[x]-dp[x-1])=-dp[x]+dp[x+w]</span></span><br><span class="line">        <span class="comment">//(W+1)dp[x]-dp[x+w]=Wdp[x-1]</span></span><br><span class="line">        <span class="comment">//dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k</span></span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="built_in">max</span>(N,K+W+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;dp(maxn,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=W;i++)&#123;</span><br><span class="line">            dp[K<span class="number">-1</span>]+=dp[i+K<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[K<span class="number">-1</span>]/=W;</span><br><span class="line">        <span class="comment">//dp[K - 1] = 1.0 * min(N - K + 1, W) / W;</span></span><br><span class="line">        <span class="comment">//dp[K-1]=((W+1)*dp[K]-dp[K+W])/W;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=K<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=((W+<span class="number">1</span>)*dp[i+<span class="number">1</span>]-dp[i+W+<span class="number">1</span>])/W;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;837-新21点&quot;&gt;&lt;a href=&quot;#837-新21点&quot; class=&quot;headerlink&quot; title=&quot;837. 新21点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/new-21-game/&quot; targe
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode416_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode416-m/</id>
    <published>2020-08-31T13:17:48.000Z</published>
    <updated>2020-08-31T13:18:02.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h4><p>难度中等218</p><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure><hr><p>01背包问题 具体解体思路见注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//背包问题</span></span><br><span class="line">        <span class="comment">//背包的容量是总和的一半</span></span><br><span class="line">        <span class="comment">//dp[i][j] 表示取了前i个数剩余容积为j时候的最大值</span></span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> V=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只取0号数字的时候的初始化：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums[<span class="number">0</span>];i&lt;=V;i++)&#123;<span class="comment">//注意越界问题</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=nums[<span class="number">0</span>];<span class="comment">//因为只能取一次nums[0];</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//dp状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[n<span class="number">-1</span>][V]!=V)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;416-分割等和子集&quot;&gt;&lt;a href=&quot;#416-分割等和子集&quot; class=&quot;headerlink&quot; title=&quot;416. 分割等和子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode221_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode221-m/</id>
    <published>2020-08-31T13:16:52.000Z</published>
    <updated>2020-09-10T02:40:38.559Z</updated>
    
    <content type="html"><![CDATA[<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h4><p>难度中等428</p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>神必的dp</p><p>主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度;</p><p>状态转移方程比较难像:</p><p>$dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$</p><p>解释如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/image-20200531160513652.png" alt="image-20200531160513652" title="">                </div>                <div class="image-caption">image-20200531160513652</div>            </figure><p>为了代码的美观减少一次特判,应该要在左边和上边多加一列:</p><p>0 0 0 …..</p><p>0  matrix</p><p>0 </p><p>…</p><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#重点是神必的状态转移方程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        height=len(matrix)</span><br><span class="line">        width=len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(width+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(height+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#dp初始化,并且在外面多套了一层;</span></span><br><span class="line">        <span class="comment">#dp[i,j]表示以i,j为右下角的矩形的最大宽度;</span></span><br><span class="line">        <span class="comment"># 0 0 0 0 ....</span></span><br><span class="line">        <span class="comment"># 0 matrix</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># 0</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment">#转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1</span></span><br><span class="line">        maxedge=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(dp[i][j],dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">                maxedge=max(maxedge,dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> maxedge*maxedge</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;221-最大正方形&quot;&gt;&lt;a href=&quot;#221-最大正方形&quot; class=&quot;headerlink&quot; title=&quot;221. 最大正方形&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximal-square/&quot;
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode213_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode213-m/</id>
    <published>2020-08-31T13:16:12.000Z</published>
    <updated>2020-08-31T13:16:24.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>难度中等284</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;dp1(nums.size(),0);</span><br><span class="line">        vector&lt;int&gt;dp2(nums.size(),0);</span><br><span class="line">        dp1[0]&#x3D;nums[0];</span><br><span class="line"></span><br><span class="line">        dp1[1]&#x3D;max(nums[0],nums[1]);</span><br><span class="line">        </span><br><span class="line">        if(nums.size()&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(nums.size()&#x3D;&#x3D;3)&#123;</span><br><span class="line">            return dp1[1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123;</span><br><span class="line">            dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int result1&#x3D;dp1[nums.size()-2];</span><br><span class="line"></span><br><span class="line">        dp2[1]&#x3D;nums[1];</span><br><span class="line">        dp2[2]&#x3D;max(nums[1],nums[2]);</span><br><span class="line">        for(int i&#x3D;3;i&lt;nums.size();i++)&#123;</span><br><span class="line">            dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int result2&#x3D;dp2[nums.size()-1];</span><br><span class="line">        return max(result1,result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;213-打家劫舍-II&quot;&gt;&lt;a href=&quot;#213-打家劫舍-II&quot; class=&quot;headerlink&quot; title=&quot;213. 打家劫舍 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robb
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode198_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode198-m/</id>
    <published>2020-08-31T13:15:12.000Z</published>
    <updated>2020-08-31T13:15:36.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>难度简单875</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p>原始版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:第0间-第i间房子偷窃的最高金额;</span></span><br><span class="line">        <span class="comment">//dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span></span><br><span class="line">        <span class="comment">//初始化:</span></span><br><span class="line">        <span class="comment">//dp[0]=nums[0]</span></span><br><span class="line">        <span class="comment">//dp[1]=max(nums[0],nums[1])</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(len,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;++i)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//滚动数组优化;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>滚动数组优化版本;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额;</span><br><span class="line">        &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的;</span><br><span class="line">        &#x2F;&#x2F;初始化:</span><br><span class="line">        &#x2F;&#x2F;dp[0]&#x3D;nums[0]</span><br><span class="line">        &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1])</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int len&#x3D;nums.size();</span><br><span class="line">        int first&#x3D;nums[0];</span><br><span class="line">        if(nums.size()&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return first;</span><br><span class="line">            &#x2F;&#x2F;return dp[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int sec&#x3D;max(nums[1],nums[0]);</span><br><span class="line">        int result&#x3D;sec;</span><br><span class="line">        for(int i&#x3D;2;i&lt;len;i++)&#123;</span><br><span class="line">            result&#x3D;max(sec,first+nums[i]);</span><br><span class="line">            first&#x3D;sec;</span><br><span class="line">            sec&#x3D;result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;198-打家劫舍&quot;&gt;&lt;a href=&quot;#198-打家劫舍&quot; class=&quot;headerlink&quot; title=&quot;198. 打家劫舍&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot; targ
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode96-m/</id>
    <published>2020-08-31T13:10:02.000Z</published>
    <updated>2020-08-31T13:13:23.891Z</updated>
    
    <content type="html"><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>难度中等537</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]:i个结点的时候二叉搜索树的个数</span></span><br><span class="line">        <span class="comment">//空树只有一种情况:dp[0]=1</span></span><br><span class="line">        <span class="comment">//dp[1]=1</span></span><br><span class="line">        <span class="comment">//dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-bin
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode64_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode64-m/</id>
    <published>2020-08-31T13:09:13.000Z</published>
    <updated>2020-08-31T13:09:41.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>难度中等486</p><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]:到i,j 的最小路径和;</span></span><br><span class="line">        <span class="comment">//dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(grid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m=dp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n=dp[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode62-m/</id>
    <published>2020-08-31T13:04:05.000Z</published>
    <updated>2020-09-10T02:42:28.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>难度中等560</p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/picture/robot_maze.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#x2F;&#x2F;dp[0][0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;dp[0][1]&#x3D;1&#39;</span><br><span class="line">        &#x2F;&#x2F;dp[1][0]&#x3D;1;</span><br><span class="line">        if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt;tmp(m,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n,tmp);</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            dp[0][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][0]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;m;j++)&#123;</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode53_s</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode53-s/</id>
    <published>2020-08-31T13:03:25.000Z</published>
    <updated>2020-08-31T13:03:46.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>难度简单</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><p>水题:</p><p>dp[i]表示第i个之前的连续子数组的最大和</p><p>dp[i]=max(dp[i],dp[i-1]+dp[i]) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnum;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums)</span></span>;</span><br><span class="line">        maxnum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;53-最大子序和&quot;&gt;&lt;a href=&quot;#53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. 最大子序和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; 
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode32_h</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode32-h/</id>
    <published>2020-08-31T13:01:40.000Z</published>
    <updated>2020-08-31T13:02:23.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><p>难度困难784</p><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>通过次数74,856</p><p>提交次数233,569</p><p>题解见注释:主要是要两两字符判断;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度;</span></span><br><span class="line">        <span class="comment">//对于...............():</span></span><br><span class="line">        <span class="comment">//dp[i]=dp[i-2]+2;</span></span><br><span class="line">        <span class="comment">//对于...............)):</span></span><br><span class="line">        <span class="comment">//dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) </span></span><br><span class="line">        <span class="comment">//判断s[i-dp[i-1]-1],如果是(:</span></span><br><span class="line">        <span class="comment">//dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.length();;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i]=<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                        dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>+dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]; </span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;32-最长有效括号&quot;&gt;&lt;a href=&quot;#32-最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32. 最长有效括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-pa
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode5-m/</id>
    <published>2020-08-31T13:00:48.000Z</published>
    <updated>2020-08-31T13:01:10.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>难度中等</p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><p>这题目可以使用动态规划</p><p>我觉得很棒的一个<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> len=s.length();</span><br><span class="line">       <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[j][i]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][i]=dp[j+<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=i-j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;maxl)&#123;</span><br><span class="line">                        maxl=temp;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5. 最长回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HDU_1284</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/HDU-1284/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/HDU-1284/</id>
    <published>2020-08-31T12:58:32.000Z</published>
    <updated>2020-08-31T12:59:37.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 15976  Accepted Submission(s): 9546<br>**</strong></p><p>Problem Description</p><p>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。</p><p>Input</p><p>每行只有一个正整数N，N小于32768。</p><p>Output</p><p>对应每个输入，输出兑换方法数。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2934</span><br><span class="line">12553</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">718831</span><br><span class="line">13137761</span><br></pre></td></tr></table></figure><p>Author</p><p>SmallBeer(CML)</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%BA%BC%B5%E7ACM%BC%AF%D1%B5%B6%D3%D1%B5%C1%B7%C8%FC%A3%A8VII%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">杭电ACM集训队训练赛（VII）</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//相当于3件物品，容量为N的背包，第i件物品的重量是i</span></span><br><span class="line"><span class="comment">//初始化: dp[0][0]=1</span></span><br><span class="line"><span class="comment">//dp[i][j]表示用前i件物品组成j的方案数量</span></span><br><span class="line"><span class="comment">//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;</span></span><br><span class="line"><span class="comment">//滚动数组优化：</span></span><br><span class="line"><span class="comment">//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">33000</span>;<span class="comment">//32468</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;maxn;j++)&#123;</span><br><span class="line">            dp[j]+=dp[j-i];</span><br><span class="line">          <span class="comment">//  printf("%lld\n",dp[j]);</span></span><br><span class="line">           <span class="comment">// dp[j]+=max(dp[j],dp[j-i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf("here");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    scanf("%d",&amp;temp);</span></span><br><span class="line"><span class="comment">//        printf("%lld",dp[temp]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,dp[temp]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;钱币兑换问题&quot;&gt;&lt;a href=&quot;#钱币兑换问题&quot; class=&quot;headerlink&quot; title=&quot;钱币兑换问题&quot;&gt;&lt;/a&gt;钱币兑换问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;Time Limit: 2000/1000 MS (Java/Other
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://Tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode19_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode19-m/</id>
    <published>2020-08-31T03:12:38.000Z</published>
    <updated>2020-08-31T12:50:14.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h4><p>难度中等947收藏分享切换为英文关注反馈</p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗</p><p>快慢指针的想法来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* l;</span><br><span class="line">        ListNode*r;</span><br><span class="line">        l=head;</span><br><span class="line">        r=head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(cnt=<span class="number">0</span>;cnt&lt;n;cnt++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;r-&gt;val&lt;&lt;endl;      </span></span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;l-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        l-&gt;next=l-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;19-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode16_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode16-m/</id>
    <published>2020-08-31T03:11:14.000Z</published>
    <updated>2020-08-31T12:50:07.255Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><p>难度中等530</p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p>通过次数141,122</p><p>提交次数308,415</p><p>和leetcode15相似,主要思路还是排序+双指针</p><p>我使用了minA维护了当前的最小值,然后使用res记录和;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#排序: -4 -1 1 2</span></span><br><span class="line">        <span class="comment">#minA 对于遍历到的每一个i,维护minA;</span></span><br><span class="line">        <span class="comment">#每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回;</span></span><br><span class="line"></span><br><span class="line">        n=len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> NULL</span><br><span class="line">        minA=sys.maxsize <span class="comment"># INT最大值</span></span><br><span class="line">        res=minA</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-2</span>):</span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                cur=nums[i]+nums[L]+nums[R]</span><br><span class="line">                <span class="keyword">if</span> cur==target:</span><br><span class="line">                    minA=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> cur</span><br><span class="line">                <span class="keyword">elif</span> cur&lt;target:</span><br><span class="line">                    tempres=target-cur</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tempres=cur-target</span><br><span class="line">                    <span class="keyword">if</span> abs(tempres)&lt;minA:</span><br><span class="line">                        minA=abs(tempres)</span><br><span class="line">                        res=cur        </span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-close
      
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>leetcode15_m</title>
    <link href="http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/"/>
    <id>http://Tyler-ytr.github.io/2020/08/31/leetcode15-m/</id>
    <published>2020-08-31T03:06:50.000Z</published>
    <updated>2020-08-31T12:50:01.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>难度中等2455</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过次数293,697</p><p>提交次数1,016,765</p><p>还是看了题解,排序太香了！</p><p>主要操作是排序使用双指针进行检查;同时记得去重;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#从i遍历到n-2,使用双指针维护和探查;</span></span><br><span class="line">        <span class="comment">#记得去重,也就是对于相同的找最后的;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#去重</span></span><br><span class="line">            </span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="number">0</span>):</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]):</span><br><span class="line">                        L=L+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L&lt; R <span class="keyword">and</span> nums[R]==nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R=R<span class="number">-1</span></span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R]&lt;<span class="number">0</span>:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R=R<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      咸鱼leetcode刷题ing
    
    </summary>
    
      <category term="leetcode刷题" scheme="http://Tyler-ytr.github.io/categories/leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="双指针" scheme="http://Tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="basic knowledge" scheme="http://Tyler-ytr.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Winter plan</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/winter-learning-plan/</id>
    <published>2020-01-22T09:17:23.000Z</published>
    <updated>2020-01-22T09:23:27.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>需要完成的目标:</p><ul><li>线性代数复习</li><li>学习cs224n</li><li>刷leetcode</li><li>算法竞赛入门经典</li></ul></li><li><p>目前进度:</p><ul><li>线性代数: <ul><li>1.22 </li></ul></li><li>cs224n<ul><li>1.22 </li></ul></li><li>leetcode<ul><li>1.22 </li></ul></li><li>算法竞赛入门经典</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要完成的目标:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性代数复习&lt;/li&gt;
&lt;li&gt;学习cs224n&lt;/li&gt;
&lt;li&gt;刷leetcode&lt;/li&gt;
&lt;li&gt;算法竞赛入门经典&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前进度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线
      
    
    </summary>
    
      <category term="个人计划" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="flag" scheme="http://Tyler-ytr.github.io/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu教程</title>
    <link href="http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/"/>
    <id>http://Tyler-ytr.github.io/2020/01/22/ubuntu-back/</id>
    <published>2020-01-22T08:28:15.000Z</published>
    <updated>2020-01-24T07:42:44.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;</li><li>重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜</li></ul><h2 id="复活操作"><a href="#复活操作" class="headerlink" title="复活操作"></a>复活操作</h2><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><ul><li>管理员权限,换源,安装vim  <pre><code>  sudo passwd(修改sudo密码)  sudo apt-get update  sudo apt-get install vim  </code></pre></li><li>更换国内源,这里我选择的是<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华源</a>用下面的命令打开文件,并且注释里面的所有内容,<br> <pre><code> sudo vim /etc/apt/sources.list<br></code></pre> <ul><li>然后粘贴下面的内容到打开的文件里面<br><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br></code></pre><br>如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下;</li></ul></li><li>安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇<a href="https://blog.csdn.net/qq_33159059/article/details/85019467" target="_blank" rel="noopener">博客</a></li><li>然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义<pre><code>suapt-get install build-essentialapt-get install man                # on-line reference manualapt-get install gcc-doc            # manual for GCCapt-get install gdb                # GNU debuggerapt-get install git                # reversion control systemapt-get install libreadline-dev    # a library to use compile the project laterapt-get install libsdl2-dev        # a library to use compile the project laterapt-get install qemu-system-x86    # QEMU</code></pre></li><li>安装chrome:请使用bing搜索;用gmail同步很香;</li></ul><h4 id="科学的看世界"><a href="#科学的看世界" class="headerlink" title="科学的看世界"></a>科学的看世界</h4><ul><li>我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) <pre><code> mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json </code></pre></li><li>将下面的内容根据自己的配置放进去:<pre><code>{  "server":"my_server_ip",  "server_port":53450,  "local_address": "127.0.0.1",  "local_port":1080,  "password":"密码",  "timeout":300,  "method":"aes-256-gcm",  "fast_open": false}</code></pre></li><li>然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;<br>自己测试一下有没有问题;</li><li>感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)：<ul><li>先写一个自启动脚本：<pre><code> touch ~/.ssstart.shvim ~/.ssstart.sh</code></pre>内容是:<pre><code>#!/bin/bashss-local -c ~/shadowsocks/shadowsocks.json </code></pre></li><li>然后在终端里面起别名:<br><pre><code>vim ~/.bashrc<br>在末尾添加:<br>alias ss=’. ~/.ssstart.sh’<br>:wq 保存,退出<br>在终端里面:<br>source ~/.bashrc<br>(如果是zsh:source ~/.zshrc)<br></code></pre><br>尝试一下在终端输入ss,它lei了;</li></ul></li><li><p>因为后面的netdata需要<strong>终端</strong>翻墙,我也就尝试了一下,如果没有需求可以跳过这一步:</p><ul><li>主要参考的是谷歌出来的<a href="http://www.totorocyx.me/2018/10/02/ubuntu_shadowsocks/" target="_blank" rel="noopener">网站</a></li><li>首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装</li><li><p>下面尝试全局代理(我也不确定能不能成功)：</p><ul><li>sudo pip install genpac</li><li>选择安装配置文件的目录,我选择的是:<pre><code>/home/larryytr/shadowsocks</code></pre></li><li>然后执行以下命令:<pre><code>sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a></code></pre></li><li>下面是一句搬运,我没有遇到过:<pre><code>注意：如果报错“fetch gfwlist fail.online: <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a><br></pre></code></li><li>执行完之后,目录下面会有一个autoproxy.pac文件。</li><li><p>然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写：</p><pre><code>file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改)</code></pre></li></ul></li><li><p>然后使得终端也能使用代理。我们需要<strong>privoxy</strong>代理工具:</p><ul><li><p>安装很自然:sudo apt-get install privoxy</p></li><li><p>然后编辑配置文件<pre><code>sudo vim /etc/privoxy/config </pre></code></p></li><li><p>在文档中搜索(vim 使用/搜索)“<strong>listen-address</strong>”（即监听地址），找到如下一行：<strong>listen-address localhost:8118</strong> 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“<strong>forward-socks5t</strong>”，找到如下一行：<strong>forward-socks5t / 127.0.0.1:1080</strong> . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure></li><li><p>最后，再配置/etc/profile：<pre><code></p><pre><code># 先进入编辑模式</code></pre><p>sudo vim /etc/profile</p><pre><code># 在末尾添加以下三行：</code></pre><p>export http_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export https_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a><br>export ftp_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a></p><pre><code># 退出之后记得执行source /etc/profile</code></pre><p></code></pre></p></li><li><p>验证是否成功:curl <a href="http://www.google.com或wget" target="_blank" rel="noopener">www.google.com或wget</a> <a href="http://www.google.com判断是否可以访问" target="_blank" rel="noopener">www.google.com判断是否可以访问</a></p></li><li><p>HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！</p></li></ul></li></ul></li></ul><h4 id="优化美化"><a href="#优化美化" class="headerlink" title="优化美化"></a>优化美化</h4><ul><li>官网安装网易云</li><li>官网安装vscode</li><li>配置zsh,tmux,vim:</li></ul><h5 id="zsh安装与美化"><a href="#zsh安装与美化" class="headerlink" title="zsh安装与美化"></a>zsh安装与美化</h5><ul><li>学习了:<a href="https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/" target="_blank" rel="noopener">https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/</a><br><a href="https://segmentfault.com/a/1190000013612471这两篇教程" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013612471这两篇教程</a>;</li><li>感谢何伟的配置文件;</li><li>相应的setting请参考我的github<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>.</li><li>安装zsh:<pre><code>sudo apt-get updatesudo apt-get install zshchsh -s /bin/zsh (设置zsh为默认)</code></pre></li><li>重启你的ubuntu</li><li>安装oh-my-zsh插件:<pre><code> wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre></li><li>不改theme一无所有</li><li>准备使用powerline主题  </li><li>首先安装powerline字体：<pre><code>git clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts</code></pre></li><li>安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久)</li><li>安装powerline: sudo apt install powerline </li><li>我的配置见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting .zshrc</li><li>颜色选择困难请: <pre><code>for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f”</code></pre></li><li>改完请source ~/.zshrc</li></ul><h5 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h5><ul><li>tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程;</li><li>我使用了何伟的配置,具体见<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting</li><li>我又加了一个插件使得tmux在重启之后状态可以恢复:<ul><li>主要参考这个<a href="https://zhuanlan.zhihu.com/p/24660412" target="_blank" rel="noopener">知乎教程</a></li><li><pre><code>git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp</code></pre></li><li>在~/.tmux.conf.local里面加上:<pre><code>run-shell ~/tmux_tmp/resurrect.tmux</code></pre></li><li>最后载入这个配置：<pre><code>tmux source-file ~/.tmux.conf<br></code></pre></li></ul></li></ul><h5 id="vim的美化"><a href="#vim的美化" class="headerlink" title="vim的美化"></a>vim的美化</h5><ul><li>使用啦懒人vim: spf13-vim美化</li><li>请看<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh</li><li>我的配置同样在<a href="https://github.com/larryytr/Note_for_blog/tree/master/ubuntu" target="_blank" rel="noopener">相关内容</a>的setting里面;</li><li>这个时候的vim没有办法和系统剪切版交互,我根据<a href="https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html" target="_blank" rel="noopener">https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html</a> 下载了其他一些插件:<br><pre><code>sudo apt-get install vim-scripts vim-gtk vim-gnome</pre></code><br>这样 vim –version|grep “cliboard” 会看到 +clipboard;<br>然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！</li></ul><h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容:"></a>其他内容:</h4><ul><li>OSlab还需要:<ul><li>sudo apt-get install curl</li><li>sudo apt-get install gcc-multilib</li></ul></li><li>git 配置请搜索廖雪峰</li><li>ctags 可以参考Mengzelev的<a href="https://mengzelev.github.io/2018/10/04/pa-inspirations/" target="_blank" rel="noopener">博客</a></li><li>感谢xnr给我推荐的network来查看linux的运行情况<ul><li>这是netdata的官方网站:<a href="https://github.com/netdata/netdata#user-base" target="_blank" rel="noopener">https://github.com/netdata/netdata#user-base</a></li><li>但是由于GFW,安装会出现报错,事实上需要终端翻墙才行</li><li>可以通过这篇<a href="https://blog.csdn.net/zhangvalue/article/details/80270169" target="_blank" rel="noopener">教程</a><br><pre><code> sudo apt-get install net-tools<br>  ifconfig<br></code></pre><br>查看inet 之后的内容来得知自己的server_ip</li><li>成功之后,进入 <a href="http://127.0.0.1:19999/" target="_blank" rel="noopener">http://127.0.0.1:19999/</a> (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验</li><li>相应配置可以参考这篇<a href="https://cloud.tencent.com/developer/article/1181577" target="_blank" rel="noopener">博客</a>或者自己搜索</li></ul></li><li>OSlab的kvm bug处理方法：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1479558" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=1479558</a><pre><code>chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content:KERNEL=="kvm", GROUP="kvm", MODE="0666"</code></pre></li><li>texlive 安装<pre><code>sudo apt install texlive-full</code></pre>相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting)vscode的保存即编译请<pre><code>Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾；</code></pre></li><li>ubuntu的截图:我参考了这篇<a href="https://blog.csdn.net/qq_17448289/article/details/56480805" target="_blank" rel="noopener">博客</a><ul><li>打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+</li><li>显然的配置好按键,然后在命令里面写<pre><code>gnome-screenshot -a</code></pre></li><li>hint:上面的命令终端输入也有效<br>截屏的图在文件夹的图片(picture)里面;</li></ul></li></ul><h4 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h4><ul><li>有空再研究怎么换主题;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了;&lt;/li&gt;
&lt;li&gt;重装很多次的原因是因为
      
    
    </summary>
    
      <category term="个人总结" scheme="http://Tyler-ytr.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="教程" scheme="http://Tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Tyler-ytr.github.io/2020/01/21/hello-world/"/>
    <id>http://Tyler-ytr.github.io/2020/01/21/hello-world/</id>
    <published>2020-01-20T19:20:25.723Z</published>
    <updated>2020-01-20T19:20:25.723Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
