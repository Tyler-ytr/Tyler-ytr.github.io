[{"title":"面试题08_m","date":"2020-08-31T13:20:30.000Z","path":"2020/08/31/面试题08-m/","text":"面试题 08.11. 硬币难度中等82 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007) 示例1: 12345 输入: n &#x3D; 5 输出：2 解释: 有两种方式可以凑成总金额:5&#x3D;55&#x3D;1+1+1+1+1 示例2: 1234567 输入: n &#x3D; 10 输出：4 解释: 有四种方式可以凑成总金额:10&#x3D;1010&#x3D;5+510&#x3D;5+1+1+1+1+110&#x3D;1+1+1+1+1+1+1+1+1+1 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; //没有优化的版本: vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;temp(n+2,0); vector&lt;vector&lt;int&gt;&gt;dp(val.size(),temp); dp[0][0]=1; for(int i=0;i&lt;4;i++)&#123; dp[i][0]=1;//不管用几种硬币组成0元只有一种方法 &#125; for(int i=0;i&lt;n+1;i++)&#123; dp[0][i]=1;//只用一种硬币(1)当然只有一种方法 &#125; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;n+1;j++)&#123; if(j&gt;=val[i]) dp[i][j]=dp[i-1][j]% 1000000007+dp[i][j-val[i]]% 1000000007; else&#123; dp[i][j]=dp[i-1][j]% 1000000007; &#125; &#125; &#125; return dp[3][n]% 1000000007; &#125;&#125;; //上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维 1234567891011121314151617181920212223242526272829class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; // //降维到一维的版本: //dp[j]=dp[j]+dp[j-val[i]]; vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;dp(n+2,1); dp[0]=1; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(j&gt;=val[i]) dp[j]=dp[j]%1000000007+dp[j-val[i]]%1000000007; &#125; &#125; return dp[n]%1000000007; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode1014_m","date":"2020-08-31T13:19:15.000Z","path":"2020/08/31/leetcode1014-m/","text":"1014. 最佳观光组合难度中等124 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 123输入：[8,1,5,2,6]输出：11解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11 提示： 2 &lt;= A.length &lt;= 50000 1 &lt;= A[i] &lt;= 1000 通过次数17,154 提交次数32,791 主要注意优化的这种思路,真的挺妙的; 123456789101112131415161718192021class Solution &#123;public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; //A[i]+i+A[j]-j //原始解法: //对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2) //优化: //tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n) int tmp=A[0]+0; int maxn=INT_MIN; for(int i=1;i&lt;A.size();++i)&#123; maxn=max(tmp+A[i]-i,maxn); tmp=max(tmp,A[i]+i); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode837_m","date":"2020-08-31T13:18:28.000Z","path":"2020/08/31/leetcode837-m/","text":"837. 新21点难度中等190 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？ 示例 1**：** 123输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10输出：1.00000说明：爱丽丝得到一张卡，然后停止。 示例 2**：** 1234输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10输出：0.60000说明：爱丽丝得到一张卡，然后停止。在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。 示例 3**：** 12输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10输出：0.73278 提示： 0 &lt;= K &lt;= N &lt;= 10000 1 &lt;= W &lt;= 10000 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。 此问题的判断限制时间已经减少。 这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释; 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: double new21Game(int N, int K, int W) &#123; //dp[x]: 得到x分之后继续游戏,成功的概率; //dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W //初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1 //结果:dp[0] //优化:发现 dp[x]和dp[x-1]之间的关系: //Wdp[x-1]=dp[x]+...+dp[x+w-1] //Wdp[x]=dp[x+1].....dp[x+w] //W (dp[x]-dp[x-1])=-dp[x]+dp[x+w] //(W+1)dp[x]-dp[x+w]=Wdp[x-1] //dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k if(K==0)&#123; return 1.0; &#125; int maxn=max(N,K+W+1)+1; vector&lt;double&gt;dp(maxn,0); for(int i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123; dp[i]=1.0; &#125; for(int i=1;i&lt;=W;i++)&#123; dp[K-1]+=dp[i+K-1]; &#125; dp[K-1]/=W; //dp[K - 1] = 1.0 * min(N - K + 1, W) / W; //dp[K-1]=((W+1)*dp[K]-dp[K+W])/W; for(int i=K-2;i&gt;=0;i--)&#123; dp[i]=((W+1)*dp[i+1]-dp[i+W+1])/W; &#125; return dp[0]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode416_m","date":"2020-08-31T13:17:48.000Z","path":"2020/08/31/leetcode416-m/","text":"416. 分割等和子集难度中等218 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 01背包问题 具体解体思路见注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; //背包问题 //背包的容量是总和的一半 //dp[i][j] 表示取了前i个数剩余容积为j时候的最大值 //dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i]) int sum=0; int n=nums.size(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; if(sum%2!=0)&#123; return false; &#125; int V=sum/2; vector&lt;vector &lt;int&gt; &gt; dp(n,vector&lt;int&gt;(V+1,0)); //初始化: dp[0][0]=0; //只取0号数字的时候的初始化： for(int i=nums[0];i&lt;=V;i++)&#123;//注意越界问题 dp[0][i]=nums[0];//因为只能取一次nums[0]; &#125; //dp状态转移 for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;=V;j++)&#123; if(j-nums[i]&gt;=0) dp[i][j]=max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else&#123; dp[i][j]=dp[i-1][j]; &#125; &#125; &#125; if(dp[n-1][V]!=V)&#123; return false; &#125; return true; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode221_m","date":"2020-08-31T13:16:52.000Z","path":"2020/08/31/leetcode221-m/","text":"221. 最大正方形难度中等428 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 神必的dp 主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度; 状态转移方程比较难像: $dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$ 解释如下: image-20200531160513652 为了代码的美观减少一次特判,应该要在左边和上边多加一列: 0 0 0 ….. 0 matrix 0 … python代码如下： 1234567891011121314151617181920212223class Solution: #重点是神必的状态转移方程 def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) ==0: return 0 height=len(matrix) width=len(matrix[0]) dp=[[0 for i in range(width+1)] for j in range(height+1)] #dp初始化,并且在外面多套了一层; #dp[i,j]表示以i,j为右下角的矩形的最大宽度; # 0 0 0 0 .... # 0 matrix # 0 # 0 # ... #转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1 maxedge=0 for i in range(height): for j in range(width): if matrix[i][j]=='1': dp[i+1][j+1]=min(dp[i][j],dp[i+1][j],dp[i][j+1])+1 maxedge=max(maxedge,dp[i+1][j+1]) return maxedge*maxedge","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode213_m","date":"2020-08-31T13:16:12.000Z","path":"2020/08/31/leetcode213-m/","text":"213. 打家劫舍 II难度中等284 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回; if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; if(nums.size()&#x3D;&#x3D;1)&#123; return nums[0]; &#125; vector&lt;int&gt;dp1(nums.size(),0); vector&lt;int&gt;dp2(nums.size(),0); dp1[0]&#x3D;nums[0]; dp1[1]&#x3D;max(nums[0],nums[1]); if(nums.size()&#x3D;&#x3D;2)&#123; return dp1[1]; &#125; if(nums.size()&#x3D;&#x3D;3)&#123; return dp1[1]; &#125; for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123; dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]); &#125; int result1&#x3D;dp1[nums.size()-2]; dp2[1]&#x3D;nums[1]; dp2[2]&#x3D;max(nums[1],nums[2]); for(int i&#x3D;3;i&lt;nums.size();i++)&#123; dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]); &#125; int result2&#x3D;dp2[nums.size()-1]; return max(result1,result2); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode198_m","date":"2020-08-31T13:15:12.000Z","path":"2020/08/31/leetcode198-m/","text":"198. 打家劫舍难度简单875 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 原始版本: 12345678910111213141516171819202122232425262728class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; //dp[i]:第0间-第i间房子偷窃的最高金额; //dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; //初始化: //dp[0]=nums[0] //dp[1]=max(nums[0],nums[1]) if(nums.size()==0)&#123; return 0; &#125; int len=nums.size(); vector&lt;int&gt;dp(len,0); dp[0]=nums[0]; if(nums.size()==1)&#123; return dp[0]; &#125; dp[1]=max(nums[1],nums[0]); for(int i=2;i&lt;len;++i)&#123; dp[i]=max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; //滚动数组优化; &#125;&#125;; 滚动数组优化版本; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额; &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; &#x2F;&#x2F;初始化: &#x2F;&#x2F;dp[0]&#x3D;nums[0] &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1]) if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; int len&#x3D;nums.size(); int first&#x3D;nums[0]; if(nums.size()&#x3D;&#x3D;1)&#123; return first; &#x2F;&#x2F;return dp[0]; &#125; int sec&#x3D;max(nums[1],nums[0]); int result&#x3D;sec; for(int i&#x3D;2;i&lt;len;i++)&#123; result&#x3D;max(sec,first+nums[i]); first&#x3D;sec; sec&#x3D;result; &#125; return result; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode96_m","date":"2020-08-31T13:10:02.000Z","path":"2020/08/31/leetcode96-m/","text":"96. 不同的二叉搜索树难度中等537 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; //dp[i]:i个结点的时候二叉搜索树的个数 //空树只有一种情况:dp[0]=1 //dp[1]=1 //dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....) // vector&lt;int&gt;dp(n+1,0); dp[0]=1; dp[1]=1; if(n&lt;2)&#123; return dp[n]; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; dp[i]+=dp[j]*dp[i-j-1]; &#125; &#125; return dp[n]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode64_m","date":"2020-08-31T13:09:13.000Z","path":"2020/08/31/leetcode64-m/","text":"64. 最小路径和难度中等486 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 1234567891011121314151617181920212223242526class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //dp[i][j]:到i,j 的最小路径和; //dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; vector&lt;vector&lt;int&gt;&gt;dp(grid); int m=dp.size(); if(m==0)&#123;return 0;&#125;; int n=dp[0].size(); for(int i=1;i&lt;m;++i)&#123; dp[i][0]=dp[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;++i)&#123; dp[0][i]=dp[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode62_m","date":"2020-08-31T13:04:05.000Z","path":"2020/08/31/leetcode62-m/","text":"62. 不同路径难度中等560 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ img 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 1234567输入: m &#x3D; 3, n &#x3D; 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m &#x3D; 7, n &#x3D; 3输出: 28 1234567891011121314151617181920212223242526272829class Solution &#123;public: int uniquePaths(int m, int n) &#123; &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案 &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#x2F;&#x2F;dp[0][0]&#x3D;1; &#x2F;&#x2F;dp[0][1]&#x3D;1&#39; &#x2F;&#x2F;dp[1][0]&#x3D;1; if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125; vector&lt;int&gt;tmp(m,0); vector&lt;vector&lt;int&gt;&gt;dp(n,tmp); for(int i&#x3D;0;i&lt;m;i++)&#123; dp[0][i]&#x3D;1; &#125; for(int i&#x3D;0;i&lt;n;i++)&#123; dp[i][0]&#x3D;1; &#125; for(int i&#x3D;1;i&lt;n;i++)&#123; for(int j&#x3D;1;j&lt;m;j++)&#123; dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[n-1][m-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode53_s","date":"2020-08-31T13:03:25.000Z","path":"2020/08/31/leetcode53-s/","text":"53. 最大子序和难度简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 水题: dp[i]表示第i个之前的连续子数组的最大和 dp[i]=max(dp[i],dp[i-1]+dp[i]) 12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxnum; vector&lt;int&gt; dp(nums); maxnum=nums[0]; for(int i=1;i&lt;nums.size();i++)&#123; if(dp[i-1]&gt;0)&#123; dp[i]=dp[i-1]+dp[i]; &#125; maxnum=max(maxnum,dp[i]); &#125; return maxnum; &#125; &#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode32_h","date":"2020-08-31T13:01:40.000Z","path":"2020/08/31/leetcode32-h/","text":"32. 最长有效括号难度困难784 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 通过次数74,856 提交次数233,569 题解见注释:主要是要两两字符判断; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int longestValidParentheses(string s) &#123; //动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度; //对于...............(): //dp[i]=dp[i-2]+2; //对于...............)): //dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) //判断s[i-dp[i-1]-1],如果是(: //dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了; int n=s.length();; vector&lt;int&gt;dp(n+1,0); if(n==0 || n==1)&#123; return 0; &#125; int maxn=0; for(int i=1;i&lt;n;++i)&#123; if(s[i]==')')&#123; if(s[i-1]=='(')&#123; if(i&gt;=2)&#123; dp[i]=dp[i-2]+2; &#125;else&#123; dp[i]=2; &#125; &#125;else&#123; if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]=='(')&#123; if(i-dp[i-1]-2&gt;=0) dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]; else&#123; dp[i]=dp[i-1]+2; &#125; &#125; &#125; &#125; maxn=max(maxn,dp[i]); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode5_m","date":"2020-08-31T13:00:48.000Z","path":"2020/08/31/leetcode5-m/","text":"5. 最长回文子串难度中等 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 这题目可以使用动态规划 我觉得很棒的一个题解 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int len=s.length(); if(len&lt;=1) return s; vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len)); for(int i=0;i&lt;len;i++)&#123; dp[i][i]=1; &#125; int start=0; int maxl=1; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(s[i]==s[j])&#123; if(i-j&lt;=2)&#123; dp[j][i]=1; &#125;else&#123; dp[j][i]=dp[j+1][i-1]; &#125; &#125; if(dp[j][i]==1)&#123; int temp=i-j+1; if(temp&gt;maxl)&#123; maxl=temp; start=j; &#125; &#125; &#125; &#125; return s.substr(start,maxl); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"HDU_1284","date":"2020-08-31T12:58:32.000Z","path":"2020/08/31/HDU-1284/","text":"钱币兑换问题\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 15976 Accepted Submission(s): 9546** Problem Description 在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。 Input 每行只有一个正整数N，N小于32768。 Output 对应每个输入，输出兑换方法数。 Sample Input 12293412553 Sample Output 1271883113137761 Author SmallBeer(CML) Source 杭电ACM集训队训练赛（VII） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;//相当于3件物品，容量为N的背包，第i件物品的重量是i//初始化: dp[0][0]=1//dp[i][j]表示用前i件物品组成j的方案数量//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;//滚动数组优化：//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;using namespace std;int temp;const int maxn=33000;//32468long long int dp[maxn];int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; memset(dp,0,sizeof(dp)); dp[0]=1; for(int i=1;i&lt;=3;i++)&#123; for(int j=i;j&lt;maxn;j++)&#123; dp[j]+=dp[j-i]; // printf(\"%lld\\n\",dp[j]); // dp[j]+=max(dp[j],dp[j-i]); &#125; &#125;// printf(\"here\");//// scanf(\"%d\",&amp;temp);// printf(\"%lld\",dp[temp]); while(scanf(\"%d\",&amp;temp)==1)&#123; printf(\"%I64d\\n\",dp[temp]); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode19_m","date":"2020-08-31T03:12:38.000Z","path":"2020/08/31/leetcode19-m/","text":"19. 删除链表的倒数第N个节点难度中等947收藏分享切换为英文关注反馈 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗 快慢指针的想法来实现: 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* l; ListNode*r; l=head; r=head; ListNode* temp; int cnt=0; for(cnt=0;cnt&lt;n;cnt++)&#123; r=r-&gt;next; &#125; if(r==nullptr)&#123; return head-&gt;next; &#125; //cout&lt;&lt;r-&gt;val&lt;&lt;endl; while(r-&gt;next!=nullptr)&#123; r=r-&gt;next; l=l-&gt;next; &#125; // cout&lt;&lt;l-&gt;val&lt;&lt;endl; l-&gt;next=l-&gt;next-&gt;next; return head; &#125;&#125;;","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode16_m","date":"2020-08-31T03:11:14.000Z","path":"2020/08/31/leetcode16-m/","text":"16. 最接近的三数之和难度中等530 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 123输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。 提示： 3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4 通过次数141,122 提交次数308,415 和leetcode15相似,主要思路还是排序+双指针 我使用了minA维护了当前的最小值,然后使用res记录和; 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: #排序: -4 -1 1 2 #minA 对于遍历到的每一个i,维护minA; #每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回; n=len(nums) if n&lt;3 or not nums: return NULL minA=sys.maxsize # INT最大值 res=minA nums.sort() for i in range(0,n-2): L=i+1 R=n-1 while L&lt;R: cur=nums[i]+nums[L]+nums[R] if cur==target: minA=0 return cur elif cur&lt;target: tempres=target-cur if abs(tempres)&lt;minA: minA=abs(tempres) res=cur L=L+1 else: tempres=cur-target if abs(tempres)&lt;minA: minA=abs(tempres) res=cur R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode15_m","date":"2020-08-31T03:06:50.000Z","path":"2020/08/31/leetcode15-m/","text":"15. 三数之和难度中等2455 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 通过次数293,697 提交次数1,016,765 还是看了题解,排序太香了！ 主要操作是排序使用双指针进行检查;同时记得去重; 12345678910111213141516171819202122232425262728293031323334class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if n&lt;3 or not nums: return res nums.sort() #从i遍历到n-2,使用双指针维护和探查; #记得去重,也就是对于相同的找最后的; for i in range(0,n): if nums[i]&gt;0: return res if i&gt;0 and nums[i]==nums[i-1]: continue #去重 L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while L&lt; R and nums[R]==nums[R-1]: R=R-1 L=L+1 R=R-1 elif nums[i]+nums[L]+nums[R]&lt;0: L=L+1 else: R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"cmd_vs_rsa","date":"2020-08-10T12:30:55.848Z","path":"2020/08/10/cmd_vs_rsa/","text":"关于windows密钥登录服务器前言:windows的权限管理太屑了 参考https://blog.csdn.net/joshua2011/article/details/90208741","tags":[]},{"title":"Winter plan","date":"2020-01-22T09:17:23.000Z","path":"2020/01/22/winter-learning-plan/","text":"需要完成的目标: 线性代数复习 学习cs224n 刷leetcode 算法竞赛入门经典 目前进度: 线性代数: 1.22 cs224n 1.22 leetcode 1.22 算法竞赛入门经典","tags":[{"name":"flag","slug":"flag","permalink":"http://tyler-ytr.github.io/tags/flag/"}]},{"title":"ubuntu教程","date":"2020-01-22T08:28:15.000Z","path":"2020/01/22/ubuntu-back/","text":"反思 之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了; 重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜 复活操作基本配置 管理员权限,换源,安装vim sudo passwd(修改sudo密码) sudo apt-get update sudo apt-get install vim 更换国内源,这里我选择的是清华源用下面的命令打开文件,并且注释里面的所有内容, sudo vim /etc/apt/sources.list 然后粘贴下面的内容到打开的文件里面# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下; 安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇博客 然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义su apt-get install build-essential apt-get install man # on-line reference manual apt-get install gcc-doc # manual for GCC apt-get install gdb # GNU debugger apt-get install git # reversion control system apt-get install libreadline-dev # a library to use compile the project later apt-get install libsdl2-dev # a library to use compile the project later apt-get install qemu-system-x86 # QEMU 安装chrome:请使用bing搜索;用gmail同步很香; 科学的看世界 我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json 将下面的内容根据自己的配置放进去: { \"server\":\"my_server_ip\", \"server_port\":53450, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"密码\", \"timeout\":300, \"method\":\"aes-256-gcm\", \"fast_open\": false } 然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;自己测试一下有没有问题; 感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)： 先写一个自启动脚本： touch ~/.ssstart.sh vim ~/.ssstart.sh 内容是: #!/bin/bash ss-local -c ~/shadowsocks/shadowsocks.json 然后在终端里面起别名:vim ~/.bashrc在末尾添加:alias ss=’. ~/.ssstart.sh’:wq 保存,退出在终端里面:source ~/.bashrc(如果是zsh:source ~/.zshrc)尝试一下在终端输入ss,它lei了; 因为后面的netdata需要终端翻墙,我也就尝试了一下,如果没有需求可以跳过这一步: 主要参考的是谷歌出来的网站 首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装 下面尝试全局代理(我也不确定能不能成功)： sudo pip install genpac 选择安装配置文件的目录,我选择的是:/home/larryytr/shadowsocks 然后执行以下命令:sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 下面是一句搬运,我没有遇到过:注意：如果报错“fetch gfwlist fail.online: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 执行完之后,目录下面会有一个autoproxy.pac文件。 然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写： file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改) 然后使得终端也能使用代理。我们需要privoxy代理工具: 安装很自然:sudo apt-get install privoxy 然后编辑配置文件sudo vim /etc/privoxy/config 在文档中搜索(vim 使用/搜索)“listen-address”（即监听地址），找到如下一行：listen-address localhost:8118 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“forward-socks5t”，找到如下一行：forward-socks5t / 127.0.0.1:1080 . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy： 1sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config 最后，再配置/etc/profile： # 先进入编辑模式 sudo vim /etc/profile # 在末尾添加以下三行： export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118export ftp_proxy=http://127.0.0.1:8118 # 退出之后记得执行 source /etc/profile 验证是否成功:curl www.google.com或wget www.google.com判断是否可以访问 HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！ 优化美化 官网安装网易云 官网安装vscode 配置zsh,tmux,vim: zsh安装与美化 学习了:https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/https://segmentfault.com/a/1190000013612471这两篇教程; 感谢何伟的配置文件; 相应的setting请参考我的github相关内容. 安装zsh:sudo apt-get update sudo apt-get install zsh chsh -s /bin/zsh (设置zsh为默认) 重启你的ubuntu 安装oh-my-zsh插件: wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 不改theme一无所有 准备使用powerline主题 首先安装powerline字体： git clone https://github.com/powerline/fonts.git --depth=1 # install cd fonts ./install.sh # clean-up a bit cd .. rm -rf fonts 安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久) 安装powerline: sudo apt install powerline 我的配置见相关内容的setting .zshrc 颜色选择困难请: for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f” 改完请source ~/.zshrc tmux tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程; 我使用了何伟的配置,具体见相关内容的setting 我又加了一个插件使得tmux在重启之后状态可以恢复: 主要参考这个知乎教程 git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp 在~/.tmux.conf.local里面加上:run-shell ~/tmux_tmp/resurrect.tmux 最后载入这个配置：tmux source-file ~/.tmux.conf vim的美化 使用啦懒人vim: spf13-vim美化 请看相关内容的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh 我的配置同样在相关内容的setting里面; 这个时候的vim没有办法和系统剪切版交互,我根据https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html 下载了其他一些插件:sudo apt-get install vim-scripts vim-gtk vim-gnome这样 vim –version|grep “cliboard” 会看到 +clipboard;然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！ 其他内容: OSlab还需要: sudo apt-get install curl sudo apt-get install gcc-multilib git 配置请搜索廖雪峰 ctags 可以参考Mengzelev的博客 感谢xnr给我推荐的network来查看linux的运行情况 这是netdata的官方网站:https://github.com/netdata/netdata#user-base 但是由于GFW,安装会出现报错,事实上需要终端翻墙才行 可以通过这篇教程 sudo apt-get install net-tools ifconfig查看inet 之后的内容来得知自己的server_ip 成功之后,进入 http://127.0.0.1:19999/ (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验 相应配置可以参考这篇博客或者自己搜索 OSlab的kvm bug处理方法：https://bugzilla.redhat.com/show_bug.cgi?id=1479558chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content: KERNEL==\"kvm\", GROUP=\"kvm\", MODE=\"0666\" texlive 安装sudo apt install texlive-full 相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting) vscode的保存即编译请Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾； ubuntu的截图:我参考了这篇博客 打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+ 显然的配置好按键,然后在命令里面写gnome-screenshot -a hint:上面的命令终端输入也有效截屏的图在文件夹的图片(picture)里面; To be continued 有空再研究怎么换主题;","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hello World","date":"2020-01-20T19:20:25.723Z","path":"2020/01/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]