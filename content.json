[{"title":"git以及ssh代理的配置","date":"2021-07-02T07:43:45.000Z","path":"2021/07/02/git以及ssh代理的配置/","text":"git以及ssh代理的配置鄢老师提供的方案并根据自己的情况进行了调整； 修改ssh的config文件文件位置在C:\\Users\\用户名\\.ssh 目前的版本 12Host github.com ProxyCommand connect -H 127.0.0.1:7890 %h %p 修改gitconfig文件文件位置在C:\\Users\\用户名\\.gitconfig里面; 目前的版本: 1234567891011121314[user] email &#x3D; 邮箱 name &#x3D; 名字[core] autocrlf&#x3D;input[socks] proxy&#x3D;127.0.0.1:7890[http &quot;http:&#x2F;&#x2F;github.com&quot;] proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890[filter &quot;lfs&quot;] clean&#x3D;git-lfs clean -- %f smudge&#x3D;git-lfs smudge -- %f process&#x3D;git-lfs filter-process required&#x3D;true 如果改了代理的客户端请修改端口7890即可","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"学校服务器访问外网的配置","date":"2021-07-02T07:37:05.000Z","path":"2021/07/02/学校服务器访问外网的配置/","text":"访问外网的配置服务器1命令行中使用: 1setproxy 就可以通过代理服务器1的服务器1的端口访问外网。 NAT的方法(目前不用，仅作参考)服务器1可以上外网；服务器2不能上外网，但是在内网与服务器1互通；下面的操作是用iptables在服务器1上对服务器2搭建一个NAT; 并且修改服务器2的默认路由，达到服务器2访问外网的目的； 服务器11iptables -t nat -A POSTROUTING -s 服务器2 -j MASQUERADE 查看iptables： 1sudo iptables -t nat -L 带检索的查看iptables: 1sudo iptables -t nat -L POSTROUTING --line-numbers 删除刚刚操作之后的表项:(请根据查询的编号决定是不是1) 1sudo iptables -t nat -D POSTROUTING 1 服务器2查看路由 1route -n 增加默认路由:(这个操作可能会让ssh连接断掉) 1sudo route add default gw 服务器1 删除路由: 1sudo route del default gw 服务器1 具体实现流程:A表示服务器1；B表示服务器2 首先用在A上iptables -t nat -A POSTROUTING -s B的地址 -j MASQUERADE；然后SSH连接B；B上用sudo route add default gw A的地址；此时SSH 会连接B失败；然后从A上用SSH连接B；此时连接的B可以通过A的NAT访问外网然后安装v2ray;然后删除路由;退出之后在A上删除刚刚的iptables表项 iptables那步的作用是搭建了A对于B开启了nat服务;B通过修改路由把数据包转发到A上，进而访问外网; 上面的方法也是一种上网方法；只不过不是很方便 配置完之后通过v2ray访问外网; 实现流程的反思实际上可能不需要那么复杂。在能出外网的服务器1上面安装v2ray，更改配置文件保证http,socks5的代理就行了；不能连接外网的服务器通过export ALL_PROXY=socks5://服务器1的地址:端口;就可以出去了 v2ray（目前使用）安装通过来自https://github.com/v2fly/fhs-install-v2ray的脚本安装; v2ray启用: 1sudo systemctl enable v2ray v2ray打开: 1sudo systemctl start v2ray v2ray关闭: 1sudo systemctl stop v2ray 每次修改完配置文件之后需要重启 服务器1配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;log&quot;: &#123; &quot;access&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;access.log&quot;, &quot;error&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;error.log&quot;, &quot;loglevel&quot;: &quot;warning&quot; &#125;, &quot;inbounds&quot;: [ &#123; &quot;port&quot;: 端口号, &quot;protocol&quot;: &quot;http&quot;, &quot;settings&quot;: &#123;&#125; &#125;, &#123; &quot;port&quot;: 端口号, &quot;protocol&quot;: &quot;socks&quot;, &quot;settings&quot;: &#123;&#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: &#123;&#125;, &quot;tag&quot;: &quot;direct&quot; &#125; ], &quot;routing&quot;: &#123; &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;, &quot;rules&quot;: [ &#123; &quot;type&quot;: &quot;field&quot;, &quot;outboundTag&quot;: &quot;direct&quot;, &quot;domain&quot;: [&quot;geosite:cn&quot;] &#125;, &#123; &quot;type&quot;: &quot;field&quot;, &quot;outboundTag&quot;: &quot;direct&quot;, &quot;ip&quot;: [ &quot;geoip:cn&quot;, &quot;geoip:private&quot; ] &#125; ] &#125;&#125; 上述配置文件实现了socks5和http的代理; 服务器2我在.bashrc里面最后添加了: 1alias setproxy&#x3D;&quot;export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;服务器1:端口号;echo &#39;You can use &#39;unset ALL_PROXY&#39; to unset it &#39;&quot; 使用setproxy即可通过服务器1访问外网;通过unset ALL_PROXY来修改回默认设置; 于此同时该服务器也安装了v2ray；有需求的同学可以自行配置; 使用 1wget www.baidu.com 来进行连通性的测试;（不知道什么原因ping不通baidu） 参考网站https://www.v2ray.com/ https://segmentfault.com/a/1190000039686752 https://blog.csdn.net/yelllowcong/article/details/75949296","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"p4学习-6:实现网络测量","date":"2021-04-20T04:16:42.000Z","path":"2021/04/20/p4学习-6/","text":"p4学习-6:实现网络测量实验目标这个练习的目标是写一个P4程序允许一个主机区检测网络中所有链路的利用情况。这个练习是在基础的IPV4 forwarding练习上搭建的。具体来说，我们将修改基本的P4程序，以处理源路由探测包，使其能够在每一跳提取出口链路利用率，并将其交付给主机进行监控。 探测包由下面三种header types组成: 123456789101112131415161718192021222324&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe&#x2F;&#x2F; packet has traversed so far.&#x2F;&#x2F;顶层的探测header,指出这个探测包经过了多少跳header probe_t &#123; bit&lt;8&gt; hop_cnt;&#125;&#x2F;&#x2F; The data added to the probe by each switch at each hop.&#x2F;&#x2F;每一个交换机加到探测包上面的数据header probe_data_t &#123; bit&lt;1&gt; bos;&#x2F;&#x2F;bottom of stack bit&lt;7&gt; swid;&#x2F;&#x2F;switch ID bit&lt;8&gt; port; bit&lt;32&gt; byte_cnt;&#x2F;&#x2F;和下面的寄存器应该对应 time_t last_time;&#x2F;&#x2F;和下面的寄存器应该对应 time_t cur_time;&#125;&#x2F;&#x2F; Indicates the egress port the switch should send this probe&#x2F;&#x2F; packet out of. There is one of these headers for each hop.&#x2F;&#x2F;指示交换机应该发送该探测报文的出口端口。每个跳跃都有一个这样的 headerheader probe_fwd_t &#123; bit&lt;8&gt; egress_spec;&#125; topology 拓扑如上，包含了四个主机连接到四个交换机上面，连接方式好像他们在fat tree 的pod上一样。 为了监控链路利用率，交换机将维持两个寄存器数组： byte_cnt_reg 自最后一个探测包从端口传输出去以来，每个端口传输出去的字节数。 last_time_reg保存探测包最后一次从每个端口发送出去的时间。 P4程序将被写成V1Model形式（bmv2交换机），V1model可以参考它的官方源码 补充： FatTree胖树拓扑结构传统结构： image-20210420125915925 传统数据中心采用多层级的树形结构，这种结构针对客户端/服务器（C/S）模式能有较好的效果。树形结构包括单根树和多根树。多根数的根节点往往作为备份节点存在（我们以方格代表交换机） 缺点：传统单根/多根拓扑结构有以下缺点：成本高，根部交换机必须要有足够大的带宽来满足下层服务器之间的通信；性能瓶颈，无法满足数据中心内部大规模的MapReduce和数据拷贝。 FatTree 拓扑结构： Fat-Tree是以交换机为中心的拓扑。支持在横向拓展的同时拓展路径数目；且所有交换机均为相同端口数量的普通设备，降低了网络建设成本。 整个拓扑网络分为三个层次：自上而下分别为边缘层（edge）、汇聚层（aggregate）和核心层（core），其中汇聚层交换机与边缘层交换机构成一个pod，交换设备均采用商用交换设备。 一个k元的Fat-Tree可以归纳为5个特征： 每台交换机都有k个端口； 核心层为顶层，一共有(k/2)^2个交换机； 一共有k个pod，每个pod有k台交换机组成。其中汇聚层和接入层各占k/2台交换机； 接入层每个交换机可以容纳k/2台服务器，因此，k元Fat-Tree一共有k个pod，每个pod容纳$kk/4$个服务器，所有pod共能容纳$kk*k/4$台服务器；任意 两个pod之间存在k条路径。 例子： 二叉FatTree 二叉FatTree 四叉FatTree 四叉FatTree 因此上面练习的拓扑就像四叉FatTree的一个pod 代码实现headers部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#x2F;* -*- P4_16 -*- *&#x2F;#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;const bit&lt;16&gt; TYPE_PROBE &#x3D; 0x812;#define MAX_HOPS 10#define MAX_PORTS 8&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;typedef bit&lt;48&gt; time_t;header ethernet_t &#123; macAddr_t dstAddr; macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;header ipv4_t &#123; bit&lt;4&gt; version; bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe&#x2F;&#x2F; packet has traversed so far.header probe_t &#123; bit&lt;8&gt; hop_cnt;&#125;&#x2F;&#x2F; The data added to the probe by each switch at each hop.header probe_data_t &#123; bit&lt;1&gt; bos; bit&lt;7&gt; swid; bit&lt;8&gt; port; bit&lt;32&gt; byte_cnt; time_t last_time; time_t cur_time;&#125;&#x2F;&#x2F; Indicates the egress port the switch should send this probe&#x2F;&#x2F; packet out of. There is one of these headers for each hop.header probe_fwd_t &#123; bit&lt;8&gt; egress_spec;&#125;struct parser_metadata_t &#123; bit&lt;8&gt; remaining;&#125;struct metadata &#123; bit&lt;8&gt; egress_spec; parser_metadata_t parser_metadata;&#125;struct headers &#123; ethernet_t ethernet; ipv4_t ipv4; probe_t probe; probe_data_t[MAX_HOPS] probe_data; probe_fwd_t[MAX_HOPS] probe_fwd;&#125; 比之前的IPV4 forwarding多了三个探测包的header Parser部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet; &#125; state parse_ethernet &#123; packet.extract(hdr.ethernet); transition select(hdr.ethernet.etherType) &#123; TYPE_IPV4: parse_ipv4; TYPE_PROBE: parse_probe; default: accept; &#125; &#125; state parse_ipv4 &#123; packet.extract(hdr.ipv4); transition accept; &#125; state parse_probe &#123; packet.extract(hdr.probe); meta.parser_metadata.remaining &#x3D; hdr.probe.hop_cnt + 1; transition select(hdr.probe.hop_cnt) &#123; 0: parse_probe_fwd; default: parse_probe_data; &#125; &#125; state parse_probe_data &#123; packet.extract(hdr.probe_data.next); transition select(hdr.probe_data.last.bos) &#123; 1: parse_probe_fwd; default: parse_probe_data; &#125; &#125; state parse_probe_fwd &#123; packet.extract(hdr.probe_fwd.next); meta.parser_metadata.remaining &#x3D; meta.parser_metadata.remaining - 1; &#x2F;&#x2F; extract the forwarding data meta.egress_spec &#x3D; hdr.probe_fwd.last.egress_spec; transition select(meta.parser_metadata.remaining) &#123; 0: accept; default: parse_probe_fwd; &#125; &#125;&#125; 流程是：先进入start状态，通过ethernet的etherType确定是 ipv4包还是探测包，如果是ipv4包，略；如果是探测包，那么看看是不是第一个跳，探测包经过第一跳的时候不会有其他信息，因此可以直接进入向前转发的状态；否则就更新matada里面的remaing，进入parse_probe_data状态解析probe_data.next的信息，知道解析到last.bos也就是栈底的时候再进入向前转发状态；向前转发状态(parse_probe_fwd)里面,使用hdr.probe.hop_cnt指出了哪一个egress_spec来处理向前转发，并且把这个端口号存在一个metadata的域里面； Ingress Control 部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec &#x3D; port; hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; hdr.ethernet.dstAddr &#x3D; dstAddr; hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; apply &#123; if (hdr.ipv4.isValid()) &#123; ipv4_lpm.apply(); &#125; else if (hdr.probe.isValid()) &#123; standard_metadata.egress_spec &#x3D; (bit&lt;9&gt;)meta.egress_spec; hdr.probe.hop_cnt &#x3D; hdr.probe.hop_cnt + 1; &#125; &#125;&#125; 比basic那个实验多了一个如果hdr.probe.isValid()（也就是这个包是探测包），就记录 egress_spec并且更新hdr.probe.hop_cnt Egress Control 部分 这部分是状态处理发生的地方，使用byte_cnt_regs寄存器在计算自最后一个探测包通过该端口以来通过每个端口的字节数； 这部分增加了一个新的probe_data ,并且填写了 bos (bottom of stack) 和 swid (switch ID)； 要做的部分是填写探测包字段的其余部分，以确保您可以正确地测量链路利用率 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G *********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; &#x2F;&#x2F; count the number of bytes seen since the last probe register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg; &#x2F;&#x2F; remember the time of the last probe register&lt;time_t&gt;(MAX_PORTS) last_time_reg; action set_swid(bit&lt;7&gt; swid) &#123; hdr.probe_data[0].swid &#x3D; swid; &#125; table swid &#123; actions &#x3D; &#123; set_swid; NoAction; &#125; default_action &#x3D; NoAction(); &#125; apply &#123; bit&lt;32&gt; byte_cnt; bit&lt;32&gt; new_byte_cnt; time_t last_time; time_t cur_time &#x3D; standard_metadata.egress_global_timestamp; &#x2F;&#x2F; increment byte cnt for this packet&#39;s port byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port); byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length; &#x2F;&#x2F; reset the byte count when a probe packet passes through new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt; byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt); if (hdr.probe.isValid()) &#123; &#x2F;&#x2F; fill out probe fields hdr.probe_data.push_front(1); hdr.probe_data[0].setValid(); if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123; hdr.probe_data[0].bos &#x3D; 1; &#125; else &#123; hdr.probe_data[0].bos &#x3D; 0; &#125; &#x2F;&#x2F; set switch ID field swid.apply(); &#x2F;&#x2F; TODO: fill out the rest of the probe packet fields &#x2F;&#x2F; hdr.probe_data[0].port &#x3D; ... &#x2F;&#x2F; hdr.probe_data[0].byte_cnt &#x3D; ... &#x2F;&#x2F; TODO: read &#x2F; update the last_time_reg &#x2F;&#x2F; last_time_reg.read(&lt;val&gt;, &lt;index&gt;); &#x2F;&#x2F; last_time_reg.write(&lt;index&gt;, &lt;val&gt;); &#x2F;&#x2F; hdr.probe_data[0].last_time &#x3D; ... &#x2F;&#x2F; hdr.probe_data[0].cur_time &#x3D; ... &#125; &#125;&#125; 解答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G *********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; &#x2F;&#x2F; count the number of bytes seen since the last probe register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg; &#x2F;&#x2F; remember the time of the last probe register&lt;time_t&gt;(MAX_PORTS) last_time_reg; action set_swid(bit&lt;7&gt; swid) &#123; hdr.probe_data[0].swid &#x3D; swid; &#125; table swid &#123; actions &#x3D; &#123; set_swid; NoAction; &#125; default_action &#x3D; NoAction(); &#125; apply &#123; bit&lt;32&gt; byte_cnt; bit&lt;32&gt; new_byte_cnt; time_t last_time; time_t cur_time &#x3D; standard_metadata.egress_global_timestamp; &#x2F;&#x2F; increment byte cnt for this packet&#39;s port byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port); byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length; &#x2F;&#x2F; reset the byte count when a probe packet passes through new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt; byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt); if (hdr.probe.isValid()) &#123; &#x2F;&#x2F; fill out probe fields hdr.probe_data.push_front(1); hdr.probe_data[0].setValid(); if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123; hdr.probe_data[0].bos &#x3D; 1; &#125; else &#123; hdr.probe_data[0].bos &#x3D; 0; &#125; &#x2F;&#x2F; set switch ID field swid.apply(); hdr.probe_data[0].port &#x3D; (bit&lt;8&gt;)standard_metadata.egress_port; hdr.probe_data[0].byte_cnt &#x3D; byte_cnt; &#x2F;&#x2F; read &#x2F; update the last_time_reg last_time_reg.read(last_time, (bit&lt;32&gt;)standard_metadata.egress_port); last_time_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, cur_time); hdr.probe_data[0].last_time &#x3D; last_time; hdr.probe_data[0].cur_time &#x3D; cur_time; &#125; &#125;&#125; 其余部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#x2F;************************************************************************************** C H E C K S U M C O M P U T A T I O N ****************************************************************************************&#x2F;control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; update_checksum( hdr.ipv4.isValid(), &#123; hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr &#125;, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16); &#125;&#125;&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet); packet.emit(hdr.ipv4); packet.emit(hdr.probe); packet.emit(hdr.probe_data); packet.emit(hdr.probe_fwd); &#125;&#125;&#x2F;************************************************************************************************ S W I T C H ********************************************************************************************************&#x2F;V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(),MyComputeChecksum(),MyDeparser()) main; probe_hdrs.py分析:123456789101112131415161718192021222324from scapy.all import *TYPE_PROBE &#x3D; 0x812class Probe(Packet): fields_desc &#x3D; [ ByteField(&quot;hop_cnt&quot;, 0)]class ProbeData(Packet): fields_desc &#x3D; [ BitField(&quot;bos&quot;, 0, 1), BitField(&quot;swid&quot;, 0, 7), ByteField(&quot;port&quot;, 0), IntField(&quot;byte_cnt&quot;, 0), BitField(&quot;last_time&quot;, 0, 48), BitField(&quot;cur_time&quot;, 0, 48)]class ProbeFwd(Packet): fields_desc &#x3D; [ ByteField(&quot;egress_spec&quot;, 0)]bind_layers(Ether, Probe, type&#x3D;TYPE_PROBE)bind_layers(Probe, ProbeFwd, hop_cnt&#x3D;0)bind_layers(Probe, ProbeData)bind_layers(ProbeData, ProbeData, bos&#x3D;0)bind_layers(ProbeData, ProbeFwd, bos&#x3D;1)bind_layers(ProbeFwd, ProbeFwd) 这部分是在控制平面用scapy定义了探测包的结构，从bind_layers可以看出，结构关系大概如下： 123456789101112131415Ethernet&#123; ..... Probe&#123; ProbeFwd&#123; ProbeFwd&#123; .... &#125; &#125; ProbeData&#123; ProbeData&#123; .... &#125; &#125; &#125;&#125; 这样其中ProbeFwd以及ProbeData可以嵌套；具体的结构在class里面进行了定义 send.py分析12345678910111213141516171819202122232425262728#!&#x2F;usr&#x2F;bin&#x2F;env pythonimport sysimport timefrom probe_hdrs import *def main(): probe_pkt &#x3D; Ether(dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;, src&#x3D;get_if_hwaddr(&#39;eth0&#39;)) &#x2F; \\ Probe(hop_cnt&#x3D;0) &#x2F; \\ ProbeFwd(egress_spec&#x3D;4) &#x2F; \\ ProbeFwd(egress_spec&#x3D;1) &#x2F; \\ ProbeFwd(egress_spec&#x3D;4) &#x2F; \\ ProbeFwd(egress_spec&#x3D;1) &#x2F; \\ ProbeFwd(egress_spec&#x3D;3) &#x2F; \\ ProbeFwd(egress_spec&#x3D;2) &#x2F; \\ ProbeFwd(egress_spec&#x3D;3) &#x2F; \\ ProbeFwd(egress_spec&#x3D;2) &#x2F; \\ ProbeFwd(egress_spec&#x3D;1)# 根据拓扑也就是s1-s1的4端口出到s4,s41端口出到s2…… while True: try: sendp(probe_pkt, iface&#x3D;&#39;eth0&#39;)# 每隔一秒发一个探测包 time.sleep(1) except KeyboardInterrupt: sys.exit()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 这部分要结合拓扑图来看: topology 这部分probe_pkt这个包其实仔细观察不难发现，它里面的ProbeFwd和拓扑图的路线完全一致，假设是s1进行了发包，那么就是从s1-s1的4端口出到s4,s4的1端口出到s2……然后完成了一个回路到了s1;下面的代码只是每隔一秒钟发一下罢了； receive.py分析1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;env pythonfrom probe_hdrs import *def expand(x): yield x while x.payload: x &#x3D; x.payload yield xdef handle_pkt(pkt): if ProbeData in pkt: data_layers &#x3D; [l for l in expand(pkt) if l.name&#x3D;&#x3D;&#39;ProbeData&#39;] print &quot;&quot; for sw in data_layers: utilization &#x3D; 0 if sw.cur_time &#x3D;&#x3D; sw.last_time else 8.0*sw.byte_cnt&#x2F;(sw.cur_time - sw.last_time) print &quot;Switch &#123;&#125; - Port &#123;&#125;: &#123;&#125; Mbps&quot;.format(sw.swid, sw.port, utilization)def main(): iface &#x3D; &#39;eth0&#39; print &quot;sniffing on &#123;&#125;&quot;.format(iface) sniff(iface &#x3D; iface, prn &#x3D; lambda x: handle_pkt(x)) #prn指定回调函数，每当一个符合filter的报文被探测到时，就会执行回调函数，通常使用lambda表达式来写回调函数if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() expand 这个就是一个走yield的递归的函数； handle_pkt这部分首先实会不停的往后整pkt得到ProbeData的部分然后存到data_layer里面，然后解析里面的内容，看utilization，计算公式就是以Bit为单位的数据除以时间； main还是里面的sniff是一个过滤器，其实是iface为”eth0”的包就扔到handle_pkt里面去处理； 实验过程 跑: 1make run 编译link_monitor.p4 在mininet里面启动如上面图片的拓扑并且将所有的交换机都设置好p4程序和相应的table entries 根据topology.json设置所有的主机 使用mininet打开h1端口，开两个 1mininet&gt; xterm h1 h1 在一个窗口里面跑send.py脚本可以开始每秒发送探测包。探测包的路线和拓扑图一样 1./send.py 在另一个窗口跑receive.py可以开始接受并且接受这些探测包 1./receive.py 报告的链路利用率和交换机端口号将始终为0，因为探测字段还没有填写。 在h1和h4之间开一个iperf流 1mininet&gt;iperf h1 h4 在所有窗口里面exit然后make stop 测量的链路利用率与iperf报告的不一致，因为探测包字段还没有填充。您的目标是填写探测包字段，以便两个测量结果一致。 控制平面的一些说明P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。 在这个练习中，我们已经为您实现了控制平面逻辑。作为启动Mininet实例的一部分，make run命令将在每个交换机的表中安装包处理规则。这些是在sX-runtime.json中定义的，其中X 对应开关号。 注意点：我们使用P4Runtime来安装控制平面规则。 sX-runtime.json文件的运行时的内容指的是表、键和动作的特定名称，如编译器生成的P4Info文件中定义的(在执行make run后查找 build/link_monitor.p4.p4info.txt文件)。P4程序中添加或重命名表、键或操作的任何更改都需要反映在这些 sX-runtime.json文件中。","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"匈牙利算法","date":"2021-04-13T07:12:02.000Z","path":"2021/04/13/匈牙利算法/","text":"匈牙利算法匈牙利算法适用于二分图匹配有关的问题 二分图（Bipartite graph）是一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相连。下图是典型的二分图。 img 可以看到，在上面的二分图中，每条边的端点都分别处于点集X和Y中。匈牙利算法主要用来解决两个问题：求二分图的最大匹配数和最小点覆盖数。 在图论中，一个“匹配”（matching）是一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。 邻接矩阵算法123456789101112131415161718192021222324int n,m;//m代表右侧集合的元素数量,n代表左侧集合的元素数量int map[MAXN][MAXN];//邻接矩阵存图int match[MAXN];//记录当前右侧元素所对一个的左侧元素bool vis[MAXN];//记录右侧元素是否被访问过bool find(int x)&#123; for(int i = 1; i &lt;= m; ++i)&#123; if(map[x][i] &amp;&amp; !vis[i]) &#123;//右边并且i没有被访问 vis[i] = true;//记录状态为访问过 if(match[i] == 0 || find(match[i]))&#123;//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配 match[i] = x;//当前左侧元素成为当前右侧元素的新匹配 return true;//返回匹配成功 &#125; &#125; &#125; return false;//循环结束，仍未找到匹配，返回匹配失败&#125;int Hungarian()&#123; for(int i = 1; i &lt;= n; ++i) &#123; memset(vis, 0 , sizeof(vis)); if(find(i)) ans ++; &#125; return ans;&#125; 邻接链表算法邻接链表数据结构1234567891011121314151617struct Edge&#123; int to,next;&#125;edge[maxn];//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键int head[maxn],tot;//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1void init()&#123; tot=0; memset(head,-1,sizeof(head));&#125;//初始化函数void addedge(int u,int v)&#123; edge[tot].to=v;//对边进行编号 edge[tot].next=head[u];//将U这个点上一次连接的点记录如果没有即为-1 head[u]=tot++;//等于边的编号，之后edge[head[u]]即可调用这个边&#125;//加边函数 理解一下邻接链表： 邻接矩阵如下，但是它不适合稀疏图 邻接矩阵 邻接链表适合稀疏图： 邻接链表 因此结合上面的代码，head数组相当于邻接链表的一个个头，head[a]可以得到a的第一个边，通过edge[head[a]]获得，然后edge[head[a]].next可以得到下一条边的编号…… 邻接链表匈牙利 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;const int maxn=200010;//边数的最大值//参考资料https://zhuanlan.zhihu.com/p/96229700；//整理的笔记:https://tyler-ytr.github.io/2021/04/13/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95///邻接链表定义struct Edge&#123; int to,next;&#125;edge[maxn];//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键int head[maxn],tot;//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1void init()&#123; tot=0; memset(head,-1,sizeof(head));&#125;//初始化函数void addedge(int u,int v)&#123; edge[tot].to=v;//对边进行编号 edge[tot].next=head[u];//将U这个点上一次连接的点记录如果没有即为-1 head[u]=tot++;//等于边的编号，之后edge[head[u]]即可调用这个边&#125;//加边函数//匈牙利算法int match[maxn];//记录当前右侧元素所对一个的左侧元素bool vis[maxn];//记录当前右侧元素有没有被访问过int N;//左侧元素的数量bool dfs(int u)&#123;//dfs左侧元素 for (int i=head[u];i!=-1;i=edge[i].next)&#123;//顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后 int v=edge[i].to; if(!vis[v])&#123; vis[v]=true;//记录状态为访问过 if(match[v]==-1||dfs(match[v]))&#123;//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配 match[v]=u;//当前左侧元素成为当前右侧元素的新匹配 return true;//返回匹配成功 &#125; &#125; &#125; return false;&#125;int Hungarian()&#123; int res=0; memset(match,-1,sizeof(match)); for(int i=0;i&lt;N;++i)&#123; memset(vis,false,sizeof(vis)); if(dfs(i))++res; &#125; return res;&#125; 例题问题 A: 二部图最大匹配 题目描述输入一个由X、Y两部分组成的二部图，试求图上最大匹配的规模（无需输出方案） 输入第1行输入两个数，分别代表X和Y部的顶点数 第2行~第x+1行，第i行的第一个数k表示X部第(i-1)个与Y部的k个点之间有边。接下来k个数为Y部与其有边的顶点的标号。（点的标号从1开始） 输入保证X部、Y部顶点数量均不超过10^5，总边数不超过2*10^5。 输出输出1行，行内只有一个整数，为图上最大匹配的规模 样例输入123454 42 3 21 21 31 1 样例输出13 提示： 样例解释：一个最大匹配是{(X1, Y3), (X2, Y2), (X4, Y1)} 。 一个显而易见的事实是：你不应该尝试使用邻接矩阵存储图上的边。 事实上，正确执行的算法并不需要每次遍历整个图（就像样例这样，除了X2以外的点搜索的第一条边就可以加入匹配）。我们提供的绝大部分数据是稀疏图，如果你的算法对此做了正确设计，使用C/C++实现的程序执行时间应该明显低于1秒。如果你写出了时间复杂度Theta(V^2)的实现，那……也许你会在一部分数据上超时，也许不会 代码:(耗时99) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;const int maxn&#x3D;200010;&#x2F;&#x2F;边数的最大值&#x2F;&#x2F;参考资料https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;96229700；&#x2F;&#x2F;整理的笔记:https:&#x2F;&#x2F;tyler-ytr.github.io&#x2F;2021&#x2F;04&#x2F;13&#x2F;%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&#x2F;&#x2F;&#x2F;邻接链表定义struct Edge&#123; int to,next;&#125;edge[maxn];&#x2F;&#x2F;to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键int head[maxn],tot;&#x2F;&#x2F;tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1void init()&#123; tot&#x3D;0; memset(head,-1,sizeof(head));&#125;&#x2F;&#x2F;初始化函数void addedge(int u,int v)&#123; edge[tot].to&#x3D;v;&#x2F;&#x2F;对边进行编号 edge[tot].next&#x3D;head[u];&#x2F;&#x2F;将U这个点上一次连接的点记录如果没有即为-1 head[u]&#x3D;tot++;&#x2F;&#x2F;等于边的编号，之后edge[head[u]]即可调用这个边&#125;&#x2F;&#x2F;加边函数&#x2F;&#x2F;匈牙利算法int match[maxn];&#x2F;&#x2F;记录当前右侧元素所对一个的左侧元素bool vis[maxn];&#x2F;&#x2F;记录当前右侧元素有没有被访问过int N;&#x2F;&#x2F;左侧元素的数量bool dfs(int u)&#123;&#x2F;&#x2F;dfs左侧元素 for (int i&#x3D;head[u];i!&#x3D;-1;i&#x3D;edge[i].next)&#123;&#x2F;&#x2F;顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后 int v&#x3D;edge[i].to; if(!vis[v])&#123; vis[v]&#x3D;true;&#x2F;&#x2F;记录状态为访问过 if(match[v]&#x3D;&#x3D;-1||dfs(match[v]))&#123;&#x2F;&#x2F;如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配 match[v]&#x3D;u;&#x2F;&#x2F;当前左侧元素成为当前右侧元素的新匹配 return true;&#x2F;&#x2F;返回匹配成功 &#125; &#125; &#125; return false;&#125;int Hungarian()&#123; int res&#x3D;0; memset(match,-1,sizeof(match)); for(int i&#x3D;0;i&lt;N;++i)&#123; memset(vis,false,sizeof(vis)); if(dfs(i))++res; &#125; return res;&#125;int main()&#123;&#x2F;&#x2F;X为左侧，Y为右侧 int M; cin&gt;&gt;N&gt;&gt;M; &#x2F;&#x2F;printf(&quot;%d\\n&quot;,N); int tempnum; int tempy; int j&#x3D;0; init(); for(int i&#x3D;0;i&lt;N;i++)&#123; &#x2F;&#x2F;cin&gt;&gt;tempnum; scanf(&quot;%d&quot;,&amp;tempnum); &#x2F;&#x2F;printf(&quot;%d\\n&quot;,tempnum); for (j&#x3D;0;j&lt;tempnum;j++)&#123; &#x2F;&#x2F;cin&gt;&gt;tempy; scanf(&quot;%d&quot;,&amp;tempy); addedge(i,tempy); &#125; &#125; &#x2F;&#x2F;建图完毕 int result &#x3D; Hungarian(); printf(&quot;%d\\n&quot;,result); return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"C++预处理指令","date":"2021-04-13T05:14:06.000Z","path":"2021/04/13/C-预处理指令/","text":"C++翻译流程与预处理指令参考了C++语言构造手册,cppreference 翻译阶段复制自cppreference 翻译阶段编译器处理 C++ 源文件时，如同严格按照以下顺序进行各个阶段的处理： 阶段 11) （以实现定义方式）将源文件的各个单独字节，映射为基本源字符集的字符。特别是，操作系统相关的行尾指示符均被替换为换行字符。基本源字符集由以下 96 个字符组成： a) 5 个空白字符（空格 (space)、水平制表 (horizontal tab)、垂直制表 (vertical tab)、换页 (form feed)和 换行 (new-line)） b) 10 个数字字符，从 ‘0’ 到 ‘9’ c) 52 个字母，从 ‘a’ 到 ‘z’ 以及从 ‘A’ 到 ‘Z’ d) 29 个标点字符：_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \\ “ ‘ 2) 任何无法被映射到基本源字符集中的字符的源文件字符，均被替换为其通用字符名（用 \\u 或 \\U 转义），或某种被等价处理的由实现定义的形式。 3) 将各个三标符序列替换为其对应的单字符表示。 (C++17 前) 阶段 21) 当反斜杠出现于行尾（其后紧跟换行符）时，删除该反斜杠和换行符并将两个物理源码行组合成一个逻辑源码行。这是单趟操作：如果有一行以两个反斜杠结束且后随一个空行，这三行不会合为一行。若于此阶段组成了通用字符名（\\uXXXX），则行为未定义。 2) 若此步骤后，非空源文件不以换行符结束（无论是原本就无换行，还是以反斜杠结束），则其行为未定义 (C++11 前)在最后添加一个换行符 (C++11 起)。 阶段 31) 将源文件分解为注释，空白字符（空格、水平制表、换行、垂直制表和换页）的序列，和下列各种预处理记号： a) 头文件名，如 或 “myfile.h” b) 标识符 c) 预处理数字 d) ，包含用户定义的 (C++11 起)字符与字符串字面量 e) 运算符与标点（包括代用记号），如 +、&lt;&lt;=、&lt;%、## 或 and f) 不属于任何其他类别的单独非空白字符 2) 恢复在任何原始字符串字面量的首尾双引号之间在阶段 1 和 2 期间进行的所有变换。 (C++11 起) 3) 以一个空格字符替换每段注释。 保留换行符。未指明是否可将非换行空白字符序列缩减成单个空格字符。 若一个给定字符前的输入已被解析为预处理记号，下一个预处理记号通常会由能构成预处理记号的最长字符序列够成，即使这样处理会导致后续分析失败。这常被称为最大吞噬。 12345int foo &#x3D; 1;int bar &#x3D; 0xE+foo; &#x2F;&#x2F; 错误：非法的预处理数字 0xE+fooint baz &#x3D; 0xE + foo; &#x2F;&#x2F; OK int quux &#x3D; bar+++++baz; &#x2F;&#x2F; 错误：bar++ ++ +baz，而非 bar++ + ++baz。 最大吞噬规则仅有的例外是： 若以下一个字符开头的字符序列可作为原始字符串字面量的前缀和起始双引号，则下个预处理记号应当为原始字符串字面量。该字面量由匹配原始字符串模式的最短字符序列组成。#define R &quot;x&quot; const char* s = R&quot;y&quot;; // 非良构的原始字符串字面量，而非 &quot;x&quot; &quot;y&quot; const char* s2 = R&quot;(a)&quot; &quot;b)&quot;; // 原始字符串字面量后随普通字符串字面量若接下来三个字符是 **&lt;::**且后继字符不是 **:** 或者 **&gt;**，则把 **&lt;** 自身当做预处理记号（而非代用记号 &lt;: 的首字符）。struct Foo { static const int v = 1; }; std::vector&lt;::Foo&gt; x; // OK，&lt;: 未被当作 [ 的代用记号 extern int y&lt;::&gt;; // OK，同 extern int y[]。 int z&lt;:::Foo::value:&gt;; // OK，int z[::Foo::value]; (C++11 起) 头文件名预处理记号仅在 #include 指令中形成。 1std::vector&lt;int&gt; x; &#x2F;&#x2F; OK，&lt;int&gt; 不是头文件名 阶段 41) 执行预处理器。 2) #include 指令所引入的每个文件都经历阶段 1 到 4 的处理，递归执行。 3) 此阶段结束时，所有预处理器指令都应从源（代码）移除。 阶段 51) 将字符字面量及字符串字面量中的所有字符从源字符集转换到执行字符集（可以是 UTF-8 这样的多字节字符集，只要阶段 1 中所列的基本源字符集的 96 个字符都拥有单字节表示即可）。 2) 将字符字面量和非原始字符串字面量中的转义序列和通用字符名展开，并转换到执行字符集。 若某个通用字符名所指定的字符不是执行字符集的成员，则结果是由实现定义的，但保证不是空（宽）字符。 注意：某些实现能以命令行选项控制此阶段所进行的转换：gcc 和 clang 用 -finput-charset 指定源字符集的编码，用 -fexec-charset 和 -fwide-exec-charset 指定无编码前缀的 (C++11 起)字符串和字符字面量中的执行字符集的编码，而 Visual Studio 2015 Update 2 及之后版本分别用 /source-charset 和 /execution-charset 指定源字符集和执行字符集。 阶段 6拼接相邻的字符串字面量。 阶段 7进行编译：将各个预处理记号转换成记号。将所有记号当作一个翻译单元进行语法和语义分析并进行翻译。 阶段 8检验每个翻译单元，产生所要求的模板实例化的列表，其中包括显式实例化所要求的实例化。定位模板定义，并进行所要求的实例化，以产生实例化单元。 阶段 9将翻译单元、实例化单元和为满足外部引用所需的库组件汇集成一个程序映像，它含有在其执行环境中执行所需的信息。 注意某些编译器不实现实例化单元（又称为模板仓库或模板注册表），而是简单地在阶段 7 编译每个模板实例化，存储代码于其所显式或隐式要求的对象文件中，然后由连接器于阶段 9 将这些编译后的实例化缩减到一个。 引用 C++11 standard (ISO/IEC 14882:2011): C++98 standard (ISO/IEC 14882:1998): 预编译指令基本的预编译指令 $#$ 空指令 $#define$ 定义宏 $#include$ 包含一个源代码文件 $#undef$取消已经定义的宏 $#if$如果给定条件为真，则编译下面的代码 $#ifdef$如果宏已经定义就编译下面的代码 $#ifndef$如果宏没有定义，就编译下面的代码 $#elif$如果前面的$#if$给定条件不为真，当前条件为真，就编译下面的代码 $#endif$结束一个$#if….#else$条件编译块 $#error$停止编译并且显示错误信息 $# define$ 的一些使用预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。记住仅仅是进行标识符的替换。 例子如下： 用#define实现求最大值和最小值的宏 123456789101112131415161718#include &lt;stdio.h&gt;#define MAX(x,y) (((x)&gt;(y))?(x):(y))#define MIN(x,y) (((x)&lt;(y))?(x):(y))int main(void)&#123;#ifdef MAX //判断这个宏是否被定义 printf(\"3 and 5 the max is:%d\\n\",MAX(3,5));#endif#ifdef MIN printf(\"3 and 5 the min is:%d\\n\",MIN(3,5));#endif return 0;&#125;/* * (1)三元运算符要比if,else效率高 * （2）宏的使用一定要细心，需要把参数小心的用括号括起来， * 因为宏只是简单的文本替换，不注意，容易引起歧义错误。*/ 宏定义错误使用 12345678910111213141516#include &lt;stdio.h&gt;#define SQR(x) (x*x)int main(void)&#123; int b=3;#ifdef SQR//只需要宏名就可以了，不需要参数，有参数的话会警告 printf(\"a = %d\\n\",SQR(b+2));#endif return 0;&#125;/* *首先说明，这个宏的定义是错误的。并没有实现程序中的B+2的平方 * 预处理的时候，替换成如下的结果：b+2*b+2 * 正确的宏定义应该是：#define SQR(x) ((x)*(x)) * 所以，尽量使用小括号，将参数括起来。*/ 宏参数的连接 1234567891011121314151617#include &lt;stdio.h&gt;#define STR(s) #s#define CONS(a,b) (int)(a##e##b)int main(void)&#123;#ifdef STR printf(STR(VCK));#endif#ifdef CONS printf(\"\\n%d\\n\",CONS(2,3));#endif return 0;&#125;/* （绝大多数是使用不到这些的，使用到的话，查看手册就可以了） * 第一个宏，用#把参数转化为一个字符串 * 第二个宏，用##把2个宏参数粘合在一起，及aeb,2e3也就是2000*/ 用宏得到一个字的高位或低位的字节 1234567891011#include &lt;stdio.h&gt;#define WORD_LO(xxx) ((byte)((word)(xxx) &amp; 255))#define WORD_HI(xxx) ((byte)((word)(xxx) &gt;&gt; 8))int main(void)&#123; return 0;&#125;/* * 一个字2个字节，获得低字节（低8位），与255（0000,0000,1111,1111）按位相与 * 获得高字节（高8位），右移8位即可。*/ 用宏定义得到一个数组所含元素的个数 12345678910111213#include &lt;stdio.h&gt;#define ARR_SIZE(a) (sizeof((a))/sizeof((a[0])))int main(void)&#123; int array[100];#ifdef ARR_SIZE printf(\"array has %d items.\\n\",ARR_SIZE(array));#endif return 0;&#125;/* *总的大小除以每个类型的大小 */ $#ifdef$,$#ifndef$,$#endif$…的使用以上这些预编译指令，都是条件编译指令，也就是说，将决定那些代码被编译，而哪些不被编译 实例: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define DEBUGint main(void)&#123; int i &#x3D; 0; char c; while(1) &#123; i++; c &#x3D; getchar(); if(&#39;\\n&#39; !&#x3D; c) &#123; getchar(); &#125; if(&#39;q&#39; &#x3D;&#x3D; c || &#39;Q&#39; &#x3D;&#x3D; c) &#123;#ifdef DEBUG&#x2F;&#x2F;判断DEBUG是否被定义了 printf(&quot;We get:%c,about to exit.\\n&quot;,c);#endif break; &#125; else &#123; printf(&quot;i &#x3D; %d&quot;,i);#ifdef DEBUG printf(&quot;,we get:%c&quot;,c);#endif printf(&quot;\\n&quot;); &#125; &#125; printf(&quot;Hello World!\\n&quot;); return 0;&#125;&#x2F;*#endif用于终止#if预处理指令。*&#x2F; 其他指令1234#error指令将使编译器显示一条错误信息，然后停止编译。#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"}]},{"title":"机器学习导论-3","date":"2021-03-22T03:14:15.000Z","path":"2021/03/22/机器学习导论-3/","text":"线性模型 南瓜书本章连接 基本形式 线性模型一般形式$f(x)=w_1x_1+w_2x_2+\\cdots+w_dx_d+b$ 向量形式$f(x)=w^{T}x+b$ 线性回归 单一属性 基本目标:$f(x)=wx_{i}+b$使得$f(x_{i})\\simeq y_{i}$ 目的是把离散的(比如身高的高中低)转换成连续的量(比如高1.0中0.5),这种情况主要考虑”序”，比如青绿，黑色，蓝色可能没有序，这个时候不妨把它变成[0,1,0]这种向量编码(几个维度整几维); 回归:均方误差最小化 $(w^{},b^{})=arg\\ min_{(w,b)}\\sum_{i=1}^{m}(f(x_{i})-y_i)^2$ 可以使用最小二乘参数估计（求偏导让导数为零，例子要求w,b），计算暂略 偏导(w)整的主要是关于(w)的变化率，等于零的时候意味着到了极大/极小值; 多元属性 基本目标:$f(x_i)=w^Tx_i+b$使得$f(x_{i})\\simeq y_{i}$ 回归: $\\hat{w}^*=\\arg \\min_{\\hat{w}}(y-X\\hat{w})^T(y-X\\hat{w})$ 如果满秩:$\\hat{w}^*=(X^{T}X)^{-1}X^Ty$；$f(\\hat{x_{i}})=\\hat{x_{i}}^{T}(X^{T}X)^{-1}$ 如果不满秩,求助于归纳偏好或者引入正则化(regularization)(也就是加入限制) 求解非线性的模型——广义线性模型: 比如$\\ln y=w^Tx+b$,就可以用$e^{w^Tx+b}$来进行毕竟，称作对数线性回归; $g(\\cdot)$为联系函数(link function)，比如$g(\\cdot)=\\ln(\\cdot)$ 二分类任务 线性回归的实际输出:$z=w^{T}x+b$ 期望输出 $y\\in\\{0,1\\}$ 这个二分类任务就是为了找到一个z,y的联系函数 理想模型：单位阶跃函数 缺陷:数学性质很糟糕，不连续 替代函数——对数几率函数（logistic function）属于sigmoid函数的一种: logistic 和逻辑没有关系,logistic源于logit 不是logic; $y=\\frac{1}{1+e^{-z}}$ 可以表示成$y=\\frac{1}{1+e^{-z}}=\\frac{1}{1+e^{-(w^{T}x+b)}}$ 两边取对数: $\\ln\\frac{y}{1-y}=w^{T}x+b=\\ln\\frac{p(y=1|x)}{p(y=0|x)}$ $\\frac{y}{1-y}$称作几率(odds)，反映了x作为正例相对于负例的相对可能性;对数几率(log odds，亦称logit) 不需要假设数据分布,可以得到“类别”的近似概率预测，并且可以直接应用现有的数值优化算法求最优解，这是分类学习算法 使用极大似然法(maximum likelihood method)求解,给定数据集$\\{(x_{i}, y_{i})\\}^{m}_{i=1}$,对率回归模型最大化“对数似然”: l(w,b)=\\sum_{i=1}^{m}\\ln p (y_i|x_i;w,b) 似然:正例的可能性*正例+负例的可能性*负例","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"机器学习导论-2 模型评估与选择","date":"2021-03-22T02:18:18.000Z","path":"2021/03/22/机器学习导论-2/","text":"机器学习导论-2 模型评估与选择 南瓜书本章推理 空间 假设空间 假设满足XX条件的是好瓜 版本空间 有限训练集，已知XX是好瓜 归纳偏好 假设空间和训练集一致的假设 学习过程中对某种类型假设的偏好称为归纳偏好 No Free Lunch 奥卡姆剃刀：两个模型效果同样好，选择较为简单的 模型评估与选择 经验误差与过拟合 错误率率&amp;误差 错误率：错份样本的占$E=a/m$ 误差：样本真实输出与预测输出之间的差异 训练（经验）误差：训练集上 测试误差：测试集 泛化误差：初训练集外所有样本 过拟合 学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降 优化目标加正则项 Early stop 欠拟合 对训练样本的一般性质尚未学好 决策树：扩展分支 神经网络：增加训练层数 评估方法 留出法 直接将数据集划分为两个互斥集合 训练/测试集划分要尽可能保持数据分布的一致性 一般若干次随机划分，重复实验取平均值 训练/测试样本比例通常为2:1～4:1 交叉验证法 将数据集分层采样划分为$k$个大小相似的互斥子集 自助法 以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\\prime}$，$D\\backslash D^{\\prime}$用作测试集 性能度量 性能度量是衡量模型泛化能力的评价标准，反映任务的需求 回归任务最常用的是“均方误差”： $E(f:D)=\\frac{1}{m}\\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$ 查准率 $P=\\frac{TP}{TP+FP}$ 查全率 $R=\\frac{TP}{TP+FN}$ $P-R$曲线：根据学习器的预测结果对样例排序，“最可能”的正例的在前面，排在最后的是“最不可能”是正例的样本，按此顺序把样本作为整理进行预测，每一次计算出当前的P,R然后以P为纵轴，R为横轴作图 如何利用多次训练得到了多个混淆矩阵？ macro-F1: macro-P=\\frac{1}{n}\\sum^{n}_{i=1}P_i\\\\ macro-R=\\frac{1}{n}\\sum^{n}_{i=1}R_i\\\\ macro-F_1=\\frac{2\\times macro-P\\times macro-R}{macro-P+macro-R}也就是平均P,R之后再算 micro-F1: micro-P=\\frac{\\overline{TP}}{\\overline{TP}+\\overline{FP}}\\\\ micro-R=\\frac{\\overline{TP}}{\\overline{TP}+\\overline{FN}}\\\\ micro-F1=\\frac{2\\times micro-P\\times micro-R}{micro-P+micro-R} $F1$ measure：$\\frac{2\\times TP}{N+TP-TN}$ AUC预测了排序质量,越高越好； AUC=\\frac{1}{2}\\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\\cdot(y_{i}+y_{i+1})AUC与排序的密切关系:考虑每一个正反例，若正例的预测值小于反例，那么就计算一个“罚分”： \\mathcal{l}_{tank}=\\frac{1}{m^+m^-}\\sum_{x^+\\in D^+}\\sum_{x^-\\in D^-}(\\mathbb{I}(f(x^+)","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"机器学习导论-1 绪论与数学参考","date":"2021-03-08T02:18:18.000Z","path":"2021/03/08/机器学习导论-1/","text":"机器学习导论-1 绪论与数学参考 二刷机器学习导论 参考书: 统计机器学习 PRML(贝叶斯) ESL(统计学派) MLAPP UML 绪论 学习过程 训练数据，经过 学习算法训练，得到 模型(决策树，射精网络，支持向量机，Boosting，贝叶斯网……)，可以判断 新数据样本，得到结论 机器学习的局限性，失效条件: 特征信息不充分 样本信息不充分 机器学习的理论基础(计算学习理论),概率近似正确(PAC): $P(|f(x)-y|\\le \\epsilon)\\ge 1-\\delta$ f(x)是预测值,y是真实值,目的是尽可能贴近真实值也就是$|f(x)-y|\\le \\epsilon$,然后这件事情有一个概率的保证，一定大于$1-\\delta$的概率确保这件事情的完成。一句话总结就是很高的概率得到很好的结果的模型。 如果你能确定百分百正确，就不用整机器学习了 数学参考范数 在实数域中，数的大小和两个数之间的距离是通过绝对值来度量的。将数推广到向量就引入了范数。范数（Norm）是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。 在算例子的时候我觉得其实是不同维度到0点的距离 向量的范数 范数标准定义: 正定性:$||x||\\ge 0$,且$||x||= 0$当且仅当$x=0$; 齐次性:对任意实数 $\\alpha$ ，都有$||\\alpha x||=|\\alpha|\\ ||x||$ 三角不等式: 对任意$x,y\\in R^n$,都有$||x+y|| \\le ||x|| + ||y||$ 则称$||x||$为$R^n$上的向量范数 范数表达式: \\begin{align} \\left| \\left| x \\right| \\right|_{p}\\; :=\\; \\left( \\sum_{i=1}^{n}{\\left| x_{i} \\right|^{p} } \\right)^{\\frac{1}{p} }\\tag{1} \\end{align} L1范数: ||x||_1 = |x_1| + |x_2| + \\dots + |x_n| = \\sum_i^n |x_i|向量元素绝对值之和 L2范数: ||x||_2 = (|x_1|^2 + |x_2|^2+\\dots+ |x_n|^2)^{\\frac{1}{2} } =\\sqrt{ \\sum_i^n x_i^2}Euclid范数(欧几里得范数，常用计算向量长度) Lp范数: ||x||_p = (|x_1|^p + |x_2|^p+\\dots+ |x_n|^p)^{\\frac{1}{p} } =\\sqrt[p]{ \\sum_i^n x_i^p} Lp的形状随p的变化的图 L$\\infty $范数: ||x||_{\\infty} = \\max\\limits_{1\\le i\\le n} |x_i| 所有向量元素绝对值中的最大值 L$-\\infty$范数: ||x||_{\\infty} = \\min\\limits_{1\\le i\\le n} |x_i| 所有向量元素绝对值中的最小值 L0范数: ||x||_0 = \\sum_i^n I(x_i \\ne 0) 也就是非零元素的数量 例子:$x=(1,4,3,0)^T$的常用范数: $||x||_0=3$ $||x||_1=|1|+|4|+|3|+|0|=8$ $||x||_2=\\sqrt{|1|^2+|4|^2+|3|^2+|0|^2}=\\sqrt{26}$ $||x||_{\\infty}=|4|=4$ 矩阵的范数 推广到矩阵，矩阵相容范数的定义: 正定性:$||A||\\ge 0$,且$||A||= 0$当且仅当$A=0$; 齐次性:对任意实数 $\\alpha$ ，都有$||\\alpha A||=|\\alpha|\\ ||A||$ 三角不等式: 对任意$A,B\\in R^{n\\times n}$,都有$||A+B|| \\le ||A|| + ||B||$ 相容性:对任意$A,B\\in R^{n\\times n}$,都有$||AB|| \\le ||A||\\ ||B||$ 则称$||A||$为$R^{n\\times n}$上的一个矩阵范数 列范数: ||A||_1 = \\max\\limits_{1\\le j\\le n} \\sum_i^n |a_{ij}|$A$的每一列的绝对值的最大值，称作$A$的列范数 行范数: ||A||_{\\infty} = \\max\\limits_{1\\le i\\le n} \\sum_j^n |a_{ij}|$A$的每一行的绝对值的最大值，称作$A$的行范数 L2范数: ||A||_2 = \\sqrt{\\lambda_{max} (A^T A)}其中$\\lambda_{max}$表示$A^TA$的特征值的绝对值的最大值 F-范数(Frobenius): ||A||_F = (\\sum_i^n \\sum_j^n a_{ij}^2)^{\\frac{1}{2} }=(tr(A^TA))^{1/2}它相当于矩阵$A$各项元素的绝对值平方的总和,也就是矩阵张成向量之后的L2范数 求导 一阶导数：雅可比矩阵 假设函数$F:{R_n} \\to {R_m}$是一个从欧式n维空间转换到欧式m维空间的函数.这个函数由m个实函数组成:$y1(x1,…,xn), …, ym(x1,…,xn)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵, 这就是所谓的雅可比矩阵： \\begin{bmatrix} \\frac{\\partial y_1}{\\partial x_1} & \\cdots & \\frac{\\partial y_1}{\\partial x_n} \\\\ \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial y_m}{\\partial x_1} & \\cdots & \\frac{\\partial y_m}{\\partial x_n} \\end{bmatrix} 此矩阵表示为: ${J_F}({x_1}, \\ldots ,{x_n})$,或者$\\frac{ {\\partial {({y_1}, … ,{y_m})} } } { {\\partial {({x_1}, … ,{x_n})} } }$. hexo 两个{之间要加空格不然会报错: expected variable end 如果$p$是$R_n$中的一点，$F$在$p$点可微分，那么这一点的导数由$J_F(p)$给出.在此情况下, 由$F(p)$描述的线性算子即接近点$p$的$F$的最优线性逼近, $x$逼近于$p$: F({\\bf{x} }) \\approx F({\\bf{p} }) + {J_F}({\\bf{p} }) \\cdot ({\\bf{x} } – {\\bf{p} }) 二阶导数：海森矩阵 海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下： f({x_1},{x_2} \\ldots ,{x_n})如果$f$所有的二阶导都存在，那么有： H{(f)_{ij} }(x) = {D_i}{D_j}f(x)也就是: \\begin{bmatrix} \\frac{\\partial^2 f}{\\partial x_1^2} & \\frac{\\partial^2 f}{\\partial x_1\\,\\partial x_2} & \\cdots & \\frac{\\partial^2 f}{\\partial x_1\\,\\partial x_n} \\\\ \\\\ \\frac{\\partial^2 f}{\\partial x_2\\,\\partial x_1} & \\frac{\\partial^2 f}{\\partial x_2^2} & \\cdots & \\frac{\\partial^2 f}{\\partial x_2\\,\\partial x_n} \\\\ \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\\\ \\frac{\\partial^2 f}{\\partial x_n\\,\\partial x_1} & \\frac{\\partial^2 f}{\\partial x_n\\,\\partial x_2} & \\cdots & \\frac{\\partial^2 f}{\\partial x_n^2} \\end{bmatrix} 链式法则的式子里面有转置的原因可以从维度的角度来思考; 奇异值 共轭:$z=a+bi$,z的共轭$\\bar{z}=a-bi$;实数的共轭是他自身; 矩阵概念: 对称矩阵: $A^T=A$ Hermite矩阵，将实数范围讨论的对称矩阵延伸到复数范围: 其中，用$\\bar{A}$表示以$A$的元素的共轭复数为元素构成的矩阵,那么$A^H=(\\bar{A}^T)$，这个称作$A$的复共轭转置矩阵; 特征值都是实数。 任意两个不同特征值所对应的特征向量正交。 正交矩阵: $A^TA=E$ 酉矩阵: $A^HA=E$ 这玩意其实就是正交矩阵在复数范围的推广 奇异矩阵: $|A|=0$称作奇异矩阵，否则称作非奇异矩阵;$A$是可逆矩阵的充要条件是$|A|\\neq0$,因此可逆矩阵就是非奇异矩阵 正规矩阵: $A^HA=AA^H$,如果都是实数矩阵，那么$A^T=A^H,A^TA=AA^T$ 幂等矩阵: $A^2=A$ 正定矩阵:它是对称矩阵/Hermite矩阵的进一步延伸 设$A$为n阶Hermite矩阵，如果对任意n维复向量$x$都有$x^HAx\\ge 0$,则称A是半正定矩阵;如果对任意n维复向量$x$都有$x^HAx&gt; 0$,则称A是正定矩阵。 Hermite矩阵$A$为正定（半正定）矩阵 $\\leftrightarrow$$A$的所有特征值是正数（非负数）。 Hermite矩阵$A$为正定矩阵 $\\leftrightarrow$存在n阶非奇异矩阵$P$，使得$A=P^HP$ Hermite矩阵$A$为半正定矩阵$\\leftrightarrow $存在n阶矩阵$P$，使得$A=P^HP$ 特征值与特征分解: 特征值特征向量定义：$\\lambda$是特征值,$x$是特征向量,A是方阵 Ax=\\lambda x求解走: $Ax=\\lambda x\\rightarrow Ax=\\lambda E x\\rightarrow (\\lambda E-A)x=0\\rightarrow|\\lambda E-A|=0$解出特征值带入得到特征向量 特征分解:对于mxm的满秩对称矩阵A A=Q\\Sigma Q^{-1}=Q\\Sigma Q^T其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。 特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。 奇异值与奇异值分解 运用到的理论: 对于n阶方阵，$Ax=\\lambda x$; 如果$\\vec{a}$与$\\vec{b}$正交,那么有$\\vec{a} \\cdot \\vec{b} = 0$ 一个内积空间的正交基（orthogonal basis）是元素两两正交的基,基中的元素称为基向量。如果一个正交基的基向量的模长都是单位长度1，则称这正交基为标准正交基或”规范正交基”（Orthonormal basis）； A与A的转置矩阵是有相同的特征值,但是他们各自的特征向量没有关系； SVD推导之矩阵分解: 对于矩阵$A$,有$A^TA = \\lambda_{i} v_{i}$(因为$A^TA$肯定是方阵);$\\lambda_i$是特征值,$v_i$是特征向量;假设$(v_{i}, v_{j})$是一组正交基，那么有$v_{i}^{T} \\cdot v_{j} = 0$，那么: \\begin{align} (Av_{i}, Av_{j}) &= (Av_{i})^{T} \\cdot Av_{j} \\\\ &= v_{i}^{T} A^T Av_{j} \\\\ &= v_{i}^{T} \\lambda_{j} v_{j} \\\\ &= \\lambda_{j} \\color{red}{v_{i}^{T} v_{j} } \\\\ &= 0 \\end{align} \\tag{1}可以得到$Av_{i}, Av_{j}$;根据公式$(1)$可以推导得到$(Av_{i}, Av_{i}) = \\lambda_{i} v_{i}^{T} v_{i}=\\lambda_{i}$;又因为行列式的性质$|AB|=|A||B|\\rightarrow|(Av_{i})^{T} \\cdot Av_{i}|=|Av_{i}^{T} ||Av_{i}|=|Av_{i}|^2$,所以有: \\begin{align} & |Av_{i}|^2 = \\lambda_{i} \\\\ & |Av_{i}| = \\sqrt{\\lambda_{i} } \\end{align} \\tag{2}根据公式(2),有$\\frac{Av_{i} }{|Av_{i}|} = \\frac{1}{\\sqrt{\\lambda_{i} } } Av_{i}$，令$\\frac{1}{\\sqrt{\\lambda_{i} } } Av_{i}= u_{i}$,可以得到: Av_{i}= \\sqrt{\\lambda_{i} }u_{i}=\\delta_{i}u_{i} \\tag{3}其中$\\delta_{i} = \\sqrt{\\lambda_{i} }$（这个称作奇异值）,进一步推导成矩阵形式: \\begin{align} AV &= A(v_{1}, v_{2}, \\dots, v_{n} ) \\\\ &= (Av_{1}, Av_{2}, \\dots, Av_{n} ) \\\\ &= (\\delta_{1}u_{1}, \\delta_{2}u_{2}, \\dots, \\delta_{n}u_{n} ) \\\\ &= U\\Sigma \\end{align} \\tag{4}从而得到: A = U\\Sigma V^T \\tag{5} SVD推导之矩阵计算: 已知$A$怎么算$U$和$V$呢？ 首先计算$A$的转置$A^T$,而$A^T$相当于: \\begin{align} A^T = V\\Sigma^TU^T \\end{align} \\tag{6}然后计算$A^TA$: \\begin{align} A^TA &= V\\Sigma^TU^T U\\Sigma V^T \\\\ &= V\\Sigma^2V^T \\end{align} \\tag{7}通过公式(7),会发现这不就是特征值分解嘛！！！可以得到$A^TA v_{i} = \\lambda_{i}v_{i}$,只需要求出$A^TA$的特征向量就可以得到$V$了 同理计算$AA^T:$ \\begin{align} A A^T &= U\\Sigma V^T V\\Sigma^TU^T \\\\ &= U\\Sigma^2U^T \\end{align} \\tag{8}通过公式(8),可以得到$AA^T u_{i} = \\lambda_{i}u_{i}$,只需要求出$AA^T$的特征向量就可以得到$U$了 $\\Sigma$是上面公式(7)或者公式(8)中求到的非零特征值从大到小排列后开根号的值 SVD计算例子: 假设有一个矩阵$A$: A=\\begin{bmatrix} 1&1\\\\1&1\\\\0&0\\end{bmatrix}要计算: A_{3\\times 2}=U_{3\\times 3}\\Sigma_{3\\times2}V^T_{2\\times 2}中的$U,V,\\Sigma$ 计算$U$ $AA^T=\\begin{bmatrix} 2&amp;2&amp;0\\\\2&amp;2&amp;0\\\\0&amp;0&amp;0\\end{bmatrix}$,进行特征分解，得到特征值[4,0,0]以及对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T,[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T,[0,0,1]^T$,可以得到： U=\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&-\\frac{1}{\\sqrt{2}}&0 \\\\ \\frac{1}{\\sqrt{2}}&\\frac{1}{\\sqrt{2}}&0 \\\\ 0&0&1 \\end{bmatrix} 计算$V$ $A^TA=\\begin{bmatrix} 2&amp;2 \\\\ 2&amp;2 \\end{bmatrix}$,进行特征分解,得到特征值[4,0]以及对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T,[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T$,可以得到: V=\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&-\\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}}&\\frac{1}{\\sqrt{2}}\\end{bmatrix} 计算$\\Sigma$ 因为特征值是[4,0]，因此: \\Sigma=\\begin{bmatrix} 2&0 \\\\ 0&0 \\\\ 0&0 \\end{bmatrix} 所以$A$的SVD分解是: A=U \\Sigma V^T= \\begin{bmatrix} \\frac{1}{\\sqrt{2}}&-\\frac{1}{\\sqrt{2}}&0 \\\\ \\frac{1}{\\sqrt{2}}&\\frac{1}{\\sqrt{2}}&0 \\\\ 0&0&1 \\end{bmatrix} \\begin{bmatrix} 2&0 \\\\ 0&0 \\\\ 0&0 \\end{bmatrix} {\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&-\\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}}&\\frac{1}{\\sqrt{2}}\\end{bmatrix}}^T=\\begin{bmatrix} 1&1\\\\1&1\\\\0&0\\end{bmatrix} 代码求解方法: 123import numpy as npA=np.array([1,1],[1,1],[0,0])print(np.linalg.svd(A)) 以下主要是优化的部分 拉格朗日乘子法 To be done 参考博客 向量范数与矩阵范数 雅可比矩阵和海森矩阵 链式法则 Hermite矩阵性质 矩阵特征值求解 矩阵的基本知识 矩阵的奇异值推导","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"p4学习-5:完善MRI","date":"2021-03-06T08:44:38.000Z","path":"2021/03/06/p4学习-5/","text":"p4学习-5:完善MRI实验目标这次实验的目的是在基本的L3转发上面拓展一个带内遥测(INT)的阉割版本，这里称作多跳路由检查(Multi-Hop Route Inspection)(MRI)。 根据维基百科，多跳路由(Multi-hop routing)是无线电网络中的一种通信，其中网络覆盖区域大域单个节点的无线电范围，因此要到达某一个目的地的时候一个节点可以使用其他节点做中继。 MRI允许使用者追踪每一个包经过的路线以及序列的长度，为了支持这个功能需要写一个P4程序，这个程序能够在每一个包的header stack上面附加一个ID以及队列的长度。在收包的目的地，交换机ID的顺序相当于这个包走的路径，每一个ID后面都跟着这个交换机的队列长度。 控制平面已经事先设置好了 代码实现mri里面包括了两个自定义的头:mri_t包含了count，用来指示交换机ID的数量;switch_t包含了数据包经过的每个交换机跳的交换机ID和队列深度字段； 主要挑战是处理用于解析两个headers的递归逻辑；这里使用parser_metada字段的remaining来追踪有多少switch_t头需要来解析;在parse_mri状态,这个字段设置为hdr.mri.count。在parse_swtrace状态将转换到其自身，直到剩余为0。 MRI自定义报头会携带在IP Options 头里面,其中IP Options头里面的option用于指示选项的类型。 我们将使用特殊的类型31来表示MRI标头的存在。 除了解析器逻辑外，您还将在sgress中添加一个表，在swtrace中存储交换机ID和队列深度，并执行增加count字段的操作，并附加一个switch_t标头。 一个完整的mri.p4包含如下组件: 以太网（ethernet_t），IPv4（ipv4_t），IP选项（ipv4_option_t），MRI（mri_t）和交换机（switch_t）的header头部类型定义。 以太网，IPv4，IP选项，MRI和交换机的解析器Parsers，将填充ethernet_t，ipv4_t，ipv4_option_t，mri_t和switch_t。 使用mark_to_drop()丢弃数据包的动作action。 一个action动作（称为ipv4_forward），它将： 设置下一跳的出口端口。 用下一跳的地址更新以太网目标地址。 用交换机的地址更新以太网源地址。 减少TTL 一个ingress control: 定义一个表，该表将读取IPv4目标地址，并调用drop或ipv4_forward。 一个应用表的apply模块 在egress部分，将添加交换机ID和队列深度的action动作（add_swtrace）。 一个egress control,它应用表（swtrace）来存储交换机ID和队列深度并调用add_swtrace 用于选择将字段插入传出数据包的顺序的deparser。 实例化 headers部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#x2F;* -*- P4_16 -*- *&#x2F;#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;const bit&lt;8&gt; UDP_PROTOCOL &#x3D; 0x11;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;const bit&lt;5&gt; IPV4_OPTION_MRI &#x3D; 31;#define MAX_HOPS 9&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;typedef bit&lt;32&gt; switchID_t;typedef bit&lt;32&gt; qdepth_t;header ethernet_t &#123; macAddr_t dstAddr; macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;header ipv4_t &#123; bit&lt;4&gt; version; bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;header ipv4_option_t &#123; bit&lt;1&gt; copyFlag; bit&lt;2&gt; optClass; bit&lt;5&gt; option; bit&lt;8&gt; optionLength;&#125;&#x2F;&#x2F;mri头header mri_t &#123; bit&lt;16&gt; count;&#125;header switch_t &#123; switchID_t swid; qdepth_t qdepth;&#125;struct ingress_metadata_t &#123; bit&lt;16&gt; count;&#125;struct parser_metadata_t &#123; bit&lt;16&gt; remaining;&#125;struct metadata &#123; ingress_metadata_t ingress_metadata; parser_metadata_t parser_metadata;&#125;struct headers &#123; ethernet_t ethernet; ipv4_t ipv4; ipv4_option_t ipv4_option; mri_t mri; switch_t[MAX_HOPS] swtraces;&#125;error &#123; IPHeaderTooShort &#125; 实验过程1 先跑不完整的初始版本代码先跑一下初始代码看看啥样，以便和之后的做对比 在shell上面跑: make 这步会: 编译mri.p4 启动一个 Mininet 实例，其中三个交换机(s1,s2,s3)设置在三角形结构里面。有5个主机.具体见拓扑图部分 主机被指定成了10.0.1.1, 10.0.2.2，其他的也都是(10.0.&lt;Switchid&gt;.&lt;hostID&gt;)这种格式 控制平面部分的规则是基于sx-runtime.json 准备做的事情是在h1和h2之间发送低速率的流, 在h11和h22之间发送搞俗的测试流。s1和s2之间会形成一个拥塞因为在topology.json里面把带宽削减到了512kbps。因此如果我们在h2收包胡发现连接里面有很长的队列等待长度。 拓扑如下: 在make打开的Mininet命令行界面开四个窗口: 1mininet&gt; xterm h1 h11 h2 h22 在h2的xterm里面打开收包的服务: 1.&#x2F;receive.py 在h22的xterm里面打开iperf UDP 服务: 1iperf -s -u 在h1的xterm里面使用send.py给h2每秒发一个包，发30秒: 1./send.py 10.0.2.2 \"P4 is cool\" 30 在h2的xterm里面会收到”P4 is cool “信息 在h11的xterm里面，启动iperf客户端发送15秒: 1iperf -c 10.0.2.22 -t 15 -u 在h2端,MRI header没有hop信息(count=0) 退出来 这里h2虽然接到了信息，但是没有关于这条消息经过的路径的信息。完善的内容就是在mri.p4里面完善MRI逻辑来记录路径信息。 到目前的实验结果如下: 会发现h2收到的MRI信息里面的count=0; h22中因为线路的带宽有限，几次实验发现15秒发不完: h1和h11里面是发包的提示信息: h1如下: h11如下: 2 控制平面相关 控制平面相关:P4程序定义了一个数据包处理管道，但是控制数据包的规则是由控制平面插入到管道中的。 当规则与数据包匹配时，将使用控制平面提供的参数作为规则的一部分来调用其动作。在本练习中，控制平面逻辑已经实现。 作为启动Mininet实例的一部分，make脚本将在每个交换机的表中安装数据包处理规则。 这些定义在sX-runtime.json文件中，其中X对应于交换机号。 12345678910111213141516171819202122232425262728//s1-runtime.json部分代码&#123; \"target\": \"bmv2\", \"p4info\": \"build/mri.p4.p4info.txt\", \"bmv2_json\": \"build/mri.json\", \"table_entries\": [ &#123; \"table\": \"MyEgress.swtrace\", \"default_action\": true, \"action_name\": \"MyEgress.add_swtrace\", \"action_params\": &#123; \"swid\": 1 &#125; &#125;, &#123; \"table\": \"MyIngress.ipv4_lpm\", \"match\": &#123; \"hdr.ipv4.dstAddr\": [\"10.0.1.1\", 32] &#125;, \"action_name\": \"MyIngress.ipv4_forward\", \"action_params\": &#123; \"dstAddr\": \"08:00:00:00:01:01\", \"port\": 2 &#125; &#125;, //..............还有一部分已经省略 ]&#125; 不难发现这里的表项和拓扑图以及P4代码里面的table息息相关，写法也和之前的P4runtime里面的相似 3 完善MRI见前面的代码实现部分 4 运行解决方案参考博客","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode300-m","date":"2021-03-04T15:31:23.000Z","path":"2021/03/04/leetcode300-m/","text":"300. 最长递增子序列难度中等1422收藏分享切换为英文接收动态反馈 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 12输入：nums &#x3D; [0,1,0,3,2,3]输出：4 示例 3： 12输入：nums &#x3D; [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 进阶： 你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 解答 : $O(n^2)$的方法： 使用dp[i]表示[0,i]之间的最大子序列长度，根据最大子序列的定义来思考状态转移方程: dp[i]=max(dp[i],dp[j]+1 if j&lt;i and nums[j]&lt;nums[i]) 也就是一个循环遍历i，然后里面的循环遍历j，找到一个nums[i]小的然后更新; 1234567891011121314class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: _length=len(nums) if _length &lt; 2: return _length dp=[1]*(_length+1) res=dp[0] for i in range(0,_length): for j in range(0,i): if nums[j]&lt;nums[i]: dp[i]=max(dp[i],dp[j]+1) res=max(res,dp[i]) return res $O(NlogN)$的方法: 贪心加二分，不是很好想; 这里找的状态时tail[i],表示长度为i+1的所有上升子序列的结尾最小值;这里的tail[i]时严格递增的，可以用反证法证明; 这题就变成了维护tail这个数组，这个数组的长度就是我们要求的结果的长度;如何维护分为以下两步: 扩充数组元素: 如果遍历nums的时候这个 nums[i]&gt;*(tail.end()),那么就把nums[i]添加到tail数组后面，此时相当于tail数组变长了一位; 更新数组里面的元素： 如果遍历nums的时候这个nums[i]&lt;*(tail.end()),那么就要看tail数组里面第一个大于nums[i]的数，然后把它换成nums[i]; 例子解释: [9,2,3,6,7,4],初始化的时候表示长度的end=1,tail[end]=-1001,下面的[]表示tail数组 [9] 遍历到9,9&gt;tail[end],tail[end]=9 [2] 遍历到2,2&lt;tail[end],找到第一个大于2的,只有9,替换 [2,3] 遍历到3,3&gt;tail[end],添加进去 [2,3,6] 同理 [2,3,6,7] 同理 [2,3,4,7] 遍历到4,4&lt;tail[end],找到第一个大于4的,把它变小成4 直观的来看,tail 数组越紧致,它越容易边长 123456789101112131415161718192021class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: _length=len(nums) tail=[-1001]*(_length+1) end=1 tail[end-1]=nums[0] for i in range(1,_length): if nums[i]&gt;tail[end-1]: end=end+1 tail[end-1]=nums[i] elif nums[i]&lt;tail[end-1]: left=0 right=end-1 while left&lt;right: mid=(left+right)&gt;&gt;1 if tail[mid]&lt;nums[i]: left=mid+1 # 中位数不是要找的数 else: right=mid tail[left]=nums[i] return end","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"C++标准库与泛型编程学习笔记","date":"2021-03-04T13:25:17.000Z","path":"2021/03/04/STL/","text":"C++标准库与泛型编程学习笔记 感谢侯捷老师 基础知识 六大部件 容器(containers):数据存放在里面 分配器(Allocators):支持容器的内存管理 算法(Algorithms):一个个模板函数 迭代器(Iterators):泛化的指针 适配器(Adapters):有容器/迭代器/仿函数适配器，可以帮他们进行转换 仿函数(Functors):相似于函数 12345678910#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#include&lt;iostream&gt;........int main()&#123; int ia[6]=&#123;27,210,....&#125;; vector&lt;int,allocator&lt;int&gt;&gt;vi(ia,ia+6);//分配器不写会默认帮你搞好;vi是iterator; cout&lt;&lt;count_if(vi.begin(),vi.end(),notl(bind2nd(less&lt;int&gt;(),40)));//count_if 是算法,not1是function adapter(negator)，表示否定，大于等于40;bind2nd是function adapter(binder),绑定第二参数,这里的作用是有没有小于40;less是function object 仿函数;not1(....)这行称作predicate&#125; 复杂度 略 “前闭后开”区间：标准库用 c.begin()指的是头,c.end()指向尾巴的后面一个,因此是[);所以*(c.end())是不行的; 12345678910111213141516171819202122232425Container&lt;T&gt; c;....Container&lt;T&gt;::iterator ite=c.begin();for(;ite!=c.end();++ite)&#123; .....&#125;//range-based for statement C++11for(decl:coll)&#123; statement;&#125;//例子:std::vector&lt;double&gt;vec;...for(auto elem:vec)&#123; std::cout&lt;&lt;elem;&#125;for(auto&amp; elem:vec)&#123; elem*=3;//使用引用才能变;&#125;//auto的使用;list&lt;string&gt;c;list&lt;string&gt;::iterator ite;ite=::find(c.begin(),c.end(),target);//等价于auto ite=::find(c.begin(),c.end(),target); 容器测试 分类: Sequence Containers(序列式): Array:固定元素大小的数组 Vector:末端可以扩张的数组 Deque(/dek/):前后可以扩张的数组,双向队列 List:双链 Forward-List:单链,内存小于前者 Associative Containers(关联式): 适合查找 Set/Multiset:集合,底部用红黑树做;Multiset可以重复 Map/Multimap:有序的键/值对,后者的key可以重复,底部用红黑树做; Unordered Containers(不定序的元素): Unordered set/Multiset:集合,底部基于哈希-拉链法 Unordered Map/Multimap:有序的键/值对,底部基于哈希-拉链法 容器速率直观比较: (单位是毫秒) Array:47,187(项目:50万随机数for循环赋值时间和排序+二分查找时间) Vector:3063,2765(项目:100万随机数for循环push_back和排序+二分查找时间）a.size()=1000000,a.capacity()=1048576,因为vector增加的时候会预留空间,长着长着开一个两倍的空间复制进去;这个例子里面用find找元素比排序+二分快,0毫秒 List:3265,2312,16(项目:100万随机数for循环push_back和排序+二分查找时间和find的时间),list自带sort forward_list:3204,15,2656(项目:100万随机数,find的时间,sort的时间) ，它也自带sort slist:非标准库里面,#include里面有;和forward_list使用差不多; deque:2704,15,3110(项目:100万随机数push_back,find函数,使用全局sort)deque的连续是一种假象;它是分段连续,分成一个个buffer,由指针指着;如果buffer用完了就再申请一块buffer; stack: deque其实涵盖了stack和queue;它们两个的底层都是deque;812(项目:30万随机数push) queue:890(项目:30万随机数push) 因为stack,queue是由deque实现的,所以也被称为容器适配器 multiset:6609,203,0(项目:100万随机数insert放进去和全局find和自己的find)关联式容器找东西非常快 multimap:4812,0(项目: insert放进去和自己的find) unordered_multiset:4406,109,0(项目:100万随机数insert进去和全局find和自带find) ;bucket_count()可以看出篮子的个数,篮子一定比元素多;load_factor()可以看出负载因子; unordered_multimap:4313,0(项目:100万随机数insert进去和自带的find) set:3922,0,0(项目:100万随机数insert进去和全局find和自带find) map:4890,0(项目:100万放进去和自带的find)；multiset不能用c[i]=string(buf)只能用insert函数插入,但是map可以； unordered_map,unordered_set:略 一些老版本的容器比如slist,hash_set,hash_map.hash_multiset,hash_multimap要另外include; 分配器测试:下面都是GNU-C里面的: 分类器使用示例: 1template&lt;typename_Tp,typename_Alloc=std::allocator&lt;_Tp&gt;&gt;class vector:protected_Vector_base&lt;_Tp,_Alloc&gt; 不同分配器的使用示例: 123456789101112131415//使用std::allocator意外的allocator需要自行#include&lt;ext\\....&gt;#include&lt;ext\\array_allocator.h&gt;#include&lt;ext\\mt_allocator.h&gt;#include&lt;ext\\debug_allocator.h&gt;#include&lt;ext\\pool_allocator.h&gt;#include&lt;ext\\bitmap_allocator.h&gt;#include&lt;ext\\new_allocator.h&gt;....list&lt;string,allocator&lt;string&gt;&gt; c1;list&lt;string,__gnu_cxx::malloc_allocator&lt;string&gt;&gt; c2;list&lt;string,__gnu_cxx::new_allocator&lt;string&gt;&gt; c3;list&lt;string,__gnu_cxx::__pool_allocator&lt;string&gt;&gt; c4;list&lt;string,__gnu_cxx::__mt_allocator&lt;string&gt;&gt; c5;list&lt;string,__gnu_cxx::bitmap_allocator&lt;string&gt;&gt; c6; 分配器可以分配内存，但是不如malloc/free;new/delete舒服，释放内存很麻烦;比如: 1234int*p;allocator&lt;int&gt;alloc1;p&#x3D;alloc1.allocate(1);alloc1.deallocate(p,1);","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"}]},{"title":"p4学习-4:P4runtime实验","date":"2021-03-02T14:06:07.000Z","path":"2021/03/02/p4学习-4/","text":"p4学习-4:P4runtime实验实验目标使用P4Runtime而不是来交换机的CLI发送flow entries;P4程序是在basic tunnel里面的程序的基础上写的，改名叫了 advanced_tunnel.p4，并且增加了两个counters(ingressTunnelCounter, egressTunnelCounter)和两个actions(myTunnel_ingress, myTunnel_egress) 使用启动程序mycontroller.py以及一些 p4runtime_lib 库里面的函数来创建主机1和主机2之间隧道通信所需的表项。 代码部分主要是mycontroller.py里面的writeTunnelRules函数的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/env python2import argparseimport grpcimport osimport sysfrom time import sleep# Import P4Runtime lib from parent utils dir# Probably there's a better way of doing this.sys.path.append( os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../utils/'))import p4runtime_lib.bmv2from p4runtime_lib.switch import ShutdownAllSwitchConnectionsimport p4runtime_lib.helperSWITCH_TO_HOST_PORT = 1SWITCH_TO_SWITCH_PORT = 2def writeTunnelRules(p4info_helper, ingress_sw, egress_sw, tunnel_id, dst_eth_addr, dst_ip_addr): \"\"\" Installs three rules: 1) An tunnel ingress rule on the ingress switch in the ipv4_lpm table that encapsulates traffic into a tunnel with the specified ID ipv4_lpm表的入接口开关上的隧道入接口规则，该规则用指定的ID将流量封装到一个隧道中 2) A transit rule on the ingress switch that forwards traffic based on the specified ID 入口交换机上的一种传输规则，根据指定的ID转发流量 3) An tunnel egress rule on the egress switch that decapsulates traffic with the specified ID and sends it to the host 出口交换机上的一条隧道出口规则，将指定ID的流量解封装后发送给主机 :param p4info_helper: the P4Info helper :param ingress_sw: the ingress switch connection :param egress_sw: the egress switch connection :param tunnel_id: the specified tunnel ID :param dst_eth_addr: the destination IP to match in the ingress rule :param dst_ip_addr: the destination Ethernet address to write in the egress rule \"\"\" # 1) Tunnel Ingress Rule table_entry = p4info_helper.buildTableEntry( table_name=\"MyIngress.ipv4_lpm\", match_fields=&#123; \"hdr.ipv4.dstAddr\": (dst_ip_addr, 32) &#125;, action_name=\"MyIngress.myTunnel_ingress\", action_params=&#123; \"dst_id\": tunnel_id, &#125;) ingress_sw.WriteTableEntry(table_entry) print \"Installed ingress tunnel rule on %s\" % ingress_sw.name # 2) Tunnel Transit Rule # The rule will need to be added to the myTunnel_exact table and match on the tunnel ID (hdr.myTunnel.dst_id). Traffic will need to be forwarded using the myTunnel_forward action on the port connected to the next switch.这条规则是添加到myTunnel_exact table上面的，match的部分是tunnel ID (hdr.myTunnel.dst_id)。流量将会使用myTunnel_forward action转发到连接下一个交换机的端口，这里要观察下面的拓扑图会发现连接交换机(h1,h2)的都是二号端口，文件里面用SWITCH_TO_SWITCH_PORT表示了2号端口 # # For our simple topology, switch 1 and switch 2 are connected using a link attached to port 2 on both switches. We have defined a variable at the top of the file, SWITCH_TO_SWITCH_PORT, that you can use as the output port for this action. # # We will only need a transit rule on the ingress switch because we are using a simple topology. In general, you'll need on transit rule for each switch in the path (except the last switch, which has the egress rule), and you will need to select the port dynamically for each switch based on your topology. # TODO build the transit rule # TODO install the transit rule on the ingress switch #print \"TODO Install transit tunnel rule\" table_entry=p4info_helper.buildTableEntry( table_name=\"MyIngress.myTunnel_exact\", match_fields=&#123; \"hdr.myTunnel.dst_id\":tunnel_id &#125;, action_name=\"MyIngress.myTunnel_forward\", action_params=&#123; \"port\":SWITCH_TO_SWITCH_PORT &#125;) ingress_sw.WriteTableEntry(table_entry) print \"Installed transit tunnel rule on %s\" % ingress_sw.name # 3) Tunnel Egress Rule # For our simple topology, the host will always be located on the SWITCH_TO_HOST_PORT (port 1). # In general, you will need to keep track of which port the host is connected to. table_entry = p4info_helper.buildTableEntry( table_name=\"MyIngress.myTunnel_exact\", match_fields=&#123; \"hdr.myTunnel.dst_id\": tunnel_id &#125;, action_name=\"MyIngress.myTunnel_egress\", action_params=&#123; \"dstAddr\": dst_eth_addr, \"port\": SWITCH_TO_HOST_PORT &#125;) egress_sw.WriteTableEntry(table_entry) print \"Installed egress tunnel rule on %s\" % egress_sw.name #### 下面的函数省略不表 实际写的时候主要依靠下面的Tunnel Egress Rule规则仿写,主要p4文件里面: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************/control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) ingressTunnelCounter; counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) egressTunnelCounter; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec = port; hdr.ethernet.srcAddr = hdr.ethernet.dstAddr; hdr.ethernet.dstAddr = dstAddr; hdr.ipv4.ttl = hdr.ipv4.ttl - 1; &#125; action myTunnel_ingress(bit&lt;16&gt; dst_id) &#123; hdr.myTunnel.setValid(); hdr.myTunnel.dst_id = dst_id; hdr.myTunnel.proto_id = hdr.ethernet.etherType; hdr.ethernet.etherType = TYPE_MYTUNNEL; ingressTunnelCounter.count((bit&lt;32&gt;) hdr.myTunnel.dst_id); &#125; action myTunnel_forward(egressSpec_t port) &#123; standard_metadata.egress_spec = port; &#125; action myTunnel_egress(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec = port; hdr.ethernet.dstAddr = dstAddr; hdr.ethernet.etherType = hdr.myTunnel.proto_id; hdr.myTunnel.setInvalid(); egressTunnelCounter.count((bit&lt;32&gt;) hdr.myTunnel.dst_id); &#125; table ipv4_lpm &#123; key = &#123; hdr.ipv4.dstAddr: lpm; &#125; actions = &#123; ipv4_forward; myTunnel_ingress; drop; NoAction; &#125; size = 1024; default_action = NoAction(); &#125; table myTunnel_exact &#123; key = &#123; hdr.myTunnel.dst_id: exact; &#125; actions = &#123; myTunnel_forward; myTunnel_egress; drop; &#125; size = 1024; default_action = drop(); &#125; apply &#123; if (hdr.ipv4.isValid() &amp;&amp; !hdr.myTunnel.isValid()) &#123; // Process only non-tunneled IPv4 packets. ipv4_lpm.apply(); &#125; if (hdr.myTunnel.isValid()) &#123; // Process all tunneled packets. myTunnel_exact.apply(); &#125; &#125;&#125; match_field里面相当于action里面的key部分,具体的值由控制平面也就是函数里面的tunnel_id确定;action_name里面相当于调用了action myTunnel_forward,这个action的参数只有port,又因为题目里面的提示要求port是SWITCH_TO_SWITCH_PORT因此填进去就行了; 实验过程1 跑未完成的代码 mycontroller.py里面包含了一些隧道通信需要的规则，在没有完成的情况下先跑p4看看啥样: 1make 这步编译了 advanced_tunnel.p4, 启动一个Mininet实例，其中三个交换机(s1, s2, s3)配置在一个三角形中，每个交换机连接到一个主机(h1, h2, h3)，并且把10.0.1.1, 10.0.2.2, 10.0.3.3这些IP配置到对应的主机上 现在会看到mininet命令窗口，ping h1 和 h2: 1mininet&gt; h1 ping h2 因为交换机上面没有规则，现在还没法接受回应，然后如果ctrl+C就如下图各种丢包； 现在把这个ping留着继续跑然后开另一个shell 在另一个shell里面跑: 12cd ~/tutorials/exercises/p4runtime./mycontroller.py 这会安装advanced_tunnel.p4程序到switch上面并且把tunnel ingress规则推进去；这个程序每两秒打印ingress和egress的counters 因为目前没有完成还有一些TODO的部分，所以下面可以看到这些包经过s1的ingress并且让计数器增加； Ctrl-c退出 目前的交换机是根据目的IP地址将流量映射到隧道(ID)上面，要做的工作是写规则，从而让交换机能够基于隧道(tunnel) ID来转发流量 和前面的对比：之前的都是依靠一些json文件静态的设置表项，这里是动态的；要注意到p4 程序仅仅定义了一个包处理的管道，但是是不包含具体的规则的； P4程序定义了包处理管道（规则由控制平面插入），同时定义了交互机的pipeline和控制平面的接口（这部分在advanced_tunnel.p4info）里面；在mycontroller. py里面构建的表项(table entries)会根据名称引用特定的表、键和actions；使用p4info会将名字转换程P4runtime所需要的ID。在P4程序中添加或者重命名的表、键、actions都要反映在 py程序的表项(table entries)里面 2 完善隧道转发 p4runtime_lib库里面的总结,这部分代码在tutorials/utils/p4runtime_lib里面: p4runtime_lib.helper 包含了P4InfoHelper 类能够解析P4Info文件，包括了name,id,alias,match_field(本身/id/name/pb/value)，action_param(本身/id/name/pb) 提供了实体的名字到ID数字转换的方法(buildTableEnrty函数) 构建P4Runtime表项的P4依赖于程序的部分。 p4runtime_lib.switch.py 包括了SwitchConnection类，会获取gRPC的client stub以及给交换机建立连接 提供了helper方法，能够构建P4Runtime协议的buffer信息以及制作P4Runtime gRPC service calls p4runtime_lib.bmv2.py 包含了 Bmv2SwitchConnection 类，它拓展了SwitchConnections并且提供了BMv2-specific 设备载荷来装载P4程序 PS:实际上是重载了SwitchConnection 然后多了一个buildDeviceConfig函数能够根据bmv2_json_file来返回设备的配置 p4runtime_lib.convert.py 由helper.py调用 主要提供了一些把数字/字符串编码协议buffer信息需要的格式的方法以及相应的解码方法 mycontroller.py是一个结能的控制平面做了以下的事情 为P4Runtime服务构建了一个到交换机的 gRPC连接 把P4程序push给各个交换机 在h1,h2之间的两个隧道编写了ingress/egress规则 每两秒读隧道的ingress/egress计数器 代码部分主要要做的事情是在 writeTunnelRules函数里面写隧道转发规则，它对应于隧道ID并且能够把包转发到下一跳 拓扑图如下: 3 实验结果先make clean再make，然后h1 ping h2，然后开一个新端口./mycontroller.py，这个时候可以看见ingress,egress的计数都上涨了: py_info 另外ping也能够成功的收到了: mini_info 额外参考——rpc,grpc学习左转参考博客 参考博客 rpc介绍 P4 runtime 和 p4 info","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode303-s","date":"2021-03-01T12:18:36.000Z","path":"2021/03/01/leetcode303-s/","text":"303. 区域和检索 - 数组不可变难度简单283收藏分享切换为英文接收动态反馈 给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j两点。 实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])） 示例： 1234567891011输入：[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 提示： 0 &lt;= nums.length &lt;= 104 -105 &lt;= nums[i] &lt;= 105 0 &lt;= i &lt;= j &lt; nums.length 最多调用 104 次 sumRange 方法 解答： 使用前缀和方法，前缀和表示的是[0,i)之间的和，比如对于数组 [1,2,3,4,5],presum[0]=0,presum[1]=0+1=1…… 12for i in range(0,len(nums)+1): presum[i+1]=presum[i]+nums[i] 因此本题解法如下: 123456789101112131415class NumArray: def __init__(self, nums: List[int]): _length=len(nums) self.presum=[0]*(_length+1) for i in range(0,_length): self.presum[i+1]=self.presum[i]+nums[i] def sumRange(self, i: int, j: int) -&gt; int: return self.presum[j+1]-self.presum[i]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j)","tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://tyler-ytr.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"leetcode1176-h","date":"2021-02-26T09:05:15.000Z","path":"2021/02/26/leetcode1176-h/","text":"1178. 猜字谜难度困难149 外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）都不能作为谜底。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例： 1234567891011输入：words &#x3D; [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles &#x3D; [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#39;g&#39;。 提示： 1 &lt;= words.length &lt;= 10^5 4 &lt;= words[i].length &lt;= 50 1 &lt;= puzzles.length &lt;= 10^4 puzzles[i].length == 7 words[i][j], puzzles[i][j] 都是小写英文字母。 每个 puzzles[i] 所包含的字符都不重复。 解答： 这题有两个要思考的点，第一个是怎么压缩状态，非常自然的想到二进制，英文字母一共26位，用int完全可以表示，通过这一点可以想到一个朴素的方法（TLE）: 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;int&gt; findNumOfValidWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles) &#123; //int 二进制有32位 英文字母一共26位 出现一次该位为1 //a最小,z最大 //如果字谜A包含了wordB,首先A&amp;B==1，判断A中的第一个字母有没有包含在B里面 假设该字母是00010,取反是11101，(11101|B)&amp;(00010)表示有 vector&lt;int&gt;result(puzzles.size(),0); vector&lt;int&gt;wordmap(words.size(),0); vector&lt;int&gt;puzzlemap(puzzles.size(),0); int temp; for(int i=0;i&lt;words.size();++i)&#123; for (int j=0;j&lt;words[i].size();j++)&#123; temp=1&lt;&lt;(int)(words[i][j]-'a'); wordmap[i]|=temp; &#125; &#125; for(int i=0;i&lt;puzzles.size();++i)&#123; for (int j=0;j&lt;puzzles[i].size();j++)&#123; temp=1&lt;&lt;(int)(puzzles[i][j]-'a'); puzzlemap[i]|=temp; &#125; &#125; for(int i=0;i&lt;puzzles.size();++i)&#123; for(int j=0;j&lt;words.size();++j)&#123; int temp=1&lt;&lt;(int)(puzzles[i][0]-'a'); if((~temp|wordmap[j])&amp;temp)&#123; int a=puzzlemap[i]; int b=wordmap[j]; if((a&amp;b)==b)&#123; result[i]+=1; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 这个方法就是先将words,puzzles都压缩成二进制串然后一对一比较，后面比较是一个O($N^2$),并且没有利用puzzles[i].length == 7这个条件，因此会TLE；（这是TLE的分析） 根据puzzles[i].length == 7，然后可以联想到优化的方法，因为长度是固定的，所以它的子集数目也是比较小的，因此可以将words做一个unorderer_map，然后对于pussles压缩之后的每一个子集进行查询即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;int&gt; findNumOfValidWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles) &#123; //位运算 //int 二进制有32位 英文字母一共26位 出现一次该位为1 //a最小,z最大 //如何枚举一个二进制数的子集： //也就是10101的子集是10101,10100,10001,10000,00101,00100,00001,00000; /* int sub = k; do &#123; sub = (sub - 1) &amp; k; &#125; while(sub != k); */ unordered_map&lt;int, int&gt; count; for (string &amp;word: words) &#123;//注意 int mask = 0; for (char ch : word) mask |= (1 &lt;&lt; (ch - 'a')); count[mask]+=1;//如果出现了那么对应的count那么这个count应该为1 // cout&lt;&lt;count[mask]; &#125; int len=puzzles.size(); vector&lt;int&gt; result(len, 0); for(int i=0;i&lt;len;++i)&#123; string&amp;puzzle=puzzles[i]; int k=0; for(char ch:puzzle)&#123; k|=(1&lt;&lt;(ch-'a')); &#125; int sub = k; do &#123; sub = (sub - 1) &amp; k; if ((1 &lt;&lt; (puzzle[0] - 'a')) &amp; sub) result[i] += count[sub]; &#125; while(sub != k); &#125; return result; &#125;&#125;;","tags":[{"name":"位运算","slug":"位运算","permalink":"http://tyler-ytr.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"如何阅读一篇论文阅读笔记","date":"2021-02-25T08:59:25.000Z","path":"2021/02/25/how-to-read-a-paper-notes/","text":"How to read a paper 阅读笔记 原文链接:https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf 由刘恩萌启发 3段方法 1st pass 仔细阅读标题，abstract和intruduction，结论；浏览section &amp; subsection的标题、数学内容；reference；其他部分一概忽略 能够回答下面的五个C: Category:(类型：测量/分析/描述……) Context:(有关论文？理论基础？…… ) Correctness:（假设看上去正确吗？……） Contributions Clarity:（写的咋样……） 通过这些内容决定是否进一步阅读 2nd pass 比第一遍更认真的看，可以记一些笔记在空白处，划重点；看完之后应该能够把握论文内容 认真看图表，看看有没有错 标注没读过的相关文献以便进一步了解背景 如果看完还是懵逼，以下三选一： 扔一边不看了 过一会/看完背景材料再看 坚持不懈并且进入步骤3 3rd pass virtually re-implement: 标注作者的假设，然后在这些假设基础(虚拟)上重新实现这个工作，通过将重新实现和作者文章的比较，很容易发现它的创新点以及隐藏的错误/假设 重点是关注细节，积累对未来工作的想法 在这一阶段结束时，能够根据记忆重建整篇文章的结构，并且能够识别出它的优缺点。","tags":[]},{"title":"p4学习-3:P4 basic tunnel实验","date":"2021-02-24T08:52:17.000Z","path":"2021/02/24/p4学习-3/","text":"P4学习-3：P4 basic tunnel实验实验目标 在本练习中，我们将向IP添加对基本隧道协议的支持 你在上一个作业中完成的路由器。基本交换机根据目的IP地址进行转发。您的工作是定义一个新的头类型来封装IP包并修改交换代码，这样它就可以使用一个新的隧道头来决定目的端口。 新的头类型将包含协议ID，它指示被封装的包的类型，以及用于路由的目的地ID。 P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。 对于本练习，我们已经添加了必要的静态控制平面条目。作为启动Mininet实例的一部分，make run命令将在每个交换机的表中安装包处理规则。这些是在sX-runtime中定义的json files，其中X对应开关号。 因为控制平面试图访问myTunnel_exact表，而这个表还不存在，所以make run命令不能与启动器代码一起工作。 PS：这里使用P4Runtime来安装规则，文件内容在sX-runtime.json里面 拓扑如下: basic_tunnel.p4文件包含了一个基本的IP路由器的实现，完整的实现版本将能够转发基于自定义封装头的内容，以及如果封装头在数据包中不存在，那么将执行正常的IP转发。工作有以下几个部分: NOTE:添加了一个新的头类型称作myTunnel_t ,包含了proto_id and dst_id NOTE:myTunnel_t 已经加入了myTunnel_t header TODO:更新解析器，根据以太网头中的etherType字段提取myTunnel头或ipv4头。myTunnel报头对应的etherType是’ 0x1212 ‘。如果proto_id == TYPE_IPV4 &#39;即0x0800)，解析器还应该在myTunnel 头之后提取ipv4头。 TODO: 定义了一个新的action称作 myTunnel_forward ，它设置出口端口(即standard_metadata总线的egress_spec字段)到控制平面提供的端口号。 TODO:定义一个名为myTunnel_exact的新表，它对myTunnel报头的dst_id字段执行精确匹配。如果表中有匹配项，该表应该调用myTunnel_forward操作，否则它应该调用drop操作。 TODO:如果myTunnel报头有效，更新MyIngress控制块中的apply语句，以应用新定义的myTunnel_exact表。否则，如果ipv4报头有效，则调用ipv4_lpm表。 更新deparser以发出’ ethernet ‘，然后是’ myTunnel ‘，然后是’ ipv4 ‘头。请记住，deparser只会在消息头有效时发出消息头。头的隐式有效性位由解析器在提取时设置。这里不需要检查头的有效性。 为新定义的表添加静态规则，以便交换机能够正确转发’ dst_id ‘的每个可能值。请参阅下面的图，了解拓扑的端口配置以及我们将如何为主机分配id。在此步骤中，您需要将转发规则添加到“sX-runtime”中。json文件。 代码部分headers部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;* -*- P4_16 -*- *&#x2F;#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;&#x2F;&#x2F; NOTE: new type added hereconst bit&lt;16&gt; TYPE_MYTUNNEL &#x3D; 0x1212;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;header ethernet_t &#123; macAddr_t dstAddr; macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;&#x2F;&#x2F; NOTE: added new header typeheader myTunnel_t &#123;&#x2F;&#x2F;新的header type bit&lt;16&gt; proto_id; &#x2F;&#x2F;包含了proto_id以及dst_id bit&lt;16&gt; dst_id;&#125;header ipv4_t &#123; bit&lt;4&gt; version; bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;struct metadata &#123; &#x2F;* empty *&#x2F;&#125;&#x2F;&#x2F; NOTE: Added new header type to headers structstruct headers &#123; ethernet_t ethernet; myTunnel_t myTunnel; &#x2F;&#x2F;新添加的字段 ipv4_t ipv4;&#125; Parser部分：1234567891011121314151617181920212223242526272829&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as wellparser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet; &#125; state parse_ethernet &#123; packet.extract(hdr.ethernet); transition select(hdr.ethernet.etherType) &#123; TYPE_IPV4 : parse_ipv4; default : accept; &#125; &#125; state parse_ipv4 &#123; packet.extract(hdr.ipv4); transition accept; &#125;&#125; 解答: 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as wellparser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet; &#125; state parse_ethernet &#123; packet.extract(hdr.ethernet); transition select(hdr.ethernet.etherType) &#123; TYPE_IPV4 : parse_ipv4; TYPE_MYTUNNEL : parse_mytunnel; default : accept; &#125; &#125; state parse_ipv4 &#123; packet.extract(hdr.ipv4); transition accept; &#125; state parse_mytunnel&#123; packet.extract(hdr.myTunnel); transition select(hdr.myTunnel.proto_id)&#123; &#x2F;&#x2F;满足需求：如果&#96;proto_id &#96; &#x3D;&#x3D; &#96; TYPE_IPV4 &#39;&#96;即0x0800)，解析器还应该在&#96;myTunnel 头&#96;之后提取&#96;ipv4 &#96;头。 TYPE_IPV4 : parse_ipv4; default : accept; &#125; transition accept; &#125;&#125; Ingress部分（以及checksum部分）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec &#x3D; port; hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; hdr.ethernet.dstAddr &#x3D; dstAddr; hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port) &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact &#x2F;&#x2F; TODO: also remember to add table entries! apply &#123; &#x2F;&#x2F; TODO: Update control flow if (hdr.ipv4.isValid()) &#123; ipv4_lpm.apply(); &#125; &#125;&#125; 解答： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec &#x3D; port; hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; hdr.ethernet.dstAddr &#x3D; dstAddr; hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm;&#x2F;&#x2F;最长前缀匹配 &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port) action myTunnel_ford(egressSpec_t port)&#123; standard_metadata.egress_spec &#x3D; port;&#x2F;&#x2F;设置端口号 &#125; &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact table myTunnel_exact&#123; key&#x3D;&#123; hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配 &#125; actions&#x3D;&#123; myTunnel_ford; drop;&#x2F;&#x2F;如果表中有匹配项，该表应该调用&#96; myTunnel_forward &#96;操作，否则它应该调用&#96; drop &#96;操作。 &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; &#x2F;&#x2F; TODO: also remember to add table entries! apply &#123; &#x2F;&#x2F; TODO: Update control flow if (hdr.ipv4.isValid()) &#123; ipv4_lpm.apply(); &#125; if(hdr.myTunnel.isValid())&#123;&#x2F;&#x2F;模仿ipv4写的 myTunnel_exact.apply(); &#125; &#125;&#125; PS: match_kind： 这是match_action table里面的一种类型，比如 123key&#x3D;&#123; hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配&#125; 里面的exact就是一种match_kind，p4c/p4include/core.p4有三种: 12345678match_kind &#123; &#x2F;&#x2F;&#x2F; Match bits exactly.精准匹配 exact, &#x2F;&#x2F;&#x2F; Ternary match, using a mask. 把值和一个 mask 比较，比如 0x01020304 符合 mask 0x0F0F0F0F ternary, &#x2F;&#x2F;&#x2F; Longest-prefix match.最长前缀匹配 lpm&#125; p4c/p4include/v1model.p4里面有一下几种: 12345678match_kind &#123; &#x2F;&#x2F;检查是否值在一个范围里，比如取 0x01020304 - 0x010203FF 之间的值 range, &#x2F;&#x2F; Either an exact match, or a wildcard (matching any value).精准匹配或者通配 optional, &#x2F;&#x2F; Used for implementing dynamic_action_selection 用于实现dynamic_action_selection selector&#125; 因为在include上述两个文件的情况下一共有六种 Egress部分（以及checksum部分）：123456789101112131415161718192021222324252627282930313233&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; apply &#123; &#125;&#125;&#x2F;************************************************************************************** C H E C K S U M C O M P U T A T I O N ***************************************************************************************&#x2F;control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; update_checksum( hdr.ipv4.isValid(), &#123; hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr &#125;, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16); &#125;&#125; Deparser部分: 1234567891011&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet); &#x2F;&#x2F; TODO: emit myTunnel header as well packet.emit(hdr.ipv4); &#125;&#125; 解答: 12345678910111213&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet); &#x2F;&#x2F; TODO: emit myTunnel header as well packet.emit(hdr.myTunnel); packet.emit(hdr.ipv4); &#125;&#125; 实例化部分： 123456789101112&#x2F;************************************************************************************************ S W I T C H ********************************************************************************************************&#x2F;V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(),MyComputeChecksum(),MyDeparser()) main; 实验结果 make run 这会进行以下几步: 编译basic_tunnel.p4 启动一个Mininet实例，其中三个交换机(s1、s2、s3)配置在一个三角形中，每个交换机连接到一个主机(h1、h2和h3)。 这些主机的ip地址设置为10.0.1.1, 10.0.2.2, and 10.0.3.3. 然后进入mininet界面 使用mininet的xterm功能： 1mininet&gt; xterm h1 h2 在h2的界面输入 : 1.&#x2F;receive.py 在h1的界面输入: 1.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot; 这是不经过my_tunnel的测试； 如果您检查接收到的数据包，您应该会看到它由一个以太网报头、一个IP报头、一个TCP报头和消息组成。如果您更改了目的IP地址(例如试图发送到’ 10.0.3.3 ‘)，则该消息不应该被’ h2 ‘接收，而将被’ h3 ‘接收。 结果如下图: 发给10.0.3.3之后: h1有相似的显示，h2没有变化 下面测试my_tunnel 在h1的界面输入: 1.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot; --dst_id 2 结果如下图: 数据包在h2处接收。它由一个以太网报头、一个隧道报头、一个IP报头、一个TCP报头和消息组成。隧道报头就是那个###[MyTunnel]在IP报头上面; 在h1的界面输入: 1.&#x2F;send.py 10.0.3.3 &quot;P4 is cool&quot; --dst_id 2 结果如下: 即使IP地址是h3的地址，数据包也应该在h2处接收。这是因为当MyTunnel头在包中时，交换机不再使用IP头进行路由。 一开始我也不理解上面这句话，后来我看了s1-runtime文件，这个文件规定了交换机的静态规则，将这个文件和basic里面的同名文件比较会发现里面多了: 这部分内容结合刚刚./receive代码里面的—dst 2后缀可以得知刚刚那个包在进入交换机s1之后会因为p4的解包触发走myTunnel_forward的规则然后发给S1的2端口，结合拓扑图可以看出确实是发给h2的 解析其他内容my_tunnel.py12345678910111213141516171819from scapy.all import *import sys, osTYPE_MYTUNNEL = 0x1212TYPE_IPV4 = 0x0800class MyTunnel(Packet): name = \"MyTunnel\" fields_desc = [ ShortField(\"pid\", 0), ShortField(\"dst_id\", 0) ] def mysummary(self): return self.sprintf(\"pid=%pid%, dst_id=%dst_id%\")bind_layers(Ether, MyTunnel, type=TYPE_MYTUNNEL)bind_layers(MyTunnel, IP, pid=TYPE_IPV4) 因为原来的scapy只支持ipv4，不支持我们的myTunnel协议，因此需要重新定义，上面的文件就重新定义了MyTunnel； 每一个协议层都是Packet类的子类。协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。一个简单的协议层是被一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为fields_desc的属性中。每一个字段都是一个field类的实例： 上面MyTunnel的协议层有两个字段分别是pid和dst_id，默认值都是0； UDP的协议层定义如下: 123456class UDP(Packet): name &#x3D; &quot;UDP&quot; fields_desc &#x3D; [ ShortEnumField(&quot;sport&quot;, 53, UDP_SERVICES), ShortEnumField(&quot;dport&quot;, 53, UDP_SERVICES), ShortField(&quot;len&quot;, None), XShortField(&quot;chksum&quot;, None), ] 最后两句是绑定协议层; Scapy在解析协议层时一个很酷的特性是他试图猜测下一层协议是什么。连接两个协议层官方的方法是bind_layers(): send.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env pythonimport argparseimport sysimport socketimport randomimport structimport argparsefrom scapy.all import sendp, send, get_if_list, get_if_hwaddr, hexdumpfrom scapy.all import Packetfrom scapy.all import Ether, IP, UDP, TCPfrom myTunnel_header import MyTunneldef get_if(): ifs=get_if_list() # # type: () -&gt; List[str] \"\"\"Return a list of interface names\"\"\",返回接口(网卡)名字 iface=None # \"h1-eth0\" for i in get_if_list(): if \"eth0\" in i: iface=i break; if not iface: print \"Cannot find eth0 interface\" exit(1) return ifacedef main(): parser = argparse.ArgumentParser()#argsparse是python的命令行解析的标准模块，相当于就是解析./send.py后面的参数 parser.add_argument('ip_addr', type=str, help=\"The destination IP address to use\")#type是要传入的参数的数据类型 help是该参数的提示信息,使用python send.py -h可以看到 parser.add_argument('message', type=str, help=\"The message to include in packet\") parser.add_argument('--dst_id', type=int, default=None, help='The myTunnel dst_id to use, if unspecified then myTunnel header will not be included in packet') args = parser.parse_args()##获得传入的参数 addr = socket.gethostbyname(args.ip_addr)## 获取ip_addr的主机名 dst_id = args.dst_id#获得dst_id iface = get_if()#获取网卡的名字 if (dst_id is not None):#包装 print \"sending on interface &#123;&#125; to dst_id &#123;&#125;\".format(iface, str(dst_id)) pkt = Ether(src=get_if_hwaddr(iface), dst='ff:ff:ff:ff:ff:ff') pkt = pkt / MyTunnel(dst_id=dst_id) / IP(dst=addr) / args.message else: print \"sending on interface &#123;&#125; to IP addr &#123;&#125;\".format(iface, str(addr)) pkt = Ether(src=get_if_hwaddr(iface), dst='ff:ff:ff:ff:ff:ff') pkt = pkt / IP(dst=addr) / TCP(dport=1234, sport=random.randint(49152,65535)) / args.message pkt.show2()# hexdump(pkt)# print \"len(pkt) = \", len(pkt) sendp(pkt, iface=iface, verbose=False)if __name__ == '__main__': main() 大概流程就是，先分析参数，然后包装成Ether的格式然后用scapy发包; receive.py12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env pythonimport sysimport structimport osfrom scapy.all import sniff, sendp, hexdump, get_if_list, get_if_hwaddrfrom scapy.all import Packet, IPOptionfrom scapy.all import ShortField, IntField, LongField, BitField, FieldListField, FieldLenFieldfrom scapy.all import IP, TCP, UDP, Rawfrom scapy.layers.inet import _IPOption_HDRfrom myTunnel_header import MyTunneldef get_if(): # 获得网卡接口 ifs=get_if_list() iface=None for i in get_if_list(): if \"eth0\" in i: iface=i break; if not iface: print \"Cannot find eth0 interface\" exit(1) return ifacedef handle_pkt(pkt): if MyTunnel in pkt or (TCP in pkt and pkt[TCP].dport == 1234): print \"got a packet\" pkt.show2()# hexdump(pkt)# print \"len(pkt) = \", len(pkt) sys.stdout.flush()def main(): ifaces = filter(lambda i: 'eth' in i, os.listdir('/sys/class/net/')) iface = ifaces[0] print \"sniffing on %s\" % iface sys.stdout.flush() sniff(iface = iface, prn = lambda x: handle_pkt(x))if __name__ == '__main__': main() 首先获得网卡，发出“sniffing on….”信息，并且立刻打出来，然后把收到的包里面的东西立刻打印出来 原文部分IntroductionIn this exercise, we will add support for a basic tunneling protocol to the IProuter that you completed in the previous assignment. The basic switchforwards based on the destination IP address. Your jobs is to define a newheader type to encapsulate the IP packet and modify the switch code, so that itinstead decides the destination port using a new tunnel header. The new header type will contain a protocol ID, which indicates the type ofpacket being encapsulated, along with a destination ID to be used for routing. Spoiler alert: There is a reference solution in the solutionsub-directory. Feel free to compare your implementation to the reference. The starter code for this assignment is in a file called basic_tunnel.p4 andis simply the solution to the IP router from the previous exercise. A note about the control planeA P4 program defines a packet-processing pipeline, but the rules within eachtable are inserted by the control plane. When a rule matches a packet, itsaction is invoked with parameters supplied by the control plane as part of therule. For this exercise, we have already added the necessary static control planeentries. As part of bringing up the Mininet instance, the make run commandwill install packet-processing rules in the tables of each switch. These aredefined in the sX-runtime.json files, where X corresponds to the switchnumber. Since the control plane tries to access the myTunnel_exact table, and thattable does not yet exist, the make run command will not work with the startercode. Important: We use P4Runtime to install the control plane rules. The contentof files sX-runtime.json refer to specific names of tables, keys, andactions, as defined in the P4Info file produced by the compiler (look for thefile build/basic.p4info after executing make run). Any changes in the P4program that add or rename tables, keys, or actions will need to be reflectedin these sX-runtime.json files. 参考博客： P4学习笔记专栏 core.p4库 scapy中文文档 scapy添加新的协议 scapy源码 argparse使用","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode24-m","date":"2021-02-24T08:37:35.000Z","path":"2021/02/24/leetcode24-m/","text":"24. 两两交换链表中的节点难度中等827 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： img 12输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head &#x3D; []输出：[] 示例 3： 12输入：head &#x3D; [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。） 迭代解法：开了一个虚拟节点，然后pid的next是将要交换的第一个节点,pid.next.next是第二个 12345678910111213141516171819# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: temphead=ListNode(0) temphead.next=head pid=temphead while pid.next and pid.next.next: node1=pid.next node2=pid.next.next pid.next=node2 node1.next=node2.next node2.next=node1 pid=node2.next return temphead.next 递归解法：见里面的注释 首先思考递归终止条件，然后思考里面的递归过程 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode:# def __init__(self, val&#x3D;0, next&#x3D;None):# self.val &#x3D; val# self.next &#x3D; nextclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: # 终止条件：head是空或者head.next是空 比如[],[1] if not head or not head.next: return head #1,2,3,4 temp&#x3D;head.next #因为马上要修改 #1-&gt;2-&gt;3-&gt;4 #修改好了4-&gt;3 #所以1-&gt;4-&gt;3 head.next&#x3D;self.swapPairs(temp.next) #temp相当于2,2-&gt;1 temp.next&#x3D;head return temp","tags":[{"name":"递归","slug":"递归","permalink":"http://tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"链表","slug":"链表","permalink":"http://tyler-ytr.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"leetcode23-h","date":"2021-02-23T12:08:25.000Z","path":"2021/02/23/leetcode23-h/","text":"23. 合并K个升序链表难度困难1151 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 12345678910输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 示例 2： 12输入：lists &#x3D; []输出：[] 示例 3： 12输入：lists &#x3D; [[]]输出：[] 提示： k == lists.length 0 &lt;= k &lt;= 10^4 0 &lt;= lists[i].length &lt;= 500 -10^4 &lt;= lists[i][j] &lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 解答： 优先队列 heapq是二叉堆，通常用普通列表实现。 heapq模块是在Python中不错的优先级队列实现。由于heapq在技术上只提供最小堆实现，因此必须添加额外步骤来确保排序稳定性，以此来获得“实际”的优先级队列中所含有的预期特性。 12345678910111213141516import heapqq &#x3D; []heapq.heappush(q, (2, &#39;code&#39;))heapq.heappush(q, (1, &#39;eat&#39;))heapq.heappush(q, (3, &#39;sleep&#39;))while q: next_item &#x3D; heapq.heappop(q) print(next_item)# 结果：# (1, &#39;eat&#39;)# (2, &#39;code&#39;)# (3, &#39;sleep&#39;) queue.PriorityQueue这个优先级队列的实现在内部使用了heapq，时间和空间复杂度与heapq相同。 区别在于PriorityQueue是同步的，提供了锁语义来支持多个并发的生产者和消费者。 在不同情况下，锁语义可能会带来帮助，也可能会导致不必要的开销。不管哪种情况，你都可能更喜欢PriorityQueue提供的基于类的接口，而不是使用heapq提供的基于函数的接口。 12345678910111213141516from queue import PriorityQueueq &#x3D; PriorityQueue()q.put((2, &#39;code&#39;))q.put((1, &#39;eat&#39;))q.put((3, &#39;sleep&#39;))while not q.empty(): next_item &#x3D; q.get() print(next_item)# 结果：# (1, &#39;eat&#39;)# (2, &#39;code&#39;)# (3, &#39;sleep&#39;) 其中PriorityQueue可以自定义比较函数: 12345678910111213141516171819202122232425262728from queue import PriorityQueueclass Job(object): def __init__(self, priority, description): self.priority &#x3D; priority self.description &#x3D; description print(&#39;New job:&#39;, description) return def __lt__(self, other): return self.priority &lt; other.priority &#39;&#39;&#39; 或者使用__cmp__函数 def __cmp__(self, other): if self.priority &lt; other.priority: return -1 elif self.priority &#x3D;&#x3D; other.priority: return 0 else: return 1 &#39;&#39;&#39;q2 &#x3D; PriorityQueue() q2.put(Job(5, &#39;Mid-level job&#39;))q2.put(Job(10, &#39;Low-level job&#39;))q2.put(Job(1, &#39;Important job&#39;)) #数字越小，优先级越高 while not q2.empty(): next_job &#x3D; q2.get() #可根据优先级取序列 print(&#39;Processing job&#39;, next_job.description) 题解: 使用heapq解决该问题，每一个链表的第一个节点进入堆进行比较，然后最小的那个取出来扔进新链表，然后最小的那个向后移动一位（80ms） 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: import heapq minheap=[] for index,node in enumerate(lists): if node!=None: heapq.heappush(minheap,(node.val,index)) #第几个链表的节点的值 head=ListNode(-1) tail=head while minheap: nodeval,index=heapq.heappop(minheap) tail.next=lists[index] tail=tail.next lists[index]=lists[index].next if lists[index]!=None: heapq.heappush(minheap,(lists[index].val,index)) return head.next 使用PriorityQueue解决问题，速度慢于heapq(144ms)： 12345678910111213141516171819202122# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: from queue import PriorityQueue minheap=PriorityQueue() for index,node in enumerate(lists): if node!=None: minheap.put((node.val,index)) #第几个链表的节点的值 head=ListNode(-1) tail=head while not minheap.empty(): nodeval,index=minheap.get() tail.next=lists[index] tail=tail.next lists[index]=lists[index].next if lists[index]!=None: minheap.put((lists[index].val,index)) return head.next 分治 首先实现合并两个链表，然后分治： 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: # 合并两个链表的代码 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1,l2=l2,l1 l1.next=self.mergeTwoLists(l1.next,l2) return l1 or l2 #调用上面的代码合并两个节点 def mergetwonode(self,node1:ListNode,node2:ListNode)-&gt;ListNode: return self.mergeTwoLists(node1,node2) #分治 def merge(self,left:int,right:int,lists:List[ListNode])-&gt;ListNode: if left==right: return lists[left] if left&gt;right: return None mid=left+((right-left)//2) return self.mergetwonode(self.merge(left,mid,lists),self.merge(mid+1,right,lists)) def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: if not lists: return None return self.merge(0,len(lists)-1,lists)","tags":[{"name":"递归","slug":"递归","permalink":"http://tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"优先队列","slug":"优先队列","permalink":"http://tyler-ytr.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}]},{"title":"leetcode1052-m","date":"2021-02-23T09:54:13.000Z","path":"2021/02/23/leetcode1052-m/","text":"1052. 爱生气的书店老板难度中等106 今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。 在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。 请你返回这一天营业下来，最多有多少客户能够感到满意的数量。 示例： 12345输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3输出：16解释：书店老板在最后 3 分钟保持冷静。感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16. 提示： 1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000 0 &lt;= customers[i] &lt;= 1000 0 &lt;= grumpy[i] &lt;= 1 解答: 分为两部分，第一部分是不用秘密方法得到的满意度，第二部分是使用秘密方法得到的满意度 123456789101112131415class Solution: def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -&gt; int: base=0 increase=0 maxincrease=0 length=len(customers) for i in range(0,length): base=base+customers[i]*(1-grumpy[i]) for i in range(0,X): increase=increase+customers[i]*grumpy[i] maxincrease=increase for i in range(X,length): increase=increase+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X] maxincrease=max(increase,maxincrease) return maxincrease+base","tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://tyler-ytr.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"贪心","slug":"贪心","permalink":"http://tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"机器学习导论笔记","date":"2021-02-23T09:26:04.000Z","path":"2021/02/23/机器学习/","text":"机器学习笔记感谢毕秋宇同学！！ Chapter 2空间 假设空间 假设满足XX条件的是好瓜 版本空间 有限训练集，已知XX是好瓜 归纳偏好 假设空间和训练集一致的假设 学习过程中对某种类型假设的偏好称为归纳偏好 No Free Lunch 奥卡姆剃刀：两个模型效果同样好，选择较为简单的 模型评估与选择 经验误差与过拟合 错误率率&amp;误差 错误率：错份样本的占$E=a/m$ 误差：样本真实输出与预测输出之间的差异 训练（经验）误差：训练集上 测试误差：测试集 泛化误差：初训练集外所有样本 过拟合 学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降 优化目标加正则项 Early stop 欠拟合 对训练样本的一般性质尚未学好 决策树：扩展分支 神经网络：增加训练层数 评估方法 留出法 直接将数据集划分为两个互斥集合 训练/测试集划分要尽可能保持数据分布的一致性 一般若干次随机划分，重复实验取平均值 训练/测试样本比例通常为2:1～4:1 交叉验证法 将数据集分层采样划分为$k$个大小相似的互斥子集 自助法 以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\\prime}$，$D\\backslash D^{\\prime}$用作测试集 性能度量 性能度量是衡量模型泛化能力的评价标准，反映任务的需求 回归任务最常用的是“均方误差”： $E(f:D)=\\frac{1}{m}\\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$ 查准率 $P=\\frac{TP}{TP+FP}$ 查全率 $R=\\frac{TP}{TP+FN}$ $P-R$曲线 $F1$ measure：$\\frac{2\\times TP}{N+TP-TN}$ $AUC=\\frac{1}{2}\\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\\cdot(y_{i}+y_{i+1})$，预测了排序质量 代价敏感错误率 性能评估 关于性能比较 测试性能并不等于泛化性能 测试性能随着测试集的变化而变化 很多机器学习算法本身有一定的随机性 直接选取相应评估方式在相应条件下评估并不可靠 二项检验 泛化错误率为$\\epsilon$，测试错误率为$\\hat{\\epsilon}$，嘉定测试样本从样本总体分布中独立采样而来，我们可以使用“二项检验”，对于$\\epsilon&lt;epsilon_{0}$进行假设检验。 假设$\\epsilon\\leq\\epsilon_{0}$，若测试错误率小于 $t$检验 交叉验证$t$检验 偏差和方差 对于测试样本$x$，令$y_{D}$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学的模型$f$在$x$上的预测输出。 以回归任务为例： 期望预期为：$\\bar{f}(x)=\\mathbb{E}_{D}[f(x;D)]$； 使用样本数目相同的不同训练集产生的方差为$var(x)=\\mathbb{E}_{D}[(f(x:D)-\\bar{f}(x))^{2}]$； 噪声为$\\varepsilon^{2}=\\mathbb{E}_{D}[(y_{D}-y)^{2}]$ $E(f;D)=bias^{2}(x)+var(x)+\\varepsilon^2$ Chapter 3基本形式 线性模型一般形式$f(x)=w_1x_1+w_2x_2+\\cdots+w_dx_d+b$ 向量形式$f(x)=w^{T}x+b$ 区分猫狗的例子 按照像素行堆叠或列堆叠，成为一个向量 乘以单位，对于二分类问题，单位就是一个向量 Perceptron感知机 对于线性分类器，误分类则$-y_{1}(w\\cdot x_i)+b&gt;0$ 定义损失函数$L(w,b)=-\\sum_{x_{i}\\in M}y_{i}(w\\cdot x_{i}+b)$ 梯度$\\bigtriangledown_{w}L(w,b)=-\\sum_{x_{i}\\in M}y_{i}x_{i}$ $\\bigtriangledown_{b}L(w,b)=-\\sum_{x_{i}\\in M}y_{i}$ 梯度下降法 一阶方法 考虑无约束优化$min_{x}f(x)$，$f(x+\\Delta x)\\approx f(x)+\\Delta x^{T}\\bigtriangledown f(x)$ $\\Delta x^{T}\\bigtriangledown f(x)&lt;0$ $\\Delta x=-\\gamma \\bigtriangledown f(x)$ $\\gamma$使用二分查找法进行查找 优点 形式简单，易于建模 可解释性 非线性模型的基础 引入层级结构或高维映射 缺陷 解决不了$x^{2}$问题 线性回归 目的：学得一个线性模型以尽可能准确地预测实值输出标记 离散属性处理 有“序”关系 连续化为连续值 无“序”关系 单一属性的线性回归目标 $f(x)=wx_{i}+b$使得$f(x_{i})\\simeq y_{i}$ 参数/模型估计：最小二乘法（Least square method） $(w^{},b^{})=arg\\ min_{(w,b)}\\sum_{i=1}^{m}(f(x_{i})-y_i)^2$ 最小化均方误差$E_{(w,b)}$ 多元线性回归 $f(\\hat{x_{i}})=\\hat{x_{i}}^{T}(X^{T}X)^{-1}$ $X^{T}X$不满秩，进行正则化 广义线性模型 一般形式：$y=g^{-1}(w^{T}x+b)$ $g$为联系函数(link function) 二分类问题 预测值与输出标记$z=w^{T}x+b$ 寻找函数将分类标记与线性回归模型输出联系起来 最理想的模型——单位阶跃函数 替代函数——对数几率函数（logistic function） $y=\\frac{1}{1+e^{-z}}$ 运行对数几率函数$y=\\frac{1}{1+e^{-z}}=\\frac{1}{1+e^{-(w^{T}x+b)}}$ 对数几率 样本作为正例的相对可能性的对数$\\ln\\frac{y}{1-y}=\\ln\\frac{p(y=1|x)}{p(y=0|x)}=w^{T}x+b$ 极大似然法 给定数据集$\\{(x_{i}, y_{i})\\}^{m}_{i=1}$ 最大化样本属于其真实标记的概率 线性判别分析（Linear Discriminant Analysis） 最大化目标$J=\\frac{|w^{T}\\mu_{0}-w^{T}\\mu_{1}|^{2}_{2}}{w^{T}\\sum_{0}w+w^{T}\\sum_{1}w}=\\frac{w^{T}(\\mu_{0}-\\mu_{1})(\\mu_{0}-\\mu_{1})^{T}w}{w^{T}(\\sum_{0}+\\sum_{1})w}$ 类间散度矩阵，类内散度矩阵 广义瑞丽商$J=\\frac{w^{T}S_{b}w}{w^{T}S_{w}w}$ 拉格朗日乘子法 $\\bigtriangledown f(x^{})+\\lambda \\Delta g(x^{})=0$ $L(x,\\lambda)=f(x)+\\lambda g(x)$. 多分类问题 多分类学习方法 二分类学习方法推广到多类 利用二分类学习器解决多分类问题 对问题进行拆分，为拆出的每个二分类任务训练一个分类器 对于每个分类器的预测结果进行集成以获得最终的多分类结果 拆分策略 一对一（OVO） $N$个类别两两配对，$N(N-1)/2$个二类任务 各个二类任务学习分类器，$N(N-1)/2$个二类分类器 一对其余（OVR） 多对多（MVM） 若干类作为正类，若干类作为反类 输出纠错码（Error Correcting Output Code, ECOC） 类别不平衡问题$(class\\ imbalance)$ 不同类别训练样例数相差很大情况（正类为小类） 类别平衡正例预测$\\frac{y}{1-y}&gt;1\\Rightarrow \\frac{y}{1-y}&gt;\\frac{m^{+}}{m^{-}}$正负类比例 再缩放 欠采样$(undersampling)$ 去除一些反例使正反例数目接近 过采样$(oversampling)$ 增加一些正例使正反例数目接近 阈值移动$(threshold-moving)$ Chapter4 决策树4.1 基本流程决策树基于树结构来进行预测 如果用决策树来进行分来,起码该模型一定意义上是可以理解的 树结构的return(1)当前节点包含的样本全部属于同一类别(没必要分类)(2)当前的属性集为空,或所有样本所有属性上取值相同(没法分类)(3)当前节点包含的样本集合为空($ \\emptyset $)4.2划分选择 希望决策树的分支节点包含的样本尽可能属于同一类别,即节点的”纯度”(purity)越来越高 经典的属性划分方法:1)信息增益,2)增益率,3)基尼指数 划分选择-信息增益 “信息熵”是度量样本集合纯度最常用的一种指标 信息熵 Ent(D)=-\\sum_{k=1}^{|y|}p_klog_2p_k 推导:\\int P(x)f(x)dx\\rightarrow E_{x - p}(f(x))\\rightarrow E_{x-p} (log_2 \\frac{1}{p_k}) (log2可以表示用二进制表示,$\\frac{1}{p_k}$可以显示信息(概率越低越刺激)) 计算信息熵的约定:若p=0,则Ent=0 Ent(D)的值越小,纯度越大 信息增益 Gain(D,a)=Ent(D)-\\sum_{v=1}^{V}\\frac{|D^{v}|}{|D|}Ent(D^{v}) 算出信息增益之后,可以确定树的每一层应该对应哪些划分属性 存在的问题 信息增益对可取值数目较多的属性有所偏好 划分选择-增益率 增益率：Gain\\_ ratio (D,a)=\\frac{Gain(D,a)}{IV(a)}其中 IV(a)=-\\sum _{v=1}^{V}\\frac{D^v}{D}log_2 \\frac{D^v}{D} 存在的问题 增益率准则对可取值数目较少的属性有所偏好 划分选择-基尼指数Gini(D)=\\sum_{k=1}^{|y|}\\sum _{k'\\neq k}p_kp_{k'}=1-\\sum_{k=1}^{|y|}p_k^{2} Gini越小纯度越高 4.3剪枝处理 为了对抗过拟合 基本策略 预剪枝 后剪枝 判断决策树泛化性能是否提升的办法 留出法预剪枝 优点 降低过拟合风险 显著减少训练时间和测试时间开销 缺点 欠拟合风险后剪枝 优点 比预剪枝保留了更多的分支,欠拟合风险小,泛化性能往往由于预剪枝决策树 缺点 时间开销4.4连续与缺失值连续与缺失值-连续值处理 连续属性离散化(二分法) 缺失值处理 面临两个问题 如何划分,如何测试 4.5多变量决策树Chapter 55.1 神经网络模型与发展史 第一阶段 M-P模型 Hebb学习规则:类似于巴普洛夫,if input and output 同时激活或者失活, 那么这两个神经元的链接应该被加强,else 应该减弱 感知机网络 自适应神经元,最小均方学习算法 GG 1: 单层的神经网络不能解决非线性问题,多层神经网络算力不足的时候就输了 第二阶段 Hopfield 网络 反向传播算法 SVM与统计学习理论 第三阶段 DBN深度信念网络 神经元模型 M-P神经元模型 输入:来自其他n个神经元传递过来的输入信号 处理:输入信号通过带权重的连接进行传递,神经元接收到的总输入值将与神经元的阈值进行比较 输出:通过激活函数的处理以得到输出:$y=f(\\sum _{i=1}^{n}w_ix_i-\\theta)$ 扯一点signmoid(x)=$\\frac{1}{1+e^{-x}}$$y’=\\frac{1}{1+e^{-x}}’=\\frac{1}{1+e^{-x}}\\times \\frac{e^{-x}}{1+e^{-x}}=y(1-y)$ 5.2 感知机与多层网络 感知机 由两层神经元组成,输入层接受外界输入信号传递个输出层,输出层是M-神经元 与或非 多层感知机 多层前馈神经网络 定义:每层神经元与下一层神经元全互联 前馈:输入层接受外界输入,隐含层与输出层神经元对信号进行加工,最终结果由输出层神经元输出 5.3 误差逆传播算法 误差逆传播算法(BP) 前向计算: $b_h=f(\\beta _h -y_h ),\\beta _h=\\sum_{i=1}^{d}v_{ih}x_i$ $\\hat{y}_i^{k}=f(a_j-\\theta _j),\\alpha_h=\\sum_{i=1}^{d} w_{hj}b_{h}$ $E_k=\\frac{1}{2}\\sum_{j=1}^{l}(\\hat{y}_{j}^{k}-\\hat{y}_{j}^{k})^{2}$ 参数数目 权重:$v_{ih},w_{hj}$, 阈值:$\\theta _{j}$,$y_{h}$ (i=1,…,d,h=1,…,q,j=1,…,l)因此网络中需要(d+l+1)q+l个参数需要优化 参数优化 BP是迭代学习算法,在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计,任意的参数v的更新估计式为v\\leftarrow v+\\Delta v 梯度咋整? 梯度消失咋整? 因为本质上还是函数的复合,因此不能用线性函数做传递函数 一些BP算法 标准BP算法:每来一个样本,就扔到bp网络中,然后前馈得到误差,得到误差之后就逆传递回来更新网络…… 累计BP算法:用平均误差更新权值,一定意义上可以减少震荡 实际应用: Mini BP 一块一块更新 多层前馈网络: 局限: 可能遭遇过拟合 到底搞几层？ 解决过拟合策略： 正则化 早停 5.4 全局最小与局部极小 策略 使用”模拟退火” 随机梯度下降 遗传算法 5.5 其他常见神经网络 RBF网络:单隐层,激活函数与输入向量有关:\\phi(x)=\\sum^{q}_{i=1}w_i\\rho(x,c_i)$\\rho(x,c_i)$是径向基函数：\\rho(x,c_i)=e^{-\\beta_i ||x-c_i||^{2}} ART网络：自适应谐振理论竞争性学习网络,输出神经元互相竞争,遵循胜者通吃原则比较层,识别层(???) SOM网络：获取数据内在的结构 级联相关,或则隐层节点的构造 Elman网络：递归神经网络 Chapter 6: 支持向量机传奇——一刀999神经网络(1989-1994)(BP算法)—————-&gt;支持向量机 (1995-2005)(核方法,统计学习)(Vapnik)————-&gt; 神经网络(2006-今)(深度学习) 支持向量机 灵活（核方法） 能力很强 数学理论坚实 全局最优解 不需要人工调参 神经网络 更灵活 能力很强 理论不清,来自认知 局部最优解 非常依赖人工调参 支持向量机(SVM) 计算开销大 领域知识嵌入困难(对现象的认识) 服务于科学界 神经网络(NN) 可大可小 领域知识无处不在 服务于工业界 6.1 间隔与支持向量 最大间隔: 寻找参数$w$,b,使得$\\nu=\\frac{2}{||w||}$ 最大 arg~max_{w,b}~\\frac{2}{||w||}s.t. $y_i(w^{T}x_i+b)\\geq 1,i=1,2,…,m$ arg~min~\\frac{1}{2}||w||^{2}s.t. $y_i(w^{T}x_i+b) \\geq 1,i=1,2,…,m$ 6.2 对偶问题 拉格朗日乘子法 三步 解的稀疏性 最终模型:$f(x)=w^Tx+b=\\sum_{i=1}^{m}a_iy_ix_{i}^{T}x+b$ KKT条件: { \\begin{cases} a_i\\geq 0\\\\ y_if(x_i)\\geq 1\\\\a_i(y_if(x_i)-1)=0\\end{cases}} SMO-求解方法,选两个固定搞，因为两个有闭式解； 6.3 核函数 从低维映射到高维可以用线性的方式进行分类，只要维数足够高，高维的空间总可以线性的来分类； 将x映射到$\\phi(x)$转换前面的最终模型为:$f(x)=w^Tx+b=\\sum_{i=1}^{m}a_iy_i\\phi(x)_{i}^{T}\\phi(x)+b$ 定义核函数:$k(x_i,x_j)=\\phi(x_i)^{T}\\phi(x_j)$ 定义核矩阵:K= {\\left[ \\begin{matrix} k(x_1,x_1) & k(x_1,x_2) & ... & k(x_1,x_n)\\\\ k(x_2,x_1) & k(x_2,x_2) & ... & k(x_2,y_n) \\\\ ...&... & ... & .. \\\\ k(x_n,x_1) & k(x_n,x_2) & ... & k(x_n,y_n) \\end{matrix} \\right]} 6.4 软间隔与正则化 黑人问号，谜の调参(C) 6.5 支持向量回归 因为听不懂所以自闭了 感觉大概推了一个神奇的二次回归吧 6.6 核方法 表示定理：对于任意单调增函数$\\Omega$和任意非负损失函数l,优化问题…… Chapter 7 :贝叶斯7.1 贝叶斯决策论概率框架下实施决策的基本理论： 条件风险 $R(c_i|x)=\\sum_{j=1}^{N}\\lambda _{ij}P(c_j|x)$ 贝叶斯判定准则 $h^{*}(x)=argmin_{c\\in \\gamma} ~R(c|x)$ $h^*(x)$:贝叶斯最优分类器, 反应了机器学习所能产生的模型精度的理论上限 P(c|x)在现实中通常难以直接获得 两种基本策略： 判别式模型：直接对P(c|x)建模 决策树 BP神经网络 SVM 生成式模型：先对联合概率分布P(x,c)建模,再由此获得P(c|x) $P(c|x)=\\frac{P(x.c)}{P(x)}$ 贝叶斯定理 后验概率与联合概率分布的关系： $P(c|x)=\\frac{P=(x,c)}{P(x)}$ $P(c|x)=\\frac{P(c)P(x|c)}{P(x)}=\\frac{P(c)P(x|c)}{\\int P(c)P(x|c)~dc}$ P(c):先验概率(人群中得病概率为1/1000000) P(x):证据 P(c|x):后验概率(医院看到了症状之后判断的概率) P(x|c): likehood 似然(重点在另外的变量$\\theta$上) ,likehood function目的是求$\\theta$ Prob(重点在变量上面) 7.2极大似然估计fenleiqifenleiqi（不太懂 https://blog.csdn.net/chenjianbo88/article/details/52398181 7.3 朴素贝叶斯分类器(naive Bayes classifier)假定属性独立地对分类结果发生影响 P(c|x)=\\frac{P(c)P(x|c)}{P(x)}=\\frac{P(c)}{P(x)}\\Pi^{d}_{i=1}P(x_i|c) P(c)=$\\frac{D_c}{D}$ $P(x_i|c)=\\frac{D_{c,x_i}}{D_c}$ 拉普拉斯修正(为了解决某一个属性值在训练集中没有与某个类同时出现过就凉了 所以要假设出现了一次) $\\hat{P(c)}=\\frac{|D_c|+1}{|D|+N}$ $\\hat{P(x_i|c)}=\\frac{|D+{c_i,x_i}|+1}{|D_c|+N_i}$ hint: 连续的分布用概率密度来代替,(一般用高斯分布) 7.4 半朴素贝叶斯分类器One - Dependent Esitimator SPODE 超父带你飞 TAN 计算条件互信息 $I(x_i,x_j|y)=\\sum _{x_i,x_j;c\\in \\gamma}P(x_i,x_j|c)log\\frac{P(x_i,x_j|c)}{P(x_i|c)P(x_j|c)}$ 建完全图,权重设为上面的I 构建最大带权生成树,挑选根变量,将变置为有向 加入类别节点y,增加从y到每一个属性的有向边 AODE 7.5 贝叶斯网（概率论知识反应不能,To be continued V型例子:各位的智商x1 考试难度x2 最后的考试成绩x4,考完结果出来x1,x2就不独立了 道德图(从marriage的梗里面获得) Chap 8 集成学习​ ​ PS：使用https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/ 里面的方法解决了博客的数学公式显示问题","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"数学期望","date":"2021-02-23T09:24:41.000Z","path":"2021/02/23/数学期望/","text":"离散型:$\\sum _{k=1}^{\\infty}x_kp_k$,需要它绝对收敛; 连续型:$\\int_{-\\infty}^{\\infty}xp(x)dx$,同样需要它绝对收敛,如果$\\int_{-\\infty}^{\\infty}|x|p(x)dx$发散,则X的数学期望不存在 Gamma函数:\\Gamma(x)=\\int_{0}^{+\\infty}t^{x-1}e^{-t} $\\Gamma(1)=1$ $\\Gamma(x+1)=x\\Gamma(x)$ $\\Gamma(n)=(n-1)!$ 高斯积分: $\\int_{-\\infty}^{+\\infty}e^{-x^2}dx=\\sqrt{\\pi}$ $C_{n}^{k}=\\frac{n!}{k!(n-k)!}$ $\\int \\frac{1}{1+x^2}=arctanx$ 数学期望 概率与数学期望及方差: 0-1分布:$X~B(1,p)$,$0&lt;p&lt;1$: E(x)=0(1-p)+1p=p D(X)=pq 二项分布:$X~B(n,p)$,$0&lt;p&lt;1$ $P\\{X=k\\}=C_{n}^kp^k(1-p)^{n-k},(k=0,1,…,n)$ $E(X)=np$ $E(X)$的证明注意$\\sum^{n-1}_{s=0}C^{s}_{n-1}p^s(1-p)^{n-1-s}=1$ $D(x)=npq$ 几何分布: P(X=k)=$p(1-p)^{k-1}$ E(x)= 泊松分布:X~$P(\\lambda),\\lambda&gt;0$ $P\\{X=k\\}=\\frac{\\lambda^{k}}{k!}e^{-\\lambda}$ E(X)=$\\lambda$ $E(x)$的证明注意$\\sum_{m=0}^{\\infty}\\frac{\\lambda^m}{m!}e^{-\\lambda}=1$(这是因为泊松分布概率的加和为1) D(X)=$\\lambda$ 均匀分布:X~$U(a,b)$ $\\begin{aligned}p(x)&amp;=\\frac{1}{b-a},a&lt;x&lt;b;\\\\&amp;=0,~~~~others;\\end{aligned}$ E(x)=$\\frac{a+b}{2}$ 指数分布:X~E($\\lambda$)$\\lambda&gt;0$, p(x)=$\\lambda e^{-\\lambda x}$,x&gt;0; E(x)=$\\frac{1}{\\lambda}$ 正态分布:X~N($\\mu,\\sigma^2$) p(x)=$\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},-\\infty&lt;x&lt;\\infty$ E(x)=$\\mu$ $\\mu$:平均值;$\\sigma^2$:X取值的离散程度 代换: 一维 E(Y)=E[g(X)]=$\\sum_{k=1}^{\\infty}g(x_k)p_k$(离散) E(Y)=E[g(X)]=$\\int_{-\\infty}^{+\\infty}g(x)p(x)dx$ 二维 E(Z)=E[g(X,Y)]=$\\sum_{j=1}^{\\infty}\\sum_{i=1}^{\\infty}g(x_i,y_i)p_{ij}$(离散型) E(Z)=E[g(X,Y)]=$\\int_{j=1}^{\\infty}\\int_{i=1}^{\\infty}g(x,y)p_{x,y}dxdy$(连续型) 边缘密度:E(g(X,Y)),g(X,Y)=x,E(x)=$\\int_{j=1}^{\\infty}\\int_{i=1}^{\\infty}xp_{x,y}dxdy$ 性质: E(X+Y)=E(X)+E(Y) if X,Y互相独立:E(XY)=E(X)E(Y) 设C是常数:E(C)=C 设k是常数:E(kx)=kE(x) 方差 D(X)=E{[X-E(X)]$^2$} D(X)=$\\sum_{k=1}^{+\\infty}[x_k-E(X)]^2p_k$ D(X)=$\\int_{-infty}^{+\\infty}[x_k-E(X)]^2p_k$ D(x)=E($X^2$)-$[E(x)]^2$ 性质: D(C)=0; C是常数 D(CX)=$C^2$D(X) D(X+C)=D(X) D(X),D(Y)存在: if 不独立:D($X\\pm Y$)=$D(X)\\pm +D(y)\\pm 2E\\{(X-E(X))(Y-E(Y))\\}$ else:D($X\\pm Y$)=$D(X)\\pm +D(y)$ 切比雪夫不等式: $P{|X-E(X)|\\geq \\varepsilon }\\leq \\frac{D(X)}{\\varepsilon ^2 }$ $P{|X-E(X)|&lt;&gt; \\varepsilon }\\geq 1- \\frac{D(X)}{\\varepsilon ^2 }$ D(X)=0 $\\Leftrightarrow $ P{X=C}=1","tags":[{"name":"概率论","slug":"概率论","permalink":"http://tyler-ytr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"p4学习-2:P4 basic实验","date":"2021-02-21T09:12:26.000Z","path":"2021/02/21/p4学习-2/","text":"P4学习-2：P4 basic实验实验目标 写一个P4程序完成基本的IPV4转发，也就是交换机需要:1.更新源和目的MAC地址 2. 在IP报头中减少 time-to-live(TTL) 3.将数据包转发到适当的端口 交换机有一个简单的table,控制平面将根据基本的规则更新它。每个规则将一个IP地址映射到下一跳的MAC地址和输出端口。我们已经定义了控制平面规则，所以你只需要实现你的P4程序的数据平面逻辑。 拓扑如下: 实验basic.p4给了一个p4程序，关键部分被TODO代替，这个程序主要由以下部分组成: Ethernet (ethernet_t) and IPv4 (ipv4_t)两个header type的类型定义 TODO：用于以太网和IPv4的Parser,它通过解析数据包填充了上述两个header; 一个丢包的动作，用了mark_to_drop() TODO：一个动作（ipv4_forward）： 设置下一跳的出口端口。 更新以太网目的地址为下一跳地址。 将以太网源地址更新为交换机地址。 TTL衰减。 TODO: 一个control: 定义一个表，该表将读取IPv4目的地址，并调用drop 或者ipv4_forward 应用这个表的一个 apply block 选择字段插入出数据包的顺序的Deparser。 实例化部分 通常，包还需要校验和验证和重新计算控件的实例。这些对于本教程来说不是必需的，它们将被空控件的实例化所取代。 代码部分本部分根据上面对程序的描述一一进行分析： headers部分:12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;* -*- P4_16 -*- *&#x2F; # 声明语言是p4-16#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;header ethernet_t &#123; # header数据结构相当于c语言里面的 packed struct,它有一个隐藏的参数validity，如果解析正确那么是true，可以通过isValid()获得，比如hdr.ipv4.isValid(); macAddr_t dstAddr;# macAddr_t是typedef bit&lt;48&gt; 的自定义类型 macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;header ipv4_t &#123; bit&lt;4&gt; version;#4bit的数据 bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;struct metadata &#123; #struct数据结构相当于python里面的 dictionary &#x2F;* empty *&#x2F; #这个实验用不到&#125;struct headers &#123; ethernet_t ethernet; ipv4_t ipv4;&#125; 其中V1model的结构如下图所示: 总的来说这是一个模板，大致由下图组成: 主要由HEADERS,PARSER,CHECKSUMVERFICATION,INGRESSPROCESSING,EGRESSPROCESSING,CHECKSUM UPDATE,DEPARSER,SWITCH组成;大概实例化的解释如下: 12345678V1Switch(MyParser(), &#x2F;&#x2F; 解析数据包，提取包头 MyVerifyChecksum(), &#x2F;&#x2F; 校验和验证MyIngress(), &#x2F;&#x2F; 输入处理MyEgress(), &#x2F;&#x2F; 输出处理MyComputeChecksum(), &#x2F;&#x2F; 计算新的校验和MyDeparser() &#x2F;&#x2F; 逆解析器) main; Parser部分1234567891011121314&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; &#x2F;* TODO: add parser logic *&#x2F; transition accept;#表示接受，也就是程序终止 &#125;&#125; 解答:123456789101112131415161718192021222324&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;parser MyParser(packet_in packet, out headers hdr, #out相当于输出的数据,然后它的type是headers inout metadata meta, #inout同时作为输入和输出值，类似 c++ 里面的引用 inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet;#转移到解析以太包头阶段 &#125; state parse_ethernet&#123; packet.extract(hdr.ethernet); #把packet提取到hdr的ethernet里面，这里的过程可以理解为根据ethernet的长度截取一段数据 transition select(hdr.ethernet.etherType)&#123;#根据etherType的值选择进入的状态 TYPE_IPV4: parse_ipv4;#是IPV4包，进入解析ipv4的状态 default: accept; &#125; &#125; state parse_ipv4&#123; packet.extract(hdr.ipv4); #接着解析ipv4部分，这里可以理解为指针又往前移动了 transition accept; &#125;&#125; Ingress部分123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分 &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; &#x2F;* TODO: fill out code in action body *&#x2F; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; NoAction(); &#125; apply &#123; &#x2F;* TODO: fix ingress control logic * - ipv4_lpm should be applied only when IPv4 header is valid *&#x2F; ipv4_lpm.apply(); &#125;&#125; 解答: 1234567891011121314151617181920212223242526272829303132333435363738&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分 &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec&#x3D;port; #egress_spec可以在输入代码中指定一个值来控制数据包将去哪个输出端口 hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; #原数据包的源地址改为目的地址 hdr.ethernet.dstAddr &#x3D; dstAddr; #目的地址改为控制面传入的新的地址 hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; #ttl要减去1 &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; NoAction(); &#125; apply &#123; if (hdr.ipv4.isValid()) &#123;# 隐藏的参数，判断解析是否成功 ipv4_lpm.apply(); &#125; &#125;&#125; PS:standard_metadata是v1model.p4里面定义的数据结构，在simple_switch的README里面进行了详细的解释,simple_switch是p4语言的一种架构，它大概的定义如下,其中v1m表示v1model,p4-16的一种模型，sm14是p4-14里面定义的模型 123456789ingress_port (sm14, v1m) - For new packets, the number of the ingress port on which the packet arrived to the device. Read only.packet_length (sm14, v1m) - For new packets from a port, or recirculated packets, the length of the packet in bytes. For cloned or resubmitted packets, you may need to include this in a list of fields to preserve, otherwise its value will become 0.egress_spec (sm14, v1m) - Can be assigned a value in ingress code to control which output port a packet will go to. The P4_14 primitive drop, and the v1model primitive action mark_to_drop, have the side effect of assigning an implementation specific value DROP_PORT to this field (511 decimal for simple_switch by default, but can be changed through the --drop-port target-specific command-line option), such that if egress_spec has that value at the end of ingress processing, the packet will be dropped and not stored in the packet buffer, nor sent to egress processing. See the &quot;after-ingress pseudocode&quot; for relative priority of this vs. other possible packet operations at end of ingress. If your P4 program assigns a value of DROP_PORT to egress_spec, it will still behave according to the &quot;after-ingress pseudocode&quot;, even if you never call mark_to_drop (P4_16) or drop (P4_14).egress_port (sm14, v1m) - Only intended to be accessed during egress processing, read only. The output port this packet is destined to.egress_instance (sm14) - Renamed egress_rid in simple_switch. See egress_rid below.instance_type (sm14, v1m) - Contains a value that can be read by your P4 code. In ingress code, the value can be used to distinguish whether the packet is newly arrived from a port (NORMAL), it was the result of a resubmit primitive action (RESUBMIT), or it was the result of a recirculate primitive action (RECIRC). In egress processing, can be used to determine whether the packet was produced as the result of an ingress-to-egress clone primitive action (INGRESS_CLONE), egress-to-egress clone primitive action (EGRESS_CLONE), multicast replication specified during ingress processing (REPLICATION), or none of those, so a normal unicast packet from ingress (NORMAL). Until such time as similar constants are pre-defined for you, you may copy this list of constants into your code.parser_status (sm14) or parser_error (v1m) - parser_status is the name in the P4_14 language specification. It has been renamed to parser_error in v1model. The value 0 (sm14) or error.NoError (P4_16 + v1model) means no error. Otherwise, the value indicates what error occurred during parsing.parser_error_location (sm14) - Not present in v1model.p4, and not implemented in simple_switch.checksum_error (v1m) - Read only. 1 if a call to the verify_checksum primitive action finds a checksum error, otherwise 0. Calls to verify_checksum should be in the VerifyChecksum control in v1model, which is executed after the parser and before ingress. Egress部分123456789&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; apply &#123; &#125;&#125; Checksum 部分1234567891011121314151617181920212223&#x2F;************************************************************************************** C H E C K S U M C O M P U T A T I O N ***************************************************************************************&#x2F;control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; update_checksum( hdr.ipv4.isValid(), &#123; hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr &#125;, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16); &#125;&#125;# 内置函数 Deparser部分123456789&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; &#x2F;* TODO: add deparser logic *&#x2F; &#125;&#125; 解答: 12345678910&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet);#按照顺序封装,emit的含义是发射 packet.emit(hdr.ipv4); &#125;&#125; 实例化部分12345678910111213&#x2F;************************************************************************************************ S W I T C H ********************************************************************************************************&#x2F;V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(),MyComputeChecksum(),MyDeparser()) main; 实验结果:pingall测试: image-20210223225105957","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"p4学习-1:介绍与参考资料","date":"2021-02-18T03:08:37.000Z","path":"2021/02/18/p4学习-1/","text":"P4学习-1：介绍与参考资料实验前 P4的PISA(Protocol-Independent Switch Architecture)结构： Programmable Parser—-&gt;Programmable Match-Action Pipeline—-&gt; Programmable Deparser； Parser作用:程序员声明应该被识别的头和它们在包中的顺序 Match-Action作用:程序员定义表和精确的处理算法 Deparser作用:程序员声明输出的包怎样输出到总线上 整个结构都是流水线架构，一个来自外部的网络数据包经过层层流程首先被Parser解析出headers,然后进入Match-Action Table进行匹配和操作，这些headsers可以被添加/修改/删除；然后进入Deparser组装好流入外部网络，因为是流水线，所以Match-Action部分是不可以回头的 ； 实验部分——文件结构:(主要参考博客) tutorials的文件结构: 1234tutorials&#x2F;├── exercises # 存放各种练习├── utils # 工具脚本目录└── vm # 用于vagrant构建虚拟机的目录，可以无视 例子的文件结构: 123456789101112131415# 我们切换进入 exercises&#x2F;basic_tunnel 这个例子basic├── basic_tunnel.p4 # 要编写的p4代码├── build # 生成文件的目录├── logs # 日志文件， 在调试的时候真的非常重要！├── Makefile ### 通过Makefile 来调用utils下的脚本!├── pcaps # 生成的pcap包，可以使用wireshark等工具来分析├── README.md # 详细的指导├── receive.py ## 利用scapy写的抓取和分析数据包的工具├── s1-runtime.json #├── s2-runtime.json # 在运行同时加载入交换机的控制面代码，这里有争议，稍后再谈├── s3-runtime.json #├── send.py ## 利用scapy写的构建和发送数据包的工具├── solution # 这里有这个例子的示例代码（答案）└── topology.json # 描述拓扑的json文件 这部分摘自参考资料的博客，实际情况有所不同 Makefile会调用前面提到的utils下面的Makefile脚本，运行P4代码; 使用make run 启动; 调用make run，我们可以运行当前目录下（以basic目录为例）的代码，它将执行以下几个步骤: 编译basic.p4 代码，生成basic.json 解析topology.json， 并且构建相应的mininet仿真拓扑，按照该拓扑启动一台或者多台BMv2交换机，以及一些host 启动BMv2的同时会将p4代码编译产生的json文件导入 启动BMv2后会解析 sN-runtime.json 文件(s1,s2,s3……)，将其载入 交换机sN流表之中 进入mininet命令行，同时开始记录log以及搜集pcap文件 P4的参考手册:https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html 参考资料 https://www.sdnlab.com/22512.html P4官方tutorial(https://github.com/p4lang/tutorials) P4学习笔记专栏","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode21-s","date":"2021-02-14T09:46:54.000Z","path":"2021/02/14/leetcode21-s/","text":"21. 合并两个有序链表难度简单1530 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： img 12输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4] 示例 2： 12输入：l1 &#x3D; [], l2 &#x3D; []输出：[] 示例 3： 12输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0] 123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1,l2=l2,l1 l1.next=self.mergeTwoLists(l1.next,l2) return l1 or l2","tags":[{"name":"递归","slug":"递归","permalink":"http://tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"p4安装","date":"2021-02-07T08:25:10.000Z","path":"2021/02/07/p4安装/","text":"P4环境配置 因为之后使用的时候PI那块还是有问题，建议谨做参考，安装还是最好用一用官方的tuorials里面的虚拟机脚本 0.准备 基础环境ubuntu 18.04 LTS 使用trojan终端代理，不然一些下载太慢了 ubuntu换源到阿里云 在~目录新建P4目录并且加入环境变量 1234mkdir P4cd P4echo&quot;P4_HOME&#x3D;$(pwd)&quot;&gt;&gt; ~&#x2F;.bashrcsource ~&#x2F;.bashrc 安装依赖包 12sudo apt-get install -y cmake g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev libboost-graph-dev llvm pkg-config python python-scapy python-ipaddr python-ply tcpdump doxygen graphviz texlivesudo apt-get install g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev pkg-config python python-scapy python-ipaddr tcpdump cmake## 两个参考里面的可能有重复 下面都是在P4文件夹进行的工作 所有的make都巨慢，合理安排好时间 1. 安装依赖库protocol 参考了这个依赖库github的C++环境的README; 安装依赖并且git clone 12345sudo apt-get install autoconf automake libtool curl make g++ unzipgit clone https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf.gitcd protobufgit submodule update --init --recursive.&#x2F;autogen.sh 其中 git submodule update —init —recursive 必做，这会下载好相应的googletest文件，忽略这一步会在make check报错 然后build以及安装，下面步骤耗时较长: 12345.&#x2F;configuremakemake checksudo make installsudo ldconfig # refresh shared library cache.更新共享库 2. 安装PI以及它的依赖 参考PI的 github网站https://github.com/p4lang/PI 安装 首先安装gRPC V1.17.2 123456789git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;grpc.gitcd grpc&#x2F;git checkout tags&#x2F;v1.17.2git submodule update --init --recursive # 这步耗时较长，一定要代理make #也可以make -j4 表示用四个核make,j后面这个数量可以自己设定sudo make installsudo ldconfig# Install gRPC Python Package 这步安装挺慢的sudo pip install grpcio 然后安装PI —with-proto,（To include p4runtime.proto in the build, please run configure with --with-proto.） 123456.&#x2F;autogen.sh.&#x2F;configure --with-protomake make checksudo make installsudo ldconfig 3. 安装bmv2 建议先阅读原来的github库(https://github.com/p4lang/behavioral-model) 安装操作 1234cd ~&#x2F;P4git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;behavioral-model.gitcd behavioral-modelsudo .&#x2F;install_deps.sh #脚本安装依赖库 终端代理的好处在于这些脚本如果不是终端代理下载会异常慢以至于不得不手动转换到gitee安装 安装依赖库因为要编译其他第三方库也异常的慢 123456 .&#x2F;autogen.sh .&#x2F;configure --enable-debugger --with-pi make sudo make install sudo sudo ldconfigcd .. 4. 安装p4c 下载库 123456789cd ~&#x2F;P4git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;p4c.gitcd p4cmkdir buildcd buildcmake ..make -j4 #4线程编译sudo make installcd ..&#x2F;.. 这步如果make -j4后面make check 会花很多时间然后有可能报错 5. 下载p4 tutorials1git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;tutorials 目前的目录: 12345678P4|——behavioral-model # BMv2 软件交换机|——grpc # 作为BMv2的依赖|——mininet # 网络仿真|——p4c #p4c编译器|——PI # PI P4 runtime库|——protobuf # 依赖|——tutorials #教程 6. 解决实验出现的bug在做实验的时候出现了陆陆续续的bug，还需要: No module named psutil 1234wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;p&#x2F;psutil&#x2F;psutil-2.1.3.tar.gz tar -zxvf psutil-2.1.3.tar.gz cd psutil-2.1.3 python setup.py install No module named google.protobuf.internal 1pip install protobuf 根据https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc 安装simple_switch_grpc 安装之后还是P4 switch s1 did not start correctly，根据issuehttps://github.com/p4lang/tutorials/issues/107 ，还需要： 1sudo ldconfig 至此可以编译basic实验 安装之后进行P4runtime的时候出现报错 ：No module named rpc 尚未解决 因此建议还是使用官方的vagrant PS: 最后发现其实最标准的安装操作是根据tutorials（https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢 参考博客 https://p4.org/p4/getting-started-with-p4.html https://www.jianshu.com/p/2878192ba3f7 https://www.sdnlab.com/22512.html","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"深度探索C++对象模型2","date":"2020-10-09T03:13:38.000Z","path":"2020/10/09/深度探索C-对象模型2/","text":"深度探索c++对象模型2这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”和“程序效率”的冲击 Default Constructor的构造操作 带有默认构造函数的Member Class Object 总结而言就是，如果对象a中依次有对象b，c，d，如果程序员仅仅初始化了c（10），那么编译器会调用b，d的默认构造函数，顺序是b，c（10），d；另外，对于对象g，假设里面只有int c;string d;编译器的隐式默认构造函数是不会帮忙解决这两者的初始化问题的，也就是这个构造函数是trivial的 带有默认构造函数的Base Class 一个类的构造函数，需要调用一些基类的构造函数（必要之默认构造函数），你自定义的构造函数，编译器会帮你补上调用那些构造函数的部分；先调用基类的默认构造函数然后调用成员类的默认构造函数 带有一个Virtual Function 的 Class 以下两种情况，需要编译器合成出default constructor class声明（或者继承）一个virtual constructor class派生自一个继承串链，其中有一个或者更多的virtual base classes以上两种情况如果缺乏用户声明的constructor，那么编译器会详细记录合成一个default constructor 的必要信息。主要有以下两种扩张行动： 一个虚函数表会被编译器产生出来，存放着类的虚函数地址 一个vptr会被编译器合成出来，包含着虚函数表的地址 带有一个Virtual Base Class 的 Class C继承A、B，A虚继承X，B虚继承X；根据不同编译器，在构造这些对象的时候会有类似指针的东西指向虚继承的类里面的成员，这些都是编译器在类对象构造期间完成的；对于这样的类所定义的每一个构造函数，编译器会安插那些“允许每一个virtual base class的执行期存取操作”的代码。如果class没有声明任何的constructors,编译器必须为它合成一个default constructor。； 总结： 上面四种情况，会造成：编译器必须为没有声明构造函数的类合成一个默认构造函数“，这些合成物被称为隐式非平凡默认构造函数(implicit nontrivial default constructors)。除此之外都是隐式平凡构造函数，实际上不会被合成出来。 在合成出来的这些构造函数里面，只有base class subobjects和member class objects会被初始化，其他的都不会。 Copy Constructor 的构造操作 下面三种情况，会以一个object的内容作为另一个class object的初值 显式地以一个对象的内容作为另一个类对象的初值 12X x;X xx&#x3D;x; 当对象被当做参数交给某一个函数的时候 当函数传回一个类对象的时候 如果类的设计者显式定义了一个拷贝构造函数，就会调用它 默认的拷贝构造函数 当类没有提供一个显示的拷贝构造函数时候使用，用递归的方式实行member initialization，比每一个内建的活着派生的data member的值从一个object拷贝到另一个上面。 下面讨论的是隐式的拷贝构造函数编译器是否会合成一个default copy constructor的问题。根据C++标准，决定一个copy constructor 是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。（只有nontrivial的实例才会被合成于程序里面。） bitwise copy semantics（位逐次拷贝） 什么时候一个class不展现出所谓的位逐次拷贝呢？ 一个class中有一个成员变量的class里面声明了一个copy constructor 这个class继承自一个基类，然后这个基类里面有一个copy constructor 当class声明了一个或者多个virtual functions（考虑vptr的拷贝问题） 当class派生自一个继承串链，其中有一个或者多个virtual base classes（发生在一个class object 以其derived classes的某一个对象作为初值的时候，编译器需要安插一些代码来设定virtual base class pointer/offset 的初值） 程序转化语义学（Program Transformation Semantics） 主要从初始化，参数初始化，返回值初始化三个角度探讨了拷贝构造函数的应用及应用的伪码； 显示初始化： 1234void foo_bar()&#123; X x1(x0); X x2&#x3D;x0; X x3&#x3D;X(x0); 转换成的可能的伪码： Alt 其中： 1x1.X::X(x0); //表现为对一下copy constructor 的调用： 1X::x(const X&amp; xx); 参数初始化：对于一下子调用方式： 1234void foo(X x0);X xx;&#x2F;&#x2F;...foo(xx) 可能的伪码： 123X __temp0;__temp0.X::X(xx);foo(__temp0); 返回值的初始化：对于以下函数： 12345X bar()&#123; x xx; &#x2F;&#x2F;.... return xx;&#125; 转化为如下伪码： NRV优化： NRV(name returned value)优化大致如下，我觉得是通过把返回的临时变量变成一个引用形参来实现的； NRV优化需要一个copy constructor,（最好是内联的提高效率) 最后探讨了copy constructor 要还是不要的问题，我觉得它的含义是，从速度角度来看，如果存在NRV优化的可能性，以及传值的要求，那么实现拷贝构造函数可以帮助实现这一点； 同时实现拷贝构造函数准备使用memcpy，memset的时候要注意是否有虚函数或者含有虚基类，防止错误的改变内部的vtpr; 比如下图： Alt Alt 成员初始化表 必须使用成员初始化表的四种情况： 当初始化一个reference member 当初始化一个const member; 当调用一个base class 的constructor，而它拥有一组参数的时候; 当调用一个member class的constructor，而它拥有一组参数的时候； 使用的注意点： 顺序问题，成员初始化表的初始化顺序是声明的顺序，因此如下代码会有bug: 12345678class X&#123; int i; int j; public: X(int val):j(val),i(j)&#123; ; &#125;&#125; 因为实际执行的时候是先i(j)然后j(val)的； 另外成员初始化表在显式代码的前面，因此 12345678class X&#123; int i; int j; public: X(int val):j(val)&#123; i&#x3D;j; &#125;&#125; 是合法的； 本书不太建议在成员初始化表里面调用一个member function进行初始化，主要因为不清楚具体的依赖关系的问题；当然如下图的伪代码，这是合法的： Alt -","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"http://tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"leetcode_478_m","date":"2020-09-25T09:13:45.000Z","path":"2020/09/25/leetcode478-m/","text":"478. 在圆内随机生成点难度中等37 给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。 说明: 输入值和输出值都将是浮点数。 圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。 圆周上的点也认为是在圆中。 randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。 示例 1： 1234输入: [&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;][[1,0,0],[],[],[]]输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]] 示例 2： 1234输入: [&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;][[10,5,-7.5],[],[],[]]输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]] 输入语法说明： 输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。 C++11新特性,随机数库,不香嘛？ https://blog.csdn.net/qq_23225317/article/details/79787543 基本语法: 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;std::random_device rd;std::default_random_engine e(rd());//e.seed(time(0));//随机整数std::uniform_int_distribution&lt;unsigned&gt; u(0, 9);//随机实数std::uniform_real_distribution&lt;double&gt; u2(0, 1);for(size_t i = 0; i &lt; 10; i++) std::cout&lt;&lt;u2(e)&lt;&lt;'\\t';//正态分布std::cout&lt;&lt;\"test normal distribution:\\n\";e.seed(time(0));std::normal_distribution&lt;&gt; n(4, 1.5);std::vector&lt;unsigned&gt; vals(9);for(size_t i = 0; i &lt; 250; i++)&#123; unsigned v = lround(n(e)); if(v &lt; vals.size()) vals[v]++;&#125;for(size_t i = 0; i &lt; vals.size(); i++)&#123; std::cout&lt;&lt;i&lt;&lt;\": \"&lt;&lt;std::string(vals[i], '*')&lt;&lt;std::endl;&#125;std::cout&lt;&lt;\"test normal distribution done.\\n\"&lt;&lt;std::endl;//伯努利分布std::cout&lt;&lt;\"test bernoulli distribution:\\n\";e.seed(time(0));std::bernoulli_distribution b(0.7);std::vector&lt;unsigned&gt; bers(2);for(size_t i = 0; i &lt; 200; i++)&#123; if(b(e)) bers[1]++; else bers[0]++;&#125;std::cout&lt;&lt;\"True: \"&lt;&lt;bers[1]&lt;&lt;std::endl;std::cout&lt;&lt;\"False: \"&lt;&lt;bers[0]&lt;&lt;std::endl;std::cout&lt;&lt;\"test bernoulli distribution done.\\n\"; 某一个题解: 相信大部分人都没有看懂，我就来通俗地解释一下吧。 确定圆内一点，需要有相对于圆心的距离r，以及相对于圆心的角度angle。 一开始的想法，我们在[0, radius]中等概率取r，在[0, 2π)中等概率取angle即可实现圆内的随机分布。 事实上，这是不对的。 在[0, 2π)中等概率取angle，相对于把一个圆分成了无数个扇形，点落在每个扇形上的概率均相等。 假设某个扇形的圆心角是theta，那么该扇形的面积是0.5 theta radius ^ 2，分布在该扇形区域上的概率是theta / 2π，只要每个扇形的圆心角相等，扇形面积就是相等的，点在扇形中也是等概率的。 在[0, radius]中等概率取r，相当于把一个圆分成了无数个环形，点落在每个环形上的概率均相等。 假设某个环形的内径是r1，外径是r2，那么该环形的面积是π * (r2 ^ 2 - r1 ^ 2)。可见每个环形的面积是不一样的，显然每个环形上的点密度是不一样的。这样做会造成靠近圆心的点分布比较密集，远离圆心的点分布比较稀疏。 那么，如何取r使得点落在圆内任意区域的概率均相等呢？这样做显然会使得落在每个环形上的概率均不同，且环形面积较大的概率高，环形面积较小的概率小。 根据环形面积的计算公式：π * (r2 ^ 2 - r1 ^ 2)，落在该环形面积上的概率应为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)。 在[0, radius]中如何分布概率密度函数f(x)，可以使得f(x)其在[r1, r2]上的积分值为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)呢？ 取f(x) = 2x / (radius ^ 2)可以满足上述条件，即半径r在[0, radius]上的概率密度函数应为f(x) = 2x / (radius ^ 2)，故只需要在[0, radius ^ 2]范围内等概率取r ^ 2，再开根号即得r值。（求一下导数即可，x ^ 2的导数是2x） 时间复杂度是和空间复杂度均是O(1)。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;private: double radius; double x_center,y_center; double _2pi;public://极坐标:x=rcos(\\theta),y=rsin(\\theta) Solution(double radius, double x_center, double y_center) &#123; this-&gt;radius=radius; this-&gt;x_center=x_center; this-&gt;y_center=y_center; this-&gt;_2pi=acos(-1)*2; &#125; vector&lt;double&gt; randPoint() &#123; vector&lt;double&gt;result; if(radius&gt;0)&#123; random_device rd; default_random_engine e(rd()); uniform_real_distribution&lt;double&gt;u1(0,radius*radius); uniform_real_distribution&lt;double&gt;u2(0,_2pi);//acos(-1)*2=2\\pi double r=sqrt(u1(e)); double theta=u2(e); double x=x_center+r*cos(theta); double y=y_center+r*sin(theta); result.push_back(x); result.push_back(y); &#125; return result; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(radius, x_center, y_center); * vector&lt;double&gt; param_1 = obj-&gt;randPoint(); */","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"name":"随机采样","slug":"随机采样","permalink":"http://tyler-ytr.github.io/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"}]},{"title":"leetcode_18_m 四数之和","date":"2020-09-25T08:19:56.000Z","path":"2020/09/25/leetcode18-m/","text":"18. 四数之和难度中等572 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，**b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 通过次数109,251 提交次数284,303 双指针法;主要要注意的是几个边界以及怎么去重的方法; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; //双指针法; //比O(n^4)的暴力减少了一些重复的内容; //算法是:固定a,b=a+1,然后c,d双指针遍历;然后b++……;然后b结束外层循环a++; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt;result; int size=nums.size(); if(size&lt;4)return result; int a,b,c,d; for(int a=0;a&lt;=size-4;++a)&#123; if(a&gt;0&amp;&amp;nums[a]==nums[a-1])continue; for(int b=a+1;b&lt;=size-3;++b)&#123; if(b&gt;a+1&amp;&amp;nums[b]==nums[b-1])continue; c=b+1; d=size-1; while(c&lt;d)&#123; if(nums[a]+nums[b]+nums[c]+nums[d]&lt;target)&#123; c++; &#125;else if(nums[a]+nums[b]+nums[c]+nums[d]&gt;target)&#123; d--; &#125;else&#123; result.push_back(&#123;nums[a],nums[b],nums[c],nums[d]&#125;); while(c&lt;d&amp;&amp;nums[c]==nums[c+1])&#123; c++; &#125; while(c&lt;d&amp;&amp;nums[d]==nums[d-1])&#123; d--; &#125; c++; d--; &#125; &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic_knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"HDU_4734 F(x)","date":"2020-09-20T12:19:26.000Z","path":"2020/09/20/HDU-4734/","text":"F(x)For a decimal number x with n digits (AnAn-1An-2 … A2A1), we define its weight as F(x) = An 2n-1 + An-1 2n-2 + … + A2 2 + A1 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). Input The first line has a number T (T &lt;= 10000) , indicating the number of test cases.For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109) Output For every case,you should output “Case #t: “ at first, without quotes. The t is the case number starting from 1. Then output the answer. Sample Input 123430 1001 105 100 Sample Output 123Case #1: 1Case #2: 2Case #3: 13 最开始的思路肯定是搜索 首先是对数位的搜索 然后开始思考另外有什么状态是需要往下面传的，那么就只有前面数的和了，因此是二维的，第一维度是数位，第二个维度是sum; 然后思考记忆化,最直观的就是第二维度就是sum,但是这样子的话每一次都需要根据all进行修改;比较特别的是dp里面的sum记录的是all-sum的值,这样做可以有效的利用memset优化; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstring&gt;int dp[12][5005];//dp[pos][sum]:对于位置pos的数位,这里的sum存储的是all-当前pos前缀和的差;int cur[12];int all;using namespace std;int f(int a)&#123;//计算F(a)的值 if(a==0)return 0; int pos=0; int able[11]; while(a)&#123; able[pos++]=a%10; a/=10; &#125; int result=0;// int now=1; for(int i=pos-1;i&gt;=0;--i)&#123; result+=(able[i]&lt;&lt;i); //now*=2; &#125; //cout&lt;&lt;\"result:\"&lt;&lt;result&lt;&lt;endl; return result;&#125;// pos:当前的数位,sum 当前的和/* if(pos&lt;0)return 1;合法; */int dfs(int pos,int sum,bool limit)&#123;//这里的sum表示的是到目前数位的前缀和 if(pos&lt;0)return sum&lt;=all; if(sum&gt;all)return 0; if(!limit&amp;&amp;dp[pos][all-sum]!=-1)return dp[pos][all-sum]; int up=limit?cur[pos]:9; int ans=0; for(int i=0;i&lt;=up;++i)&#123; ans+=dfs(pos-1,sum+i*(1&lt;&lt;pos),limit&amp;&amp;cur[pos]==i); &#125; if(!limit)dp[pos][all-sum]=ans;// cout&lt;&lt;pos&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;limit&lt;&lt;\" \"&lt;&lt;ans&lt;&lt;endl; return ans; &#125;int solve(int a,int b)&#123;// memset(cur,0,sizeof(cur)); all=f(a); int pos=0; if(b==0)return 0; while(b)&#123; cur[pos++]=b%10; b/=10; &#125; // for(int i=pos-1;i&gt;=0;--i)&#123; // cout&lt;&lt;cur[i]&lt;&lt;endl; // &#125; int result=dfs(pos-1,0,true); return result;&#125;int main()&#123; int t; //cin&gt;&gt;t; scanf(\"%d\",&amp;t); memset(dp,-1,sizeof(dp)); for(int i=0;i&lt;t;++i)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); //cin&gt;&gt;a&gt;&gt;b; int result=solve(a,b); // printf(\"Case #%d: %d\",i+1,result); printf(\"Case #%d: %d\\n\",i+1,result); // cout&lt;&lt;\"Case #\"&lt;&lt;i+1&lt;&lt;\": \"&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位dp","slug":"数位dp","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"}]},{"title":"HDU_2089 不要62","date":"2020-09-19T12:40:05.000Z","path":"2020/09/19/HDU-2089/","text":"不要62杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input 输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input 121 1000 0 Sample Output 180 经典的数位dp题目,数位dp我参考了数位dp总结 之 从入门到模板进行学习;总的来说的思想是对每一个数位进行枚举,然后辅之以记忆化搜索,以下是我根据板子做出来的结果; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int dp[10][2];int a[10];//pos:数位,pre:前一位什么数,state:前一位是不是6,如果是6那么就是1,否则是0;limit:防止超过最大数;为true的时候表示上一个到顶了;int dfs(int pos,int pre,int state,bool limit)&#123; if(pos&lt;0)&#123; return 1;//枚举合法 &#125; if(!limit&amp;&amp;dp[pos][state]!=-1)return dp[pos][state];//记忆化; int up=limit?a[pos]:9;//如果limit成功,那么前面的没有到顶,因此可以到9,否则只能到这个数位的值,比如231,前面枚举到3的时候,最后一位只有1可以; int ans=0;//计数; for(int i=0;i&lt;=up;++i)&#123; if(i==4)continue; if(pre==6&amp;&amp;i==2)continue; ans+=dfs(pos-1,i,i==6,i==up&amp;&amp;limit); &#125; if(!limit)dp[pos][state]=ans; return ans; &#125;int solve(int n)&#123;//分解数位 memset(a,0,sizeof(a)); int pos=0; while(n)&#123; a[pos]=n%10; n/=10; pos++; &#125; int result=dfs(pos-1,0,0,true); return result;&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp)); while(cin&gt;&gt;l&gt;&gt;r &amp;&amp;(l!=0||r!=0))&#123; int result=solve(r)-solve(l-1); cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位dp","slug":"数位dp","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"}]},{"title":"深度探索C++对象模型1","date":"2020-09-10T02:08:08.000Z","path":"2020/09/10/深度探索C-对象模型1/","text":"深度探索c++对象模型1 C++的主要额外负担： virtual function 机制 virtual base class 用以实现“多次出现在继承体系中的base class，又一个单一而被共享的实例” 多重继承下的额外负担 1.1 C++对象模式 C++对象模型 非静态成员变量存放在每一个class object里面，静态成员变量存放在个别的class object 之外；静态函数，非静态函数成员放在个别的class object之外，虚函数特殊对待： 每一个class 产生出一堆指向virtual function 的指针，放在表格中，这个表格称之为虚函数表（virtual table） 每一个class object被安插一个指针，指向相关的virtual table。通常这个指针称为$vtpr$.$vtpr$的设定由每一个class的constructor，destructor和copy assignment运算符自动完成。每一个class所关联的$tyle_info$ object(用来支持runtime type identification)也经由虚函数表纸出来，通常放在表格的第一个slot里面。例子如下 Alt C++继承 使用所谓的base table 模型。每一个class object内涵一个bptr,被初始化，指向它的base class table，然后这个表就如同虚函数表一样指向继承的类的对象，如下图 Alt 什么时候一个人应该使用struct 取代class？当它让一个人感觉比较好的时候（狗头）聚合（composition）而非继承才是把C++和C结合起来的好方法。struct在C++中的一个合理用途，是当你要传递一个“复杂的class object的全部或者部分”到某一个C函数去的时候，struct声明可以将数据封装起来，并且保证拥有与C兼容的空间布局，然而这种保证只在聚合（composition）的情况下存在。如果是继承的话，可能会因为内存布局原因无法实现想要的结果。 C++以下列方法支持多态： 经过一组隐式的转化操作，比如把一个派生类的指针转化为一个指向它的public base type的指针：shape *ps=new circle (); 经由virtual function机制：ps-&gt;rotate（） 经由$dynamic_cast$和typeid运算符：$if(circle pc=dynami_cast &lt; circle&gt;(ps))$ 需要多少内存才能够表现一个class object： 非静态成员变量的总和大小 加上任何由于alignment（对齐）的需求而填补（padding）上去的空间 加上为了支持virtual而内部产生的任何额外负担 关于指针：不同类型的指针从内存需求的观点来看没有什么不同，“指向不同类型之各指针‘间的差异，既不在其指针表示法的不同，也不再其内容的不同，而是在其所寻址出来的object类型不同。也就是说，“指针类型”会教导编译器如何解释某一个特定地址的内存内容及其大小。 最后一部分内容讨论了多态发生的条件，我认为总结下来就是引用和指针可能触发多态，通过虚函数来实现。然后将子对象赋值给父类对象一般会导致切割，来放置数据溢出。 具体问题： 一个Bear指针和一个ZooAnimal指针有什么不同： 123Bear b;ZooAnimal *pz&#x3D;&amp;b;Bear *pb&#x3D;&amp;; 它们每一个都指向Bear object 的第一个type，它们的区别是：pb所涵盖的地址包含整个 Bear object但是pz所涵盖的地址之包含Bear object中的ZooAnimal subobject.内存布局如下图： Alt","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"http://tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"leetcode22_m","date":"2020-09-07T01:28:58.000Z","path":"2020/09/07/leetcode22-m/","text":"22. 括号生成难度中等1252收藏分享切换为英文关注反馈 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 12345678输入：n &#x3D; 3输出：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 通过次数166,462 提交次数218,996 一道经典的回溯算法的题目,lcnit表示左边括号的数目,rcnt表示右括号的数目;结束的条件是temp.size()==2*n,也就是满足长度; 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt;result; int maxn=0; void back_track(string temp,int lcnt,int rcnt)&#123; if(temp.size()==maxn*2)&#123; result.push_back(temp); return; &#125; if(lcnt&lt;maxn)&#123; temp.push_back('('); back_track(temp,lcnt+1,rcnt); temp.pop_back(); &#125; if(rcnt&lt;lcnt)&#123; temp.push_back(')'); back_track(temp,lcnt,rcnt+1); temp.pop_back(); &#125; return; &#125; vector&lt;string&gt; generateParenthesis(int n) &#123; string temp=\"\"; maxn=n; back_track(temp,0,0); return result; &#125;&#125;;","tags":[{"name":"栈","slug":"栈","permalink":"http://tyler-ytr.github.io/tags/%E6%A0%88/"},{"name":"数据结构","slug":"数据结构","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode134_m","date":"2020-09-07T01:26:14.000Z","path":"2020/09/07/leetcode134-m/","text":"134. 加油站难度中等243 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 1234567891011121314输入: gas &#x3D; [1,2,3,4,5]cost &#x3D; [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 12345678910111213输入: gas &#x3D; [2,3,4]cost &#x3D; [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 参考了一个数形结合的题解 注意最小值的初始化问题 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int success=0; int n=gas.size(); int tempsum=0; for(int i=0;i&lt;n;i++)&#123; tempsum=tempsum+gas[i]-cost[i]; &#125; if(tempsum&lt;0)&#123; success=0; return -1; &#125; //现在起码可以环绕一圈，开始找起始点 //我觉得如果可以跑的话就是一个逃税过程，如何逃掉更多的税呢？因为起始点起始相当于少交一次前面的税 int gassum=0; int costsum=0; int min_ans=0; int min_result=INT_MAX; int temp=0; for(int i=0;i&lt;n;i++)&#123; gassum+=gas[i]; costsum+=cost[i]; temp=gassum-costsum; if(temp&lt;min_result)&#123; min_result=temp; min_ans=i; &#125; &#125; return (min_ans+1)%n; &#125;&#125;;","tags":[{"name":"贪心","slug":"贪心","permalink":"http://tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"poj2386","date":"2020-09-07T01:24:14.000Z","path":"2020/09/07/poj2386/","text":"Lake Counting Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 59523 Accepted: 28958 Description Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John’s field, determine how many ponds he has. Input * Line 1: Two space-separated integers: N and M * Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output * Line 1: The number of ponds in Farmer John’s field. Sample Input 123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output 13 Hint OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left,and one along the right side. Source USACO 2004 November 题目大意: 计算出相连的’W’有多少块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;//#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;char mapa[maxn][maxn];int N,M;void dfs(int x,int y)&#123; mapa[x][y]='.'; int tempx; int tempy; for(int i=-1;i&lt;=1;i++)&#123; for(int j=-1;j&lt;=1;j++)&#123; tempx=x+i; tempy=y+j; if(tempx&gt;=0&amp;&amp;tempx&lt;N&amp;&amp;tempy&gt;=0&amp;&amp;tempy&lt;M&amp;&amp;mapa[tempx][tempy]=='W')&#123; dfs(tempx,tempy); &#125; &#125; &#125; return ;&#125;int main() &#123; // std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; cin&gt;&gt;N&gt;&gt;M; // vector&lt;vector&lt;char&gt; &gt; map(N,(vector&lt;char&gt; (M))); for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; char temp; cin &gt;&gt; temp; mapa[i][j]=temp; &#125; &#125;//cout&lt;&lt;\"here\"&lt;&lt;endl; int cnt=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(mapa[i][j]=='W')&#123; dfs(i,j);// cout&lt;&lt;cnt&lt;&lt;endl;// for(int i=0;i&lt;N;i++)&#123;// for(int j=0;j&lt;M;j++)&#123;//// cout&lt;&lt;mapa[i][j]&lt;&lt;\" \";// &#125;// cout&lt;&lt;endl;// &#125; cnt+=1; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"poj1321 棋盘问题","date":"2020-09-07T01:22:23.000Z","path":"2020/09/07/poj1321/","text":"棋盘问题 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 96005 Accepted: 43758 Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input 1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output 1221 Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;vector&lt;string&gt;map;//vector&lt;bool&gt;line;int cnt;int ans;void clear()&#123; map.clear(); cnt=0; ans=0;&#125;int N;int K;void backtrace(int j,vector&lt;bool&gt;&amp;line) &#123; if (cnt == K) &#123;//注意出递归的条件是cnt==K也就是找到这么多个 ans++; return; &#125; if(j&gt;=N)&#123;//这里是为了防止遍历的行数超过边界 return; &#125; for (int i = 0; i &lt; N; i++)&#123; if(!line[i]&amp;&amp;map[j][i]=='#')&#123; line[i]=true; cnt+=1; backtrace(j+1,line); cnt-=1; line[i]=false; &#125; &#125; backtrace(j+1,line);//遍历下一行&#125;int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; //vector&lt;string&gt;map; int n; int t; clear(); vector&lt;bool&gt;line(9, false); while(cin&gt;&gt;n&amp;&amp;cin&gt;&gt;t)&#123; if(n==-1&amp;&amp;t==-1)&#123; break; &#125;else&#123; N=n; K=t; for(int i=0;i&lt;n;i++)&#123; string a; cin&gt;&gt;a; map.push_back(a); &#125; for(int i=0;i&lt;9;i++)&#123; line[i]=false; &#125; backtrace(0,line); // N=n;// for(int i=0;i&lt;n;i++)&#123;// for(int j=0;j&lt;n;j++)// cout&lt;&lt;map[i][j]&lt;&lt;\" \";// &#125; cout&lt;&lt;ans&lt;&lt;endl; //cout结果; clear(); &#125; &#125; return 0;&#125; PS:leetcode刷题表示所有的OJ题","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode491_m","date":"2020-09-07T01:18:16.000Z","path":"2020/09/07/leetcode491-m/","text":"491. 递增子序列难度中等88 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。 示例: 12输入: [4, 6, 7, 7]输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 说明: 给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。 通过次数7,099 提交次数14,688 使用回溯算法进行dfs;主要要和那道全排列进行比较和区分; 使用set可以减少重复(我感觉剪枝更快但是不好写) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: set&lt;vector&lt;int&gt;&gt;result; void dfs(vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;temp,int pos)&#123; if(temp.size()==0)&#123; temp.push_back(nums[pos]); &#125; for(int i=1;i&lt;nums.size();++i)&#123; if(i+pos&gt;nums.size()-1||nums[i+pos]&lt;temp.back())&#123; continue; &#125;else&#123; temp.push_back(nums[pos+i]); result.insert(temp); dfs(nums,temp,pos+i); temp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; //感觉是回溯算法做的; vector&lt;int&gt;temp; for(int i=0;i&lt;nums.size();++i)&#123; temp.clear(); dfs(nums,temp,i); &#125; vector&lt;vector&lt;int&gt;&gt;ans; set&lt;vector&lt;int&gt;&gt;::iterator it; for(it=result.begin();it!=result.end();++it)&#123; ans.push_back(*it); &#125; return ans; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode386_m","date":"2020-09-07T01:14:51.000Z","path":"2020/09/07/leetcode386-m/","text":"386. 字典序排数难度中等74 给定一个整数 n, 返回从 1 到 n 的字典顺序。 例如， 给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。 请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt;result; void dfs(int cur,int n)&#123; if(cur&gt;n)&#123; return; &#125; else&#123; result.push_back(cur); for(int i=0;i&lt;10;++i)&#123; if(cur*10+i&gt;n)&#123; return; &#125;else&#123; dfs(cur*10+i,n); &#125; &#125; &#125; &#125; vector&lt;int&gt; lexicalOrder(int n) &#123; for(int i=1;i&lt;=9;++i) dfs(i,n); return result; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode133_m","date":"2020-09-07T01:12:57.000Z","path":"2020/09/07/leetcode133-m/","text":"133. 克隆图难度中等155 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。 示例 1： img 12345678输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2： img 123输入：adjList &#x3D; [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3： 123输入：adjList &#x3D; []输出：[]解释：这个图是空的，它不含任何节点。 示例 4： img 12输入：adjList &#x3D; [[2],[1]]输出：[[2],[1]] 提示： 节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 图是连通图，你可以从给定节点访问到所有节点。 使用dfs+字典/哈希表 即可;重点需要学会的是C++map/unorder_map的使用count查询的操作,count返回0表示没有,1表示有; 递归+数组版本: 12345678910111213141516171819class Solution &#123;public: Node*used[101]; Node* cloneGraph(Node* node) &#123; //需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素; //也可以不用Map 用一个Node*数组来表示; if(!node)return node; if(used[node-&gt;val])return used[node-&gt;val]; Node*p=new Node(node-&gt;val);//创建拷贝结点; used[node-&gt;val]=p; vector&lt;Node*&gt;tp=node-&gt;neighbors; for(int i=0;i&lt;tp.size();++i)&#123; p-&gt;neighbors.push_back(cloneGraph(tp[i])); &#125; return p; &#125;&#125;; 递归+unorder_map版本; 123456789101112131415161718class Solution &#123;public: unordered_map&lt;Node*, Node*&gt;used; Node* cloneGraph(Node* node) &#123; //需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素; //也可以不用Map 用一个Node*数组来表示; if(!node)return node; if(used.count(node))return used[node]; Node*p=new Node(node-&gt;val);//创建拷贝结点; used[node]=p; vector&lt;Node*&gt;tp=node-&gt;neighbors; for(int i=0;i&lt;tp.size();++i)&#123; p-&gt;neighbors.push_back(cloneGraph(tp[i])); &#125; return p; &#125;&#125;; map版本用map替换unorder_map即可; 其中速度:map慢于unorder_map慢于数组; 原因:(摘自一个题解): map： 优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间 适用处：对于那些有顺序要求的问题，用map会更高效一些 unordered_map： 优点： 因为内部实现了哈希表，因此其查找速度非常的快缺点： 哈希表的建立比较耗费时间适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map 深度优先遍历的递归写法1.发现新节点1.如果没有操作该节点，就操作该节点，并将该节点的visit置11.1接着对该节点的neibor挨个遍历dfs函数2.如果有操作就返回该节点或者pass 非递归版本: 12345678910111213141516171819202122232425262728293031class Solution &#123;public: &#x2F;&#x2F;unordered_map&lt;Node*, Node*&gt;used; Node* cloneGraph(Node* node) &#123; if(!node)return node; stack&lt;Node*&gt;S; S.push(node);&#x2F;&#x2F;等同于 stack &lt;Node*&gt;S(&#123;node&#125;); unordered_map&lt;Node*, Node*&gt;used; used[node] &#x3D; new Node(node-&gt;val); Node* tmp; while(!S.empty())&#123; tmp &#x3D; S.top(); S.pop(); Node* r &#x3D; used[tmp]; vector&lt;Node*&gt;n&#x3D;tmp-&gt;neighbors; for(int i&#x3D;0;i&lt;n.size();++i)&#123; &#x2F;&#x2F;如果这个节点之前已经遍历到，就把他的复制加到链表中 &#x2F;&#x2F;没有遍历过就复刻该节点，加入map，加入neighbor Node*cur&#x3D;n[i]; if(!used.count(cur))&#123; Node*t&#x3D;new Node(cur-&gt;val); used[cur]&#x3D;t; S.push(cur); &#125; r-&gt;neighbors.push_back(used[cur]); &#125; &#125; return used[node]; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode131_m","date":"2020-09-07T01:10:18.000Z","path":"2020/09/07/leetcode131-m/","text":"98. 验证二叉搜索树难度中等471 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 &#x2F; \\ 1 3输出: true 示例 2: 123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 dfs 递归版本 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int flag; bool dfs(TreeNode* root,long long int lower,long long int higher)&#123; if(root==NULL)&#123; return true; &#125; long long int temp=root-&gt;val; if(temp&lt;=lower||temp&gt;=higher)&#123; return false; &#125; return dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); &#125; bool isValidBST(TreeNode* root) &#123; flag=1; return dfs(root,LONG_MIN,LONG_MAX); &#125; &#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode98_m","date":"2020-09-07T01:05:19.000Z","path":"2020/09/07/leetcode98-m/","text":"98. 验证二叉搜索树难度中等471 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 &#x2F; \\ 1 3输出: true 示例 2: 123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 dfs 递归版本 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int flag; bool dfs(TreeNode* root,long long int lower,long long int higher)&#123; if(root==NULL)&#123; return true; &#125; long long int temp=root-&gt;val; if(temp&lt;=lower||temp&gt;=higher)&#123; return false; &#125; return dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); &#125; bool isValidBST(TreeNode* root) &#123; flag=1; return dfs(root,LONG_MIN,LONG_MAX); &#125; &#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode51_h","date":"2020-09-07T01:00:57.000Z","path":"2020/09/07/leetcode51-h/","text":"51. N皇后难度困难377 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 img 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例: 12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, &#x2F;&#x2F; 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: //行列; 本质上还是回溯法 //逐个行来扫描,这一行确定了之后就删除一些状态 //三个需要验证的合法性: //列,两个对角线: //line,incline1,incline2 //按行遍历,如果这列ok 就line[i]=1 //0x0x //x1xx (1,1)(0,0)(2,2)(3,3) 发现abs(j-i)是相同的;因此j-i+N 相同(这样确保大于0)) //0x0x (1,1)(0,2)(3,0) 发现对角线上面i+j是相同的 //xxx0 //所以每次更新的时候都是line[i]=true,incline[i+j]=true,incline[j-i+N]=true; int N; vector&lt;vector&lt;string&gt;&gt;result;//用来保存; void place(int j,vector&lt;vector&lt;bool&gt;&gt;&amp;track,vector&lt;bool&gt;&amp;line,vector&lt;bool&gt;&amp;incline1,vector&lt;bool&gt;&amp;incline2)&#123; if(j==N)&#123; //递归结束 string a=\"\"; vector&lt;string&gt; b; for(int p=0;p&lt;N;p++)&#123; for(int k=0;k&lt;N;k++)&#123; if(track[p][k])&#123; a.push_back('Q'); &#125;else&#123; a.push_back('.'); &#125; &#125; b.push_back(a); a.clear(); &#125; result.push_back(b); return; &#125;else&#123; for(int i=0;i&lt;N;i++)&#123; if(!line[i]&amp;&amp;!incline1[i+j]&amp;&amp;!incline2[j-i+N])&#123; line[i]=true; incline1[i+j]=true; incline2[j-i+N]=true; track[j][i]=true; place(j+1,track,line,incline1,incline2); line[i]=false; incline1[i+j]=false; incline2[j-i+N]=false; track[j][i]=false; &#125; &#125; ; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;bool&gt;incline1(2*n,false); vector&lt;bool&gt;incline2(2*n,false); vector&lt;bool&gt;line(n,false); vector&lt;vector&lt;bool&gt;&gt; track(n,line); N=n; place(0,track,line,incline1,incline2); return result; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"回溯法","slug":"回溯法","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"leetcode46_m","date":"2020-09-07T00:59:34.000Z","path":"2020/09/07/leetcode46-m/","text":"46 PermutationsMedium 333697Add to ListShare Given a collection of distinct integers, return all possible permutations. Example: 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt;res; vector&lt;bool&gt; vis;//表示这个解遇到过了; void backtrace(const vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;track,int index)&#123; //index记录vis的编号; if(index==nums.size())&#123; res.push_back(track); return; &#125; for(int i=0;i&lt;nums.size();i++)&#123; if(vis[i])&#123; ; &#125;else&#123; //没有访问过; vis[i]=true; track.push_back(nums[i]); backtrace(nums,track,index+1); track.pop_back(); vis[i]=false; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; res.clear(); if(nums.size()==0)&#123; return res; &#125; vis = vector&lt;bool&gt;(nums.size(), false); vector&lt;int&gt; track; backtrace(nums,track,0); return res; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"回溯法","slug":"回溯法","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"leetcode124_h","date":"2020-09-07T00:58:16.000Z","path":"2020/09/07/leetcode124-h/","text":"124. 二叉树中的最大路径和难度困难510 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 1234567输入: [1,2,3] 1 &#x2F; \\ 2 3输出: 6 示例 2: 123456789输入: [-10,9,20,null,null,15,7] -10 &#x2F; \\ 9 20 &#x2F; \\ 15 7输出: 42 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ //用一个maxm来缓存对于某一个根节点的状态; //dfs过程中返回给上层应该是最大的一边;class Solution &#123;public: int maxm=INT_MIN; int dfs(TreeNode*root)&#123; if(root==nullptr)&#123; return 0; &#125; int left=max(0,dfs(root-&gt;left)); int right=max(0,dfs(root-&gt;right)); maxm=max(maxm,root-&gt;val+left+right); return max(left+root-&gt;val,right+root-&gt;val); &#125; int maxPathSum(TreeNode* root) &#123; // dfs(root); return maxm; &#125;&#125;; dfs解决该题,使用maxm缓存最大的结点处于的状态;dfs到某一个结点的时候,该节点返回给上一层:该节点值,该结点值+左值,该节点的值+右值的最大值; 对于空节点,返回0,表示对原来的结点没有贡献; 对于负值,和0比较取max的步骤表示如果有一边是负的那么就不做贡献,和空节点没有区别;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode690_s","date":"2020-09-07T00:56:33.000Z","path":"2020/09/07/leetcode690-s/","text":"690. 员工的重要性难度简单88 给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。 比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。 现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。 示例 1: 1234输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1输出: 11解释:员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 &#x3D; 11。 注意: 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。 通过次数13,683 提交次数23,456 重要的是先进行的hash操作,运用了unorder_map结构体,极大的简化了dfs的操作; 12345678910111213141516171819202122232425262728293031// Definition for Employee.class Employee &#123;public: int id; int importance; vector&lt;int&gt; subordinates;&#125;;class Solution &#123;public: unordered_map&lt;int,Employee*&gt;mp; int result=0; void dfs(int id)&#123; result+=mp[id]-&gt;importance; for(int i=0;i&lt;mp[id]-&gt;subordinates.size();++i)&#123; dfs(mp[id]-&gt;subordinates[i]); &#125; &#125; int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; //哈希: for(Employee* tmp:employees)&#123; mp[tmp-&gt;id]=tmp; &#125; //进行dfs; dfs(id); return result; &#125;&#125;; BFS版本: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*// Definition for Employee.class Employee &#123;public: int id; int importance; vector&lt;int&gt; subordinates;&#125;;*/// unordered_map&lt;int, Employee*&gt; mp;// int ans = 0;// public:// int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;// for (auto&amp; e : employees) // mp[e-&gt;id] = e;// dfs(id);// return ans;// &#125;// void dfs(int id) &#123;// ans += mp[id]-&gt;importance;// for (int i = 0; i &lt; mp[id]-&gt;subordinates.size(); ++i) // dfs(mp[id]-&gt;subordinates[i]);// &#125;class Solution &#123;public: unordered_map&lt;int,Employee*&gt;mp; int result=0; int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; //哈希: for(Employee* tmp:employees)&#123; mp[tmp-&gt;id]=tmp; &#125; //进行bfs queue&lt;int&gt; q; q.push(id); while(!q.empty())&#123; int temp=q.front(); q.pop(); result+=mp[temp]-&gt;importance; for(int i=0;i&lt;mp[temp]-&gt;subordinates.size();++i)&#123; q.push(mp[temp]-&gt;subordinates[i]); &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode199_m","date":"2020-09-07T00:53:29.000Z","path":"2020/09/07/leetcode199-m/","text":"199. 二叉树的右视图难度中等186 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例: 123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- &#x2F; \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 通过次数29,576 提交次数46,105 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; //bfs // 1 //2 3 // 5 4 //广度优先搜索，当q里面只有最右边一个元素的时候把这个元素加入到输出的队列里面; // if(root==nullptr)&#123;return NULL&#125;; vector&lt;int&gt;result; if(root==nullptr)&#123;return result;&#125;; queue&lt;TreeNode*&gt;q;//先进先出 q.push(root); while(!q.empty())&#123; // TreeNode*temp=q.front(); //关键点: 用len记录q的size;通过这个来获得最右侧的点; int len=q.size(); for(int i=0;i&lt;len;i++)&#123; TreeNode*temp=q.front(); if(i==len-1)&#123; result.push_back(temp-&gt;val); &#125; q.pop(); if(temp-&gt;left!=nullptr)&#123; q.push(temp-&gt;left); &#125; if(temp-&gt;right!=nullptr)&#123; q.push(temp-&gt;right); &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode101_s","date":"2020-09-07T00:51:12.000Z","path":"2020/09/07/leetcode101-s/","text":"101. 对称二叉树难度简单 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 &#x2F; \\2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 BFS的板子题 12345678910111213141516171819202122class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int size = q.size(); vector&lt;int&gt; v(size); for(int i = 0; i&lt;size; ++i)&#123; root = q.front(); q.pop(); v[i] = root ? root-&gt;val : INT_MIN; if(root) &#123; q.push(root-&gt;left); q.push(root-&gt;right); &#125; &#125; // 判断是否回文 for(int i = 0; i&lt; size/2; ++i)&#123; if(v[i] != v[size-1-i]) return false; &#125; &#125; return true; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode200_m","date":"2020-09-07T00:49:14.000Z","path":"2020/09/07/leetcode200-m/","text":"200. 岛屿数量难度中等515 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1: 123456输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。 解法1:BFS 遍历每一个点,遇到1就bfs并且把bfs到的1变成0;记录bfs的次数即可： 测试数据竟然有空集，这样会导致int maxn=map[0].size();//列数; 出现runtime error神必报错我tm…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; //感觉可以bfs //遍历map的每一个点,如果map[i][j]是1,进行bfs,遇到1的变成0; vector&lt;vector&lt;char&gt;&gt;map(grid); int cnt=0; //m*n; int maxm=map.size();//行数 if(maxm==0)&#123;return 0;&#125;//对付空集的神必特判 int maxn=map[0].size();//列数; for(int i=0;i&lt;maxm;i++)&#123; for(int j=0;j&lt;maxn;j++)&#123; if(map[i][j]=='1')&#123; cnt+=1; queue&lt;pair&lt;int,int&gt;&gt;q; pair&lt;int,int&gt;temp; temp.first=i; temp.second=j; q.push(temp); map[i][j]='0'; while(!q.empty())&#123; pair&lt;int,int&gt;cur=q.front(); q.pop(); int tempi=cur.first; int tempj=cur.second; if(tempi-1&gt;=0&amp;&amp;map[tempi-1][tempj]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi-1; temp2.second=tempj; q.push(temp2); map[tempi-1][tempj]='0'; &#125; if(tempi+1&lt;maxm&amp;&amp;map[tempi+1][tempj]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi+1; temp2.second=tempj; q.push(temp2); map[tempi+1][tempj]='0'; &#125; if(tempj-1&gt;=0&amp;&amp;map[tempi][tempj-1]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi; temp2.second=tempj-1; q.push(temp2); map[tempi][tempj-1]='0'; &#125; if(tempj+1&lt;maxn&amp;&amp;map[tempi][tempj+1]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi; temp2.second=tempj+1; q.push(temp2); map[tempi][tempj+1]='0'; &#125; ; &#125; ; &#125; &#125; &#125; return cnt; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode705_s","date":"2020-09-06T08:26:54.000Z","path":"2020/09/06/leetcode705-s/","text":"705. 设计哈希集合难度简单40 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: 123456789MyHashSet hashSet &#x3D; new MyHashSet();hashSet.add(1); hashSet.add(2); hashSet.contains(1); &#x2F;&#x2F; 返回 truehashSet.contains(3); &#x2F;&#x2F; 返回 false (未找到)hashSet.add(2); hashSet.contains(2); &#x2F;&#x2F; 返回 truehashSet.remove(2); hashSet.contains(2); &#x2F;&#x2F; 返回 false (已经被删除) 注意： 所有的值都在 [0, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 通过次数11,949 提交次数21,319 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class MyHashSet &#123;private: struct Node&#123; int val; Node* next; Node(int val):val(val),next(nullptr)&#123;&#125; &#125;;public: vector&lt;Node*&gt; arr; const int len=101; /** Initialize your data structure here. */ MyHashSet() &#123; arr=vector&lt;Node*&gt;(len,new Node(-1)); &#125; void add(int key) &#123; int addr=key%len; Node*temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)return; if(!(temp-&gt;next))&#123; Node*node=new Node(key); temp-&gt;next=node; return; &#125; temp = temp -&gt; next; &#125; &#125;else&#123; temp-&gt;val=key; return; &#125; &#125; void remove(int key) &#123;// int haval = key % len;// Node* temp = arr[haval];// if(temp -&gt; val != -1)&#123;// while(temp)&#123;// if(temp -&gt; val == key)&#123;// temp -&gt; val = -1;// return;// &#125;// temp = temp -&gt; next;// &#125;// &#125; int addr=key%len; Node*temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)&#123; temp-&gt;val=-1; return; &#125; temp=temp-&gt;next; &#125; &#125; &#125; /** Returns true if this set contains the specified element */ bool contains(int key) &#123; int addr=key%len; Node* temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)&#123; return true; &#125; temp=temp-&gt;next; &#125; return false; &#125;else&#123; return false; &#125; &#125;&#125;;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","permalink":"http://tyler-ytr.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"leetcode67_s","date":"2020-09-06T08:25:13.000Z","path":"2020/09/06/leetcode67-s/","text":"67. 二进制求和难度简单398 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;输出: &quot;10101&quot; 提示： 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 模拟题,用j来从后往前遍历; 一开始搞错的原因是因为忘记在result.push_back之后加上temp=0了,佛佛佛 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string addBinary(string a, string b) &#123; vector&lt;int&gt;result; int n=a.size(); int m=b.size(); int maxn=max(n,m); int out=0;//处理进位 int temp=0; for(int j=0;j&lt;maxn;++j)&#123; if(n-j&gt;0)&#123; temp+=(int)(a[n-j-1]-'0'); &#125; if(m-j&gt;0)&#123; temp+=(int)(b[m-j-1]-'0'); &#125; temp+=out; out=0; if(temp&gt;=2)&#123; temp-=2; out=1; &#125; result.push_back(temp); temp=0; &#125; if(out==1)&#123; result.push_back(1); &#125; string res; for(int i=result.size()-1;i&gt;=0;--i)&#123; if(result[i]==1)&#123; res=res+'1'; &#125;else&#123;res=res+'0';&#125; &#125; return res; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"leetcode14_s","date":"2020-09-06T07:58:44.000Z","path":"2020/09/06/leetcode14-s/","text":"14. 最长公共前缀难度简单1079 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 模拟题实锤,纵向比较,重点是要掌握string的substr方法; 12345678910111213141516171819202122232425262728class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int cnt=0; //纵向扫描; if(strs.size()==0)&#123; return \"\"; &#125; int length=strs[0].size(); if(length==0)&#123; return \"\"; &#125; for(int i=0;i&lt;length;++i)&#123; char c=strs[0][i]; for(int j=1;j&lt;strs.size();++j)&#123; if(strs[j][i]!=c||i==strs[j].size())&#123; return strs[0].substr(0,cnt); &#125; &#125; cnt+=1; &#125; if(cnt==0)&#123; return \"\"; &#125; return strs[0]; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"leetcode892_s","date":"2020-09-06T07:56:59.000Z","path":"2020/09/06/leetcode892-s/","text":"892. 三维形体的表面积难度简单90 在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： 12输入：[[2]]输出：10 示例 2： 12输入：[[1,2],[3,4]]输出：34 示例 3： 12输入：[[1,0],[0,2]]输出：16 示例 4： 12输入：[[1,1,1],[1,0,1],[1,1,1]]输出：32 示例 5： 12输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46 提示： 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 一道模拟题，题目意思很难懂 第一个示例的意思是 0,0这个位置有一个高度为2的立方体； 第二个示例的意思是 0,0 高度为1;0,1 高度为2………… 主要解法是找到一个求解表面积的公式 12345678910111213141516171819202122232425class Solution &#123;public: int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int N=grid.size(); int result=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;N;j++)&#123; if(grid[i][j]&gt;0)&#123; result+=2+4*grid[i][j]; &#125; if(i&gt;0)&#123; if(grid[i-1][j]&gt;0)&#123; result-=min(grid[i-1][j],grid[i][j])*2; &#125; &#125; if(j&gt;0)&#123;if(grid[i][j-1]&gt;0)&#123; result-=min(grid[i][j-1],grid[i][j])*2; &#125; &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"DNS刷新","date":"2020-09-04T06:56:33.000Z","path":"2020/09/04/DNS刷新/","text":"DNS刷新垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中心的工程师打完电话之后发现是自己电脑DNS的问题，因此bing搜索，发现了如下的方法进行DNS的刷新: 1234netsh int ip reset netsh winsock resetipconfig&#x2F;flushdns 重启 然后报错从dns probe finished no Internet变成了 image-20200904150200196 佛了 面对不知道咋整的东西，那就选择重装系列： 右击 image-20200904184552395 然后点击网络重置 好像就行了？！","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"关于windows密钥登录服务器","date":"2020-09-04T06:56:33.000Z","path":"2020/09/04/cmd_vs_rsa/","text":"关于windows密钥登录服务器前言:windows的权限管理太屑了 参考https://blog.csdn.net/joshua2011/article/details/90208741","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"wishlist_together","date":"2020-09-04T02:18:35.000Z","path":"2020/09/04/wishlist-together/","text":"2020 wishlist 一起去鬼屋 一起去迪士尼","tags":[{"name":"wishlist","slug":"wishlist","permalink":"http://tyler-ytr.github.io/tags/wishlist/"}]},{"title":"leetcode4_h","date":"2020-08-31T14:55:42.000Z","path":"2020/08/31/leetcode4-h/","text":"4. 寻找两个正序数组的中位数难度困难2695 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 &#x3D; [1, 3]nums2 &#x3D; [2]则中位数是 2.0 示例 2: 1234nums1 &#x3D; [1, 2]nums2 &#x3D; [3, 4]则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5 123456789101112131415161718192021222324252627282930class Solution: #二分法,对于arr1,arr2,k:令x=k//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小; #注意处理边界 def findkthelement(self,arr1:List[int],arr2:List[int],k)-&gt;float: len1=len(arr1) len2=len(arr2) if len1&gt;len2: return self.findkthelement(arr2,arr1,k) ##确保arr1是短的一边; if not arr1: #arr1为空,递归结束 return arr2[k-1] if k==1: #返回最小的元素 return min(arr1[0],arr2[0]) x=k//2 i=int(min(x,len1)-1) #arr1的边界;因为是数组所以要减一,代表有i+1个元素 j=int(min(x,len2)-1) if arr1[i]&lt;arr2[j]: return self.findkthelement(arr1[i+1:],arr2,k-i-1) else: return self.findkthelement(arr1,arr2[j+1:],k-j-1) def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: len1=len(nums1) len2=len(nums2) #考虑中位数的奇偶问题 mid1=(len1+len2+1)//2 mid2=(len1+len2+2)//2 return(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/2","tags":[{"name":"二分","slug":"二分","permalink":"http://tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"leetcode990_m","date":"2020-08-31T14:28:06.000Z","path":"2020/08/31/leetcode990-m/","text":"990. 等式方程的可满足性难度中等73 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&quot;a==b&quot; 或 &quot;a!=b&quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 123输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]输出：false解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 123输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]输入：true解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。 示例 3： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]输出：true 示例 4： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]输出：false 示例 5： 12输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]输出：true 提示： 1 &lt;= equations.length &lt;= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 &#39;=&#39;，要么是 &#39;!&#39; equations[i][2] 是 &#39;=&#39; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int p[26]; int find_set(int x)&#123; if(x!=p[x])&#123; p[x]=find_set(p[x]); &#125; return p[x]; &#125; bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; //图的连通性问题---并查集 for(int i =0;i&lt;26;i++)&#123; p[i]=i; &#125; for(int i=0;i&lt;equations.size();i++)&#123; //==就合并; if(equations[i][1]=='=')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1!=fx2)&#123; p[fx1]=p[fx2]; &#125; &#125; &#125; for(int i=0;i&lt;equations.size();i++)&#123; if(equations[i][1]=='!')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1==fx2)return false; &#125; &#125; return true; &#125;&#125;; 官方版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class UnionFind &#123;private: vector&lt;int&gt; parent;public: UnionFind() &#123; parent.resize(26); iota(parent.begin(), parent.end(), 0); &#125; int find(int index) &#123; if (index &#x3D;&#x3D; parent[index]) &#123; return index; &#125; parent[index] &#x3D; find(parent[index]); return parent[index]; &#125; void unite(int index1, int index2) &#123; parent[find(index1)] &#x3D; find(index2); &#125;&#125;;class Solution &#123;public: bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; UnionFind uf; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; uf.unite(index1, index2); &#125; &#125; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","tags":[{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"}]},{"title":"leetcode547_m","date":"2020-08-31T14:23:59.000Z","path":"2020/08/31/leetcode547-m/","text":"547. 朋友圈难度中等255 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2: 123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意： N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 通过次数47,496 提交次数83,180 并查集版本 改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前; 还有就是find函数的条件是$x==f[x]$ 别搞错了; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: struct dis_set&#123; int n; //int f[205]; vector&lt;int&gt;f; dis_set(int x)&#123; // this-&gt;n=205; //f.resize(this-&gt;n); //iota(f.begin(),f.end(),0); n=x; f.resize(x+1); for(int i=0;i&lt;this-&gt;n;i++)&#123; f[i]=i; &#125; &#125; int find(int x)&#123; if(x==f[x])&#123; return x; &#125; f[x]=find(f[x]); return f[x]; &#125; void unite(int a,int b)&#123; int roota=find(a); int rootb=find(b); if(roota==rootb)return ; this-&gt;n--; f[roota]=rootb; &#125; int count()&#123; return n; &#125; &#125;; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? if(M.size()==0) return 0; int n=M[0].size(); struct dis_set cur(n); for(int i=0;i&lt;M.size();++i)&#123; for(int j=0;j&lt;M[0].size();++j)&#123; if(M[i][j]==1)&#123; cur.unite(i,j); &#125; &#125; &#125; return cur.count(); &#125; &#125;; dfs版本: 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt;vis; void dfs(int id,vector&lt;vector&lt;int&gt;&gt;&amp;M)&#123; if(vis[id]==1)return; vis[id]=1; for(int i=0;i&lt;M[id].size();++i)&#123; if(M[id][i]==1)&#123; dfs(i,M); &#125; &#125; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; vis.resize(n); // iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数; for(int i=0;i&lt;n;i++)&#123; vis[i]=0; &#125; for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]==0)&#123; dfs(i,M); cnt++; &#125; &#125; return cnt; &#125; &#125;; bfs 版本的解法: 注意vis[j]=1那句,很重要; image-20200617203349985 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; //还可以用bfs做;同样用vis记录没有访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; queue&lt;int&gt;Q; vector&lt;int&gt;vis(n,0); for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]!=1)&#123; Q.push(i); while(!Q.empty())&#123; int top=Q.front(); Q.pop(); vis[top]=1; for(int j=0;j&lt;M[top].size();++j)&#123; if(M[top][j]==1&amp;&amp;vis[j]==0)&#123; Q.push(j); vis[j]=1;//这句很重要,如果没有这句会慢很多; &#125; &#125; &#125; cnt++; &#125; &#125; return cnt; &#125; &#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"}]},{"title":"leetcode94_m","date":"2020-08-31T14:11:42.000Z","path":"2020/08/31/leetcode94-m/","text":"94. 二叉树的中序遍历难度中等614 给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 &#x2F; 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 通过次数210,162 提交次数290,172 递归版本: 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void sol(TreeNode *root,vector&lt;int&gt;&amp;nums)&#123; if(root==NULL)&#123; return; &#125; sol(root-&gt;left,nums); nums.push_back(root-&gt;val); sol(root-&gt;right,nums); return ; ; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt;nums; sol(root,nums); return nums; &#125;&#125;; 迭代版本: 1234567891011121314151617181920212223242526272829vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; //迭代版本如下: stack&lt;TreeNode*&gt;S; vector&lt;int&gt;result; TreeNode*cur=root; while(cur!=NULL||!S.empty())&#123; while(cur!=NULL)&#123; S.push(cur); cur=cur-&gt;left; &#125; cur=S.top(); result.push_back(cur-&gt;val); S.pop(); cur=cur-&gt;right; /* # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。 # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。 # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。 */ &#125; return result;&#125; image-20200809090152414 以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……","tags":[{"name":"树","slug":"树","permalink":"http://tyler-ytr.github.io/tags/%E6%A0%91/"}]},{"title":"面试题51_h","date":"2020-08-31T14:10:23.000Z","path":"2020/08/31/面试题51-h/","text":"面试题51. 数组中的逆序对难度困难90 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 12输入: [7,5,6,4]输出: 5 限制： 10 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000 当然二重for循环暴力可以解决，但是会超时； 实际上是一道二分思想的归并排序题目 image-20200424130136282 对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: vector&lt;int &gt;temp; int mergesort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)&#123; return 0; &#125;; int tempresult=0; //int mid=(l+r)/2; int mid=l+((r-l)&gt;&gt;1);//防止l,r过大的时候溢出 //int mid=(l+r)&gt;&gt;1; 最快 tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+1,r); int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;=nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; tempresult+=mid-i+1;//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作 &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; return tempresult; &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; //居然是归并排序 if(nums.size()&lt;2)&#123; return 0; &#125; else&#123; int result=0; temp.resize((int)nums.size()+1, 0); result=mergesort(nums,0,(int)nums.size()-1); return result; &#125; &#125;&#125;;","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode912_m","date":"2020-08-31T13:27:52.000Z","path":"2020/08/31/leetcode912-m/","text":"912. 排序数组难度中等98 给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 12输入：nums &#x3D; [5,2,3,1]输出：[1,2,3,5] 示例 2： 12输入：nums &#x3D; [5,1,1,2,0,0]输出：[0,0,1,1,2,5] 排序算法复习题 归并排序 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; temp; void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)return;//左指针偶遇右指针 int mid=(l+r)&gt;&gt;1; mergeSort(nums,l,mid); mergeSort(nums,mid+1,r); // 现在l-mid mid+1-r是有序的 //考虑合并的情况 int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; temp.resize((int)nums.size(), 0); mergeSort(nums, 0, (int)nums.size() - 1); return nums; &#125;&#125;; 插入排序 12 快速排序 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: //快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick int partition(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int pivot=nums[r]; int i=l-1; for(int j=l;j&lt;=r-1;++j)&#123; if(nums[j]&lt;=pivot)&#123; i=i+1;//扩展比pivot小的边界; swap(nums[i],nums[j]); &#125; &#125; swap(nums[i+1],nums[r]); return i+1; &#125; int randomized_partiton(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int i = rand() % (r - l + 1) + l; cout&lt;&lt;i&lt;&lt;endl; swap(nums[r],nums[i]);//选择pivot然后存放到最右端; return partition(nums,l,r); &#125; void quicksort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&lt;r)&#123; int pos=randomized_partiton(nums,l,r); quicksort(nums,l,pos-1); quicksort(nums,pos+1,r); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; srand((unsigned)time(NULL)); quicksort(nums,0,(int)nums.size()-1); return nums; &#125;&#125;; 堆排序（不稳定排序） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: void maxheapify(vector&lt;int&gt;&amp;nums,int i,int len)&#123;//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1) for(;(i&lt;&lt;1)+1&lt;=len;)&#123; int lson=(i&lt;&lt;1)+1; int rson=(i&lt;&lt;1)+2; int largest; if(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123; largest=lson; &#125;else&#123; largest=i; &#125; if(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123; largest=rson; &#125; if(i!=largest)&#123; int temp=nums[i]; nums[i]=nums[largest]; nums[largest]=temp; i=largest; &#125;else&#123;break;&#125; &#125; &#125; void buildmaxheap(vector&lt;int&gt;&amp;nums,int len)&#123; for(int i=len/2;i&gt;=0;--i)&#123; maxheapify(nums,i,len); &#125; &#125; void heapsort(vector&lt;int&gt;&amp;nums)&#123; int len=(int)nums.size()-1; buildmaxheap(nums,len); for(int i=len;i&gt;=1;--i)&#123; int temp=nums[0]; nums[0]=nums[i]; nums[i]=temp; len-=1; maxheapify(nums,0,len); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; heapsort(nums); return nums; &#125;&#125;; //另外关于排序算法 线性时间但是有限制的有: 计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\\Theta(n+k)$ 基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort 桶排序:","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode50_m","date":"2020-08-31T13:26:51.000Z","path":"2020/08/31/leetcode50-m/","text":"50. Pow(x, n)难度中等365 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 通过次数85,540 提交次数241,065 123456789101112131415161718192021222324class Solution &#123;public:double fastPower(double base, long long power) &#123; double result = 1.0; while (power &gt; 0) &#123; if (power &amp; 1) &#123;//此处等价于if(power%2==1) result = result * base; &#125; power &gt;&gt;= 1;//此处等价于power=power/2 base = (base * base) ; &#125; return result;&#125; double myPow(double x, int n) &#123; long long temp=n; if(n&gt;0) return fastPower(x,temp); else&#123; return 1/fastPower(x,-temp); &#125; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode914_s","date":"2020-08-31T13:25:40.000Z","path":"2020/08/31/leetcode914-s/","text":"914. 卡牌分组难度简单100 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X &gt;= 2 时返回 true。 示例 1： 123输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2： 123输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。 示例 3： 123输入：[1]输出：false解释：没有满足要求的分组。 示例 4： 123输入：[1,1]输出：true解释：可行的分组是 [1,1] 示例 5： 123输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: const int maxn=10002; int cnt[10002];int GCD1(int num1,int num2)&#123;if(num1%num2==0)&#123;return num2;&#125;else&#123;int next1=num2; int next2=num1%num2;return GCD1(next1,next2);&#125;&#125; bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123; memset(cnt,0,sizeof(cnt)); for(int i=0;i&lt;deck.size();i++)&#123; cnt[deck[i]]+=1; &#125; int g=-1; for(int i=0;i&lt;maxn;i++)&#123; if(cnt[i]!=0)&#123; if(g==-1)&#123; g=cnt[i]; &#125;else&#123; g=GCD1(g,cnt[i]); &#125; &#125; &#125; if(g&gt;=2)return true; else return false; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode312_h","date":"2020-08-31T13:23:43.000Z","path":"2020/08/31/leetcode312-h/","text":"312. 戳气球难度困难318 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 1234输入: [3,1,5,8]输出: 167 解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167 这题需要考虑的有两点: 第一点是状态的寻找和转移 第二点是如何进行递推; image-20200620172037074 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; //dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量; //dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \\in [i+1,j-1] 这里k表示最后一次戳哪一个气球; //注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历; //另外还需要在左端和右端都添加虚假的气球; int n=nums.size(); vector&lt;int&gt;points(n+2,0); points[0]=1; points[n+1]=1; for(int i=0;i&lt;n;++i)&#123; points[i+1]=nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt; (n + 2, 0)); for(int i=n;i&gt;=0;--i)&#123; for(int j=i+1;j&lt;n+2;++j)&#123; int maxn=0; for(int k=i+1;k&lt;j;++k)&#123; maxn=max(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]); &#125; dp[i][j]=maxn; &#125; &#125; return dp[0][n+1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"HDU2513 切蛋糕","date":"2020-08-31T13:21:36.000Z","path":"2020/08/31/HDU2513/","text":"多校联合训练的常见问题回答（FAQ） Cake slicing\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583 Accepted Submission(s): 305 ** Problem DescriptionA rectangular cake with a grid of mn unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts For example, assume that the cake has a grid of 34 unit squares on its top, and there are three cherries on the top, as shown in the figure below. One allowable slicing is as follows. For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is In this case, the total length of the cutting edges is 3+2=5. Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges. InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks. OutputOutput an integer indicating the least total length of the cutting edges. Sample Input3 4 3 1 2 2 3 3 2 Sample OutputCase 1: 5 SourceECJTU 2008 Autumn Contest 【题意】 有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底) 我参考了网上的博客,思路如下: 这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于 image-20200620162927557 因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int MAXN=0x3f3f3f3f;int m[25][25];int dp[25][25][25][25];int y,x,sum;//y*x矩阵；sum个樱桃;int Dp(int i,int j,int k,int l)&#123;//以i,j为左上角,k,l为右下角 if(dp[i][j][k][l]!=-1)&#123; return dp[i][j][k][l]; &#125;//如果之前计算过了,直接返回; //统计区域里面的樱桃数量; int cherry=0; for(int a=i;a&lt;=k;++a)&#123; for(int b=j;b&lt;=l;++b)&#123; if(m[a][b]==1)&#123; cherry+=1; &#125; &#125; &#125; //如果樱桃数量==1,那么不需要切割,返回0; if(cherry==1)&#123; dp[i][j][k][l]=0; return 0; &#125; //如果是0,那么这是一个不应该取得解,返回INF; if(cherry==0)&#123; dp[i][j][k][l]=MAXN; return MAXN; &#125; //否则需要切割;横着切或者纵着切; int minn=MAXN; //横着切: for(int a=i;a&lt;k;++a)&#123; minn=min(minn,Dp(i,j,a,l)+Dp(a+1,j,k,l)+l-j+1); &#125; //纵着切割: for(int b=j;b&lt;l;++b)&#123; minn=min(minn,Dp(i,j,k,b)+Dp(i,b+1,k,l)+k-i+1); &#125; dp[i][j][k][l]=minn; return dp[i][j][k][l];&#125;void init()&#123; memset(dp,-1,sizeof(dp)); memset(m,0,sizeof(m));&#125;int main() &#123; int cnt=1; while(~scanf(\"%d%d%d\",&amp;y,&amp;x,&amp;sum))&#123; init(); for(int i=0;i&lt;sum;++i)&#123; int p,q; scanf(\"%d%d\",&amp;p,&amp;q); m[p][q]=1; &#125; Dp(1,1,y,x); printf(\"Case %d: %d\\n\",cnt,dp[1][1][y][x]); cnt+=1; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"面试题08_m","date":"2020-08-31T13:20:30.000Z","path":"2020/08/31/面试题08-m/","text":"面试题 08.11. 硬币难度中等82 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007) 示例1: 12345 输入: n &#x3D; 5 输出：2 解释: 有两种方式可以凑成总金额:5&#x3D;55&#x3D;1+1+1+1+1 示例2: 1234567 输入: n &#x3D; 10 输出：4 解释: 有四种方式可以凑成总金额:10&#x3D;1010&#x3D;5+510&#x3D;5+1+1+1+1+110&#x3D;1+1+1+1+1+1+1+1+1+1 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; //没有优化的版本: vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;temp(n+2,0); vector&lt;vector&lt;int&gt;&gt;dp(val.size(),temp); dp[0][0]=1; for(int i=0;i&lt;4;i++)&#123; dp[i][0]=1;//不管用几种硬币组成0元只有一种方法 &#125; for(int i=0;i&lt;n+1;i++)&#123; dp[0][i]=1;//只用一种硬币(1)当然只有一种方法 &#125; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;n+1;j++)&#123; if(j&gt;=val[i]) dp[i][j]=dp[i-1][j]% 1000000007+dp[i][j-val[i]]% 1000000007; else&#123; dp[i][j]=dp[i-1][j]% 1000000007; &#125; &#125; &#125; return dp[3][n]% 1000000007; &#125;&#125;; //上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维 1234567891011121314151617181920212223242526272829class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; // //降维到一维的版本: //dp[j]=dp[j]+dp[j-val[i]]; vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;dp(n+2,1); dp[0]=1; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(j&gt;=val[i]) dp[j]=dp[j]%1000000007+dp[j-val[i]]%1000000007; &#125; &#125; return dp[n]%1000000007; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode1014_m","date":"2020-08-31T13:19:15.000Z","path":"2020/08/31/leetcode1014-m/","text":"1014. 最佳观光组合难度中等124 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 123输入：[8,1,5,2,6]输出：11解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11 提示： 2 &lt;= A.length &lt;= 50000 1 &lt;= A[i] &lt;= 1000 通过次数17,154 提交次数32,791 主要注意优化的这种思路,真的挺妙的; 123456789101112131415161718192021class Solution &#123;public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; //A[i]+i+A[j]-j //原始解法: //对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2) //优化: //tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n) int tmp=A[0]+0; int maxn=INT_MIN; for(int i=1;i&lt;A.size();++i)&#123; maxn=max(tmp+A[i]-i,maxn); tmp=max(tmp,A[i]+i); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode837_m","date":"2020-08-31T13:18:28.000Z","path":"2020/08/31/leetcode837-m/","text":"837. 新21点难度中等190 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？ 示例 1**：** 123输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10输出：1.00000说明：爱丽丝得到一张卡，然后停止。 示例 2**：** 1234输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10输出：0.60000说明：爱丽丝得到一张卡，然后停止。在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。 示例 3**：** 12输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10输出：0.73278 提示： 0 &lt;= K &lt;= N &lt;= 10000 1 &lt;= W &lt;= 10000 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。 此问题的判断限制时间已经减少。 这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释; 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: double new21Game(int N, int K, int W) &#123; //dp[x]: 得到x分之后继续游戏,成功的概率; //dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W //初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1 //结果:dp[0] //优化:发现 dp[x]和dp[x-1]之间的关系: //Wdp[x-1]=dp[x]+...+dp[x+w-1] //Wdp[x]=dp[x+1].....dp[x+w] //W (dp[x]-dp[x-1])=-dp[x]+dp[x+w] //(W+1)dp[x]-dp[x+w]=Wdp[x-1] //dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k if(K==0)&#123; return 1.0; &#125; int maxn=max(N,K+W+1)+1; vector&lt;double&gt;dp(maxn,0); for(int i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123; dp[i]=1.0; &#125; for(int i=1;i&lt;=W;i++)&#123; dp[K-1]+=dp[i+K-1]; &#125; dp[K-1]/=W; //dp[K - 1] = 1.0 * min(N - K + 1, W) / W; //dp[K-1]=((W+1)*dp[K]-dp[K+W])/W; for(int i=K-2;i&gt;=0;i--)&#123; dp[i]=((W+1)*dp[i+1]-dp[i+W+1])/W; &#125; return dp[0]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode416_m","date":"2020-08-31T13:17:48.000Z","path":"2020/08/31/leetcode416-m/","text":"416. 分割等和子集难度中等218 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 01背包问题 具体解体思路见注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; //背包问题 //背包的容量是总和的一半 //dp[i][j] 表示取了前i个数剩余容积为j时候的最大值 //dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i]) int sum=0; int n=nums.size(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; if(sum%2!=0)&#123; return false; &#125; int V=sum/2; vector&lt;vector &lt;int&gt; &gt; dp(n,vector&lt;int&gt;(V+1,0)); //初始化: dp[0][0]=0; //只取0号数字的时候的初始化： for(int i=nums[0];i&lt;=V;i++)&#123;//注意越界问题 dp[0][i]=nums[0];//因为只能取一次nums[0]; &#125; //dp状态转移 for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;=V;j++)&#123; if(j-nums[i]&gt;=0) dp[i][j]=max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else&#123; dp[i][j]=dp[i-1][j]; &#125; &#125; &#125; if(dp[n-1][V]!=V)&#123; return false; &#125; return true; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode221_m","date":"2020-08-31T13:16:52.000Z","path":"2020/08/31/leetcode221-m/","text":"221. 最大正方形难度中等428 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 神必的dp 主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度; 状态转移方程比较难像: $dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$ 解释如下: image-20200531160513652 为了代码的美观减少一次特判,应该要在左边和上边多加一列: 0 0 0 ….. 0 matrix 0 … python代码如下： 1234567891011121314151617181920212223class Solution: #重点是神必的状态转移方程 def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) ==0: return 0 height=len(matrix) width=len(matrix[0]) dp=[[0 for i in range(width+1)] for j in range(height+1)] #dp初始化,并且在外面多套了一层; #dp[i,j]表示以i,j为右下角的矩形的最大宽度; # 0 0 0 0 .... # 0 matrix # 0 # 0 # ... #转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1 maxedge=0 for i in range(height): for j in range(width): if matrix[i][j]=='1': dp[i+1][j+1]=min(dp[i][j],dp[i+1][j],dp[i][j+1])+1 maxedge=max(maxedge,dp[i+1][j+1]) return maxedge*maxedge","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode213_m","date":"2020-08-31T13:16:12.000Z","path":"2020/08/31/leetcode213-m/","text":"213. 打家劫舍 II难度中等284 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回; if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; if(nums.size()&#x3D;&#x3D;1)&#123; return nums[0]; &#125; vector&lt;int&gt;dp1(nums.size(),0); vector&lt;int&gt;dp2(nums.size(),0); dp1[0]&#x3D;nums[0]; dp1[1]&#x3D;max(nums[0],nums[1]); if(nums.size()&#x3D;&#x3D;2)&#123; return dp1[1]; &#125; if(nums.size()&#x3D;&#x3D;3)&#123; return dp1[1]; &#125; for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123; dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]); &#125; int result1&#x3D;dp1[nums.size()-2]; dp2[1]&#x3D;nums[1]; dp2[2]&#x3D;max(nums[1],nums[2]); for(int i&#x3D;3;i&lt;nums.size();i++)&#123; dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]); &#125; int result2&#x3D;dp2[nums.size()-1]; return max(result1,result2); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode198_m","date":"2020-08-31T13:15:12.000Z","path":"2020/08/31/leetcode198-m/","text":"198. 打家劫舍难度简单875 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 原始版本: 12345678910111213141516171819202122232425262728class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; //dp[i]:第0间-第i间房子偷窃的最高金额; //dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; //初始化: //dp[0]=nums[0] //dp[1]=max(nums[0],nums[1]) if(nums.size()==0)&#123; return 0; &#125; int len=nums.size(); vector&lt;int&gt;dp(len,0); dp[0]=nums[0]; if(nums.size()==1)&#123; return dp[0]; &#125; dp[1]=max(nums[1],nums[0]); for(int i=2;i&lt;len;++i)&#123; dp[i]=max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; //滚动数组优化; &#125;&#125;; 滚动数组优化版本; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额; &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; &#x2F;&#x2F;初始化: &#x2F;&#x2F;dp[0]&#x3D;nums[0] &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1]) if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; int len&#x3D;nums.size(); int first&#x3D;nums[0]; if(nums.size()&#x3D;&#x3D;1)&#123; return first; &#x2F;&#x2F;return dp[0]; &#125; int sec&#x3D;max(nums[1],nums[0]); int result&#x3D;sec; for(int i&#x3D;2;i&lt;len;i++)&#123; result&#x3D;max(sec,first+nums[i]); first&#x3D;sec; sec&#x3D;result; &#125; return result; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode96_m","date":"2020-08-31T13:10:02.000Z","path":"2020/08/31/leetcode96-m/","text":"96. 不同的二叉搜索树难度中等537 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; //dp[i]:i个结点的时候二叉搜索树的个数 //空树只有一种情况:dp[0]=1 //dp[1]=1 //dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....) // vector&lt;int&gt;dp(n+1,0); dp[0]=1; dp[1]=1; if(n&lt;2)&#123; return dp[n]; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; dp[i]+=dp[j]*dp[i-j-1]; &#125; &#125; return dp[n]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode64_m","date":"2020-08-31T13:09:13.000Z","path":"2020/08/31/leetcode64-m/","text":"64. 最小路径和难度中等486 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 1234567891011121314151617181920212223242526class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //dp[i][j]:到i,j 的最小路径和; //dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; vector&lt;vector&lt;int&gt;&gt;dp(grid); int m=dp.size(); if(m==0)&#123;return 0;&#125;; int n=dp[0].size(); for(int i=1;i&lt;m;++i)&#123; dp[i][0]=dp[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;++i)&#123; dp[0][i]=dp[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode62_m","date":"2020-08-31T13:04:05.000Z","path":"2020/08/31/leetcode62-m/","text":"62. 不同路径难度中等560 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ img 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 1234567输入: m &#x3D; 3, n &#x3D; 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m &#x3D; 7, n &#x3D; 3输出: 28 1234567891011121314151617181920212223242526272829class Solution &#123;public: int uniquePaths(int m, int n) &#123; &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案 &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#x2F;&#x2F;dp[0][0]&#x3D;1; &#x2F;&#x2F;dp[0][1]&#x3D;1&#39; &#x2F;&#x2F;dp[1][0]&#x3D;1; if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125; vector&lt;int&gt;tmp(m,0); vector&lt;vector&lt;int&gt;&gt;dp(n,tmp); for(int i&#x3D;0;i&lt;m;i++)&#123; dp[0][i]&#x3D;1; &#125; for(int i&#x3D;0;i&lt;n;i++)&#123; dp[i][0]&#x3D;1; &#125; for(int i&#x3D;1;i&lt;n;i++)&#123; for(int j&#x3D;1;j&lt;m;j++)&#123; dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[n-1][m-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode53_s","date":"2020-08-31T13:03:25.000Z","path":"2020/08/31/leetcode53-s/","text":"53. 最大子序和难度简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 水题: dp[i]表示第i个之前的连续子数组的最大和 dp[i]=max(dp[i],dp[i-1]+dp[i]) 12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxnum; vector&lt;int&gt; dp(nums); maxnum=nums[0]; for(int i=1;i&lt;nums.size();i++)&#123; if(dp[i-1]&gt;0)&#123; dp[i]=dp[i-1]+dp[i]; &#125; maxnum=max(maxnum,dp[i]); &#125; return maxnum; &#125; &#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode32_h","date":"2020-08-31T13:01:40.000Z","path":"2020/08/31/leetcode32-h/","text":"32. 最长有效括号难度困难784 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 通过次数74,856 提交次数233,569 题解见注释:主要是要两两字符判断; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int longestValidParentheses(string s) &#123; //动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度; //对于...............(): //dp[i]=dp[i-2]+2; //对于...............)): //dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) //判断s[i-dp[i-1]-1],如果是(: //dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了; int n=s.length();; vector&lt;int&gt;dp(n+1,0); if(n==0 || n==1)&#123; return 0; &#125; int maxn=0; for(int i=1;i&lt;n;++i)&#123; if(s[i]==')')&#123; if(s[i-1]=='(')&#123; if(i&gt;=2)&#123; dp[i]=dp[i-2]+2; &#125;else&#123; dp[i]=2; &#125; &#125;else&#123; if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]=='(')&#123; if(i-dp[i-1]-2&gt;=0) dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]; else&#123; dp[i]=dp[i-1]+2; &#125; &#125; &#125; &#125; maxn=max(maxn,dp[i]); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode5_m","date":"2020-08-31T13:00:48.000Z","path":"2020/08/31/leetcode5-m/","text":"5. 最长回文子串难度中等 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 这题目可以使用动态规划 我觉得很棒的一个题解 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int len=s.length(); if(len&lt;=1) return s; vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len)); for(int i=0;i&lt;len;i++)&#123; dp[i][i]=1; &#125; int start=0; int maxl=1; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(s[i]==s[j])&#123; if(i-j&lt;=2)&#123; dp[j][i]=1; &#125;else&#123; dp[j][i]=dp[j+1][i-1]; &#125; &#125; if(dp[j][i]==1)&#123; int temp=i-j+1; if(temp&gt;maxl)&#123; maxl=temp; start=j; &#125; &#125; &#125; &#125; return s.substr(start,maxl); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"HDU_1284","date":"2020-08-31T12:58:32.000Z","path":"2020/08/31/HDU-1284/","text":"钱币兑换问题\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 15976 Accepted Submission(s): 9546** Problem Description 在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。 Input 每行只有一个正整数N，N小于32768。 Output 对应每个输入，输出兑换方法数。 Sample Input 12293412553 Sample Output 1271883113137761 Author SmallBeer(CML) Source 杭电ACM集训队训练赛（VII） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;//相当于3件物品，容量为N的背包，第i件物品的重量是i//初始化: dp[0][0]=1//dp[i][j]表示用前i件物品组成j的方案数量//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;//滚动数组优化：//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;using namespace std;int temp;const int maxn=33000;//32468long long int dp[maxn];int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; memset(dp,0,sizeof(dp)); dp[0]=1; for(int i=1;i&lt;=3;i++)&#123; for(int j=i;j&lt;maxn;j++)&#123; dp[j]+=dp[j-i]; // printf(\"%lld\\n\",dp[j]); // dp[j]+=max(dp[j],dp[j-i]); &#125; &#125;// printf(\"here\");//// scanf(\"%d\",&amp;temp);// printf(\"%lld\",dp[temp]); while(scanf(\"%d\",&amp;temp)==1)&#123; printf(\"%I64d\\n\",dp[temp]); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode19_m","date":"2020-08-31T03:12:38.000Z","path":"2020/08/31/leetcode19-m/","text":"19. 删除链表的倒数第N个节点难度中等947收藏分享切换为英文关注反馈 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗 快慢指针的想法来实现: 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* l; ListNode*r; l=head; r=head; ListNode* temp; int cnt=0; for(cnt=0;cnt&lt;n;cnt++)&#123; r=r-&gt;next; &#125; if(r==nullptr)&#123; return head-&gt;next; &#125; //cout&lt;&lt;r-&gt;val&lt;&lt;endl; while(r-&gt;next!=nullptr)&#123; r=r-&gt;next; l=l-&gt;next; &#125; // cout&lt;&lt;l-&gt;val&lt;&lt;endl; l-&gt;next=l-&gt;next-&gt;next; return head; &#125;&#125;;","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode16_m","date":"2020-08-31T03:11:14.000Z","path":"2020/08/31/leetcode16-m/","text":"16. 最接近的三数之和难度中等530 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 123输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。 提示： 3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4 通过次数141,122 提交次数308,415 和leetcode15相似,主要思路还是排序+双指针 我使用了minA维护了当前的最小值,然后使用res记录和; 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: #排序: -4 -1 1 2 #minA 对于遍历到的每一个i,维护minA; #每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回; n=len(nums) if n&lt;3 or not nums: return NULL minA=sys.maxsize # INT最大值 res=minA nums.sort() for i in range(0,n-2): L=i+1 R=n-1 while L&lt;R: cur=nums[i]+nums[L]+nums[R] if cur==target: minA=0 return cur elif cur&lt;target: tempres=target-cur if abs(tempres)&lt;minA: minA=abs(tempres) res=cur L=L+1 else: tempres=cur-target if abs(tempres)&lt;minA: minA=abs(tempres) res=cur R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode15_m","date":"2020-08-31T03:06:50.000Z","path":"2020/08/31/leetcode15-m/","text":"15. 三数之和难度中等2455 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 通过次数293,697 提交次数1,016,765 还是看了题解,排序太香了！ 主要操作是排序使用双指针进行检查;同时记得去重; 12345678910111213141516171819202122232425262728293031323334class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if n&lt;3 or not nums: return res nums.sort() #从i遍历到n-2,使用双指针维护和探查; #记得去重,也就是对于相同的找最后的; for i in range(0,n): if nums[i]&gt;0: return res if i&gt;0 and nums[i]==nums[i-1]: continue #去重 L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while L&lt; R and nums[R]==nums[R-1]: R=R-1 L=L+1 R=R-1 elif nums[i]+nums[L]+nums[R]&lt;0: L=L+1 else: R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"Winter plan","date":"2020-01-22T09:17:23.000Z","path":"2020/01/22/winter-learning-plan/","text":"需要完成的目标: 线性代数复习 学习cs224n 刷leetcode 算法竞赛入门经典 目前进度: 线性代数: 1.22 cs224n 1.22 leetcode 1.22 算法竞赛入门经典","tags":[{"name":"flag","slug":"flag","permalink":"http://tyler-ytr.github.io/tags/flag/"}]},{"title":"ubuntu教程","date":"2020-01-22T08:28:15.000Z","path":"2020/01/22/ubuntu-back/","text":"反思 之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了; 重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜 复活操作基本配置 管理员权限,换源,安装vim sudo passwd(修改sudo密码) sudo apt-get update sudo apt-get install vim 更换国内源,这里我选择的是清华源用下面的命令打开文件,并且注释里面的所有内容, sudo vim /etc/apt/sources.list 然后粘贴下面的内容到打开的文件里面# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse 如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下; 安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇博客 然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义su apt-get install build-essential apt-get install man # on-line reference manual apt-get install gcc-doc # manual for GCC apt-get install gdb # GNU debugger apt-get install git # reversion control system apt-get install libreadline-dev # a library to use compile the project later apt-get install libsdl2-dev # a library to use compile the project later apt-get install qemu-system-x86 # QEMU 安装chrome:请使用bing搜索;用gmail同步很香; 科学的看世界 我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json 将下面的内容根据自己的配置放进去: { \"server\":\"my_server_ip\", \"server_port\":53450, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"密码\", \"timeout\":300, \"method\":\"aes-256-gcm\", \"fast_open\": false } 然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;自己测试一下有没有问题; 感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)： 先写一个自启动脚本： touch ~/.ssstart.sh vim ~/.ssstart.sh 内容是: #!/bin/bash ss-local -c ~/shadowsocks/shadowsocks.json 然后在终端里面起别名:vim ~/.bashrc 在末尾添加: alias ss='. ~/.ssstart.sh' :wq 保存,退出 在终端里面: source ~/.bashrc (如果是zsh:source ~/.zshrc) 尝试一下在终端输入ss,它lei了; 因为后面的netdata需要终端翻墙,我也就尝试了一下,如果没有需求可以跳过这一步: 主要参考的是谷歌出来的网站 首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装 下面尝试全局代理(我也不确定能不能成功)： sudo pip install genpac 选择安装配置文件的目录,我选择的是:/home/larryytr/shadowsocks 然后执行以下命令:sudo genpac --proxy=\"SOCKS5 127.0.0.1:1080\" --gfwlist-proxy=\"SOCKS5 127.0.0.1:1080\" -o autoproxy.pac --gfwlist-url=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\" 下面是一句搬运,我没有遇到过:注意：如果报错“fetch gfwlist fail.online: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt local:None”，可以使用后面的语句：sudo genpac --proxy=\"SOCKS5 127.0.0.1:1080\" -o autoproxy.pac --gfwlist-url=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\" &lt;/code&gt; 执行完之后,目录下面会有一个autoproxy.pac文件。 然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写： file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改) 然后使得终端也能使用代理。我们需要privoxy代理工具: 安装很自然:sudo apt-get install privoxy 然后编辑配置文件sudo vim /etc/privoxy/config &lt;/code&gt; 在文档中搜索(vim 使用/搜索)“listen-address”（即监听地址），找到如下一行：listen-address localhost:8118 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“forward-socks5t”，找到如下一行：forward-socks5t / 127.0.0.1:1080 . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy： 1sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config 最后，再配置/etc/profile： # 先进入编辑模式 sudo vim /etc/profile # 在末尾添加以下三行： export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118export ftp_proxy=http://127.0.0.1:8118 # 退出之后记得执行 source /etc/profile &lt;/code&gt;&lt;/pre&gt; 验证是否成功:curl www.google.com或wget www.google.com判断是否可以访问 HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！ 优化美化 官网安装网易云 官网安装vscode 配置zsh,tmux,vim: zsh安装与美化 学习了:https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/https://segmentfault.com/a/1190000013612471这两篇教程; 感谢何伟的配置文件; 相应的setting请参考我的github相关内容. 安装zsh:sudo apt-get update sudo apt-get install zsh chsh -s /bin/zsh (设置zsh为默认) 重启你的ubuntu 安装oh-my-zsh插件: wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 不改theme一无所有 准备使用powerline主题 首先安装powerline字体： git clone https://github.com/powerline/fonts.git --depth=1 # install cd fonts ./install.sh # clean-up a bit cd .. rm -rf fonts 安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久) 安装powerline: sudo apt install powerline 我的配置见相关内容的setting .zshrc 颜色选择困难请: for code ({000..255}) print -P -- \"$code: %F{$code}This is how your text would look like%f\" 改完请source ~/.zshrc tmux tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程; 我使用了何伟的配置,具体见相关内容的setting 我又加了一个插件使得tmux在重启之后状态可以恢复: 主要参考这个知乎教程 git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp 在~/.tmux.conf.local里面加上:run-shell ~/tmux_tmp/resurrect.tmux 最后载入这个配置：tmux source-file ~/.tmux.conf vim的美化 使用啦懒人vim: spf13-vim美化 请看相关内容的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh 我的配置同样在相关内容的setting里面; 这个时候的vim没有办法和系统剪切版交互,我根据https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html 下载了其他一些插件:sudo apt-get install vim-scripts vim-gtk vim-gnome&lt;/code&gt;这样 vim —version|grep “cliboard” 会看到 +clipboard;然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！ 其他内容: OSlab还需要: sudo apt-get install curl sudo apt-get install gcc-multilib git 配置请搜索廖雪峰 ctags 可以参考Mengzelev的博客 感谢xnr给我推荐的network来查看linux的运行情况 这是netdata的官方网站:https://github.com/netdata/netdata#user-base 但是由于GFW,安装会出现报错,事实上需要终端翻墙才行 可以通过这篇教程 sudo apt-get install net-tools ifconfig 查看inet 之后的内容来得知自己的server_ip 成功之后,进入 http://127.0.0.1:19999/ (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验 相应配置可以参考这篇博客或者自己搜索 OSlab的kvm bug处理方法：https://bugzilla.redhat.com/show_bug.cgi?id=1479558chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content: KERNEL==\"kvm\", GROUP=\"kvm\", MODE=\"0666\" texlive 安装sudo apt install texlive-full 相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting) vscode的保存即编译请Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾； ubuntu的截图:我参考了这篇博客 打开右上角的设置—&gt;设备—&gt;键盘—&gt;快捷键,点击+ 显然的配置好按键,然后在命令里面写gnome-screenshot -a hint:上面的命令终端输入也有效截屏的图在文件夹的图片(picture)里面; ubuntu jupyter lab配置在服务器上面配置了jupyter lab; 主要借鉴了:https://cloud.tencent.com/developer/article/1769288?from=information.detail.jupyter%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8 安装anaconda 使用python生成密钥; 12345678In [1]: from notebook.auth import passwd In [2]: passwd() Enter password: Verify password: Out[2]: &#39;sha1:salt:hashed-password&#39;#这里输出的东西就是密钥，复制好之后填In [3]: exit() 生成配置文件: 1jupyter notebook --generate-config 修改它: 1vi ~/.jupyter/jupyter_notebook_config.py 在末尾加上: 1234567c.NotebookApp.allow_remote_access &#x3D; True # 允许外部访问c.NotebookApp.ip&#x3D;&#39;*&#39; # 设置所有ip皆可访问c.NotebookApp.password &#x3D; u&#39;sha1:salt:hashed-password&#39; # 使用刚才生成的密钥c.NotebookApp.open_browser &#x3D; False # 禁止自动打开浏览器c.NotebookApp.port &#x3D; 2021 # 任意指定一个不冲突的端口，c.NotebookApp.notebook_dir &#x3D; &#39;&#x2F;home&#x2F;ubuntu&#x2F;JupyterProject&#x2F;&#39; #默认文件路径,这里用户名要改成自己的c.NotebookApp.allow_root &#x3D; True # 允许root身份运行jupyter notebook 记得在安全组里面打开这个 在服务器端输入jupyter notebook, 然后本地浏览器输入 服务器地址:2021就行啦(比如 122.52.187.69:2021)(这个服务器是随意打的) To be continued 有空再研究怎么换主题;","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hello World","date":"2020-01-20T19:20:25.723Z","path":"2020/01/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]