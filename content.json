[{"title":"leetcode4_h","date":"2020-08-31T14:55:42.000Z","path":"2020/08/31/leetcode4-h/","text":"4. 寻找两个正序数组的中位数难度困难2695 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 &#x3D; [1, 3]nums2 &#x3D; [2]则中位数是 2.0 示例 2: 1234nums1 &#x3D; [1, 2]nums2 &#x3D; [3, 4]则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5 123456789101112131415161718192021222324252627282930class Solution: #二分法,对于arr1,arr2,k:令x=k//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小; #注意处理边界 def findkthelement(self,arr1:List[int],arr2:List[int],k)-&gt;float: len1=len(arr1) len2=len(arr2) if len1&gt;len2: return self.findkthelement(arr2,arr1,k) ##确保arr1是短的一边; if not arr1: #arr1为空,递归结束 return arr2[k-1] if k==1: #返回最小的元素 return min(arr1[0],arr2[0]) x=k//2 i=int(min(x,len1)-1) #arr1的边界;因为是数组所以要减一,代表有i+1个元素 j=int(min(x,len2)-1) if arr1[i]&lt;arr2[j]: return self.findkthelement(arr1[i+1:],arr2,k-i-1) else: return self.findkthelement(arr1,arr2[j+1:],k-j-1) def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: len1=len(nums1) len2=len(nums2) #考虑中位数的奇偶问题 mid1=(len1+len2+1)//2 mid2=(len1+len2+2)//2 return(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/2","tags":[{"name":"二分","slug":"二分","permalink":"http://tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"leetcode990_m","date":"2020-08-31T14:28:06.000Z","path":"2020/08/31/leetcode990-m/","text":"990. 等式方程的可满足性难度中等73 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&quot;a==b&quot; 或 &quot;a!=b&quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 123输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]输出：false解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 123输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]输入：true解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。 示例 3： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]输出：true 示例 4： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]输出：false 示例 5： 12输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]输出：true 提示： 1 &lt;= equations.length &lt;= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 &#39;=&#39;，要么是 &#39;!&#39; equations[i][2] 是 &#39;=&#39; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int p[26]; int find_set(int x)&#123; if(x!=p[x])&#123; p[x]=find_set(p[x]); &#125; return p[x]; &#125; bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; //图的连通性问题---并查集 for(int i =0;i&lt;26;i++)&#123; p[i]=i; &#125; for(int i=0;i&lt;equations.size();i++)&#123; //==就合并; if(equations[i][1]=='=')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1!=fx2)&#123; p[fx1]=p[fx2]; &#125; &#125; &#125; for(int i=0;i&lt;equations.size();i++)&#123; if(equations[i][1]=='!')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1==fx2)return false; &#125; &#125; return true; &#125;&#125;; 官方版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class UnionFind &#123;private: vector&lt;int&gt; parent;public: UnionFind() &#123; parent.resize(26); iota(parent.begin(), parent.end(), 0); &#125; int find(int index) &#123; if (index &#x3D;&#x3D; parent[index]) &#123; return index; &#125; parent[index] &#x3D; find(parent[index]); return parent[index]; &#125; void unite(int index1, int index2) &#123; parent[find(index1)] &#x3D; find(index2); &#125;&#125;;class Solution &#123;public: bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; UnionFind uf; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; uf.unite(index1, index2); &#125; &#125; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","tags":[{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"}]},{"title":"leetcode547_m","date":"2020-08-31T14:23:59.000Z","path":"2020/08/31/leetcode547-m/","text":"547. 朋友圈难度中等255 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2: 123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意： N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 通过次数47,496 提交次数83,180 并查集版本 改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前; 还有就是find函数的条件是$x==f[x]$ 别搞错了; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: struct dis_set&#123; int n; //int f[205]; vector&lt;int&gt;f; dis_set(int x)&#123; // this-&gt;n=205; //f.resize(this-&gt;n); //iota(f.begin(),f.end(),0); n=x; f.resize(x+1); for(int i=0;i&lt;this-&gt;n;i++)&#123; f[i]=i; &#125; &#125; int find(int x)&#123; if(x==f[x])&#123; return x; &#125; f[x]=find(f[x]); return f[x]; &#125; void unite(int a,int b)&#123; int roota=find(a); int rootb=find(b); if(roota==rootb)return ; this-&gt;n--; f[roota]=rootb; &#125; int count()&#123; return n; &#125; &#125;; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? if(M.size()==0) return 0; int n=M[0].size(); struct dis_set cur(n); for(int i=0;i&lt;M.size();++i)&#123; for(int j=0;j&lt;M[0].size();++j)&#123; if(M[i][j]==1)&#123; cur.unite(i,j); &#125; &#125; &#125; return cur.count(); &#125; &#125;; dfs版本: 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt;vis; void dfs(int id,vector&lt;vector&lt;int&gt;&gt;&amp;M)&#123; if(vis[id]==1)return; vis[id]=1; for(int i=0;i&lt;M[id].size();++i)&#123; if(M[id][i]==1)&#123; dfs(i,M); &#125; &#125; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; vis.resize(n); // iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数; for(int i=0;i&lt;n;i++)&#123; vis[i]=0; &#125; for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]==0)&#123; dfs(i,M); cnt++; &#125; &#125; return cnt; &#125; &#125;; bfs 版本的解法: 注意vis[j]=1那句,很重要; image-20200617203349985 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; //还可以用bfs做;同样用vis记录没有访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; queue&lt;int&gt;Q; vector&lt;int&gt;vis(n,0); for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]!=1)&#123; Q.push(i); while(!Q.empty())&#123; int top=Q.front(); Q.pop(); vis[top]=1; for(int j=0;j&lt;M[top].size();++j)&#123; if(M[top][j]==1&amp;&amp;vis[j]==0)&#123; Q.push(j); vis[j]=1;//这句很重要,如果没有这句会慢很多; &#125; &#125; &#125; cnt++; &#125; &#125; return cnt; &#125; &#125;;","tags":[{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"}]},{"title":"leetcode94_m","date":"2020-08-31T14:11:42.000Z","path":"2020/08/31/leetcode94-m/","text":"94. 二叉树的中序遍历难度中等614 给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 &#x2F; 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 通过次数210,162 提交次数290,172 递归版本: 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void sol(TreeNode *root,vector&lt;int&gt;&amp;nums)&#123; if(root==NULL)&#123; return; &#125; sol(root-&gt;left,nums); nums.push_back(root-&gt;val); sol(root-&gt;right,nums); return ; ; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt;nums; sol(root,nums); return nums; &#125;&#125;; 迭代版本: 1234567891011121314151617181920212223242526272829vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; //迭代版本如下: stack&lt;TreeNode*&gt;S; vector&lt;int&gt;result; TreeNode*cur=root; while(cur!=NULL||!S.empty())&#123; while(cur!=NULL)&#123; S.push(cur); cur=cur-&gt;left; &#125; cur=S.top(); result.push_back(cur-&gt;val); S.pop(); cur=cur-&gt;right; /* # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。 # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。 # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。 */ &#125; return result;&#125; image-20200809090152414 以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……","tags":[{"name":"树","slug":"树","permalink":"http://tyler-ytr.github.io/tags/%E6%A0%91/"}]},{"title":"面试题51_h","date":"2020-08-31T14:10:23.000Z","path":"2020/08/31/面试题51-h/","text":"面试题51. 数组中的逆序对难度困难90 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 12输入: [7,5,6,4]输出: 5 限制： 10 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000 当然二重for循环暴力可以解决，但是会超时； 实际上是一道二分思想的归并排序题目 image-20200424130136282 对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: vector&lt;int &gt;temp; int mergesort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)&#123; return 0; &#125;; int tempresult=0; //int mid=(l+r)/2; int mid=l+((r-l)&gt;&gt;1);//防止l,r过大的时候溢出 //int mid=(l+r)&gt;&gt;1; 最快 tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+1,r); int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;=nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; tempresult+=mid-i+1;//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作 &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; return tempresult; &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; //居然是归并排序 if(nums.size()&lt;2)&#123; return 0; &#125; else&#123; int result=0; temp.resize((int)nums.size()+1, 0); result=mergesort(nums,0,(int)nums.size()-1); return result; &#125; &#125;&#125;;","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode912_m","date":"2020-08-31T13:27:52.000Z","path":"2020/08/31/leetcode912-m/","text":"912. 排序数组难度中等98 给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 12输入：nums &#x3D; [5,2,3,1]输出：[1,2,3,5] 示例 2： 12输入：nums &#x3D; [5,1,1,2,0,0]输出：[0,0,1,1,2,5] 排序算法复习题 归并排序 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; temp; void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)return;//左指针偶遇右指针 int mid=(l+r)&gt;&gt;1; mergeSort(nums,l,mid); mergeSort(nums,mid+1,r); // 现在l-mid mid+1-r是有序的 //考虑合并的情况 int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; temp.resize((int)nums.size(), 0); mergeSort(nums, 0, (int)nums.size() - 1); return nums; &#125;&#125;; 插入排序 12 快速排序 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: //快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick int partition(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int pivot=nums[r]; int i=l-1; for(int j=l;j&lt;=r-1;++j)&#123; if(nums[j]&lt;=pivot)&#123; i=i+1;//扩展比pivot小的边界; swap(nums[i],nums[j]); &#125; &#125; swap(nums[i+1],nums[r]); return i+1; &#125; int randomized_partiton(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int i = rand() % (r - l + 1) + l; cout&lt;&lt;i&lt;&lt;endl; swap(nums[r],nums[i]);//选择pivot然后存放到最右端; return partition(nums,l,r); &#125; void quicksort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&lt;r)&#123; int pos=randomized_partiton(nums,l,r); quicksort(nums,l,pos-1); quicksort(nums,pos+1,r); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; srand((unsigned)time(NULL)); quicksort(nums,0,(int)nums.size()-1); return nums; &#125;&#125;; 堆排序（不稳定排序） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: void maxheapify(vector&lt;int&gt;&amp;nums,int i,int len)&#123;//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1) for(;(i&lt;&lt;1)+1&lt;=len;)&#123; int lson=(i&lt;&lt;1)+1; int rson=(i&lt;&lt;1)+2; int largest; if(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123; largest=lson; &#125;else&#123; largest=i; &#125; if(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123; largest=rson; &#125; if(i!=largest)&#123; int temp=nums[i]; nums[i]=nums[largest]; nums[largest]=temp; i=largest; &#125;else&#123;break;&#125; &#125; &#125; void buildmaxheap(vector&lt;int&gt;&amp;nums,int len)&#123; for(int i=len/2;i&gt;=0;--i)&#123; maxheapify(nums,i,len); &#125; &#125; void heapsort(vector&lt;int&gt;&amp;nums)&#123; int len=(int)nums.size()-1; buildmaxheap(nums,len); for(int i=len;i&gt;=1;--i)&#123; int temp=nums[0]; nums[0]=nums[i]; nums[i]=temp; len-=1; maxheapify(nums,0,len); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; heapsort(nums); return nums; &#125;&#125;; //另外关于排序算法 线性时间但是有限制的有: 计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\\Theta(n+k)$ 基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort 桶排序:","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode50_m","date":"2020-08-31T13:26:51.000Z","path":"2020/08/31/leetcode50-m/","text":"50. Pow(x, n)难度中等365 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 通过次数85,540 提交次数241,065 123456789101112131415161718192021222324class Solution &#123;public:double fastPower(double base, long long power) &#123; double result = 1.0; while (power &gt; 0) &#123; if (power &amp; 1) &#123;//此处等价于if(power%2==1) result = result * base; &#125; power &gt;&gt;= 1;//此处等价于power=power/2 base = (base * base) ; &#125; return result;&#125; double myPow(double x, int n) &#123; long long temp=n; if(n&gt;0) return fastPower(x,temp); else&#123; return 1/fastPower(x,-temp); &#125; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode914_s","date":"2020-08-31T13:25:40.000Z","path":"2020/08/31/leetcode914-s/","text":"914. 卡牌分组难度简单100 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X &gt;= 2 时返回 true。 示例 1： 123输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2： 123输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。 示例 3： 123输入：[1]输出：false解释：没有满足要求的分组。 示例 4： 123输入：[1,1]输出：true解释：可行的分组是 [1,1] 示例 5： 123输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: const int maxn=10002; int cnt[10002];int GCD1(int num1,int num2)&#123;if(num1%num2==0)&#123;return num2;&#125;else&#123;int next1=num2; int next2=num1%num2;return GCD1(next1,next2);&#125;&#125; bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123; memset(cnt,0,sizeof(cnt)); for(int i=0;i&lt;deck.size();i++)&#123; cnt[deck[i]]+=1; &#125; int g=-1; for(int i=0;i&lt;maxn;i++)&#123; if(cnt[i]!=0)&#123; if(g==-1)&#123; g=cnt[i]; &#125;else&#123; g=GCD1(g,cnt[i]); &#125; &#125; &#125; if(g&gt;=2)return true; else return false; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode312_h","date":"2020-08-31T13:23:43.000Z","path":"2020/08/31/leetcode312-h/","text":"312. 戳气球难度困难318 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 1234输入: [3,1,5,8]输出: 167 解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167 这题需要考虑的有两点: 第一点是状态的寻找和转移 第二点是如何进行递推; image-20200620172037074 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; //dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量; //dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \\in [i+1,j-1] 这里k表示最后一次戳哪一个气球; //注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历; //另外还需要在左端和右端都添加虚假的气球; int n=nums.size(); vector&lt;int&gt;points(n+2,0); points[0]=1; points[n+1]=1; for(int i=0;i&lt;n;++i)&#123; points[i+1]=nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt; (n + 2, 0)); for(int i=n;i&gt;=0;--i)&#123; for(int j=i+1;j&lt;n+2;++j)&#123; int maxn=0; for(int k=i+1;k&lt;j;++k)&#123; maxn=max(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]); &#125; dp[i][j]=maxn; &#125; &#125; return dp[0][n+1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"HDU2513","date":"2020-08-31T13:21:36.000Z","path":"2020/08/31/HDU2513/","text":"多校联合训练的常见问题回答（FAQ） Cake slicing\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583 Accepted Submission(s): 305 ** Problem DescriptionA rectangular cake with a grid of mn unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts For example, assume that the cake has a grid of 34 unit squares on its top, and there are three cherries on the top, as shown in the figure below. One allowable slicing is as follows. For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is In this case, the total length of the cutting edges is 3+2=5. Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges. InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks. OutputOutput an integer indicating the least total length of the cutting edges. Sample Input3 4 3 1 2 2 3 3 2 Sample OutputCase 1: 5 SourceECJTU 2008 Autumn Contest 【题意】 有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底) 我参考了网上的博客,思路如下: 这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于 image-20200620162927557 因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int MAXN=0x3f3f3f3f;int m[25][25];int dp[25][25][25][25];int y,x,sum;//y*x矩阵；sum个樱桃;int Dp(int i,int j,int k,int l)&#123;//以i,j为左上角,k,l为右下角 if(dp[i][j][k][l]!=-1)&#123; return dp[i][j][k][l]; &#125;//如果之前计算过了,直接返回; //统计区域里面的樱桃数量; int cherry=0; for(int a=i;a&lt;=k;++a)&#123; for(int b=j;b&lt;=l;++b)&#123; if(m[a][b]==1)&#123; cherry+=1; &#125; &#125; &#125; //如果樱桃数量==1,那么不需要切割,返回0; if(cherry==1)&#123; dp[i][j][k][l]=0; return 0; &#125; //如果是0,那么这是一个不应该取得解,返回INF; if(cherry==0)&#123; dp[i][j][k][l]=MAXN; return MAXN; &#125; //否则需要切割;横着切或者纵着切; int minn=MAXN; //横着切: for(int a=i;a&lt;k;++a)&#123; minn=min(minn,Dp(i,j,a,l)+Dp(a+1,j,k,l)+l-j+1); &#125; //纵着切割: for(int b=j;b&lt;l;++b)&#123; minn=min(minn,Dp(i,j,k,b)+Dp(i,b+1,k,l)+k-i+1); &#125; dp[i][j][k][l]=minn; return dp[i][j][k][l];&#125;void init()&#123; memset(dp,-1,sizeof(dp)); memset(m,0,sizeof(m));&#125;int main() &#123; int cnt=1; while(~scanf(\"%d%d%d\",&amp;y,&amp;x,&amp;sum))&#123; init(); for(int i=0;i&lt;sum;++i)&#123; int p,q; scanf(\"%d%d\",&amp;p,&amp;q); m[p][q]=1; &#125; Dp(1,1,y,x); printf(\"Case %d: %d\\n\",cnt,dp[1][1][y][x]); cnt+=1; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"面试题08_m","date":"2020-08-31T13:20:30.000Z","path":"2020/08/31/面试题08-m/","text":"面试题 08.11. 硬币难度中等82 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007) 示例1: 12345 输入: n &#x3D; 5 输出：2 解释: 有两种方式可以凑成总金额:5&#x3D;55&#x3D;1+1+1+1+1 示例2: 1234567 输入: n &#x3D; 10 输出：4 解释: 有四种方式可以凑成总金额:10&#x3D;1010&#x3D;5+510&#x3D;5+1+1+1+1+110&#x3D;1+1+1+1+1+1+1+1+1+1 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; //没有优化的版本: vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;temp(n+2,0); vector&lt;vector&lt;int&gt;&gt;dp(val.size(),temp); dp[0][0]=1; for(int i=0;i&lt;4;i++)&#123; dp[i][0]=1;//不管用几种硬币组成0元只有一种方法 &#125; for(int i=0;i&lt;n+1;i++)&#123; dp[0][i]=1;//只用一种硬币(1)当然只有一种方法 &#125; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;n+1;j++)&#123; if(j&gt;=val[i]) dp[i][j]=dp[i-1][j]% 1000000007+dp[i][j-val[i]]% 1000000007; else&#123; dp[i][j]=dp[i-1][j]% 1000000007; &#125; &#125; &#125; return dp[3][n]% 1000000007; &#125;&#125;; //上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维 1234567891011121314151617181920212223242526272829class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; // //降维到一维的版本: //dp[j]=dp[j]+dp[j-val[i]]; vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;dp(n+2,1); dp[0]=1; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(j&gt;=val[i]) dp[j]=dp[j]%1000000007+dp[j-val[i]]%1000000007; &#125; &#125; return dp[n]%1000000007; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode1014_m","date":"2020-08-31T13:19:15.000Z","path":"2020/08/31/leetcode1014-m/","text":"1014. 最佳观光组合难度中等124 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 123输入：[8,1,5,2,6]输出：11解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11 提示： 2 &lt;= A.length &lt;= 50000 1 &lt;= A[i] &lt;= 1000 通过次数17,154 提交次数32,791 主要注意优化的这种思路,真的挺妙的; 123456789101112131415161718192021class Solution &#123;public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; //A[i]+i+A[j]-j //原始解法: //对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2) //优化: //tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n) int tmp=A[0]+0; int maxn=INT_MIN; for(int i=1;i&lt;A.size();++i)&#123; maxn=max(tmp+A[i]-i,maxn); tmp=max(tmp,A[i]+i); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode837_m","date":"2020-08-31T13:18:28.000Z","path":"2020/08/31/leetcode837-m/","text":"837. 新21点难度中等190 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？ 示例 1**：** 123输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10输出：1.00000说明：爱丽丝得到一张卡，然后停止。 示例 2**：** 1234输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10输出：0.60000说明：爱丽丝得到一张卡，然后停止。在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。 示例 3**：** 12输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10输出：0.73278 提示： 0 &lt;= K &lt;= N &lt;= 10000 1 &lt;= W &lt;= 10000 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。 此问题的判断限制时间已经减少。 这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释; 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: double new21Game(int N, int K, int W) &#123; //dp[x]: 得到x分之后继续游戏,成功的概率; //dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W //初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1 //结果:dp[0] //优化:发现 dp[x]和dp[x-1]之间的关系: //Wdp[x-1]=dp[x]+...+dp[x+w-1] //Wdp[x]=dp[x+1].....dp[x+w] //W (dp[x]-dp[x-1])=-dp[x]+dp[x+w] //(W+1)dp[x]-dp[x+w]=Wdp[x-1] //dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k if(K==0)&#123; return 1.0; &#125; int maxn=max(N,K+W+1)+1; vector&lt;double&gt;dp(maxn,0); for(int i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123; dp[i]=1.0; &#125; for(int i=1;i&lt;=W;i++)&#123; dp[K-1]+=dp[i+K-1]; &#125; dp[K-1]/=W; //dp[K - 1] = 1.0 * min(N - K + 1, W) / W; //dp[K-1]=((W+1)*dp[K]-dp[K+W])/W; for(int i=K-2;i&gt;=0;i--)&#123; dp[i]=((W+1)*dp[i+1]-dp[i+W+1])/W; &#125; return dp[0]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode416_m","date":"2020-08-31T13:17:48.000Z","path":"2020/08/31/leetcode416-m/","text":"416. 分割等和子集难度中等218 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 01背包问题 具体解体思路见注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; //背包问题 //背包的容量是总和的一半 //dp[i][j] 表示取了前i个数剩余容积为j时候的最大值 //dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i]) int sum=0; int n=nums.size(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; if(sum%2!=0)&#123; return false; &#125; int V=sum/2; vector&lt;vector &lt;int&gt; &gt; dp(n,vector&lt;int&gt;(V+1,0)); //初始化: dp[0][0]=0; //只取0号数字的时候的初始化： for(int i=nums[0];i&lt;=V;i++)&#123;//注意越界问题 dp[0][i]=nums[0];//因为只能取一次nums[0]; &#125; //dp状态转移 for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;=V;j++)&#123; if(j-nums[i]&gt;=0) dp[i][j]=max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else&#123; dp[i][j]=dp[i-1][j]; &#125; &#125; &#125; if(dp[n-1][V]!=V)&#123; return false; &#125; return true; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode221_m","date":"2020-08-31T13:16:52.000Z","path":"2020/08/31/leetcode221-m/","text":"221. 最大正方形难度中等428 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 神必的dp 主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度; 状态转移方程比较难像: $dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$ 解释如下: image-20200531160513652 为了代码的美观减少一次特判,应该要在左边和上边多加一列: 0 0 0 ….. 0 matrix 0 … python代码如下： 1234567891011121314151617181920212223class Solution: #重点是神必的状态转移方程 def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) ==0: return 0 height=len(matrix) width=len(matrix[0]) dp=[[0 for i in range(width+1)] for j in range(height+1)] #dp初始化,并且在外面多套了一层; #dp[i,j]表示以i,j为右下角的矩形的最大宽度; # 0 0 0 0 .... # 0 matrix # 0 # 0 # ... #转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1 maxedge=0 for i in range(height): for j in range(width): if matrix[i][j]=='1': dp[i+1][j+1]=min(dp[i][j],dp[i+1][j],dp[i][j+1])+1 maxedge=max(maxedge,dp[i+1][j+1]) return maxedge*maxedge","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode213_m","date":"2020-08-31T13:16:12.000Z","path":"2020/08/31/leetcode213-m/","text":"213. 打家劫舍 II难度中等284 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回; if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; if(nums.size()&#x3D;&#x3D;1)&#123; return nums[0]; &#125; vector&lt;int&gt;dp1(nums.size(),0); vector&lt;int&gt;dp2(nums.size(),0); dp1[0]&#x3D;nums[0]; dp1[1]&#x3D;max(nums[0],nums[1]); if(nums.size()&#x3D;&#x3D;2)&#123; return dp1[1]; &#125; if(nums.size()&#x3D;&#x3D;3)&#123; return dp1[1]; &#125; for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123; dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]); &#125; int result1&#x3D;dp1[nums.size()-2]; dp2[1]&#x3D;nums[1]; dp2[2]&#x3D;max(nums[1],nums[2]); for(int i&#x3D;3;i&lt;nums.size();i++)&#123; dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]); &#125; int result2&#x3D;dp2[nums.size()-1]; return max(result1,result2); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode198_m","date":"2020-08-31T13:15:12.000Z","path":"2020/08/31/leetcode198-m/","text":"198. 打家劫舍难度简单875 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 原始版本: 12345678910111213141516171819202122232425262728class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; //dp[i]:第0间-第i间房子偷窃的最高金额; //dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; //初始化: //dp[0]=nums[0] //dp[1]=max(nums[0],nums[1]) if(nums.size()==0)&#123; return 0; &#125; int len=nums.size(); vector&lt;int&gt;dp(len,0); dp[0]=nums[0]; if(nums.size()==1)&#123; return dp[0]; &#125; dp[1]=max(nums[1],nums[0]); for(int i=2;i&lt;len;++i)&#123; dp[i]=max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; //滚动数组优化; &#125;&#125;; 滚动数组优化版本; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额; &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; &#x2F;&#x2F;初始化: &#x2F;&#x2F;dp[0]&#x3D;nums[0] &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1]) if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; int len&#x3D;nums.size(); int first&#x3D;nums[0]; if(nums.size()&#x3D;&#x3D;1)&#123; return first; &#x2F;&#x2F;return dp[0]; &#125; int sec&#x3D;max(nums[1],nums[0]); int result&#x3D;sec; for(int i&#x3D;2;i&lt;len;i++)&#123; result&#x3D;max(sec,first+nums[i]); first&#x3D;sec; sec&#x3D;result; &#125; return result; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode96_m","date":"2020-08-31T13:10:02.000Z","path":"2020/08/31/leetcode96-m/","text":"96. 不同的二叉搜索树难度中等537 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; //dp[i]:i个结点的时候二叉搜索树的个数 //空树只有一种情况:dp[0]=1 //dp[1]=1 //dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....) // vector&lt;int&gt;dp(n+1,0); dp[0]=1; dp[1]=1; if(n&lt;2)&#123; return dp[n]; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; dp[i]+=dp[j]*dp[i-j-1]; &#125; &#125; return dp[n]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode64_m","date":"2020-08-31T13:09:13.000Z","path":"2020/08/31/leetcode64-m/","text":"64. 最小路径和难度中等486 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 1234567891011121314151617181920212223242526class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //dp[i][j]:到i,j 的最小路径和; //dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; vector&lt;vector&lt;int&gt;&gt;dp(grid); int m=dp.size(); if(m==0)&#123;return 0;&#125;; int n=dp[0].size(); for(int i=1;i&lt;m;++i)&#123; dp[i][0]=dp[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;++i)&#123; dp[0][i]=dp[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode62_m","date":"2020-08-31T13:04:05.000Z","path":"2020/08/31/leetcode62-m/","text":"62. 不同路径难度中等560 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ img 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 1234567输入: m &#x3D; 3, n &#x3D; 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m &#x3D; 7, n &#x3D; 3输出: 28 1234567891011121314151617181920212223242526272829class Solution &#123;public: int uniquePaths(int m, int n) &#123; &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案 &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#x2F;&#x2F;dp[0][0]&#x3D;1; &#x2F;&#x2F;dp[0][1]&#x3D;1&#39; &#x2F;&#x2F;dp[1][0]&#x3D;1; if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125; vector&lt;int&gt;tmp(m,0); vector&lt;vector&lt;int&gt;&gt;dp(n,tmp); for(int i&#x3D;0;i&lt;m;i++)&#123; dp[0][i]&#x3D;1; &#125; for(int i&#x3D;0;i&lt;n;i++)&#123; dp[i][0]&#x3D;1; &#125; for(int i&#x3D;1;i&lt;n;i++)&#123; for(int j&#x3D;1;j&lt;m;j++)&#123; dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[n-1][m-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode53_s","date":"2020-08-31T13:03:25.000Z","path":"2020/08/31/leetcode53-s/","text":"53. 最大子序和难度简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 水题: dp[i]表示第i个之前的连续子数组的最大和 dp[i]=max(dp[i],dp[i-1]+dp[i]) 12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxnum; vector&lt;int&gt; dp(nums); maxnum=nums[0]; for(int i=1;i&lt;nums.size();i++)&#123; if(dp[i-1]&gt;0)&#123; dp[i]=dp[i-1]+dp[i]; &#125; maxnum=max(maxnum,dp[i]); &#125; return maxnum; &#125; &#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode32_h","date":"2020-08-31T13:01:40.000Z","path":"2020/08/31/leetcode32-h/","text":"32. 最长有效括号难度困难784 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 通过次数74,856 提交次数233,569 题解见注释:主要是要两两字符判断; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int longestValidParentheses(string s) &#123; //动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度; //对于...............(): //dp[i]=dp[i-2]+2; //对于...............)): //dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) //判断s[i-dp[i-1]-1],如果是(: //dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了; int n=s.length();; vector&lt;int&gt;dp(n+1,0); if(n==0 || n==1)&#123; return 0; &#125; int maxn=0; for(int i=1;i&lt;n;++i)&#123; if(s[i]==')')&#123; if(s[i-1]=='(')&#123; if(i&gt;=2)&#123; dp[i]=dp[i-2]+2; &#125;else&#123; dp[i]=2; &#125; &#125;else&#123; if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]=='(')&#123; if(i-dp[i-1]-2&gt;=0) dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]; else&#123; dp[i]=dp[i-1]+2; &#125; &#125; &#125; &#125; maxn=max(maxn,dp[i]); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode5_m","date":"2020-08-31T13:00:48.000Z","path":"2020/08/31/leetcode5-m/","text":"5. 最长回文子串难度中等 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 这题目可以使用动态规划 我觉得很棒的一个题解 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int len=s.length(); if(len&lt;=1) return s; vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len)); for(int i=0;i&lt;len;i++)&#123; dp[i][i]=1; &#125; int start=0; int maxl=1; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(s[i]==s[j])&#123; if(i-j&lt;=2)&#123; dp[j][i]=1; &#125;else&#123; dp[j][i]=dp[j+1][i-1]; &#125; &#125; if(dp[j][i]==1)&#123; int temp=i-j+1; if(temp&gt;maxl)&#123; maxl=temp; start=j; &#125; &#125; &#125; &#125; return s.substr(start,maxl); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"HDU_1284","date":"2020-08-31T12:58:32.000Z","path":"2020/08/31/HDU-1284/","text":"钱币兑换问题\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 15976 Accepted Submission(s): 9546** Problem Description 在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。 Input 每行只有一个正整数N，N小于32768。 Output 对应每个输入，输出兑换方法数。 Sample Input 12293412553 Sample Output 1271883113137761 Author SmallBeer(CML) Source 杭电ACM集训队训练赛（VII） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;//相当于3件物品，容量为N的背包，第i件物品的重量是i//初始化: dp[0][0]=1//dp[i][j]表示用前i件物品组成j的方案数量//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;//滚动数组优化：//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;using namespace std;int temp;const int maxn=33000;//32468long long int dp[maxn];int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; memset(dp,0,sizeof(dp)); dp[0]=1; for(int i=1;i&lt;=3;i++)&#123; for(int j=i;j&lt;maxn;j++)&#123; dp[j]+=dp[j-i]; // printf(\"%lld\\n\",dp[j]); // dp[j]+=max(dp[j],dp[j-i]); &#125; &#125;// printf(\"here\");//// scanf(\"%d\",&amp;temp);// printf(\"%lld\",dp[temp]); while(scanf(\"%d\",&amp;temp)==1)&#123; printf(\"%I64d\\n\",dp[temp]); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode19_m","date":"2020-08-31T03:12:38.000Z","path":"2020/08/31/leetcode19-m/","text":"19. 删除链表的倒数第N个节点难度中等947收藏分享切换为英文关注反馈 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗 快慢指针的想法来实现: 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* l; ListNode*r; l=head; r=head; ListNode* temp; int cnt=0; for(cnt=0;cnt&lt;n;cnt++)&#123; r=r-&gt;next; &#125; if(r==nullptr)&#123; return head-&gt;next; &#125; //cout&lt;&lt;r-&gt;val&lt;&lt;endl; while(r-&gt;next!=nullptr)&#123; r=r-&gt;next; l=l-&gt;next; &#125; // cout&lt;&lt;l-&gt;val&lt;&lt;endl; l-&gt;next=l-&gt;next-&gt;next; return head; &#125;&#125;;","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode16_m","date":"2020-08-31T03:11:14.000Z","path":"2020/08/31/leetcode16-m/","text":"16. 最接近的三数之和难度中等530 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 123输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。 提示： 3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4 通过次数141,122 提交次数308,415 和leetcode15相似,主要思路还是排序+双指针 我使用了minA维护了当前的最小值,然后使用res记录和; 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: #排序: -4 -1 1 2 #minA 对于遍历到的每一个i,维护minA; #每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回; n=len(nums) if n&lt;3 or not nums: return NULL minA=sys.maxsize # INT最大值 res=minA nums.sort() for i in range(0,n-2): L=i+1 R=n-1 while L&lt;R: cur=nums[i]+nums[L]+nums[R] if cur==target: minA=0 return cur elif cur&lt;target: tempres=target-cur if abs(tempres)&lt;minA: minA=abs(tempres) res=cur L=L+1 else: tempres=cur-target if abs(tempres)&lt;minA: minA=abs(tempres) res=cur R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode15_m","date":"2020-08-31T03:06:50.000Z","path":"2020/08/31/leetcode15-m/","text":"15. 三数之和难度中等2455 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 通过次数293,697 提交次数1,016,765 还是看了题解,排序太香了！ 主要操作是排序使用双指针进行检查;同时记得去重; 12345678910111213141516171819202122232425262728293031323334class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if n&lt;3 or not nums: return res nums.sort() #从i遍历到n-2,使用双指针维护和探查; #记得去重,也就是对于相同的找最后的; for i in range(0,n): if nums[i]&gt;0: return res if i&gt;0 and nums[i]==nums[i-1]: continue #去重 L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while L&lt; R and nums[R]==nums[R-1]: R=R-1 L=L+1 R=R-1 elif nums[i]+nums[L]+nums[R]&lt;0: L=L+1 else: R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"cmd_vs_rsa","date":"2020-08-10T12:30:55.848Z","path":"2020/08/10/cmd_vs_rsa/","text":"关于windows密钥登录服务器前言:windows的权限管理太屑了 参考https://blog.csdn.net/joshua2011/article/details/90208741","tags":[]},{"title":"Winter plan","date":"2020-01-22T09:17:23.000Z","path":"2020/01/22/winter-learning-plan/","text":"需要完成的目标: 线性代数复习 学习cs224n 刷leetcode 算法竞赛入门经典 目前进度: 线性代数: 1.22 cs224n 1.22 leetcode 1.22 算法竞赛入门经典","tags":[{"name":"flag","slug":"flag","permalink":"http://tyler-ytr.github.io/tags/flag/"}]},{"title":"ubuntu教程","date":"2020-01-22T08:28:15.000Z","path":"2020/01/22/ubuntu-back/","text":"反思 之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了; 重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜 复活操作基本配置 管理员权限,换源,安装vim sudo passwd(修改sudo密码) sudo apt-get update sudo apt-get install vim 更换国内源,这里我选择的是清华源用下面的命令打开文件,并且注释里面的所有内容, sudo vim /etc/apt/sources.list 然后粘贴下面的内容到打开的文件里面# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下; 安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇博客 然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义su apt-get install build-essential apt-get install man # on-line reference manual apt-get install gcc-doc # manual for GCC apt-get install gdb # GNU debugger apt-get install git # reversion control system apt-get install libreadline-dev # a library to use compile the project later apt-get install libsdl2-dev # a library to use compile the project later apt-get install qemu-system-x86 # QEMU 安装chrome:请使用bing搜索;用gmail同步很香; 科学的看世界 我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json 将下面的内容根据自己的配置放进去: { \"server\":\"my_server_ip\", \"server_port\":53450, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"密码\", \"timeout\":300, \"method\":\"aes-256-gcm\", \"fast_open\": false } 然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;自己测试一下有没有问题; 感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)： 先写一个自启动脚本： touch ~/.ssstart.sh vim ~/.ssstart.sh 内容是: #!/bin/bash ss-local -c ~/shadowsocks/shadowsocks.json 然后在终端里面起别名:vim ~/.bashrc在末尾添加:alias ss=’. ~/.ssstart.sh’:wq 保存,退出在终端里面:source ~/.bashrc(如果是zsh:source ~/.zshrc)尝试一下在终端输入ss,它lei了; 因为后面的netdata需要终端翻墙,我也就尝试了一下,如果没有需求可以跳过这一步: 主要参考的是谷歌出来的网站 首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装 下面尝试全局代理(我也不确定能不能成功)： sudo pip install genpac 选择安装配置文件的目录,我选择的是:/home/larryytr/shadowsocks 然后执行以下命令:sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 下面是一句搬运,我没有遇到过:注意：如果报错“fetch gfwlist fail.online: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 执行完之后,目录下面会有一个autoproxy.pac文件。 然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写： file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改) 然后使得终端也能使用代理。我们需要privoxy代理工具: 安装很自然:sudo apt-get install privoxy 然后编辑配置文件sudo vim /etc/privoxy/config 在文档中搜索(vim 使用/搜索)“listen-address”（即监听地址），找到如下一行：listen-address localhost:8118 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“forward-socks5t”，找到如下一行：forward-socks5t / 127.0.0.1:1080 . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy： 1sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config 最后，再配置/etc/profile： # 先进入编辑模式 sudo vim /etc/profile # 在末尾添加以下三行： export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118export ftp_proxy=http://127.0.0.1:8118 # 退出之后记得执行 source /etc/profile 验证是否成功:curl www.google.com或wget www.google.com判断是否可以访问 HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！ 优化美化 官网安装网易云 官网安装vscode 配置zsh,tmux,vim: zsh安装与美化 学习了:https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/https://segmentfault.com/a/1190000013612471这两篇教程; 感谢何伟的配置文件; 相应的setting请参考我的github相关内容. 安装zsh:sudo apt-get update sudo apt-get install zsh chsh -s /bin/zsh (设置zsh为默认) 重启你的ubuntu 安装oh-my-zsh插件: wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 不改theme一无所有 准备使用powerline主题 首先安装powerline字体： git clone https://github.com/powerline/fonts.git --depth=1 # install cd fonts ./install.sh # clean-up a bit cd .. rm -rf fonts 安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久) 安装powerline: sudo apt install powerline 我的配置见相关内容的setting .zshrc 颜色选择困难请: for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f” 改完请source ~/.zshrc tmux tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程; 我使用了何伟的配置,具体见相关内容的setting 我又加了一个插件使得tmux在重启之后状态可以恢复: 主要参考这个知乎教程 git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp 在~/.tmux.conf.local里面加上:run-shell ~/tmux_tmp/resurrect.tmux 最后载入这个配置：tmux source-file ~/.tmux.conf vim的美化 使用啦懒人vim: spf13-vim美化 请看相关内容的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh 我的配置同样在相关内容的setting里面; 这个时候的vim没有办法和系统剪切版交互,我根据https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html 下载了其他一些插件:sudo apt-get install vim-scripts vim-gtk vim-gnome这样 vim –version|grep “cliboard” 会看到 +clipboard;然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！ 其他内容: OSlab还需要: sudo apt-get install curl sudo apt-get install gcc-multilib git 配置请搜索廖雪峰 ctags 可以参考Mengzelev的博客 感谢xnr给我推荐的network来查看linux的运行情况 这是netdata的官方网站:https://github.com/netdata/netdata#user-base 但是由于GFW,安装会出现报错,事实上需要终端翻墙才行 可以通过这篇教程 sudo apt-get install net-tools ifconfig查看inet 之后的内容来得知自己的server_ip 成功之后,进入 http://127.0.0.1:19999/ (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验 相应配置可以参考这篇博客或者自己搜索 OSlab的kvm bug处理方法：https://bugzilla.redhat.com/show_bug.cgi?id=1479558chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content: KERNEL==\"kvm\", GROUP=\"kvm\", MODE=\"0666\" texlive 安装sudo apt install texlive-full 相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting) vscode的保存即编译请Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾； ubuntu的截图:我参考了这篇博客 打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+ 显然的配置好按键,然后在命令里面写gnome-screenshot -a hint:上面的命令终端输入也有效截屏的图在文件夹的图片(picture)里面; To be continued 有空再研究怎么换主题;","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hello World","date":"2020-01-20T19:20:25.723Z","path":"2020/01/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]