[{"title":"leetcode22_m","date":"2020-09-07T01:28:58.000Z","path":"2020/09/07/leetcode22-m/","text":"22. 括号生成难度中等1252收藏分享切换为英文关注反馈 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 12345678输入：n &#x3D; 3输出：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 通过次数166,462 提交次数218,996 一道经典的回溯算法的题目,lcnit表示左边括号的数目,rcnt表示右括号的数目;结束的条件是temp.size()==2*n,也就是满足长度; 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt;result; int maxn=0; void back_track(string temp,int lcnt,int rcnt)&#123; if(temp.size()==maxn*2)&#123; result.push_back(temp); return; &#125; if(lcnt&lt;maxn)&#123; temp.push_back('('); back_track(temp,lcnt+1,rcnt); temp.pop_back(); &#125; if(rcnt&lt;lcnt)&#123; temp.push_back(')'); back_track(temp,lcnt,rcnt+1); temp.pop_back(); &#125; return; &#125; vector&lt;string&gt; generateParenthesis(int n) &#123; string temp=\"\"; maxn=n; back_track(temp,0,0); return result; &#125;&#125;;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"http://tyler-ytr.github.io/tags/%E6%A0%88/"}]},{"title":"leetcode134_m","date":"2020-09-07T01:26:14.000Z","path":"2020/09/07/leetcode134-m/","text":"134. 加油站难度中等243 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 1234567891011121314输入: gas &#x3D; [1,2,3,4,5]cost &#x3D; [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 12345678910111213输入: gas &#x3D; [2,3,4]cost &#x3D; [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 参考了一个数形结合的题解 注意最小值的初始化问题 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int success=0; int n=gas.size(); int tempsum=0; for(int i=0;i&lt;n;i++)&#123; tempsum=tempsum+gas[i]-cost[i]; &#125; if(tempsum&lt;0)&#123; success=0; return -1; &#125; //现在起码可以环绕一圈，开始找起始点 //我觉得如果可以跑的话就是一个逃税过程，如何逃掉更多的税呢？因为起始点起始相当于少交一次前面的税 int gassum=0; int costsum=0; int min_ans=0; int min_result=INT_MAX; int temp=0; for(int i=0;i&lt;n;i++)&#123; gassum+=gas[i]; costsum+=cost[i]; temp=gassum-costsum; if(temp&lt;min_result)&#123; min_result=temp; min_ans=i; &#125; &#125; return (min_ans+1)%n; &#125;&#125;;","tags":[{"name":"贪心","slug":"贪心","permalink":"http://tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"poj2386","date":"2020-09-07T01:24:14.000Z","path":"2020/09/07/poj2386/","text":"Lake Counting Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 59523 Accepted: 28958 Description Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John’s field, determine how many ponds he has. Input * Line 1: Two space-separated integers: N and M * Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output * Line 1: The number of ponds in Farmer John’s field. Sample Input 123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output 13 Hint OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left,and one along the right side. Source USACO 2004 November 题目大意: 计算出相连的’W’有多少块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;//#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;char mapa[maxn][maxn];int N,M;void dfs(int x,int y)&#123; mapa[x][y]='.'; int tempx; int tempy; for(int i=-1;i&lt;=1;i++)&#123; for(int j=-1;j&lt;=1;j++)&#123; tempx=x+i; tempy=y+j; if(tempx&gt;=0&amp;&amp;tempx&lt;N&amp;&amp;tempy&gt;=0&amp;&amp;tempy&lt;M&amp;&amp;mapa[tempx][tempy]=='W')&#123; dfs(tempx,tempy); &#125; &#125; &#125; return ;&#125;int main() &#123; // std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; cin&gt;&gt;N&gt;&gt;M; // vector&lt;vector&lt;char&gt; &gt; map(N,(vector&lt;char&gt; (M))); for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; char temp; cin &gt;&gt; temp; mapa[i][j]=temp; &#125; &#125;//cout&lt;&lt;\"here\"&lt;&lt;endl; int cnt=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(mapa[i][j]=='W')&#123; dfs(i,j);// cout&lt;&lt;cnt&lt;&lt;endl;// for(int i=0;i&lt;N;i++)&#123;// for(int j=0;j&lt;M;j++)&#123;//// cout&lt;&lt;mapa[i][j]&lt;&lt;\" \";// &#125;// cout&lt;&lt;endl;// &#125; cnt+=1; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"poj1321 棋盘问题","date":"2020-09-07T01:22:23.000Z","path":"2020/09/07/poj1321/","text":"棋盘问题 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 96005 Accepted: 43758 Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input 1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output 1221 Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;vector&lt;string&gt;map;//vector&lt;bool&gt;line;int cnt;int ans;void clear()&#123; map.clear(); cnt=0; ans=0;&#125;int N;int K;void backtrace(int j,vector&lt;bool&gt;&amp;line) &#123; if (cnt == K) &#123;//注意出递归的条件是cnt==K也就是找到这么多个 ans++; return; &#125; if(j&gt;=N)&#123;//这里是为了防止遍历的行数超过边界 return; &#125; for (int i = 0; i &lt; N; i++)&#123; if(!line[i]&amp;&amp;map[j][i]=='#')&#123; line[i]=true; cnt+=1; backtrace(j+1,line); cnt-=1; line[i]=false; &#125; &#125; backtrace(j+1,line);//遍历下一行&#125;int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; //vector&lt;string&gt;map; int n; int t; clear(); vector&lt;bool&gt;line(9, false); while(cin&gt;&gt;n&amp;&amp;cin&gt;&gt;t)&#123; if(n==-1&amp;&amp;t==-1)&#123; break; &#125;else&#123; N=n; K=t; for(int i=0;i&lt;n;i++)&#123; string a; cin&gt;&gt;a; map.push_back(a); &#125; for(int i=0;i&lt;9;i++)&#123; line[i]=false; &#125; backtrace(0,line); // N=n;// for(int i=0;i&lt;n;i++)&#123;// for(int j=0;j&lt;n;j++)// cout&lt;&lt;map[i][j]&lt;&lt;\" \";// &#125; cout&lt;&lt;ans&lt;&lt;endl; //cout结果; clear(); &#125; &#125; return 0;&#125; PS:leetcode刷题表示所有的OJ题","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode491_m","date":"2020-09-07T01:18:16.000Z","path":"2020/09/07/leetcode491-m/","text":"491. 递增子序列难度中等88 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。 示例: 12输入: [4, 6, 7, 7]输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 说明: 给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。 通过次数7,099 提交次数14,688 使用回溯算法进行dfs;主要要和那道全排列进行比较和区分; 使用set可以减少重复(我感觉剪枝更快但是不好写) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: set&lt;vector&lt;int&gt;&gt;result; void dfs(vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;temp,int pos)&#123; if(temp.size()==0)&#123; temp.push_back(nums[pos]); &#125; for(int i=1;i&lt;nums.size();++i)&#123; if(i+pos&gt;nums.size()-1||nums[i+pos]&lt;temp.back())&#123; continue; &#125;else&#123; temp.push_back(nums[pos+i]); result.insert(temp); dfs(nums,temp,pos+i); temp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; //感觉是回溯算法做的; vector&lt;int&gt;temp; for(int i=0;i&lt;nums.size();++i)&#123; temp.clear(); dfs(nums,temp,i); &#125; vector&lt;vector&lt;int&gt;&gt;ans; set&lt;vector&lt;int&gt;&gt;::iterator it; for(it=result.begin();it!=result.end();++it)&#123; ans.push_back(*it); &#125; return ans; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode386_m","date":"2020-09-07T01:14:51.000Z","path":"2020/09/07/leetcode386-m/","text":"386. 字典序排数难度中等74 给定一个整数 n, 返回从 1 到 n 的字典顺序。 例如， 给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。 请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt;result; void dfs(int cur,int n)&#123; if(cur&gt;n)&#123; return; &#125; else&#123; result.push_back(cur); for(int i=0;i&lt;10;++i)&#123; if(cur*10+i&gt;n)&#123; return; &#125;else&#123; dfs(cur*10+i,n); &#125; &#125; &#125; &#125; vector&lt;int&gt; lexicalOrder(int n) &#123; for(int i=1;i&lt;=9;++i) dfs(i,n); return result; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode133_m","date":"2020-09-07T01:12:57.000Z","path":"2020/09/07/leetcode133-m/","text":"133. 克隆图难度中等155 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。 示例 1： img 12345678输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2： img 123输入：adjList &#x3D; [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3： 123输入：adjList &#x3D; []输出：[]解释：这个图是空的，它不含任何节点。 示例 4： img 12输入：adjList &#x3D; [[2],[1]]输出：[[2],[1]] 提示： 节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 图是连通图，你可以从给定节点访问到所有节点。 使用dfs+字典/哈希表 即可;重点需要学会的是C++map/unorder_map的使用count查询的操作,count返回0表示没有,1表示有; 递归+数组版本: 12345678910111213141516171819class Solution &#123;public: Node*used[101]; Node* cloneGraph(Node* node) &#123; //需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素; //也可以不用Map 用一个Node*数组来表示; if(!node)return node; if(used[node-&gt;val])return used[node-&gt;val]; Node*p=new Node(node-&gt;val);//创建拷贝结点; used[node-&gt;val]=p; vector&lt;Node*&gt;tp=node-&gt;neighbors; for(int i=0;i&lt;tp.size();++i)&#123; p-&gt;neighbors.push_back(cloneGraph(tp[i])); &#125; return p; &#125;&#125;; 递归+unorder_map版本; 123456789101112131415161718class Solution &#123;public: unordered_map&lt;Node*, Node*&gt;used; Node* cloneGraph(Node* node) &#123; //需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素; //也可以不用Map 用一个Node*数组来表示; if(!node)return node; if(used.count(node))return used[node]; Node*p=new Node(node-&gt;val);//创建拷贝结点; used[node]=p; vector&lt;Node*&gt;tp=node-&gt;neighbors; for(int i=0;i&lt;tp.size();++i)&#123; p-&gt;neighbors.push_back(cloneGraph(tp[i])); &#125; return p; &#125;&#125;; map版本用map替换unorder_map即可; 其中速度:map慢于unorder_map慢于数组; 原因:(摘自一个题解): map： 优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间 适用处：对于那些有顺序要求的问题，用map会更高效一些 unordered_map： 优点： 因为内部实现了哈希表，因此其查找速度非常的快缺点： 哈希表的建立比较耗费时间适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map 深度优先遍历的递归写法1.发现新节点1.如果没有操作该节点，就操作该节点，并将该节点的visit置11.1接着对该节点的neibor挨个遍历dfs函数2.如果有操作就返回该节点或者pass 非递归版本: 12345678910111213141516171819202122232425262728293031class Solution &#123;public: &#x2F;&#x2F;unordered_map&lt;Node*, Node*&gt;used; Node* cloneGraph(Node* node) &#123; if(!node)return node; stack&lt;Node*&gt;S; S.push(node);&#x2F;&#x2F;等同于 stack &lt;Node*&gt;S(&#123;node&#125;); unordered_map&lt;Node*, Node*&gt;used; used[node] &#x3D; new Node(node-&gt;val); Node* tmp; while(!S.empty())&#123; tmp &#x3D; S.top(); S.pop(); Node* r &#x3D; used[tmp]; vector&lt;Node*&gt;n&#x3D;tmp-&gt;neighbors; for(int i&#x3D;0;i&lt;n.size();++i)&#123; &#x2F;&#x2F;如果这个节点之前已经遍历到，就把他的复制加到链表中 &#x2F;&#x2F;没有遍历过就复刻该节点，加入map，加入neighbor Node*cur&#x3D;n[i]; if(!used.count(cur))&#123; Node*t&#x3D;new Node(cur-&gt;val); used[cur]&#x3D;t; S.push(cur); &#125; r-&gt;neighbors.push_back(used[cur]); &#125; &#125; return used[node]; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode131_m","date":"2020-09-07T01:10:18.000Z","path":"2020/09/07/leetcode131-m/","text":"98. 验证二叉搜索树难度中等471 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 &#x2F; \\ 1 3输出: true 示例 2: 123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 dfs 递归版本 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int flag; bool dfs(TreeNode* root,long long int lower,long long int higher)&#123; if(root==NULL)&#123; return true; &#125; long long int temp=root-&gt;val; if(temp&lt;=lower||temp&gt;=higher)&#123; return false; &#125; return dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); &#125; bool isValidBST(TreeNode* root) &#123; flag=1; return dfs(root,LONG_MIN,LONG_MAX); &#125; &#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode98_m","date":"2020-09-07T01:05:19.000Z","path":"2020/09/07/leetcode98-m/","text":"98. 验证二叉搜索树难度中等471 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 &#x2F; \\ 1 3输出: true 示例 2: 123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 dfs 递归版本 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int flag; bool dfs(TreeNode* root,long long int lower,long long int higher)&#123; if(root==NULL)&#123; return true; &#125; long long int temp=root-&gt;val; if(temp&lt;=lower||temp&gt;=higher)&#123; return false; &#125; return dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); &#125; bool isValidBST(TreeNode* root) &#123; flag=1; return dfs(root,LONG_MIN,LONG_MAX); &#125; &#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode51_h","date":"2020-09-07T01:00:57.000Z","path":"2020/09/07/leetcode51-h/","text":"51. N皇后难度困难377 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 img 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例: 12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, &#x2F;&#x2F; 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: //行列; 本质上还是回溯法 //逐个行来扫描,这一行确定了之后就删除一些状态 //三个需要验证的合法性: //列,两个对角线: //line,incline1,incline2 //按行遍历,如果这列ok 就line[i]=1 //0x0x //x1xx (1,1)(0,0)(2,2)(3,3) 发现abs(j-i)是相同的;因此j-i+N 相同(这样确保大于0)) //0x0x (1,1)(0,2)(3,0) 发现对角线上面i+j是相同的 //xxx0 //所以每次更新的时候都是line[i]=true,incline[i+j]=true,incline[j-i+N]=true; int N; vector&lt;vector&lt;string&gt;&gt;result;//用来保存; void place(int j,vector&lt;vector&lt;bool&gt;&gt;&amp;track,vector&lt;bool&gt;&amp;line,vector&lt;bool&gt;&amp;incline1,vector&lt;bool&gt;&amp;incline2)&#123; if(j==N)&#123; //递归结束 string a=\"\"; vector&lt;string&gt; b; for(int p=0;p&lt;N;p++)&#123; for(int k=0;k&lt;N;k++)&#123; if(track[p][k])&#123; a.push_back('Q'); &#125;else&#123; a.push_back('.'); &#125; &#125; b.push_back(a); a.clear(); &#125; result.push_back(b); return; &#125;else&#123; for(int i=0;i&lt;N;i++)&#123; if(!line[i]&amp;&amp;!incline1[i+j]&amp;&amp;!incline2[j-i+N])&#123; line[i]=true; incline1[i+j]=true; incline2[j-i+N]=true; track[j][i]=true; place(j+1,track,line,incline1,incline2); line[i]=false; incline1[i+j]=false; incline2[j-i+N]=false; track[j][i]=false; &#125; &#125; ; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;bool&gt;incline1(2*n,false); vector&lt;bool&gt;incline2(2*n,false); vector&lt;bool&gt;line(n,false); vector&lt;vector&lt;bool&gt;&gt; track(n,line); N=n; place(0,track,line,incline1,incline2); return result; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"回溯法","slug":"回溯法","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"leetcode46_m","date":"2020-09-07T00:59:34.000Z","path":"2020/09/07/leetcode46-m/","text":"46 PermutationsMedium 333697Add to ListShare Given a collection of distinct integers, return all possible permutations. Example: 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt;res; vector&lt;bool&gt; vis;//表示这个解遇到过了; void backtrace(const vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;track,int index)&#123; //index记录vis的编号; if(index==nums.size())&#123; res.push_back(track); return; &#125; for(int i=0;i&lt;nums.size();i++)&#123; if(vis[i])&#123; ; &#125;else&#123; //没有访问过; vis[i]=true; track.push_back(nums[i]); backtrace(nums,track,index+1); track.pop_back(); vis[i]=false; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; res.clear(); if(nums.size()==0)&#123; return res; &#125; vis = vector&lt;bool&gt;(nums.size(), false); vector&lt;int&gt; track; backtrace(nums,track,0); return res; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"回溯法","slug":"回溯法","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"leetcode124_h","date":"2020-09-07T00:58:16.000Z","path":"2020/09/07/leetcode124-h/","text":"124. 二叉树中的最大路径和难度困难510 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 1234567输入: [1,2,3] 1 &#x2F; \\ 2 3输出: 6 示例 2: 123456789输入: [-10,9,20,null,null,15,7] -10 &#x2F; \\ 9 20 &#x2F; \\ 15 7输出: 42 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ //用一个maxm来缓存对于某一个根节点的状态; //dfs过程中返回给上层应该是最大的一边;class Solution &#123;public: int maxm=INT_MIN; int dfs(TreeNode*root)&#123; if(root==nullptr)&#123; return 0; &#125; int left=max(0,dfs(root-&gt;left)); int right=max(0,dfs(root-&gt;right)); maxm=max(maxm,root-&gt;val+left+right); return max(left+root-&gt;val,right+root-&gt;val); &#125; int maxPathSum(TreeNode* root) &#123; // dfs(root); return maxm; &#125;&#125;; dfs解决该题,使用maxm缓存最大的结点处于的状态;dfs到某一个结点的时候,该节点返回给上一层:该节点值,该结点值+左值,该节点的值+右值的最大值; 对于空节点,返回0,表示对原来的结点没有贡献; 对于负值,和0比较取max的步骤表示如果有一边是负的那么就不做贡献,和空节点没有区别;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode690_s","date":"2020-09-07T00:56:33.000Z","path":"2020/09/07/leetcode690-s/","text":"690. 员工的重要性难度简单88 给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。 比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。 现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。 示例 1: 1234输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1输出: 11解释:员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 &#x3D; 11。 注意: 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。 通过次数13,683 提交次数23,456 重要的是先进行的hash操作,运用了unorder_map结构体,极大的简化了dfs的操作; 12345678910111213141516171819202122232425262728293031// Definition for Employee.class Employee &#123;public: int id; int importance; vector&lt;int&gt; subordinates;&#125;;class Solution &#123;public: unordered_map&lt;int,Employee*&gt;mp; int result=0; void dfs(int id)&#123; result+=mp[id]-&gt;importance; for(int i=0;i&lt;mp[id]-&gt;subordinates.size();++i)&#123; dfs(mp[id]-&gt;subordinates[i]); &#125; &#125; int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; //哈希: for(Employee* tmp:employees)&#123; mp[tmp-&gt;id]=tmp; &#125; //进行dfs; dfs(id); return result; &#125;&#125;; BFS版本: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*// Definition for Employee.class Employee &#123;public: int id; int importance; vector&lt;int&gt; subordinates;&#125;;*/// unordered_map&lt;int, Employee*&gt; mp;// int ans = 0;// public:// int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;// for (auto&amp; e : employees) // mp[e-&gt;id] = e;// dfs(id);// return ans;// &#125;// void dfs(int id) &#123;// ans += mp[id]-&gt;importance;// for (int i = 0; i &lt; mp[id]-&gt;subordinates.size(); ++i) // dfs(mp[id]-&gt;subordinates[i]);// &#125;class Solution &#123;public: unordered_map&lt;int,Employee*&gt;mp; int result=0; int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; //哈希: for(Employee* tmp:employees)&#123; mp[tmp-&gt;id]=tmp; &#125; //进行bfs queue&lt;int&gt; q; q.push(id); while(!q.empty())&#123; int temp=q.front(); q.pop(); result+=mp[temp]-&gt;importance; for(int i=0;i&lt;mp[temp]-&gt;subordinates.size();++i)&#123; q.push(mp[temp]-&gt;subordinates[i]); &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode199_m","date":"2020-09-07T00:53:29.000Z","path":"2020/09/07/leetcode199-m/","text":"199. 二叉树的右视图难度中等186 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例: 123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- &#x2F; \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 通过次数29,576 提交次数46,105 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; //bfs // 1 //2 3 // 5 4 //广度优先搜索，当q里面只有最右边一个元素的时候把这个元素加入到输出的队列里面; // if(root==nullptr)&#123;return NULL&#125;; vector&lt;int&gt;result; if(root==nullptr)&#123;return result;&#125;; queue&lt;TreeNode*&gt;q;//先进先出 q.push(root); while(!q.empty())&#123; // TreeNode*temp=q.front(); //关键点: 用len记录q的size;通过这个来获得最右侧的点; int len=q.size(); for(int i=0;i&lt;len;i++)&#123; TreeNode*temp=q.front(); if(i==len-1)&#123; result.push_back(temp-&gt;val); &#125; q.pop(); if(temp-&gt;left!=nullptr)&#123; q.push(temp-&gt;left); &#125; if(temp-&gt;right!=nullptr)&#123; q.push(temp-&gt;right); &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode101_s","date":"2020-09-07T00:51:12.000Z","path":"2020/09/07/leetcode101-s/","text":"101. 对称二叉树难度简单 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 &#x2F; \\2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 BFS的板子题 12345678910111213141516171819202122class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int size = q.size(); vector&lt;int&gt; v(size); for(int i = 0; i&lt;size; ++i)&#123; root = q.front(); q.pop(); v[i] = root ? root-&gt;val : INT_MIN; if(root) &#123; q.push(root-&gt;left); q.push(root-&gt;right); &#125; &#125; // 判断是否回文 for(int i = 0; i&lt; size/2; ++i)&#123; if(v[i] != v[size-1-i]) return false; &#125; &#125; return true; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode200_m","date":"2020-09-07T00:49:14.000Z","path":"2020/09/07/leetcode200-m/","text":"200. 岛屿数量难度中等515 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1: 123456输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。 解法1:BFS 遍历每一个点,遇到1就bfs并且把bfs到的1变成0;记录bfs的次数即可： 测试数据竟然有空集，这样会导致int maxn=map[0].size();//列数; 出现runtime error神必报错我tm…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; //感觉可以bfs //遍历map的每一个点,如果map[i][j]是1,进行bfs,遇到1的变成0; vector&lt;vector&lt;char&gt;&gt;map(grid); int cnt=0; //m*n; int maxm=map.size();//行数 if(maxm==0)&#123;return 0;&#125;//对付空集的神必特判 int maxn=map[0].size();//列数; for(int i=0;i&lt;maxm;i++)&#123; for(int j=0;j&lt;maxn;j++)&#123; if(map[i][j]=='1')&#123; cnt+=1; queue&lt;pair&lt;int,int&gt;&gt;q; pair&lt;int,int&gt;temp; temp.first=i; temp.second=j; q.push(temp); map[i][j]='0'; while(!q.empty())&#123; pair&lt;int,int&gt;cur=q.front(); q.pop(); int tempi=cur.first; int tempj=cur.second; if(tempi-1&gt;=0&amp;&amp;map[tempi-1][tempj]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi-1; temp2.second=tempj; q.push(temp2); map[tempi-1][tempj]='0'; &#125; if(tempi+1&lt;maxm&amp;&amp;map[tempi+1][tempj]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi+1; temp2.second=tempj; q.push(temp2); map[tempi+1][tempj]='0'; &#125; if(tempj-1&gt;=0&amp;&amp;map[tempi][tempj-1]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi; temp2.second=tempj-1; q.push(temp2); map[tempi][tempj-1]='0'; &#125; if(tempj+1&lt;maxn&amp;&amp;map[tempi][tempj+1]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi; temp2.second=tempj+1; q.push(temp2); map[tempi][tempj+1]='0'; &#125; ; &#125; ; &#125; &#125; &#125; return cnt; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode705_s","date":"2020-09-06T08:26:54.000Z","path":"2020/09/06/leetcode705-s/","text":"705. 设计哈希集合难度简单40 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: 123456789MyHashSet hashSet &#x3D; new MyHashSet();hashSet.add(1); hashSet.add(2); hashSet.contains(1); &#x2F;&#x2F; 返回 truehashSet.contains(3); &#x2F;&#x2F; 返回 false (未找到)hashSet.add(2); hashSet.contains(2); &#x2F;&#x2F; 返回 truehashSet.remove(2); hashSet.contains(2); &#x2F;&#x2F; 返回 false (已经被删除) 注意： 所有的值都在 [0, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 通过次数11,949 提交次数21,319 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class MyHashSet &#123;private: struct Node&#123; int val; Node* next; Node(int val):val(val),next(nullptr)&#123;&#125; &#125;;public: vector&lt;Node*&gt; arr; const int len=101; /** Initialize your data structure here. */ MyHashSet() &#123; arr=vector&lt;Node*&gt;(len,new Node(-1)); &#125; void add(int key) &#123; int addr=key%len; Node*temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)return; if(!(temp-&gt;next))&#123; Node*node=new Node(key); temp-&gt;next=node; return; &#125; temp = temp -&gt; next; &#125; &#125;else&#123; temp-&gt;val=key; return; &#125; &#125; void remove(int key) &#123;// int haval = key % len;// Node* temp = arr[haval];// if(temp -&gt; val != -1)&#123;// while(temp)&#123;// if(temp -&gt; val == key)&#123;// temp -&gt; val = -1;// return;// &#125;// temp = temp -&gt; next;// &#125;// &#125; int addr=key%len; Node*temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)&#123; temp-&gt;val=-1; return; &#125; temp=temp-&gt;next; &#125; &#125; &#125; /** Returns true if this set contains the specified element */ bool contains(int key) &#123; int addr=key%len; Node* temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)&#123; return true; &#125; temp=temp-&gt;next; &#125; return false; &#125;else&#123; return false; &#125; &#125;&#125;;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","permalink":"http://tyler-ytr.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"leetcode67_s","date":"2020-09-06T08:25:13.000Z","path":"2020/09/06/leetcode67-s/","text":"67. 二进制求和难度简单398 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;输出: &quot;10101&quot; 提示： 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 模拟题,用j来从后往前遍历; 一开始搞错的原因是因为忘记在result.push_back之后加上temp=0了,佛佛佛 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string addBinary(string a, string b) &#123; vector&lt;int&gt;result; int n=a.size(); int m=b.size(); int maxn=max(n,m); int out=0;//处理进位 int temp=0; for(int j=0;j&lt;maxn;++j)&#123; if(n-j&gt;0)&#123; temp+=(int)(a[n-j-1]-'0'); &#125; if(m-j&gt;0)&#123; temp+=(int)(b[m-j-1]-'0'); &#125; temp+=out; out=0; if(temp&gt;=2)&#123; temp-=2; out=1; &#125; result.push_back(temp); temp=0; &#125; if(out==1)&#123; result.push_back(1); &#125; string res; for(int i=result.size()-1;i&gt;=0;--i)&#123; if(result[i]==1)&#123; res=res+'1'; &#125;else&#123;res=res+'0';&#125; &#125; return res; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"leetcode14_s","date":"2020-09-06T07:58:44.000Z","path":"2020/09/06/leetcode14-s/","text":"14. 最长公共前缀难度简单1079 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 模拟题实锤,纵向比较,重点是要掌握string的substr方法; 12345678910111213141516171819202122232425262728class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int cnt=0; //纵向扫描; if(strs.size()==0)&#123; return \"\"; &#125; int length=strs[0].size(); if(length==0)&#123; return \"\"; &#125; for(int i=0;i&lt;length;++i)&#123; char c=strs[0][i]; for(int j=1;j&lt;strs.size();++j)&#123; if(strs[j][i]!=c||i==strs[j].size())&#123; return strs[0].substr(0,cnt); &#125; &#125; cnt+=1; &#125; if(cnt==0)&#123; return \"\"; &#125; return strs[0]; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"leetcode892_s","date":"2020-09-06T07:56:59.000Z","path":"2020/09/06/leetcode892-s/","text":"892. 三维形体的表面积难度简单90 在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： 12输入：[[2]]输出：10 示例 2： 12输入：[[1,2],[3,4]]输出：34 示例 3： 12输入：[[1,0],[0,2]]输出：16 示例 4： 12输入：[[1,1,1],[1,0,1],[1,1,1]]输出：32 示例 5： 12输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46 提示： 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 一道模拟题，题目意思很难懂 第一个示例的意思是 0,0这个位置有一个高度为2的立方体； 第二个示例的意思是 0,0 高度为1;0,1 高度为2………… 主要解法是找到一个求解表面积的公式 12345678910111213141516171819202122232425class Solution &#123;public: int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int N=grid.size(); int result=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;N;j++)&#123; if(grid[i][j]&gt;0)&#123; result+=2+4*grid[i][j]; &#125; if(i&gt;0)&#123; if(grid[i-1][j]&gt;0)&#123; result-=min(grid[i-1][j],grid[i][j])*2; &#125; &#125; if(j&gt;0)&#123;if(grid[i][j-1]&gt;0)&#123; result-=min(grid[i][j-1],grid[i][j])*2; &#125; &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"关于windows密钥登录服务器","date":"2020-09-04T06:56:33.000Z","path":"2020/09/04/cmd_vs_rsa/","text":"关于windows密钥登录服务器前言:windows的权限管理太屑了 参考https://blog.csdn.net/joshua2011/article/details/90208741","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"DNS刷新","date":"2020-09-04T06:56:33.000Z","path":"2020/09/04/DNS刷新/","text":"DNS刷新垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中心的工程师打完电话之后发现是自己电脑DNS的问题，因此bing搜索，发现了如下的方法进行DNS的刷新: 1234netsh int ip reset netsh winsock resetipconfig&#x2F;flushdns 重启 然后报错从dns probe finished no Internet变成了 image-20200904150200196 佛了 面对不知道咋整的东西，那就选择重装系列： 右击 image-20200904184552395 然后点击网络重置 好像就行了？！","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"wishlist_together","date":"2020-09-04T02:18:35.000Z","path":"2020/09/04/wishlist-together/","text":"2020 wishlist 一起去鬼屋 一起去迪士尼","tags":[{"name":"wishlist","slug":"wishlist","permalink":"http://tyler-ytr.github.io/tags/wishlist/"}]},{"title":"leetcode4_h","date":"2020-08-31T14:55:42.000Z","path":"2020/08/31/leetcode4-h/","text":"4. 寻找两个正序数组的中位数难度困难2695 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 &#x3D; [1, 3]nums2 &#x3D; [2]则中位数是 2.0 示例 2: 1234nums1 &#x3D; [1, 2]nums2 &#x3D; [3, 4]则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5 123456789101112131415161718192021222324252627282930class Solution: #二分法,对于arr1,arr2,k:令x=k//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小; #注意处理边界 def findkthelement(self,arr1:List[int],arr2:List[int],k)-&gt;float: len1=len(arr1) len2=len(arr2) if len1&gt;len2: return self.findkthelement(arr2,arr1,k) ##确保arr1是短的一边; if not arr1: #arr1为空,递归结束 return arr2[k-1] if k==1: #返回最小的元素 return min(arr1[0],arr2[0]) x=k//2 i=int(min(x,len1)-1) #arr1的边界;因为是数组所以要减一,代表有i+1个元素 j=int(min(x,len2)-1) if arr1[i]&lt;arr2[j]: return self.findkthelement(arr1[i+1:],arr2,k-i-1) else: return self.findkthelement(arr1,arr2[j+1:],k-j-1) def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: len1=len(nums1) len2=len(nums2) #考虑中位数的奇偶问题 mid1=(len1+len2+1)//2 mid2=(len1+len2+2)//2 return(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/2","tags":[{"name":"二分","slug":"二分","permalink":"http://tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"leetcode990_m","date":"2020-08-31T14:28:06.000Z","path":"2020/08/31/leetcode990-m/","text":"990. 等式方程的可满足性难度中等73 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&quot;a==b&quot; 或 &quot;a!=b&quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 123输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]输出：false解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 123输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]输入：true解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。 示例 3： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]输出：true 示例 4： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]输出：false 示例 5： 12输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]输出：true 提示： 1 &lt;= equations.length &lt;= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 &#39;=&#39;，要么是 &#39;!&#39; equations[i][2] 是 &#39;=&#39; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int p[26]; int find_set(int x)&#123; if(x!=p[x])&#123; p[x]=find_set(p[x]); &#125; return p[x]; &#125; bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; //图的连通性问题---并查集 for(int i =0;i&lt;26;i++)&#123; p[i]=i; &#125; for(int i=0;i&lt;equations.size();i++)&#123; //==就合并; if(equations[i][1]=='=')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1!=fx2)&#123; p[fx1]=p[fx2]; &#125; &#125; &#125; for(int i=0;i&lt;equations.size();i++)&#123; if(equations[i][1]=='!')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1==fx2)return false; &#125; &#125; return true; &#125;&#125;; 官方版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class UnionFind &#123;private: vector&lt;int&gt; parent;public: UnionFind() &#123; parent.resize(26); iota(parent.begin(), parent.end(), 0); &#125; int find(int index) &#123; if (index &#x3D;&#x3D; parent[index]) &#123; return index; &#125; parent[index] &#x3D; find(parent[index]); return parent[index]; &#125; void unite(int index1, int index2) &#123; parent[find(index1)] &#x3D; find(index2); &#125;&#125;;class Solution &#123;public: bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; UnionFind uf; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; uf.unite(index1, index2); &#125; &#125; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","tags":[{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"}]},{"title":"leetcode547_m","date":"2020-08-31T14:23:59.000Z","path":"2020/08/31/leetcode547-m/","text":"547. 朋友圈难度中等255 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2: 123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意： N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 通过次数47,496 提交次数83,180 并查集版本 改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前; 还有就是find函数的条件是$x==f[x]$ 别搞错了; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: struct dis_set&#123; int n; //int f[205]; vector&lt;int&gt;f; dis_set(int x)&#123; // this-&gt;n=205; //f.resize(this-&gt;n); //iota(f.begin(),f.end(),0); n=x; f.resize(x+1); for(int i=0;i&lt;this-&gt;n;i++)&#123; f[i]=i; &#125; &#125; int find(int x)&#123; if(x==f[x])&#123; return x; &#125; f[x]=find(f[x]); return f[x]; &#125; void unite(int a,int b)&#123; int roota=find(a); int rootb=find(b); if(roota==rootb)return ; this-&gt;n--; f[roota]=rootb; &#125; int count()&#123; return n; &#125; &#125;; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? if(M.size()==0) return 0; int n=M[0].size(); struct dis_set cur(n); for(int i=0;i&lt;M.size();++i)&#123; for(int j=0;j&lt;M[0].size();++j)&#123; if(M[i][j]==1)&#123; cur.unite(i,j); &#125; &#125; &#125; return cur.count(); &#125; &#125;; dfs版本: 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt;vis; void dfs(int id,vector&lt;vector&lt;int&gt;&gt;&amp;M)&#123; if(vis[id]==1)return; vis[id]=1; for(int i=0;i&lt;M[id].size();++i)&#123; if(M[id][i]==1)&#123; dfs(i,M); &#125; &#125; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; vis.resize(n); // iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数; for(int i=0;i&lt;n;i++)&#123; vis[i]=0; &#125; for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]==0)&#123; dfs(i,M); cnt++; &#125; &#125; return cnt; &#125; &#125;; bfs 版本的解法: 注意vis[j]=1那句,很重要; image-20200617203349985 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; //还可以用bfs做;同样用vis记录没有访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; queue&lt;int&gt;Q; vector&lt;int&gt;vis(n,0); for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]!=1)&#123; Q.push(i); while(!Q.empty())&#123; int top=Q.front(); Q.pop(); vis[top]=1; for(int j=0;j&lt;M[top].size();++j)&#123; if(M[top][j]==1&amp;&amp;vis[j]==0)&#123; Q.push(j); vis[j]=1;//这句很重要,如果没有这句会慢很多; &#125; &#125; &#125; cnt++; &#125; &#125; return cnt; &#125; &#125;;","tags":[{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"},{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode94_m","date":"2020-08-31T14:11:42.000Z","path":"2020/08/31/leetcode94-m/","text":"94. 二叉树的中序遍历难度中等614 给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 &#x2F; 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 通过次数210,162 提交次数290,172 递归版本: 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void sol(TreeNode *root,vector&lt;int&gt;&amp;nums)&#123; if(root==NULL)&#123; return; &#125; sol(root-&gt;left,nums); nums.push_back(root-&gt;val); sol(root-&gt;right,nums); return ; ; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt;nums; sol(root,nums); return nums; &#125;&#125;; 迭代版本: 1234567891011121314151617181920212223242526272829vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; //迭代版本如下: stack&lt;TreeNode*&gt;S; vector&lt;int&gt;result; TreeNode*cur=root; while(cur!=NULL||!S.empty())&#123; while(cur!=NULL)&#123; S.push(cur); cur=cur-&gt;left; &#125; cur=S.top(); result.push_back(cur-&gt;val); S.pop(); cur=cur-&gt;right; /* # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。 # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。 # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。 */ &#125; return result;&#125; image-20200809090152414 以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……","tags":[{"name":"树","slug":"树","permalink":"http://tyler-ytr.github.io/tags/%E6%A0%91/"}]},{"title":"面试题51_h","date":"2020-08-31T14:10:23.000Z","path":"2020/08/31/面试题51-h/","text":"面试题51. 数组中的逆序对难度困难90 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 12输入: [7,5,6,4]输出: 5 限制： 10 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000 当然二重for循环暴力可以解决，但是会超时； 实际上是一道二分思想的归并排序题目 image-20200424130136282 对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: vector&lt;int &gt;temp; int mergesort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)&#123; return 0; &#125;; int tempresult=0; //int mid=(l+r)/2; int mid=l+((r-l)&gt;&gt;1);//防止l,r过大的时候溢出 //int mid=(l+r)&gt;&gt;1; 最快 tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+1,r); int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;=nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; tempresult+=mid-i+1;//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作 &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; return tempresult; &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; //居然是归并排序 if(nums.size()&lt;2)&#123; return 0; &#125; else&#123; int result=0; temp.resize((int)nums.size()+1, 0); result=mergesort(nums,0,(int)nums.size()-1); return result; &#125; &#125;&#125;;","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode912_m","date":"2020-08-31T13:27:52.000Z","path":"2020/08/31/leetcode912-m/","text":"912. 排序数组难度中等98 给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 12输入：nums &#x3D; [5,2,3,1]输出：[1,2,3,5] 示例 2： 12输入：nums &#x3D; [5,1,1,2,0,0]输出：[0,0,1,1,2,5] 排序算法复习题 归并排序 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; temp; void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)return;//左指针偶遇右指针 int mid=(l+r)&gt;&gt;1; mergeSort(nums,l,mid); mergeSort(nums,mid+1,r); // 现在l-mid mid+1-r是有序的 //考虑合并的情况 int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; temp.resize((int)nums.size(), 0); mergeSort(nums, 0, (int)nums.size() - 1); return nums; &#125;&#125;; 插入排序 12 快速排序 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: //快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick int partition(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int pivot=nums[r]; int i=l-1; for(int j=l;j&lt;=r-1;++j)&#123; if(nums[j]&lt;=pivot)&#123; i=i+1;//扩展比pivot小的边界; swap(nums[i],nums[j]); &#125; &#125; swap(nums[i+1],nums[r]); return i+1; &#125; int randomized_partiton(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int i = rand() % (r - l + 1) + l; cout&lt;&lt;i&lt;&lt;endl; swap(nums[r],nums[i]);//选择pivot然后存放到最右端; return partition(nums,l,r); &#125; void quicksort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&lt;r)&#123; int pos=randomized_partiton(nums,l,r); quicksort(nums,l,pos-1); quicksort(nums,pos+1,r); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; srand((unsigned)time(NULL)); quicksort(nums,0,(int)nums.size()-1); return nums; &#125;&#125;; 堆排序（不稳定排序） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: void maxheapify(vector&lt;int&gt;&amp;nums,int i,int len)&#123;//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1) for(;(i&lt;&lt;1)+1&lt;=len;)&#123; int lson=(i&lt;&lt;1)+1; int rson=(i&lt;&lt;1)+2; int largest; if(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123; largest=lson; &#125;else&#123; largest=i; &#125; if(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123; largest=rson; &#125; if(i!=largest)&#123; int temp=nums[i]; nums[i]=nums[largest]; nums[largest]=temp; i=largest; &#125;else&#123;break;&#125; &#125; &#125; void buildmaxheap(vector&lt;int&gt;&amp;nums,int len)&#123; for(int i=len/2;i&gt;=0;--i)&#123; maxheapify(nums,i,len); &#125; &#125; void heapsort(vector&lt;int&gt;&amp;nums)&#123; int len=(int)nums.size()-1; buildmaxheap(nums,len); for(int i=len;i&gt;=1;--i)&#123; int temp=nums[0]; nums[0]=nums[i]; nums[i]=temp; len-=1; maxheapify(nums,0,len); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; heapsort(nums); return nums; &#125;&#125;; //另外关于排序算法 线性时间但是有限制的有: 计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\\Theta(n+k)$ 基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort 桶排序:","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode50_m","date":"2020-08-31T13:26:51.000Z","path":"2020/08/31/leetcode50-m/","text":"50. Pow(x, n)难度中等365 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 通过次数85,540 提交次数241,065 123456789101112131415161718192021222324class Solution &#123;public:double fastPower(double base, long long power) &#123; double result = 1.0; while (power &gt; 0) &#123; if (power &amp; 1) &#123;//此处等价于if(power%2==1) result = result * base; &#125; power &gt;&gt;= 1;//此处等价于power=power/2 base = (base * base) ; &#125; return result;&#125; double myPow(double x, int n) &#123; long long temp=n; if(n&gt;0) return fastPower(x,temp); else&#123; return 1/fastPower(x,-temp); &#125; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode914_s","date":"2020-08-31T13:25:40.000Z","path":"2020/08/31/leetcode914-s/","text":"914. 卡牌分组难度简单100 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X &gt;= 2 时返回 true。 示例 1： 123输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2： 123输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。 示例 3： 123输入：[1]输出：false解释：没有满足要求的分组。 示例 4： 123输入：[1,1]输出：true解释：可行的分组是 [1,1] 示例 5： 123输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: const int maxn=10002; int cnt[10002];int GCD1(int num1,int num2)&#123;if(num1%num2==0)&#123;return num2;&#125;else&#123;int next1=num2; int next2=num1%num2;return GCD1(next1,next2);&#125;&#125; bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123; memset(cnt,0,sizeof(cnt)); for(int i=0;i&lt;deck.size();i++)&#123; cnt[deck[i]]+=1; &#125; int g=-1; for(int i=0;i&lt;maxn;i++)&#123; if(cnt[i]!=0)&#123; if(g==-1)&#123; g=cnt[i]; &#125;else&#123; g=GCD1(g,cnt[i]); &#125; &#125; &#125; if(g&gt;=2)return true; else return false; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode312_h","date":"2020-08-31T13:23:43.000Z","path":"2020/08/31/leetcode312-h/","text":"312. 戳气球难度困难318 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 1234输入: [3,1,5,8]输出: 167 解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167 这题需要考虑的有两点: 第一点是状态的寻找和转移 第二点是如何进行递推; image-20200620172037074 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; //dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量; //dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \\in [i+1,j-1] 这里k表示最后一次戳哪一个气球; //注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历; //另外还需要在左端和右端都添加虚假的气球; int n=nums.size(); vector&lt;int&gt;points(n+2,0); points[0]=1; points[n+1]=1; for(int i=0;i&lt;n;++i)&#123; points[i+1]=nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt; (n + 2, 0)); for(int i=n;i&gt;=0;--i)&#123; for(int j=i+1;j&lt;n+2;++j)&#123; int maxn=0; for(int k=i+1;k&lt;j;++k)&#123; maxn=max(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]); &#125; dp[i][j]=maxn; &#125; &#125; return dp[0][n+1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"HDU2513","date":"2020-08-31T13:21:36.000Z","path":"2020/08/31/HDU2513/","text":"多校联合训练的常见问题回答（FAQ） Cake slicing\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583 Accepted Submission(s): 305 ** Problem DescriptionA rectangular cake with a grid of mn unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts For example, assume that the cake has a grid of 34 unit squares on its top, and there are three cherries on the top, as shown in the figure below. One allowable slicing is as follows. For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is In this case, the total length of the cutting edges is 3+2=5. Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges. InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks. OutputOutput an integer indicating the least total length of the cutting edges. Sample Input3 4 3 1 2 2 3 3 2 Sample OutputCase 1: 5 SourceECJTU 2008 Autumn Contest 【题意】 有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底) 我参考了网上的博客,思路如下: 这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于 image-20200620162927557 因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int MAXN=0x3f3f3f3f;int m[25][25];int dp[25][25][25][25];int y,x,sum;//y*x矩阵；sum个樱桃;int Dp(int i,int j,int k,int l)&#123;//以i,j为左上角,k,l为右下角 if(dp[i][j][k][l]!=-1)&#123; return dp[i][j][k][l]; &#125;//如果之前计算过了,直接返回; //统计区域里面的樱桃数量; int cherry=0; for(int a=i;a&lt;=k;++a)&#123; for(int b=j;b&lt;=l;++b)&#123; if(m[a][b]==1)&#123; cherry+=1; &#125; &#125; &#125; //如果樱桃数量==1,那么不需要切割,返回0; if(cherry==1)&#123; dp[i][j][k][l]=0; return 0; &#125; //如果是0,那么这是一个不应该取得解,返回INF; if(cherry==0)&#123; dp[i][j][k][l]=MAXN; return MAXN; &#125; //否则需要切割;横着切或者纵着切; int minn=MAXN; //横着切: for(int a=i;a&lt;k;++a)&#123; minn=min(minn,Dp(i,j,a,l)+Dp(a+1,j,k,l)+l-j+1); &#125; //纵着切割: for(int b=j;b&lt;l;++b)&#123; minn=min(minn,Dp(i,j,k,b)+Dp(i,b+1,k,l)+k-i+1); &#125; dp[i][j][k][l]=minn; return dp[i][j][k][l];&#125;void init()&#123; memset(dp,-1,sizeof(dp)); memset(m,0,sizeof(m));&#125;int main() &#123; int cnt=1; while(~scanf(\"%d%d%d\",&amp;y,&amp;x,&amp;sum))&#123; init(); for(int i=0;i&lt;sum;++i)&#123; int p,q; scanf(\"%d%d\",&amp;p,&amp;q); m[p][q]=1; &#125; Dp(1,1,y,x); printf(\"Case %d: %d\\n\",cnt,dp[1][1][y][x]); cnt+=1; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"面试题08_m","date":"2020-08-31T13:20:30.000Z","path":"2020/08/31/面试题08-m/","text":"面试题 08.11. 硬币难度中等82 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007) 示例1: 12345 输入: n &#x3D; 5 输出：2 解释: 有两种方式可以凑成总金额:5&#x3D;55&#x3D;1+1+1+1+1 示例2: 1234567 输入: n &#x3D; 10 输出：4 解释: 有四种方式可以凑成总金额:10&#x3D;1010&#x3D;5+510&#x3D;5+1+1+1+1+110&#x3D;1+1+1+1+1+1+1+1+1+1 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; //没有优化的版本: vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;temp(n+2,0); vector&lt;vector&lt;int&gt;&gt;dp(val.size(),temp); dp[0][0]=1; for(int i=0;i&lt;4;i++)&#123; dp[i][0]=1;//不管用几种硬币组成0元只有一种方法 &#125; for(int i=0;i&lt;n+1;i++)&#123; dp[0][i]=1;//只用一种硬币(1)当然只有一种方法 &#125; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;n+1;j++)&#123; if(j&gt;=val[i]) dp[i][j]=dp[i-1][j]% 1000000007+dp[i][j-val[i]]% 1000000007; else&#123; dp[i][j]=dp[i-1][j]% 1000000007; &#125; &#125; &#125; return dp[3][n]% 1000000007; &#125;&#125;; //上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维 1234567891011121314151617181920212223242526272829class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; // //降维到一维的版本: //dp[j]=dp[j]+dp[j-val[i]]; vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;dp(n+2,1); dp[0]=1; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(j&gt;=val[i]) dp[j]=dp[j]%1000000007+dp[j-val[i]]%1000000007; &#125; &#125; return dp[n]%1000000007; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode1014_m","date":"2020-08-31T13:19:15.000Z","path":"2020/08/31/leetcode1014-m/","text":"1014. 最佳观光组合难度中等124 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 123输入：[8,1,5,2,6]输出：11解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11 提示： 2 &lt;= A.length &lt;= 50000 1 &lt;= A[i] &lt;= 1000 通过次数17,154 提交次数32,791 主要注意优化的这种思路,真的挺妙的; 123456789101112131415161718192021class Solution &#123;public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; //A[i]+i+A[j]-j //原始解法: //对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2) //优化: //tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n) int tmp=A[0]+0; int maxn=INT_MIN; for(int i=1;i&lt;A.size();++i)&#123; maxn=max(tmp+A[i]-i,maxn); tmp=max(tmp,A[i]+i); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode837_m","date":"2020-08-31T13:18:28.000Z","path":"2020/08/31/leetcode837-m/","text":"837. 新21点难度中等190 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？ 示例 1**：** 123输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10输出：1.00000说明：爱丽丝得到一张卡，然后停止。 示例 2**：** 1234输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10输出：0.60000说明：爱丽丝得到一张卡，然后停止。在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。 示例 3**：** 12输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10输出：0.73278 提示： 0 &lt;= K &lt;= N &lt;= 10000 1 &lt;= W &lt;= 10000 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。 此问题的判断限制时间已经减少。 这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释; 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: double new21Game(int N, int K, int W) &#123; //dp[x]: 得到x分之后继续游戏,成功的概率; //dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W //初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1 //结果:dp[0] //优化:发现 dp[x]和dp[x-1]之间的关系: //Wdp[x-1]=dp[x]+...+dp[x+w-1] //Wdp[x]=dp[x+1].....dp[x+w] //W (dp[x]-dp[x-1])=-dp[x]+dp[x+w] //(W+1)dp[x]-dp[x+w]=Wdp[x-1] //dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k if(K==0)&#123; return 1.0; &#125; int maxn=max(N,K+W+1)+1; vector&lt;double&gt;dp(maxn,0); for(int i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123; dp[i]=1.0; &#125; for(int i=1;i&lt;=W;i++)&#123; dp[K-1]+=dp[i+K-1]; &#125; dp[K-1]/=W; //dp[K - 1] = 1.0 * min(N - K + 1, W) / W; //dp[K-1]=((W+1)*dp[K]-dp[K+W])/W; for(int i=K-2;i&gt;=0;i--)&#123; dp[i]=((W+1)*dp[i+1]-dp[i+W+1])/W; &#125; return dp[0]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode416_m","date":"2020-08-31T13:17:48.000Z","path":"2020/08/31/leetcode416-m/","text":"416. 分割等和子集难度中等218 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 01背包问题 具体解体思路见注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; //背包问题 //背包的容量是总和的一半 //dp[i][j] 表示取了前i个数剩余容积为j时候的最大值 //dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i]) int sum=0; int n=nums.size(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; if(sum%2!=0)&#123; return false; &#125; int V=sum/2; vector&lt;vector &lt;int&gt; &gt; dp(n,vector&lt;int&gt;(V+1,0)); //初始化: dp[0][0]=0; //只取0号数字的时候的初始化： for(int i=nums[0];i&lt;=V;i++)&#123;//注意越界问题 dp[0][i]=nums[0];//因为只能取一次nums[0]; &#125; //dp状态转移 for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;=V;j++)&#123; if(j-nums[i]&gt;=0) dp[i][j]=max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else&#123; dp[i][j]=dp[i-1][j]; &#125; &#125; &#125; if(dp[n-1][V]!=V)&#123; return false; &#125; return true; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode221_m","date":"2020-08-31T13:16:52.000Z","path":"2020/08/31/leetcode221-m/","text":"221. 最大正方形难度中等428 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 神必的dp 主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度; 状态转移方程比较难像: $dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$ 解释如下: image-20200531160513652 为了代码的美观减少一次特判,应该要在左边和上边多加一列: 0 0 0 ….. 0 matrix 0 … python代码如下： 1234567891011121314151617181920212223class Solution: #重点是神必的状态转移方程 def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) ==0: return 0 height=len(matrix) width=len(matrix[0]) dp=[[0 for i in range(width+1)] for j in range(height+1)] #dp初始化,并且在外面多套了一层; #dp[i,j]表示以i,j为右下角的矩形的最大宽度; # 0 0 0 0 .... # 0 matrix # 0 # 0 # ... #转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1 maxedge=0 for i in range(height): for j in range(width): if matrix[i][j]=='1': dp[i+1][j+1]=min(dp[i][j],dp[i+1][j],dp[i][j+1])+1 maxedge=max(maxedge,dp[i+1][j+1]) return maxedge*maxedge","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode213_m","date":"2020-08-31T13:16:12.000Z","path":"2020/08/31/leetcode213-m/","text":"213. 打家劫舍 II难度中等284 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回; if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; if(nums.size()&#x3D;&#x3D;1)&#123; return nums[0]; &#125; vector&lt;int&gt;dp1(nums.size(),0); vector&lt;int&gt;dp2(nums.size(),0); dp1[0]&#x3D;nums[0]; dp1[1]&#x3D;max(nums[0],nums[1]); if(nums.size()&#x3D;&#x3D;2)&#123; return dp1[1]; &#125; if(nums.size()&#x3D;&#x3D;3)&#123; return dp1[1]; &#125; for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123; dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]); &#125; int result1&#x3D;dp1[nums.size()-2]; dp2[1]&#x3D;nums[1]; dp2[2]&#x3D;max(nums[1],nums[2]); for(int i&#x3D;3;i&lt;nums.size();i++)&#123; dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]); &#125; int result2&#x3D;dp2[nums.size()-1]; return max(result1,result2); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode198_m","date":"2020-08-31T13:15:12.000Z","path":"2020/08/31/leetcode198-m/","text":"198. 打家劫舍难度简单875 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 原始版本: 12345678910111213141516171819202122232425262728class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; //dp[i]:第0间-第i间房子偷窃的最高金额; //dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; //初始化: //dp[0]=nums[0] //dp[1]=max(nums[0],nums[1]) if(nums.size()==0)&#123; return 0; &#125; int len=nums.size(); vector&lt;int&gt;dp(len,0); dp[0]=nums[0]; if(nums.size()==1)&#123; return dp[0]; &#125; dp[1]=max(nums[1],nums[0]); for(int i=2;i&lt;len;++i)&#123; dp[i]=max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; //滚动数组优化; &#125;&#125;; 滚动数组优化版本; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额; &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; &#x2F;&#x2F;初始化: &#x2F;&#x2F;dp[0]&#x3D;nums[0] &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1]) if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; int len&#x3D;nums.size(); int first&#x3D;nums[0]; if(nums.size()&#x3D;&#x3D;1)&#123; return first; &#x2F;&#x2F;return dp[0]; &#125; int sec&#x3D;max(nums[1],nums[0]); int result&#x3D;sec; for(int i&#x3D;2;i&lt;len;i++)&#123; result&#x3D;max(sec,first+nums[i]); first&#x3D;sec; sec&#x3D;result; &#125; return result; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode96_m","date":"2020-08-31T13:10:02.000Z","path":"2020/08/31/leetcode96-m/","text":"96. 不同的二叉搜索树难度中等537 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; //dp[i]:i个结点的时候二叉搜索树的个数 //空树只有一种情况:dp[0]=1 //dp[1]=1 //dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....) // vector&lt;int&gt;dp(n+1,0); dp[0]=1; dp[1]=1; if(n&lt;2)&#123; return dp[n]; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; dp[i]+=dp[j]*dp[i-j-1]; &#125; &#125; return dp[n]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode64_m","date":"2020-08-31T13:09:13.000Z","path":"2020/08/31/leetcode64-m/","text":"64. 最小路径和难度中等486 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 1234567891011121314151617181920212223242526class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //dp[i][j]:到i,j 的最小路径和; //dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; vector&lt;vector&lt;int&gt;&gt;dp(grid); int m=dp.size(); if(m==0)&#123;return 0;&#125;; int n=dp[0].size(); for(int i=1;i&lt;m;++i)&#123; dp[i][0]=dp[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;++i)&#123; dp[0][i]=dp[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode62_m","date":"2020-08-31T13:04:05.000Z","path":"2020/08/31/leetcode62-m/","text":"62. 不同路径难度中等560 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ img 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 1234567输入: m &#x3D; 3, n &#x3D; 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m &#x3D; 7, n &#x3D; 3输出: 28 1234567891011121314151617181920212223242526272829class Solution &#123;public: int uniquePaths(int m, int n) &#123; &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案 &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#x2F;&#x2F;dp[0][0]&#x3D;1; &#x2F;&#x2F;dp[0][1]&#x3D;1&#39; &#x2F;&#x2F;dp[1][0]&#x3D;1; if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125; vector&lt;int&gt;tmp(m,0); vector&lt;vector&lt;int&gt;&gt;dp(n,tmp); for(int i&#x3D;0;i&lt;m;i++)&#123; dp[0][i]&#x3D;1; &#125; for(int i&#x3D;0;i&lt;n;i++)&#123; dp[i][0]&#x3D;1; &#125; for(int i&#x3D;1;i&lt;n;i++)&#123; for(int j&#x3D;1;j&lt;m;j++)&#123; dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[n-1][m-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode53_s","date":"2020-08-31T13:03:25.000Z","path":"2020/08/31/leetcode53-s/","text":"53. 最大子序和难度简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 水题: dp[i]表示第i个之前的连续子数组的最大和 dp[i]=max(dp[i],dp[i-1]+dp[i]) 12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxnum; vector&lt;int&gt; dp(nums); maxnum=nums[0]; for(int i=1;i&lt;nums.size();i++)&#123; if(dp[i-1]&gt;0)&#123; dp[i]=dp[i-1]+dp[i]; &#125; maxnum=max(maxnum,dp[i]); &#125; return maxnum; &#125; &#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode32_h","date":"2020-08-31T13:01:40.000Z","path":"2020/08/31/leetcode32-h/","text":"32. 最长有效括号难度困难784 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 通过次数74,856 提交次数233,569 题解见注释:主要是要两两字符判断; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int longestValidParentheses(string s) &#123; //动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度; //对于...............(): //dp[i]=dp[i-2]+2; //对于...............)): //dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) //判断s[i-dp[i-1]-1],如果是(: //dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了; int n=s.length();; vector&lt;int&gt;dp(n+1,0); if(n==0 || n==1)&#123; return 0; &#125; int maxn=0; for(int i=1;i&lt;n;++i)&#123; if(s[i]==')')&#123; if(s[i-1]=='(')&#123; if(i&gt;=2)&#123; dp[i]=dp[i-2]+2; &#125;else&#123; dp[i]=2; &#125; &#125;else&#123; if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]=='(')&#123; if(i-dp[i-1]-2&gt;=0) dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]; else&#123; dp[i]=dp[i-1]+2; &#125; &#125; &#125; &#125; maxn=max(maxn,dp[i]); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode5_m","date":"2020-08-31T13:00:48.000Z","path":"2020/08/31/leetcode5-m/","text":"5. 最长回文子串难度中等 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 这题目可以使用动态规划 我觉得很棒的一个题解 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int len=s.length(); if(len&lt;=1) return s; vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len)); for(int i=0;i&lt;len;i++)&#123; dp[i][i]=1; &#125; int start=0; int maxl=1; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(s[i]==s[j])&#123; if(i-j&lt;=2)&#123; dp[j][i]=1; &#125;else&#123; dp[j][i]=dp[j+1][i-1]; &#125; &#125; if(dp[j][i]==1)&#123; int temp=i-j+1; if(temp&gt;maxl)&#123; maxl=temp; start=j; &#125; &#125; &#125; &#125; return s.substr(start,maxl); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"HDU_1284","date":"2020-08-31T12:58:32.000Z","path":"2020/08/31/HDU-1284/","text":"钱币兑换问题\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 15976 Accepted Submission(s): 9546** Problem Description 在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。 Input 每行只有一个正整数N，N小于32768。 Output 对应每个输入，输出兑换方法数。 Sample Input 12293412553 Sample Output 1271883113137761 Author SmallBeer(CML) Source 杭电ACM集训队训练赛（VII） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;//相当于3件物品，容量为N的背包，第i件物品的重量是i//初始化: dp[0][0]=1//dp[i][j]表示用前i件物品组成j的方案数量//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;//滚动数组优化：//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;using namespace std;int temp;const int maxn=33000;//32468long long int dp[maxn];int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; memset(dp,0,sizeof(dp)); dp[0]=1; for(int i=1;i&lt;=3;i++)&#123; for(int j=i;j&lt;maxn;j++)&#123; dp[j]+=dp[j-i]; // printf(\"%lld\\n\",dp[j]); // dp[j]+=max(dp[j],dp[j-i]); &#125; &#125;// printf(\"here\");//// scanf(\"%d\",&amp;temp);// printf(\"%lld\",dp[temp]); while(scanf(\"%d\",&amp;temp)==1)&#123; printf(\"%I64d\\n\",dp[temp]); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode19_m","date":"2020-08-31T03:12:38.000Z","path":"2020/08/31/leetcode19-m/","text":"19. 删除链表的倒数第N个节点难度中等947收藏分享切换为英文关注反馈 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗 快慢指针的想法来实现: 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* l; ListNode*r; l=head; r=head; ListNode* temp; int cnt=0; for(cnt=0;cnt&lt;n;cnt++)&#123; r=r-&gt;next; &#125; if(r==nullptr)&#123; return head-&gt;next; &#125; //cout&lt;&lt;r-&gt;val&lt;&lt;endl; while(r-&gt;next!=nullptr)&#123; r=r-&gt;next; l=l-&gt;next; &#125; // cout&lt;&lt;l-&gt;val&lt;&lt;endl; l-&gt;next=l-&gt;next-&gt;next; return head; &#125;&#125;;","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode16_m","date":"2020-08-31T03:11:14.000Z","path":"2020/08/31/leetcode16-m/","text":"16. 最接近的三数之和难度中等530 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 123输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。 提示： 3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4 通过次数141,122 提交次数308,415 和leetcode15相似,主要思路还是排序+双指针 我使用了minA维护了当前的最小值,然后使用res记录和; 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: #排序: -4 -1 1 2 #minA 对于遍历到的每一个i,维护minA; #每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回; n=len(nums) if n&lt;3 or not nums: return NULL minA=sys.maxsize # INT最大值 res=minA nums.sort() for i in range(0,n-2): L=i+1 R=n-1 while L&lt;R: cur=nums[i]+nums[L]+nums[R] if cur==target: minA=0 return cur elif cur&lt;target: tempres=target-cur if abs(tempres)&lt;minA: minA=abs(tempres) res=cur L=L+1 else: tempres=cur-target if abs(tempres)&lt;minA: minA=abs(tempres) res=cur R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode15_m","date":"2020-08-31T03:06:50.000Z","path":"2020/08/31/leetcode15-m/","text":"15. 三数之和难度中等2455 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 通过次数293,697 提交次数1,016,765 还是看了题解,排序太香了！ 主要操作是排序使用双指针进行检查;同时记得去重; 12345678910111213141516171819202122232425262728293031323334class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if n&lt;3 or not nums: return res nums.sort() #从i遍历到n-2,使用双指针维护和探查; #记得去重,也就是对于相同的找最后的; for i in range(0,n): if nums[i]&gt;0: return res if i&gt;0 and nums[i]==nums[i-1]: continue #去重 L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while L&lt; R and nums[R]==nums[R-1]: R=R-1 L=L+1 R=R-1 elif nums[i]+nums[L]+nums[R]&lt;0: L=L+1 else: R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"Winter plan","date":"2020-01-22T09:17:23.000Z","path":"2020/01/22/winter-learning-plan/","text":"需要完成的目标: 线性代数复习 学习cs224n 刷leetcode 算法竞赛入门经典 目前进度: 线性代数: 1.22 cs224n 1.22 leetcode 1.22 算法竞赛入门经典","tags":[{"name":"flag","slug":"flag","permalink":"http://tyler-ytr.github.io/tags/flag/"}]},{"title":"ubuntu教程","date":"2020-01-22T08:28:15.000Z","path":"2020/01/22/ubuntu-back/","text":"反思 之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了; 重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜 复活操作基本配置 管理员权限,换源,安装vim sudo passwd(修改sudo密码) sudo apt-get update sudo apt-get install vim 更换国内源,这里我选择的是清华源用下面的命令打开文件,并且注释里面的所有内容, sudo vim /etc/apt/sources.list 然后粘贴下面的内容到打开的文件里面# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下; 安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇博客 然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义su apt-get install build-essential apt-get install man # on-line reference manual apt-get install gcc-doc # manual for GCC apt-get install gdb # GNU debugger apt-get install git # reversion control system apt-get install libreadline-dev # a library to use compile the project later apt-get install libsdl2-dev # a library to use compile the project later apt-get install qemu-system-x86 # QEMU 安装chrome:请使用bing搜索;用gmail同步很香; 科学的看世界 我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json 将下面的内容根据自己的配置放进去: { \"server\":\"my_server_ip\", \"server_port\":53450, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"密码\", \"timeout\":300, \"method\":\"aes-256-gcm\", \"fast_open\": false } 然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;自己测试一下有没有问题; 感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)： 先写一个自启动脚本： touch ~/.ssstart.sh vim ~/.ssstart.sh 内容是: #!/bin/bash ss-local -c ~/shadowsocks/shadowsocks.json 然后在终端里面起别名:vim ~/.bashrc在末尾添加:alias ss=’. ~/.ssstart.sh’:wq 保存,退出在终端里面:source ~/.bashrc(如果是zsh:source ~/.zshrc)尝试一下在终端输入ss,它lei了; 因为后面的netdata需要终端翻墙,我也就尝试了一下,如果没有需求可以跳过这一步: 主要参考的是谷歌出来的网站 首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装 下面尝试全局代理(我也不确定能不能成功)： sudo pip install genpac 选择安装配置文件的目录,我选择的是:/home/larryytr/shadowsocks 然后执行以下命令:sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 下面是一句搬运,我没有遇到过:注意：如果报错“fetch gfwlist fail.online: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 执行完之后,目录下面会有一个autoproxy.pac文件。 然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写： file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改) 然后使得终端也能使用代理。我们需要privoxy代理工具: 安装很自然:sudo apt-get install privoxy 然后编辑配置文件sudo vim /etc/privoxy/config 在文档中搜索(vim 使用/搜索)“listen-address”（即监听地址），找到如下一行：listen-address localhost:8118 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“forward-socks5t”，找到如下一行：forward-socks5t / 127.0.0.1:1080 . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy： 1sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config 最后，再配置/etc/profile： # 先进入编辑模式 sudo vim /etc/profile # 在末尾添加以下三行： export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118export ftp_proxy=http://127.0.0.1:8118 # 退出之后记得执行 source /etc/profile 验证是否成功:curl www.google.com或wget www.google.com判断是否可以访问 HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！ 优化美化 官网安装网易云 官网安装vscode 配置zsh,tmux,vim: zsh安装与美化 学习了:https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/https://segmentfault.com/a/1190000013612471这两篇教程; 感谢何伟的配置文件; 相应的setting请参考我的github相关内容. 安装zsh:sudo apt-get update sudo apt-get install zsh chsh -s /bin/zsh (设置zsh为默认) 重启你的ubuntu 安装oh-my-zsh插件: wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 不改theme一无所有 准备使用powerline主题 首先安装powerline字体： git clone https://github.com/powerline/fonts.git --depth=1 # install cd fonts ./install.sh # clean-up a bit cd .. rm -rf fonts 安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久) 安装powerline: sudo apt install powerline 我的配置见相关内容的setting .zshrc 颜色选择困难请: for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f” 改完请source ~/.zshrc tmux tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程; 我使用了何伟的配置,具体见相关内容的setting 我又加了一个插件使得tmux在重启之后状态可以恢复: 主要参考这个知乎教程 git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp 在~/.tmux.conf.local里面加上:run-shell ~/tmux_tmp/resurrect.tmux 最后载入这个配置：tmux source-file ~/.tmux.conf vim的美化 使用啦懒人vim: spf13-vim美化 请看相关内容的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh 我的配置同样在相关内容的setting里面; 这个时候的vim没有办法和系统剪切版交互,我根据https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html 下载了其他一些插件:sudo apt-get install vim-scripts vim-gtk vim-gnome这样 vim –version|grep “cliboard” 会看到 +clipboard;然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！ 其他内容: OSlab还需要: sudo apt-get install curl sudo apt-get install gcc-multilib git 配置请搜索廖雪峰 ctags 可以参考Mengzelev的博客 感谢xnr给我推荐的network来查看linux的运行情况 这是netdata的官方网站:https://github.com/netdata/netdata#user-base 但是由于GFW,安装会出现报错,事实上需要终端翻墙才行 可以通过这篇教程 sudo apt-get install net-tools ifconfig查看inet 之后的内容来得知自己的server_ip 成功之后,进入 http://127.0.0.1:19999/ (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验 相应配置可以参考这篇博客或者自己搜索 OSlab的kvm bug处理方法：https://bugzilla.redhat.com/show_bug.cgi?id=1479558chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content: KERNEL==\"kvm\", GROUP=\"kvm\", MODE=\"0666\" texlive 安装sudo apt install texlive-full 相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting) vscode的保存即编译请Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾； ubuntu的截图:我参考了这篇博客 打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+ 显然的配置好按键,然后在命令里面写gnome-screenshot -a hint:上面的命令终端输入也有效截屏的图在文件夹的图片(picture)里面; To be continued 有空再研究怎么换主题;","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hello World","date":"2020-01-20T19:20:25.723Z","path":"2020/01/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]