[{"title":"Tofino时间戳机制","date":"2024-04-19T07:37:02.000Z","path":"2024/04/19/Tofino时间戳机制/","text":"Tofino时间戳机制时间戳的作用 调试，例如确定硬件 pipeline 中某个部分的延迟 确定硬件 pipeline 的总延迟，然后通过 PTP 协议对交换机进行同步 Global Time Counter and Timestamp Information AvailableTofino 有一个全局 Time Counter，由两部分构成，分别是 48-bit Nanosecond component 和 28-bit Fractional component Tofino 芯片的全局时钟速度是 1.22GHz (TF1) 或 1.5GHz (TF2)，以 TF1 为例，每个时钟对应约 0.819ns，该值称为 Global Time Counter Increment，会在每个时钟周期增加到 Fractional component Global Time Counter Increment 的默认值通过芯片运行速度自动计算得出，但也可以由用户通过控制面修改 48-bit Nanosecond component 在 Tofino 上次 reset 时，从 0 开始计数；Fractional component 的整数部分每增加 1，Nanosecond component 就增加 1；约 3 天会 roll over 一次（约 78 小时） 时间戳也可以与现实世界的时间同步，但这需要额外硬件 全局 Time Counter 每 1ns 都会向 MAC, Parser 等硬件 block 分发时间信息，可以用来记录数据包在不同处理阶段的时间戳 因此，Tofino 芯片中不同 pipe，不同硬件 block 的时间都是同步的 从 Global Time Counter 发出的时间信息可以在 7 个地方记录 Tofino逐包时间戳 不同 TS 的采样位置： TS1(iTS) 和 TS6(eTS) 分别在 Ingress MAC 和 Egress MAC 采集，其差值代表了数据包在交换机内经历的总时长，用于更新 PTP 协议的 Correction Field 以实现更准确的时间同步 TS2 和 TS5 分别在 Ingress parser 和 Egress Parser 采集，与 TS3 / TS6 的差值代表了数据包在两处 Pipeline 中经历的时长 TS3 和 TS4 在进出 TM 时采集，代表数据包的排队时延，这部分时延是 P4 交换机中唯一会出现大幅变化的时延 TS1-TS5 自动保存在数据包的 Intrinsic metadata 中，可以直接在 P4 程序中读取： 时间戳 类型 元变量 含义 TS1 / iTS ingress_intrinsic_metadata_t bit ingress_mac_tstamp; IEEE 1588 timestamp (ns), taken upon arrival at ingress MAC. TS2 ingress_intrinsic_metadata_from_parser_t bit global_tstamp; Global timestamp (ns), taken upon arrival at ingress parser. TS3 egress_intrinsic_metadata_t bit enq_tstamp; // TF1 bit enq_tstamp; // TF2 Global timestamp (ns), taken when the packet is enqueued in the TM. TS4 (Derived) egress_intrinsic_metadata_t bit deq_timedelta; // TF1 bit deq_timedelta; // TF2 Time delta (ns) between the packet’s enqueue and dequeue in the TM. TS4 can be derived by adding TS3 and deq_timedelta. TS5 egress_intrinsic_metadata_from_parser_t bit global_tstamp; Global timestamp (ns), taken upon arrival at egress parser.","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"TNA架构手册翻译","date":"2024-04-19T06:59:51.000Z","path":"2024/04/19/TNA架构手册翻译/","text":"TNA架构手册翻译参考了手册《Extern_P416 Intel® Tofino™ Native Architecture – Public Version》 TNA架构 能够使用的Externs(部分新功能可能因为没有文档化所以表格没有)： Extern 表格 externs的直接性与间接性: Direct的extern见上表带有Direct前缀的Extern type；所有的direct extern与单个P4 表直接相连，表成为该extern的owner；它的性质是每一个direct extern都至少有一个方法能够更新其表条目，比如count() for a DirectCounter;我的理解是direct extern与表直接相关，具体作用类似于表的entery多了一个特定的域（比如用来计数）；另外只能由这些extern的owner表来调用对应的方法。 所有的indirect extern在编译之前就会确定大小N，可以理解为一个N个条目的数组；它的性质是每一个indirect extern都有至少一个方法来更新它的条目，比如execute(index) for a DirectMeter. P4程序可以通过这些方法来访问indirect extern，这些方法可以被一个table的action调用或者在P4的control的apply block里面被调用。 综上我个人的理解是，直接的extern就是一个表的属性，当然只能通过这个表调用；间接的extern是开了一个新的表，可以在其他地方被调用。 Externs使用的包的长度： Ingress中，长度包括从端口的metadata或者resubmit header之后的第一个字节到以太网帧Frame Check Sequence末尾的所有字节；因此对于从外部以太网接口接受的数据包，数据包长度始终至少为64字节，也就是最小以太网帧的长度 Egress中，长度包括了ingress deparser里面的所有字节（或者是egress deparser，如果是egress-to-egress mirror的情况）。它不包括egress intrinsic metadata. 需要注意的是 当前阶段的P4操作对于长度没有影响 Action profileAction profile的作用如下图所示： Action profile演示 该extern的主要效果是开一个动作表，给原来的table只需要该动作表的key即可； ActionProfile 接口 例子如下： Action profile例子 Action selector这是另外一种机制来把表的条目和表条目外部定义的action相关联的extern。它比action profile更强大因为提供了动态选择动作规范的功能(实际上又加了一层间接表) Action selector演示 接口如下： Action selector接口 checksum略，这块比较工程 CountersCounter是用来保存数据包计数 或/和 字节计数的机制；Counter的值只能被控制面的软件读；如果想要让counters能被P4程序读，那么应该另外用Register实现； TNA支持直接/间接的counter； Counter以及DirectCounter包含以下格式： A packet count A byte count Both a packet count and a byte count 其中byte count会按照上述的”包的长度”减去参数adjust_byte_count的值递增； Indirect Counter: Indirect Counter接口 Direct Counter: Direct Counter接口 另外还有default action与Direct Counter的讨论，（我感觉不是很有用如果用到再对手册） DigestDigest是一种把消息Digest从数据平面传到控制平面的机制 另外的传递消息给控制平面的方法是通过发包到CPU 以太网口或者CPU PCIe口；发送数据包到这些端口需要发送大部分通用的包头，可能还需要payload；每一个都作为单独的信息由控制平面进行接受和处理； Digest相对于往CPU端口发的好处： Digest信息比最小的Ethernet数据包小 Data可以被自动灵活的打包成Digest信息，不需要再以太网数据包定义头格式 TNA能够用硬件把多个digest信息合成一个大的messages，减少了控制面接受这些信息的时间； Tofino硬件有办法消除重复的摘要(digest)信息（重复指摘要信息的字段值与最近的摘要信息一样)这进一步降低了控制面软件必须处理的消息速率； 摘要信息可以包含数据平面的输入到ingress deparser的任意值； 创建digest实例的时候，程序员需要指定保存的值的类型，一般是P4 struct 类型；然后硬件就会把这些摘要内容进行序列化，保证控制平面能够区分不同摘要实例的信息； 一个TNA程序能够在ingress deparser里面初始化最多8个不同的摘要实例。每一个摘要信息可以包含至多47 bytes的数据；每次数据包执行ingress的时候最多创建一个摘要信息； 默认情况下不会产生digest;为了生成一个digest需要在digest_type字段里面设置0-7这样的数值，用该数值来选择要在摘要中发的值(考虑到最多初始化8个摘要实例，这个其实是在选哪一种)； digest_type在ingress开始执行的时候初始化。默认是无效的。如果ingress代码的某处把它进行了分配后续又要撤销的化，再digest_type字段使用invalidate函数即可； Digest是通过调用pack方法创建的；参数是digest里要包含的值。参数的类型必须与构造digest实例的时候给定的类型相同；pack方法必须包含在if语句中，并且带有条件(digest_type == constant). 案例代码： digest案例1 digest案例2 digest_type具有字段有效性(field validity)，如果是invalid，那么条件语句的结果会都是false； Hash可以对于header或者metadata的字段的任何集合计算这些值的确定性哈希函数；hash的输出可以用于任意的表达式，比如作为counter,meter以及register的索引； 另外可以作为ActionSelector的输出，用于实现ECMP LAG功能等； 接口如下： hash接口 Hash接口 支持的预定义的哈希函数: 预定义的哈希函数 另外用户可以用CRCPolynomial定义任意的CRC多项式，下表可用作哈希参数的参考: 哈希参数参考 哈希参数参考 上表中，如果Reversed=Y，那么要把CRCPolynomial的 reversed argument置为1，否则置为0； CRCPolynomial支持的参数: poly:要使用的多项式；对于幂N的多项式必须设置位N，也就是说字符串的位宽必须是N+1 init：CRC shift register的初始值，默认是0 reversed：指定要hash的数据为是否要用相反的顺序发送到执行CRC的shift register里面，true表示反着发，false表示按照正常顺序发 xor：在最后CRC计算的时候用于XOR的值，默认是0x0 msb：指示使用hash输出的最高有效位 extend：指示重复哈希输出宽度，知道达到所需要的位宽度 当使用CRCPolynomial的时候，HashAlgorithm_t的参数应该是HashAlgorithm_t.CUSTOM. 案例： Hash案例 MeterMeter提供了一个机制用于测量或者检测最近到来的数据包序列的速度何时高于或者低于配置的平均速率(或者是两个设置的速率，对于两个rate meters的情况) 当包访问meter的时候会被赋予黄色，绿色或者红色； -————————————————————————- 它根据的文档是RFC2698,该文档描述了trTCM 双速率三色标记；以下是该文档 如果数据包超过峰值速率PIR会被标记为红色，否则标记为黄色或者绿色，取决于是否超过承诺信息速率CIR。 Meter机制 主要流程就是Meter会对每一个包测速把结果反映在Marker里面 Meter可以以两种模式运行，在色盲Color-blind模式中，Meter保证数据包流在meter之前是不被染色的；在Color-Aware模式则表示数据包流在之前被预染色过； 需要设置的参数： 峰值信息速率 （PIR） 及其关联的峰值突发大小 （PBS） 和承诺信息速率 （CIR） 及其关联的承诺突发大小 （CBS）。 PIR 和 CIR 以每秒 IP 数据包的字节数来衡量;PIR必须大于CIR PBS和CBS以字节为单位，需要大于0，建议配置为大于等于流中最大可能的IP数据包的大小 Meter过程： Meter与Meter的模式以及两个速率为PIR,CIR的令牌桶P,C有关；这两个桶的最大的大小是PBS和CBS； P，C在最初是满的也就是Tp(0)=PBS,Tc(0)=CBS，在之后Tp美标递增PIR次，Tc美标递增CIR次直到他们满了 当一个大小为B的数据包在时间t到达的时候，trTCM如果是Color-blind会执行以下逻辑: If Tp(t)-B &lt; 0, the packet is red, else if Tc(t)-B &lt; 0, the packet is yellow and Tp is decremented by B, else the packet is green and both Tp and Tc are decremented by B. 如果是Color-aware模式： If the packet has been precolored as red or if Tp(t)-B &lt; 0, the packet is red, else if the packet has been precolored as yellow or if Tc(t)-B &lt; 0, the packet is yellow and Tp is decremented by B, else the packet is green and both Tp and Tc are decremented by B. 结果会存在DS dield里面；对于AF PHB，颜色可以编码为数据包的丢弃优先级 -—————————————————————————– 在TNA实现中Meter和Direct Meter包含了“color aware” and “color blind” meters.主要区别是调用哪一种execute方法； Meter的类型主要表示要测量包的字节数还是包的数量： MeterType 这里的包长度同样指的是上述定义的包长度减去参数adjust_byte_count的值 Meter的color有红黄绿三种 Meter 颜色 注意到虽然黄色有两种编码，但是TNA不会做区分； 用户自定义颜色（要用的时候看手册吧） Indirect Meter接口： Indirect Meter接口 Direct Meter接口： Direct Meter接口 Mirrormirror是一种创建包的备份以及把备份发送到指定目的地的机制。TNA支持两种mirror：ingress-to-egress和egress-to-egress; ingress-to-egress mirror 包目的地的决策是在ingress control里面做的；Mirror extern在ingress deparser里面提供了emit方法；Mirror会对于一个数据包刚刚抵达ingress parser的内容（在ingress以及ingress deparser做修改前；不会包含）做复制，Mirror extern会预置指定的mirror包头，然后把这个包发给Traffic Mangager； TM会使用一个mirror会话识别器(mirror session identifier，由emit的第一个参数指定)来查找mirror session table，这个表里面包含了一些元数据表明这个mirror的包应该发送到哪里；mirror sessions都是被控制面设置的；mirrored的包会在后去egress pipeline里面进行处理； egress-to-egress mirror 与前面相似；mirror 包这个决定是在egress 里面做的，会在egress deparser里面调用emit；和前面的主要区别是这里mirror的内容是经过egress control以及egress deparser所有修改完成之后的内容；其余一致； 当代码启动mirror操作的时候可以指定1023个mirror sessions之一；（不要使用保留的mirror session 0） 例子：如果 要支持一个p4程序发送一个数据包复制到CPU以太网口，P4程序以及控制面开发者约定用27号mirror session来实现，那么控制面软件会设置mirror session27的ucast_gress_port参数设置到CPU的以太网端口号；接着P4程序会处理这个包，使用mirror在27号session上面发送；这会让TM读27号上面的设置信息，找到等于CPU以太网号的ucast_gress_port；TM将镜像数据包排队等待 CPU 以太网端口。请注意，P4 程序无法更改镜像会话属性 TM可以最多将32字节的用户自定义包头预置到mirror数据包；Tofino支持多达8个可能的用户定义包头，每一个mirror数据包可以使用8个用户定义的包头之一； TNA的mirror可以选择mirror session以及自定义的头；这块都是emit的参数里面设置的；前者在session_id里面，后者在mirror_type里面； 为了在ingress里面mirror一个包，需要把mirror_type的值设置成1-7(来选择自定义包头)；初始化是0，0表示不适用mirror；如果在P4的某一个地方把mirror_type设置1-7的一个，然后又不想mirror了，把该值再次设置成0即可； 为了在egress里面mirror一个包，需要把mirror_type设置成0-7；在egress里面，mirror_type是用field validity的，在一开始的时候是invalid的；因此如果在某一个地方设置了mirror_type之后又不想mirror，设置mirror_type的field为invalid即可； mirror提供了两种emit方法，前者会创建一个不含用户定义包头的包，后者会根据hdr参数胜场含有用户自定义包头的mirror包 Mirror接口 另外emit方法需要包含在条件是(mirror_type == constant)形式的if语句里面； Mirror使用 if的语句数量最多是8个；如果mirror_type是invalid的，那么这个if语句的condition是false也不会创建mirror包 ParserCounter可以用于提取header stacks或者具有可变长度的包头；Tofino有一个8位带符号的计数器，可以用临时的值或者包头字段初始化；使用set初始化计数器的时候可以对于header字段执行有限数量的操作比如masking和circular rotation ParserCounter接口 RandomRandom可以提供均匀分布的伪随机数的生成；如果想要实现不是均匀的随机数，可以先生成均匀分布的随机数，然后对结果进行表查找 和/或 数学运算来达到想要的分布 Random接口 Register寄存器是stateful memories，它的值可以在P4程序的控制下在数据包转发期间进行读取和写入 Register也有indirect和direct两种； 构造Register的接口： Register接口 I表示indirect register的index的类型； T表示每一个条目的类型；条目的类型必须是bit, int, bit,int, bit, or int values, or may be pairs of one of those types 任何拥有两种相同类型字段的结构会被识别为一对；另外条目包含单个值得配型bit RegisterAction可以用来访问Register，RegisterAction包含了apply可以用来读和更新Register里面得一个条目；对于一个Register条目可以定义四个不同的RegisterAction，但是对于一个包对于给定的Register只能执行一个RegisterAction RegisterAction的apply方法需要定义一个或者两个参数；第一个inout参数表示正在读取和更新的Register条目的值，第二个可选的out是table action中调用execute方法将返回的值； RegisterAction由外部的table actions通过调用execute方法触发，这会让Stateful ALU读 特定的Register storage，运行RegisterAction代码然后把修改的值写回到相同的Register条目中；以下是最简案例： Register案例 Stateful ALU中有两个比较的ALU和四个数学/逻辑ALU 用于计算；比较的结果可以用于调节其他ALU的输出；对于给定的RegisterAction，所有的ALU都会按照相同的字节大小运行，可以是8,16,32比特；ALU的输入可以来自memory word (either half if it is a pair)或者来自either of two PHV registers accessed by the stateful ALU或者来自至多4个常数； (All Register Actions sharing a single Register also share these resources, so the compiler will attempt to efficiently pack and reuse values used by Register Actions in the same stateful ALU.)四个ALU会被组织成两对；编译器会把apply方法里面的操作调度到相应的ALU执行指定的计算；stateful ALU的可选输出必须是stateful ALU作为输入的值的副本或者写入内存的副本； 案例：通过在内存存储之前的时间戳来度量数据包间的时间戳来查找超过某个burst大小的bursts； Register案例2 上述代码体现了写RegisterAction的基本原则： 在修改内存里面的值之前始终对于它涉及的内存中的值进行测试 在代码的任何给定路径上对于每一个register 条目只进行一次修改 对于要输出的flag，在方法的顶端设置为0，当合适的时候设置为1；（见burst的修改） 如果RegisterAction 条目的类型是bit，那么大多数stateful ALU的程序性是禁止的；不允许比较以及PHV读，允许的操作只能是把这块内存bit设置成0或者1以及返回先前的bit value；一般用于更新ActionSelector或者不同的bloom filter； MathUnit Extern用来访问Tofino stateful ALU中的math unit；可以直接调用也可以进行一定的编程： MathUnit接口 MathUnit可以在RegisterAction里面被调用： 在Register里面使用Math 对于一个给定的Register只能有一个MathUnit；如果有多个RegisterAction共享一个Register那么他们只能用一个MathUnit； Resubmit包重传是一种在一个数据包上面重复ingress处理的过程； 比如说MPLS协议，在MPLS头后面不知道是IPV4头还是以太网，因此可以先过一遍parser来确定是哪一个，用resubmit header打个标然后用resubmit回传到ingress前端再处理； 所有的非resubmitted包(包括来自front panel port,CPU,packet generator,recirculated的包)在ingress parser的时候的ingress intrinsic metadata里面的resubmit_flag都是0；所有resubmitted数据包的resubmit_flag都是1； 自定义的头至多64bit（实践中，Tofino2里面支持128bit），会覆盖原来包的端口元数据；除了resubmit_flag字段以及端口元数据包头的部分之外，resubmit的包其余的部分和之前的数据包一样；另外一个数据包只能至多被resubmit一次，因为resubmit操作遇到resubmit_flag=1的数据包的时候会让它被丢掉； TNA支持最多8个不同的用户定义的resubmit header；需要在ingress control里面给resubmit_type赋值，在ingress deparser里面来选择； 为了resubmit 一个包，需要在0-7里面指定值到resubmit_type里面，resubmit_type同样拥有field validity，初始化是invalid的；如果代码某一处制定了resubmit_type后来又不想resubmit了，在resubmit_type上使用invalidate函数即可； Resubmit extern只会在ingress deparser里面初始化；它也提供了两个emit方法； resubmit接口 第一个是直接resubmit；第二个可以指定自定义类型的header； 样例代码如下，要注意emit方法只能包裹在条件为resubmit_type==constant的if语句里面； Resubmit案例 如果包被resubmitted了那么就不会发给traffic manager；在上述代码里面的emit会被调用，但是pkt的值会被丢掉； resubmit_type相关的if语句最多有8条。如果resubmit_type是invalid的那么语句的条件会返回false；","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"Tofino实现多pipeline不同程序的方法","date":"2024-04-19T06:55:10.000Z","path":"2024/04/19/Tofino实现多pipeline不同程序的方法/","text":"Tofino 实现多pipeline不同程序的方法PS：tna_32q_multiprogram的原始位置为: /home/admin/bin/bf-sde-9.7.0/pkgsrc/p4-examples/p4_16_programs/tna_32q_multiprogram本教程当前版本仅仅关心它的P4文件，控制面下表暂未探索 编译：分别编译两个文件，案例如下: 12~&#x2F;bin&#x2F;bf-sde-9.7.0&#x2F;tools&#x2F;p4_build.sh ~&#x2F;p4_program&#x2F;tna_32q_multiprogram&#x2F;program_a&#x2F;tna_32q_multiprogram_a.p4~&#x2F;bin&#x2F;bf-sde-9.7.0&#x2F;tools&#x2F;p4_build.sh ~&#x2F;p4_program&#x2F;tna_32q_multiprogram&#x2F;program_b&#x2F;tna_32q_multiprogram_b.p4 修改.conf文件: 通过第一步之后，在形如/home/admin/bin/bf-sde-9.7.0/install/share/p4/targets/tofino 的文件夹中会有.conf文件，案例中名称为tna_32q_multiprogram_a.conf和tna_32q_multiprogram_b.conf； 复制tna_32q_multiprogram_a.conf，重命名为tna_32q_multiprogram.conf 在新文件中复制tna_32q_multiprogram_b.conf的”p4_programs”中的大括号的内容到tna_32q_multiprogram.conf中，并且修改pipe_scope变量指定pipeline；注意：我们的tofino1交换机只有两个pipeline 因此应该分别为0和1； 运行：$SDE/run_switchd.sh -p tna_32q_multiprogram 这一步最后的名字和conf文件的前半部分相同。 案例中的文件 tna_32q_multiprogram_a.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;chip_list&quot;: [ &#123; &quot;id&quot;: &quot;asic-0&quot;, &quot;chip_family&quot;: &quot;tofino&quot;, &quot;instance&quot;: 0, &quot;pcie_sysfs_prefix&quot;: &quot;&#x2F;sys&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:03.0&#x2F;0000:05:00.0&quot;, &quot;pcie_domain&quot;: 0, &quot;pcie_bus&quot;: 5, &quot;pcie_fn&quot;: 0, &quot;pcie_dev&quot;: 0, &quot;pcie_int_mode&quot;: 1, &quot;sds_fw_path&quot;: &quot;share&#x2F;tofino_sds_fw&#x2F;avago&#x2F;firmware&quot; &quot;sds_fw_path&quot;: &quot;share&#x2F;tofino_sds_fw&#x2F;avago&#x2F;firmware&quot; &#125; ], &quot;instance&quot;: 0, &quot;p4_devices&quot;: [ &#123; &quot;device-id&quot;: 0, &quot;p4_programs&quot;: [ &#123; &quot;program-name&quot;: &quot;tna_32q_multiprogram_a&quot;, &quot;bfrt-config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&#x2F;bf-rt.json&quot;, &quot;p4_pipelines&quot;: [ &#123; &quot;p4_pipeline_name&quot;: &quot;profile_a&quot;, &quot;context&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&#x2F;profile_a&#x2F;context.json&quot;, &quot;config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&#x2F;profile_a&#x2F;tofino.bin&quot;, &quot;pipe_scope&quot;: [ 0, 1, 2, 3 ], &quot;path&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&quot; &#125; ] &#125; ], &quot;agent0&quot;: &quot;lib&#x2F;libpltfm_mgr.so&quot; &#125; ]&#125; tna_32q_multiprogram_b.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;chip_list&quot;: [ &#123; &quot;id&quot;: &quot;asic-0&quot;, &quot;chip_family&quot;: &quot;tofino&quot;, &quot;instance&quot;: 0, &quot;pcie_sysfs_prefix&quot;: &quot;&#x2F;sys&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:03.0&#x2F;0000:05:00.0&quot;, &quot;pcie_domain&quot;: 0, &quot;pcie_bus&quot;: 5, &quot;pcie_fn&quot;: 0, &quot;pcie_dev&quot;: 0, &quot;pcie_int_mode&quot;: 1, &quot;sds_fw_path&quot;: &quot;share&#x2F;tofino_sds_fw&#x2F;avago&#x2F;firmware&quot; &#125; ], &quot;instance&quot;: 0, &quot;p4_devices&quot;: [ &#123; &quot;device-id&quot;: 0, &quot;p4_programs&quot;: [ &#123; &quot;program-name&quot;: &quot;tna_32q_multiprogram_b&quot;, &quot;bfrt-config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&#x2F;bf-rt.json&quot;, &quot;p4_pipelines&quot;: [ &#123; &quot;p4_pipeline_name&quot;: &quot;profile_b&quot;, &quot;context&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&#x2F;profile_b&#x2F;context.json&quot;, &quot;config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&#x2F;profile_b&#x2F;tofino.bin&quot;, &quot;pipe_scope&quot;: [ 0, 1, 2, 3 ], &quot;path&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&quot; &#125; ] &#125; ], &quot;agent0&quot;: &quot;lib&#x2F;libpltfm_mgr.so&quot; &#125; ]&#125; tna_32q_multiprogram.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; &quot;chip_list&quot;: [ &#123; &quot;id&quot;: &quot;asic-0&quot;, &quot;chip_family&quot;: &quot;tofino&quot;, &quot;instance&quot;: 0, &quot;pcie_sysfs_prefix&quot;: &quot;&#x2F;sys&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:03.0&#x2F;0000:05:00.0&quot;, &quot;pcie_domain&quot;: 0, &quot;pcie_bus&quot;: 5, &quot;pcie_fn&quot;: 0, &quot;pcie_dev&quot;: 0, &quot;pcie_int_mode&quot;: 1, &quot;sds_fw_path&quot;: &quot;share&#x2F;tofino_sds_fw&#x2F;avago&#x2F;firmware&quot; &#125; ], &quot;instance&quot;: 0, &quot;p4_devices&quot;: [ &#123; &quot;device-id&quot;: 0, &quot;p4_programs&quot;: [ &#123; &quot;program-name&quot;: &quot;tna_32q_multiprogram_a&quot;, &quot;bfrt-config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&#x2F;bf-rt.json&quot;, &quot;p4_pipelines&quot;: [ &#123; &quot;p4_pipeline_name&quot;: &quot;profile_a&quot;, &quot;context&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&#x2F;profile_a&#x2F;context.json&quot;, &quot;config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&#x2F;profile_a&#x2F;tofino.bin&quot;, &quot;pipe_scope&quot;: [ 0 ], &quot;path&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_a&quot; &#125; ] &#125;, &#123; &quot;program-name&quot;: &quot;tna_32q_multiprogram_b&quot;, &quot;bfrt-config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&#x2F;bf-rt.json&quot;, &quot;p4_pipelines&quot;: [ &#123; &quot;p4_pipeline_name&quot;: &quot;profile_b&quot;, &quot;context&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&#x2F;profile_b&#x2F;context.json&quot;, &quot;config&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&#x2F;profile_b&#x2F;tofino.bin&quot;, &quot;pipe_scope&quot;: [ 1 ], &quot;path&quot;: &quot;share&#x2F;tofinopd&#x2F;tna_32q_multiprogram_b&quot; &#125; ] &#125; ], &quot;agent0&quot;: &quot;lib&#x2F;libpltfm_mgr.so&quot; &#125; ]&#125;","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"飞书机器人及反向代理配置","date":"2023-09-18T00:38:54.000Z","path":"2023/09/18/飞书及反向代理配置/","text":"飞书配置及frp反代过程记录环境及需求 公网服务器A，假设为 1.1.1.1；内网服务器B，假设为2.2.2.2；目的是公网服务器A暴露端口(23333)给飞书API，然后通过frp反代给内网服务器B的nonebot(1234端口)； 飞书及机器人配置流程 安装需要的环境，注意python3版本大于3.8; pipx及nb-cli安装: 1234python -m pip install --user pipxpython -m pipx ensurepath# 重开一个窗口pipx install nb-cli 使用脚手架创建项目: 1234567891011121314151617nb createbootstrap(初学者模式)按回车进入下一项[?] Project Name:输入你的机器人项目名称后按回车进入下一项[?] Witch driver(s) would you like to use? 使用上下方向键移动光标，空格键选择驱动器，可以多选。选中FastAPI(FastAPI驱动器)后按回车进入下一项[?] Witch adapter(s) would you like to use? 选择方式同上，选择飞书(飞书协议)后按回车进入下一项[?] Install dependencies now? (Y&#x2F;n) 是否安装依赖，输入Y选择是，按回车进入下一项[?] Create virtual enviroment? (Y&#x2F;n) 是否创建虚拟环境，输入Y选择是，按回车进入下一项[?] Which builtin plugin(s) would you like to use? 使用上下方向键移动光标，空格键选择内置插件，可以多选。选中echo后按回车完成创建# 使用如下命令可以开启.venv中的python虚拟环境source .venv&#x2F;bin&#x2F;activate 这个时候该项目实际上啥都没有；使用nb run可以运行基本的机器人; 在项目下的.env.prod中增加内容类似下面的代码: 12345DRIVER&#x3D;~fastapiFEISHU_BOTS&#x3D;FEISHU_BOTS&#x3D;[&#123;&quot;app_id&quot;:&quot;&lt;your app_id&gt;&quot;,&quot;app_secret&quot;:&quot;&lt;your app_secret&gt;&quot;,&quot;verification_token&quot;:&quot;&lt;your app_verification_token&gt;&quot;,&quot;is_lark&quot;:false&#125;]HOST&#x3D;0.0.0.0PORT&#x3D;1234LOG_LEVEL&#x3D;0 创建目录src/plugins;在里面创建demo.py: 需要pip3 install requests 12345678910111213141516171819#-*- coding: utf-8 -*-import jsonimport requestsfrom nonebot import on_commandfrom nonebot.rule import to_mefrom nonebot.matcher import Matcherfrom nonebot.adapters import Messagefrom nonebot.params import Arg, CommandArg, ArgPlainTextfrom nonebot.typing import T_Statefrom nonebot.adapters.feishu import Bot as FeishuBot, MessageEventfrom nonebot.adapters.feishu import MessageSegmenthelp = on_command(\"help\", rule=to_me(), aliases=&#123;\"help\", \"帮助\"&#125;, priority=5)@help.handle()async def handle_func(): await help.send(\"你可以尝试对我说:XXXXXXXXX\") #await help.send(MessageSegment.image(image_key=\"img_v2_11xxxxx17-f751-4e86-8f2d-43fd4b231edg\")) #这里可以写关键词命中后的业务逻辑 该插件正常表现情况是@test_bot /help返回”你可以尝试对我说:XXXXXXXXX” 在项目下创建bot.py： 123456789import nonebotfrom nonebot.adapters.feishu import Adapter as FeishuAdapternonebot.init()driver = nonebot.get_driver()driver.register_adapter(FeishuAdapter)nonebot.load_plugins(\"src/plugins/\")nonebot.run() 到此为止 除了env.prod中的部分信息需要从下一步获得之外，demo的nonebot部分基本完成； 配置飞书: 这块的流程是，在开发者平台开发应用，获得必要的配置，填到nonebot的.env中; 登录飞书开发者平台 点进开发者后台，创建企业自建应用，假设叫测试bot；！！！注意需要添加机器人功能，不然会在后面的步骤中python3 bot.py的时候出错 在开发者后台的测试bot的凭证与基础信息可以获得App ID和App Secret;可以在事件订阅获得Verification Token; 联动飞书api和nonebot: 把2中获得的信息填入到env.prod中 python3 bot.py启动机器人 在飞书的事件订阅的请求地址配置中输入:http://$HOST:$PORT/feishu/$app_id;案例中为http://1.1.1.1:23333/feishu/$app_id app_id来自于第2步;如果需要反代的话参考下面的章节做好配置 如果成功的话第3步可以配置好; 记得创建版本;然后飞书开个群，加个机器人，搜对应的名字即可; frp反代配置流程上述第3步中的请求地址需要公网服务器的地址，通过frp可以在内网服务器开发，然后暴露公网服务器地址和端口并转发内网服务器的服务; 预备工作：在公网服务器和内网服务器都下载对应的frp release; 需要配置三个地方并且相互对应: 公网服务器的frps.ini: 123456789[common]bind_port &#x3D; 4321vhost_http_port &#x3D; 23333dashboard_port &#x3D; 9999log_level &#x3D; infoprivilege_mode &#x3D; trueprivilege_token &#x3D; 复杂的密码privilege_allow_ports &#x3D; 4000-50000max_pool_count &#x3D; 100 内网服务器的frpc.ini: 12345678910111213; 参考https:&#x2F;&#x2F;learnku.com&#x2F;articles&#x2F;73370[common]server_addr &#x3D; 1.1.1.1server_port &#x3D; 4321log_level &#x3D; infoprivilege_token &#x3D; 复杂的密码[bagubot]type &#x3D; httpcustom_domains &#x3D; 1.1.1.1local_ip &#x3D; 127.0.0.1local_port &#x3D; 1234; remote_port &#x3D; 6000 飞书的事件订阅的请求地址配置:http://1.1.1.1:23333/feishu/$app_id 大概原理是公网服务器通过frpc监听和使用自己的4321端口和内网服务器通信;同时公网服务器对外暴露vhost_http_port也就是23333;可以在9999端口进入frp的后台界面; frp非后台运行: 服务端 : 1./frps -c frps.ini 客户端： 1.&#x2F;frpc -c .&#x2F;frpc.ini frp后台运行: 服务端: 1nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp; 客户端: 1nohup ./frpc -c ./frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp; 关闭: 123ps -aux|grep frp| grep -v greproot 3600 0.1 0.1 110188 9484 pts/0 Sl 15:04 0:00 ./frpc -c ./frpc.inikill -9 3600 参考博客 NoneBot对接机器人 frp内网穿透配置 nonebot官方文档 frp官方文档 nonebot飞书适配器官网文档","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"开发记录","slug":"开发记录","permalink":"http://tyler-ytr.github.io/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]},{"title":"算法模板整理","date":"2023-08-26T08:02:31.000Z","path":"2023/08/26/算法板子/","text":"算法模板与题目整理链表链表反转https://leetcode.cn/problems/reverse-linked-list/ 123456789101112ListNode* reverseList(ListNode* head) &#123; ListNode* cur = head; ListNode* prev = nullptr; while(cur != nullptr) &#123; ListNode* next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; &#125; return prev;&#125; 检查回文链表先使用快慢指针找到回文串的右部分，然后翻转右部分，再将两个链表进行比对。 https://leetcode.cn/problems/palindrome-linked-list 12345678910111213141516bool isPalindrome(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head; while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* rp = reverseList(slow-&gt;next); ListNode* lp = head; while(lp != nullptr &amp;&amp; rp != nullptr) &#123; if(lp-&gt;val != rp-&gt;val) return false; lp = lp-&gt;next; rp = rp-&gt;next; &#125; return true;&#125; 区间翻转链表假设需要翻转[l, r]，那么我们记录start=l, end=r+1, startPrev=start-1。翻转之后，startPrev-&gt;next = reversedHead, start-&gt;next = end。由于翻转之后head可能会被改变，因此需要在head前添加一个dummy节点用于找到新链表的头。 https://leetcode.cn/problems/reverse-linked-list-ii/ 1234567891011121314151617181920212223242526272829303132ListNode* reverseList(ListNode* head, ListNode* end) &#123; ListNode* cur = head; ListNode* prev = nullptr; while(cur != end) &#123; ListNode* next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; &#125; return prev;&#125;ListNode* reverseBetween(ListNode* head, int left, int right) &#123; ListNode* dummy = new ListNode(-1, head); ListNode* startPrev = dummy; ListNode* start = dummy; ListNode* end = dummy; for(int i = 0; i &lt; left; i++) &#123; startPrev = start; start = start-&gt;next; &#125; for(int i = 0; i &lt; right; i++) &#123; end = end-&gt;next; &#125; end = end-&gt;next; startPrev-&gt;next = reverseList(start, end); start-&gt;next = end; return dummy-&gt;next;&#125; 两两交换链表中的节点思路和链表的区间翻转是一样的，区间的大小为2，需要特殊考虑奇数点的情况。 https://leetcode.cn/problems/swap-nodes-in-pairs/ 12345678910111213141516171819ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(-1, head); ListNode* startPrev = dummy; ListNode* start = head; ListNode* end = head; while(end != nullptr) &#123; // 奇数个点 if(end-&gt;next == nullptr) &#123; break; &#125; end = end-&gt;next-&gt;next; startPrev-&gt;next = reverseList(start, end); start-&gt;next = end; startPrev = start; start = end; &#125; return dummy-&gt;next;&#125; K个一组翻转链表两两交换链表节点的一般情况，区间大小为k，需要考虑不足k个点的情况。 https://leetcode.cn/problems/reverse-nodes-in-k-group 1234567891011121314151617181920212223242526272829303132ListNode* reverseKGroup(ListNode* head, int k) &#123; ListNode* dummy = new ListNode(-1, head); ListNode* startPrev = dummy; ListNode* start = head; ListNode* end = head; while(end != nullptr) &#123; // 判断是否能移动k步 bool flag = false; for(int i = 0; i &lt; k-1; i++) &#123; if(end-&gt;next == nullptr) &#123; flag = true; break; &#125; end = end-&gt;next; &#125; // 无法移动k步 if(flag) &#123; break; &#125; // 可以走k步 end = end-&gt;next; startPrev-&gt;next = reverseList(start, end); start-&gt;next = end; startPrev = start; start = end; &#125; return dummy-&gt;next;&#125; 数组区间查询计算——树状数组307. 区域和检索 - 数组可修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//需要注意的是，因为利用了位运算的奇技淫巧，所以树状数组需要从1开始class NumArray &#123;public: //树状数组,https://oi-wiki.org/ds/fenwick/ vector&lt;int&gt;bit;//bit[1....n] bit[1]表示a[0];bit[2]表示a[0]+a[1]; 管辖的区间是[x-lowbit(x),x-1]; 假设管辖的数组从0开始计数 int lowbit(int x)&#123; // lowbit(0b01011000) == 0b00001000 return x &amp; -x; &#125; // bit[0]..bit[x] 中间覆盖的点的和 相当于nums[0]+...+nums[x] int pre_sum(int x)&#123; int sum = 0; while(x &gt;= 0)&#123; if(x==0)&#123; sum += bit[x]; break; &#125; sum += bit[x]; x -= lowbit(x); &#125; return sum; &#125; //单点加法，对于x加上y，更新所有的树状数组 void add(int x, int y)&#123; while(x &lt; bit.size())&#123; bit[x] += y; x += lowbit(x); &#125; &#125; //bit[left] 到 bit[right] 中间覆盖的点的和 nums[left]+...+nums[right] int get_sum(int left,int right)&#123; if(left&gt;0) return pre_sum(right) - pre_sum(left-1); else&#123; return pre_sum(right); &#125; &#125; NumArray(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); bit.resize(n,0); for(int i=0;i&lt;n;i++)&#123; bit[i]+=nums[i]; int t=i+lowbit(i);//树状数组性质:c[x]真包含于c[x+lowbit(x)] if(t&lt;n)bit[t]+=bit[i]; &#125; &#125; void update(int index, int val) &#123; int old = sumRange(index, index); add(index, val-old); &#125; int sumRange(int left, int right) &#123; return get_sum(left, right); &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ 区间查询计算——线段树307. 区域和检索 - 数组可修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//线段树class SegmentTreeNode&#123; public: SegmentTreeNode(int start,int end,int sum,SegmentTreeNode*left=nullptr,SegmentTreeNode*right=nullptr):start(start),end(end),sum(sum),left(left),right(right)&#123;&#125;; SegmentTreeNode(const SegmentTreeNode&amp;) = delete;//禁用拷贝构造函数 SegmentTreeNode&amp; operator=(const SegmentTreeNode&amp;) = delete;//禁用赋值 ~SegmentTreeNode()&#123; delete left; delete right; left=right=nullptr; &#125; public: int start; int end; int sum; SegmentTreeNode*left; SegmentTreeNode*right; &#125;;class NumArray &#123;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; _nums.assign(nums.begin(),nums.end()); if(!_nums.empty())&#123; _root=(buildTree(0,_nums.size()-1)); &#125; &#125; void update(int index, int val) &#123; updateTree(_root,index,val); &#125; int sumRange(int left, int right) &#123; return sumRange(_root,left,right); &#125;private: //线段树操作 /* build(start,end,vals) O(n) update(index,value) O(logn) rangequery(start,end) O(logn+k) k表示会被的段的数量 */ vector&lt;int&gt;_nums; SegmentTreeNode*_root; SegmentTreeNode*buildTree(int start,int end)&#123; if(start==end)&#123; return new SegmentTreeNode(start,end,_nums[start]); &#125; int mid=start+(end-start)/2; auto left=buildTree(start,mid); auto right=buildTree(mid+1,end); auto node=new SegmentTreeNode(start, end, left-&gt;sum + right-&gt;sum, left, right); return node; &#125; void updateTree(SegmentTreeNode*root,int i,int val)&#123; if(root-&gt;start==i&amp;&amp;root-&gt;end==i)&#123; root-&gt;sum=val; return; &#125; int mid=root-&gt;start+(root-&gt;end-root-&gt;start)/2; if(i&lt;=mid)&#123; updateTree(root-&gt;left,i,val); &#125;else&#123; updateTree(root-&gt;right,i,val); &#125; root-&gt;sum=root-&gt;left-&gt;sum+root-&gt;right-&gt;sum; &#125; int sumRange(SegmentTreeNode*root,int i ,int j)&#123; if(i==root-&gt;start&amp;&amp;j==root-&gt;end)&#123; return root-&gt;sum; &#125; int mid=root-&gt;start+(root-&gt;end-root-&gt;start)/2; if(j&lt;=mid)&#123; return sumRange(root-&gt;left,i,j); &#125;else if (i &gt;mid)&#123; return sumRange(root-&gt;right,i,j); &#125;else&#123; return sumRange(root-&gt;left,i,mid)+sumRange(root-&gt;right,mid+1,j); &#125; &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ 搜索排序归并排序统计逆序对例题，剑指Offer51 https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/ 123456789101112131415161718192021222324252627282930313233343536vector&lt;int&gt; temp;int reverseCount;void merge(vector&lt;int&gt;&amp; nums, int al, int ar, int bl, int br) &#123; int i = al, j = bl; int k = al; while(i &lt;= ar &amp;&amp; j &lt;= br) &#123; if(nums[i] &lt;= nums[j]) &#123; temp[k++] = nums[i++]; &#125; else &#123; reverseCount += ar - i + 1; temp[k++] = nums[j++]; &#125; &#125; while(i &lt;= ar) &#123; temp[k++] = nums[i++]; &#125; while(j &lt;= br) &#123; temp[k++] = nums[j++]; &#125; for(k = al; k &lt;= br; k++) &#123; nums[k] = temp[k]; &#125;&#125;void mergeSort(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if(l &gt;= r) return; int mid = (l + r) / 2; mergeSort(nums, l, mid); mergeSort(nums, mid+1, r); merge(nums, l, mid, mid+1, r);&#125;int reversePairs(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); temp = vector&lt;int&gt;(n, 0); mergeSort(nums, 0, n-1); return reverseCount;&#125; 快速排序求第K大例题，LeetCode216 https://leetcode.cn/problems/kth-largest-element-in-an-array/ 12345678910111213141516// 统计nums[l, r]中的第k大int findK(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; int i = l - 1; int pivot = nums[r]; for(int j = l; j &lt;= r-1; j++) &#123; if(nums[j] &gt; pivot) &#123; i++; swap(nums[j], nums[i]); &#125; &#125; swap(nums[i+1], nums[r]); // 分清楚i+1和k的关系 if(i+1 - l + 1 == k) return nums[i+1]; else if(i+1 - l + 1 &gt; k) return findK(nums, l, i, k); else return findK(nums, i+2, r, k - (i+1 - l + 1));&#125; 图论并查集样例:leetcode 990 等式方程的可满足性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//count表示连通分量的个数，这里find使用了路径压缩，注意if语句而不是while;class Solution &#123;public: //并查集 //如果是等号，那么union； //如果是不等号，那么connect返回的值应该是false； vector&lt;int&gt;parent; int count; int find(int x)&#123; if(parent[x]!=x)&#123; parent[x]=find(parent[x]); &#125; return parent[x]; &#125; void _union(int p,int q)&#123; int root_p=find(p); int root_q=find(q); if(root_p!=root_q)&#123; parent[root_p]=root_q; count--; &#125; return; &#125; bool connect(int p,int q)&#123; return find(p)==find(q); &#125; bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; for(int i=0;i&lt;26;i++)&#123; parent.emplace_back(i); &#125; count=26; for(string now:equations)&#123; if(now[1]=='=')&#123; int a=now[0]-'a'; int b=now[3]-'a'; _union(a,b); &#125; &#125; for(string now:equations)&#123; if(now[1]=='!')&#123; int a=now[0]-'a'; int b=now[3]-'a'; if(connect(a,b))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;; 树拓扑排序KruskalPrim树的直径最短路图遍历/环检测/拓扑排序例题，207.课程表；另外拓扑排序相当于后序遍历加入的值(边表示依赖)(或者翻转后序遍历的值，边表示被依赖）210.课程表 II 1234567891011121314151617181920212223242526//DFS版本// 需要注意visited和onPath的顺序，如果onPath在循环内部，那么会错过根节点// 记录被遍历过的节点vector&lt;bool&gt; visited;// 记录从起点到当前节点的路径vector&lt;bool&gt; onPath;bool hasCycle = false;/* 图遍历框架 */void traverse(vector&lt;int&gt;* graph, int s) &#123; if (onPath[s]) &#123; // 发现环！！！ hasCycle = true; &#125; if (visited[s] || hasCycle) &#123; return; &#125; // 将节点 s 标记为已遍历 visited[s] = true; // 开始遍历节点 s onPath[s] = true; for (int t : graph[s]) &#123; traverse(graph, t); &#125; // 节点 s 遍历完成 onPath[s] = false;&#125; Dijkstra例题，LeetCode743 https://leetcode.cn/problems/network-delay-time/ 12345678910111213141516171819// 初始化vector&lt;bool&gt; vis(n+1, false);vector&lt;int&gt; dist(n+1, 0x3fffffff);dist[st] = 0;// 其实遍历n-1就可以for(int i = 1; i &lt;= n; i++) &#123; // 寻找dist[u]最小且未被访问过的点 int u = -1; for(int j = 1; j &lt;= n; j++) &#123; if(!vis[j] &amp;&amp; (u == -1 || dist[j] &lt; dist[u])) &#123; u = j; &#125; &#125; // 根据dist[u]更新其邻点的dist vis[u] = true; for(auto&amp;&amp; [v, w] : g[u]) &#123; dist[v] = min(dist[v], dist[u] + w); &#125;&#125; 强连通分量例题，POJ2186（貌似不支持C++11及其以上的语法） http://poj.org/problem?id=2186 1234567891011121314151617181920212223242526272829void tarjan(int u) &#123; dfn[u] = low[u] = ++timeStamp; // 入栈 s.push(u); inStack[u] = true; for(auto&amp;&amp; v : g[u]) &#123; if(dfn[v] == -1) &#123; // 没有访问过的节点 tarjan(v); low[u] = min(low[u], low[v]); // 如果v能够到达dfn更小的点，那么u也可以 &#125; else if(inStack[v]) &#123; // v一定比u先被访问 low[u] = min(low[u], dfn[v]); // 更新v能够到达的dfn更小的点 &#125; &#125; // 缩点 if(low[u] == dfn[u]) &#123; ++sccCount; int x; do &#123; x = s.top(); s.pop(); inStack[x] = false; node2scc[x] = sccCount; ++sccSize[sccCount]; &#125; while(x != u); &#125;&#125; 二分图匹配（匈牙利算法）1274 – The Perfect Stall (poj.org) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758vector&lt;vector&lt;int&gt; &gt; g;vector&lt;int &gt; x;vector&lt;int &gt; y;vector&lt;bool &gt; vis;int n, m;bool hungary(int u) &#123; // u为X部的顶点 // v为Y部的顶点 for (int i = 0; i &lt; g[u].size(); i++) &#123; int v = g[u][i]; if (vis[v]) &#123; continue; &#125; vis[v] = true; // 如果Y部的顶点v还未被匹配，那么可以去匹配它 // 假设v匹配了X部的顶点p，且从p能找到另一个匹配q，那么x-y-p-q是一条增广路径 if (y[v] == -1 || hungary(y[v])) &#123; x[u] = v; y[v] = u; return true; &#125; &#125; return false;&#125;int main() &#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; g = vector&lt;vector&lt;int&gt; &gt;(n, vector&lt;int&gt;(m, 0)); vis = vector&lt;bool &gt;(m, false); x = vector&lt;int &gt;(n, -1); y = vector&lt;int &gt;(m, -1); for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; while (x--) &#123; int a; cin &gt;&gt; a; g[i].push_back(a - 1); &#125; &#125; int res = 0; for (int u = 0; u &lt; n; u++) &#123; // 如果X部还存在点未被匹配，那么尝试去匹配它 if (x[u] == -1) &#123; vis = vector&lt;bool &gt;(m + 1, false); if (hungary(u)) &#123; res++; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 最大流题目P3376 【模板】网络最大流 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Edmod-Karp算法 其思想是使用bfs不断地找增广路，复杂度很高 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int EdmodKarp(int source, int dest, vector&lt;vector&lt;ll&gt;&gt;&amp; cap) &#123; constexpr int maxFlow = 0x7fffffff; int n = cap.size(); vector&lt;int&gt; pre(n, -1); auto bfs = [&amp;]() &#123; queue&lt;int&gt; q; pre = vector&lt;int&gt;(n, -1); vector&lt;bool&gt; vis(n, false); vis[source] = true; q.push(source); int flow = maxFlow; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (u == dest) &#123; break; &#125; for (int v = 0; v &lt; n; v++) &#123; if (cap[u][v] &gt; 0 &amp;&amp; !vis[v]) &#123; vis[v] = true; pre[v] = u; if (flow &gt; cap[u][v]) flow = cap[u][v]; q.push(v); &#125; &#125; &#125; if (pre[dest] == -1) &#123; return 0; &#125; else &#123; return flow; &#125; &#125;; int delta = 0; int sumFlow = 0; while (true) &#123; delta = bfs(); // delta不为0说明还能找到一条从source到dest的增广路径 if (delta == 0) &#123; break; &#125; int cur = dest; while (pre[cur] != -1) &#123; int last = pre[cur]; cap[last][cur] -= delta; cap[cur][last] += delta; cur = last; &#125; sumFlow += delta; &#125; return sumFlow;&#125; Ford-Fulkerson算法 将上述EK算法的bfs寻路改为dfs，即得到Ford-Fulkerson算法 123456789101112131415161718192021222324252627282930313233343536373839404142using ll = long long;ll FordFulkerson(int source, int dest, vector&lt;vector&lt;ll&gt;&gt;&amp; cap) &#123; constexpr ll maxFlow = 0x7fffffff; int n = cap.size(); vector&lt;bool&gt; vis(n, false); auto dfs = [&amp;](int cur, int des, ll curFlow) &#123; function&lt;ll(int, int, ll)&gt; _dfs; _dfs = [&amp;](int cur, int des, ll curFlow) -&gt; ll &#123; if (cur == des) &#123; return curFlow; &#125; vis[cur] = true; for (int v = 0; v &lt; n; v++) &#123; if (cap[cur][v] &gt; 0 &amp;&amp; !vis[v]) &#123; ll flow = _dfs(v, des, min(curFlow, cap[cur][v])); if (flow &gt; 0) &#123; cap[cur][v] -= flow; cap[v][cur] += flow; return flow; &#125; &#125; &#125; return 0; &#125;; return _dfs(cur, des, curFlow); &#125;; ll sumFlow = 0; while (true) &#123; vis = vector&lt;bool&gt;(n, false); ll delta = dfs(source, dest, maxFlow); if (delta == 0) &#123; break; &#125; sumFlow += delta; &#125; return sumFlow;&#125; Dinic算法 首先使用bfs计算当前残差网络中每个节点的层次，然后使用dfs寻找增广路，要求在搜索过程中，深度为d的顶点只能走到深度为d+1的顶点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using ll = long long;ll Dinic(int source, int dest, vector&lt;vector&lt;ll&gt;&gt;&amp; cap) &#123; constexpr ll maxFlow = 0x7fffffff; int n = cap.size(); vector&lt;int&gt; depth(n, -1); auto dfs = [&amp;](int cur, int des, ll curFlow) &#123; function&lt;ll(int, int, ll)&gt; _dfs; _dfs = [&amp;](int cur, int des, ll curFlow) -&gt; ll &#123; if (cur == des) &#123; return curFlow; &#125; for (int v = 0; v &lt; n; v++) &#123; if (cap[cur][v] &gt; 0 &amp;&amp; depth[v] == depth[cur] + 1) &#123; ll flow = _dfs(v, des, min(curFlow, cap[cur][v])); if (flow &gt; 0) &#123; cap[cur][v] -= flow; cap[v][cur] += flow; return flow; &#125; &#125; &#125; return 0; &#125;; return _dfs(cur, des, curFlow); &#125;; auto bfs = [&amp;]() -&gt; bool &#123; queue&lt;int&gt; q; depth = vector&lt;int&gt;(n, -1); depth[source] = 1; q.push(source); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v = 0; v &lt; n; v++) &#123; if (cap[u][v] &gt; 0 &amp;&amp; depth[v] == -1) &#123; depth[v] = depth[u] + 1; q.push(v); &#125; &#125; &#125; return depth[dest] != -1; &#125;; ll sumFlow = 0; while (bfs()) &#123; while (true) &#123; ll delta = dfs(source, dest, maxFlow); if (delta == 0) &#123; break; &#125; sumFlow += delta; &#125; &#125; return sumFlow;&#125; 最小费用最大流题目P3381 【模板】最小费用最大流 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 在EK算法的基础上，求解增广路的同时求最短路（source到dest增广路径上的cost之和最小） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct Edge &#123; int u; int v; int cap; int cost; int next; Edge() = default; Edge(int _u, int _v, int _cap, int _cost, int _n) : u(_u), v(_v), cap(_cap), cost(_cost), next(_n) &#123;&#125;&#125;;struct Graph &#123; vector&lt;int&gt; head; vector&lt;Edge&gt; edges; Graph() = delete; Graph(int n) : head(vector&lt;int&gt;(n, -1)) &#123;&#125; void AddEdge(int u, int v, int cap, int cost) &#123; edges.emplace_back(u, v, cap, cost, head[u]); head[u] = edges.size() - 1; &#125;&#125;;int spfa(int source, int dest, int n, Graph&amp; g, vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; path, vector&lt;int&gt;&amp; costSum) &#123; constexpr int inf = 0x3fffffff; queue&lt;int&gt; q; vector&lt;bool&gt; inque(n ,false); pre = vector&lt;int&gt;(n, -1); path = vector&lt;int&gt;(n, -1); costSum = vector&lt;int&gt;(n, inf); vector&lt;int&gt; flow(n, 0); // 源点的流量初始为无穷大，cost为0 q.push(source); inque[source] = true; flow[source] = inf; costSum[source] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); // 这里是spfa求最短路，不完全是一遍bfs inque[u] = false; for (int eid = g.head[u]; eid != -1; eid = g.edges[eid].next) &#123; int v = g.edges[eid].v; int cost = g.edges[eid].cost; int cap = g.edges[eid].cap; // 松弛边 if (g.edges[eid].cap &gt; 0 &amp;&amp; costSum[v] &gt; costSum[u] + cost) &#123; // 更新到v点的最小cost之和 costSum[v] = costSum[u] + cost; // 更新到v点的最大流量 flow[v] = min(flow[u], cap); // 记录到v点的上一个点和边号 pre[v] = u; path[v] = eid; // spfa算法中v重新入队 if (!inque[v]) &#123; inque[v] = true; q.push(v); &#125; &#125; &#125; &#125; return flow[dest];&#125;int mcmf(int source, int dest, int n, Graph&amp; g) &#123; vector&lt;int&gt; pre(n, -1); vector&lt;int&gt; path(n, -1); vector&lt;int&gt; costSum(n, 0); int minCost = 0; int maxFlow = 0; while (true) &#123; // 运行一次最短路，求出增广路径上的流量 int flow = spfa(source, dest, n, g, pre, path, costSum); if (flow == 0) &#123; break; &#125; // 更新最大流量和最小费用 maxFlow += flow; minCost += flow * costSum[dest]; // 更新残差网络 int cur = dest; while (cur != source) &#123; g.edges[path[cur]].cap -= flow; g.edges[path[cur] ^ 1].cap += flow; cur = pre[cur]; &#125; &#125; cout &lt;&lt; maxFlow &lt;&lt; \" \" &lt;&lt; minCost &lt;&lt; endl; return minCost;&#125;int main() &#123; int n, m, s, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; Graph g(n); while (m--) &#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; // 正向边，capacity为c，cost为d g.AddEdge(a-1, b-1, c, d); // 反向边，capacity为0，cost为-d g.AddEdge(b-1, a-1, 0, -d); &#125; mcmf(s-1, t-1, n, g); return 0;&#125; 动态规划最长上升子序列dp(i)表示长度为i+1的上升子序列的最后一位的最小值 https://leetcode.cn/problems/longest-increasing-subsequence 123456789101112131415int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int len = 0; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; for(int i = 1; i &lt; nums.size(); i++) &#123; if(dp[len] &lt; nums[i]) &#123; dp[++len] = nums[i]; &#125; else &#123; auto it = lower_bound(dp.begin(), dp.begin() + len + 1, nums[i]); *it = nums[i]; &#125; &#125; return len + 1;&#125; 不同的子序列给定字符串s和t，计算s子序列中t出现的次数。首先在s和t前面加上一个标记字符，然后dp(i, j)表示s[1…i]的子序列中t[1…j]出现的次数。 https://leetcode.cn/problems/distinct-subsequences/ 1234567891011121314151617181920int numDistinct(string s, string t) &#123; s = \"#\" + s; t = \"#\" + t; int lens = s.size(); int lent = t.size(); vector&lt;vector&lt;unsigned long long&gt;&gt; dp(lens, vector&lt;unsigned long long&gt;(lent, 0)); for(int i = 0; i &lt; lens; i++) dp[i][0] = 1; for(int i = 1; i &lt; lens; i++) &#123; for(int j = 1; j &lt; lent; j++) &#123; if(s[i] == t[j]) &#123; dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; &#125; else &#123; dp[i][j] = dp[i-1][j]; &#125; &#125; &#125; return dp[lens - 1][lent - 1];&#125; 最长回文子序列dp(i, j)表示s[i…j]中的最长回文子序列的长度，分情况讨论s[i]是否等于s[j]即可。 https://leetcode.cn/problems/longest-palindromic-subsequence/ 1234567891011121314151617181920212223int longestPalindromeSubseq(string s) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) &#123; dp[i][i] = 1; if(i &lt; n-1) &#123; if(s[i] == s[i+1]) dp[i][i+1] = 2; else dp[i][i+1] = 1; &#125; &#125; for(int i = n-1; i &gt;= 0; i--) &#123; for(int j = i + 2; j &lt; n; j++) &#123; if(s[i] == s[j]) &#123; dp[i][j] = dp[i+1][j-1] + 2; &#125; else &#123; dp[i][j] = max(dp[i+1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[0][n-1];&#125; 数位dp树状dp例题,leetcode 834 树中距离之和,换根DP，原理是当根发生变化的时候只有部分状态需要修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//result数组保存第i个节点到所有其他节点的距离之和//dp[i] 表示以0为根节点的情况下，以i节点为根的子树中，i节点到它的子孙的距离之和//size[i] 表示i节点为根的子树的点的数量//初始情况下dp[i]=0 size[i]=1//样例中dp[0]=dp[1]+size[1]+dp[2]+size[2]=0+1+3+4=8class Solution &#123;public: vector&lt;int&gt;dp; vector&lt;int&gt;size; vector&lt;int&gt;result; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;graph,int now,int father)&#123; size[now]=1; dp[now]=0; for(int node:graph[now])&#123; if(node!=father)&#123; dfs(graph,node,now); dp[now]=dp[now]+dp[node]+size[node]; size[now]=size[node]+size[now]; &#125; &#125; &#125; void solve(vector&lt;vector&lt;int&gt;&gt;&amp;graph,int now,int father)&#123; result[now]=dp[now]; for(int node:graph[now])&#123; if(node!=father)&#123; //换根 主要原理是很多点的状态不需要修改 //首先保留原来的状态 int dp_now=dp[now],size_now=size[now],dp_node=dp[node],size_node=size[node]; //状态转移 假设以node为根，进行求解; dp[now]=dp[now]-(dp[node]+size[node]); size[now]=size[now]-size[node]; dp[node]=dp[node]+dp[now]+size[now]; size[node]=size[node]+size[now]; solve(graph,node,now); //还原现场 dp[now]=dp_now; dp[node]=dp_node; size[now]=size_now; size[node]=size_node; &#125; &#125; &#125; vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;vector&lt;int&gt;&gt;graph(n,vector&lt;int&gt;()); dp.resize(n,0); size.resize(n,0); result.resize(n,0); for(vector&lt;int&gt;_pair:edges)&#123; int u=_pair[0]; int v=_pair[1]; graph[u].emplace_back(v); graph[v].emplace_back(u); &#125; dfs(graph,0,-1);//从0这个根节点开始做预处理; solve(graph,0,-1); return result; &#125;&#125;; 字符串字典树Rabin-Karp (Hash)Knuth-Morris-Pratt数学GCD 最大公约数914. 卡牌分组，365. 水壶问题， 1071. 字符串的最大公因子 1234567int _gcd(int a,int b)&#123; //gcd(a,b)=gcd(b,a%b); if(b==0)&#123; return a; &#125; return _gcd(b,a%b); &#125; 优质算法博客 木易東 labuladong OI wiki 几乎刷完了力扣所有的堆题，我发现了这些东西。。。","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"},{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"C++多线程","date":"2023-08-20T15:23:34.000Z","path":"2023/08/20/C-多线程/","text":"C++多线程代码仓库位于multithread_example中;里面包含了一些案例: mempool_example: 包含了线程池的实现 multithread_example: 包含了C++ 多线程库的案例实现 model_example: 包含了多线程模型的实现(TOBEDONE) C++内存模型关系术语sequenced-beforesequenced-before用于表示单线程之间，两个操作上的先后顺序，这个顺序是非对称、可以进行传递的关系。 它不仅仅表示两个操作之间的先后顺序，还表示了操作结果之间的可见性关系。两个操作A和操作B，如果有A sequenced-before B，除了表示操作A的顺序在B之前，还表示了操作A的结果操作B可见。 happens-before与sequenced-before不同的是，happens-before关系表示的不同线程之间的操作先后顺序，同样的也是非对称、可传递的关系。 如果A happens-before B，则A的内存状态将在B操作执行之前就可见。在上一篇文章中，某些情况下一个写操作只是简单的写入内存就返回了，其他核心上的操作不一定能马上见到操作的结果，这样的关系是不满足happens-before的。 synchronizes-withsynchronizes-with关系强调的是变量被修改之后的传播关系（propagate），即如果一个线程修改某变量的之后的结果能被其它线程可见，那么就是满足synchronizes-with关系的。 显然，满足synchronizes-with关系的操作一定满足happens-before关系。 C++ 11 内存模型 支持以下内存模型:12345678 enum memory_order &#123; memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst&#125;; 上述一致性模型可以分为四类，从一致性约束强到一致性约束弱的顺序为: 顺序一致性:memory_order_seq_cst Acquire-Release:memory_order_acquire, memory_order_release, memory_order_acq_rel Release-Consume:memory_order_consume Relaxed:memory_order_relaxed 顺序一致性: 每个处理器的执行顺序和代码中的顺序（program order）一样。 所有处理器都只能看到一个单一的操作执行顺序。 Acquire-Release: 假设store()使用memory_order_release，而load()使用memory_order_acquire。这种模型有两种效果： 第一种是可以限制 CPU 指令的重排：在store()之前的所有读写操作，不允许被移动到这个store()的后面；在load()之后的所有读写操作，不允许被移动到这个load()的前面。 假设 Thread-1 store()的那个值，成功被 Thread-2 load()到了，那么 Thread-1 在store()之前对内存的所有写入操作，此时对 Thread-2 来说，都是可见的。 Release-Consume: carry-a-dependency: 12b &#x3D; *a;c &#x3D; *b; 其中第二行代码的执行结果依赖于第一行代码的执行结果，此时称这两行代码之间的关系为“carry-a-dependency ”。 C++中引入的memory_order_consume内存模型就针对这类代码间有明确的依赖关系的语句限制其先后顺序。相当于对于有依赖关系的部分是有先后顺序的(如同acquire)，但是对于没有依赖关系的部分是不保证先后顺序的。 Relaxed:允许乱序，只保证操作原子性； C++多线程使用C++多线程相关头文件 C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;,&lt;future&gt; &lt;atomic&gt;：该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。 &lt;thread&gt;：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。 &lt;mutex&gt;：该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数。C++14/17更新了shared_timed_mutex/shared_mutex; &lt;condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。 &lt;future&gt;：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。 Thread库下文所述，如无另外标记，默认为C++11特性 thread: 创建线程，可以传入(带参)函数，lambda表达式 join与detach thread类调用join()函数后，原始线程会等待新线程执行完毕之后再去销毁线程对象。thread::join()还会在进程结束后清理子线程相关的内存空间，此后该thread对象不再与该子线程相关，即thread::joinable() = false ,故join对一个线程而言只能调用一次 thread::detach将线程从thread对象分离出来，运行线程独立执行。当主线程结束时，由运行时库负责清理与子线程相关的资源。通常称分离线程为守护线程(daemon threads),UNIX中守护线程是指，没有任何显式的用户接口，并在后台运行的线程。(经过测试，当main()结束的时候，派生的子线程也不在运行)由于detach不像join一样会等待子线程与主线程汇聚，故要注意以下几点: 如果传递int这种简单类型，推荐使用值传递，不要用引用 如果传递类对象，避免使用隐式类型转换，全部都在创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象。 线程管理 yield：让出处理器，重新调度各执行线程;通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。 get_id: 返回当前线程的线程 id;可以以此来标识不同的线程。 sleep_for: 是让当前线程停止一段时间。 sleep_until: 使当前线程的执行停止直到指定的时间点 一次调用 call_once：即便在多线程环境下，也能保证只调用某个函数一次 once_flag：与call_once配合使用 竞争条件和临界区当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为竞争条件（race condition）。 访问共享数据的代码片段称之为临界区（critical section）。比如04_native_multithread中的sum变量。要避免竞争条件，就需要对临界区进行数据保护。 mutex库mutexmutex是mutual exclusion（互斥）的简写。 mutex有如下类型： mutex：提供基本互斥设施 timed_mutex：提供互斥设施，带有超时功能 recursive_mutex：提供能被同一线程递归锁定的互斥设施 recursive_timed_mutex：提供能被同一线程递归锁定的互斥设施，带有超时功能 shared_timed_mutex(C++14)：提供共享互斥设施并带有超时功能 shared_mutex(C++17)：提供共享互斥设施 这些类型都提供如下方法： lock：锁定互斥体，如果不可用，则阻塞 try_lock：尝试锁定互斥体，如果不可用，直接返回 unlock：解锁互斥体 在这些基础功能上，其他的类进行了如下三方面扩展： 超时：timed_mutex，recursive_timed_mutex，shared_timed_mutex的名称都带有timed，这意味着它们都支持超时功能。它们都提供了try_lock_for和try_lock_until方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。 可重入：recursive_mutex和recursive_timed_mutex的名称都带有recursive。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。 共享：shared_timed_mutex和shared_mutex提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。共享锁通常用在读者写者模型上。 共享锁有如下方法： lock_shared：获取互斥体的共享锁，如果无法获取则阻塞 try_lock_shared：尝试获取共享锁，如果不可用，直接返回 unlock_shared：解锁共享锁 通用互斥管理&lt;mutex&gt;中提供了以下类来提供通用互斥管理： lock_guard: 实现严格基于作用域的互斥体所有权包装器; unique_lock: 实现可移动的互斥体所有权包装器 shared_lock(C++14): 实现可移动的共享互斥体所有权封装器 scoped_lock(C++17)：用于多个互斥体的免死锁 RAII 封装器 这些类有以下锁定策略： defer_lock：类型为 defer_lock_t，不获得互斥的所有权 try_to_lock：类型为try_to_lock_t，尝试获得互斥的所有权而不阻塞 adopt_lock：类型为adopt_lock_t，假设调用方已拥有互斥的所有权 通用互斥管理解决的问题是手动的lock和unlock带来的繁琐和易错。标准库基于RAII思想提供了以上API； RAIIRAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。 RAII会把对象使用前请求的资源的生命周期和对象本身的生命周期绑定。它保证对象存在的时候里面的资源能被访问，并且当对象生命周期结束的时候，资源会按照获取顺序逆序释放。如果某一个资源获取失败，那么以获取的资源也会逆序释放。 RAII 可总结如下: 将每个资源封装入一个类，其中： 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常， 析构函数释放资源并决不抛出异常； 始终经由 RAII 类的实例使用满足要求的资源，该资源 自身拥有自动存储期或临时生存期，或 具有与自动或临时对象的生存期绑定的生存期 condition_variable 库&lt;condition_variable&gt;库提供了以下环境变量： condition_variable：提供与 std::unique_lock 关联的条件变量 condition_variable_any：提供与任何锁类型关联的条件变量 notify_all_at_thread_exit：安排到在此线程完全结束时对 notify_all 的调用 cv_status：列出条件变量上定时等待的可能结果 condition_variable有以下公共接口： wait 阻塞 wait_for 阻塞特定时间 wait_until 阻塞到某一个时间点 notify_one 放行一个线程，如果此时托管了多个线程，则随机抽取。 notify_all 放行所有线程。 native_handle 返回原生句柄。 future 库&lt;future&gt;库提供了以下API： async：异步运行一个函数，并返回保有其结果的std::future future：等待被异步设置的值 packaged_task：打包一个函数，存储其返回值以进行异步获取；(packaged_task绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的future来获取任务的结果。调度程序只需要处理packaged_task，而非各个函数。) promise：存储一个值以进行异步获取 shared_future：等待被异步设置的值（可能为其他 future 所引用） 使用注意点线程传参 线程传参是如果是用detach那么需要考虑主线程先结束，子线程还没有结束的情况；此时传参不建议使用引用，不可以使用指针(因为指针传过去的地址会被回收)； 建议使用创建线程的同时构造临时对象的方法传递参数(他可以保证在主线程结束前将myprint()的第二个参数构造出来，隐式类型转换再detach()则不能保证);总而言之，对于detach的thread: 若果传递内置类型的变量，建议都是按照值传递，不推荐使用引用，坚决不能用指针 如果传递类对象，避免使用隐式类型转换。全部都在创建线程这一行创建出临时对象来，并且在函数参数中使用引用来接收参数。 除非万不得已！是使用join()就不会出现局部变量失效导致线程对内存非法访问的情形。 可以使用get_ID()对构造过程进行追踪，根据thread_test_2的结果： 当使用隐式类型转换时，临时对象是在子线程中被构建的，这就会导致detach()出现问题。（主线程执行完，释放了临时变量可能导致子线程无法构造） 当创建线程使用临时对象时，临时对象是在主线程中被构建出来的，这样确保使用子线程不会出问题。 shared_ptr 线程安全 线程安全的定义： 多个线程同时访问的时候，表现出正确的行为； 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织 调用端代码无须额外的同步或者其他协调动作。 shared_ptr有两部分组成：引用计数(指向控制块的指针)和原始指针。shared_ptr的引用计数本身是安全并且无锁的；多线程环境下，调用不同shared_ptr实例的成员函数是不需要额外的同步手段的；但是，智能指针的另一个成员，原始指针不是原子的。因此shared_ptr不是线程安全的。 多线程同时读同一个shared_ptr对象是线程安全的，但是如果是多个线程对同一个shared_ptr对象进行读和写，则需要加锁。文档案例如下： Example 0: 引用计数改变 原子操作 安全1shared_ptr&lt;int&gt; p(new int(42)); Example 1: 两个线程读 安全12345&#x2F;&#x2F; thread Ashared_ptr&lt;int&gt; p2(p); &#x2F;&#x2F; reads p&#x2F;&#x2F; thread Bshared_ptr&lt;int&gt; p3(p); &#x2F;&#x2F; OK, multiple reads are safe Example 2: 两个线程写不同的shared_ptr 安全(reset()包含两个操作。当智能指针中有值的时候，调用reset()会使引用计数减1.当调用reset(new xxx())重新赋值时，智能指针首先是生成新对象，然后将就对象的引用计数减1（当然，如果发现引用计数为0时，则析构旧对象），然后将新对象的指针交给智能指针保管)12345&#x2F;&#x2F; thread Ap.reset(new int(1912)); &#x2F;&#x2F; writes p&#x2F;&#x2F; thread Bp2.reset(); &#x2F;&#x2F; OK, writes p2 Example 3: 两个线程读写一个shared_ptr 不安全：12345&#x2F;&#x2F; thread Ap &#x3D; p3; &#x2F;&#x2F; reads p3, writes p&#x2F;&#x2F; thread Bp3.reset(); &#x2F;&#x2F; writes p3; undefined, simultaneous read&#x2F;write y=x操作涉及到两个成员的操作，也就是shared_ptr中裸指针的赋值和引用计数的变化，如果没有mutex那么多线程就有race condition Example 4: 两个线程读/销毁一个shared_ptr 不安全；12345&#x2F;&#x2F; thread Ap3 &#x3D; p2; &#x2F;&#x2F; reads p2, writes p3&#x2F;&#x2F; thread B&#x2F;&#x2F; p2 goes out of scope: undefined, the destructor is considered a &quot;write access&quot; Example 5: 两个线程同时写一个shared_ptr 不安全12345&#x2F;&#x2F; thread Ap3.reset(new int(1));&#x2F;&#x2F; thread Bp3.reset(new int(2)); &#x2F;&#x2F; undefined, multiple writes 多线程无保护写可能会出现race condition: 以下场景: 有 3 个 shared_ptr&lt;Foo&gt;对象 x、g、n： 12345678910111213141516171819shared_ptr&lt;Foo&gt; g(new Foo1); &#x2F;&#x2F; 线程之间共享的 shared_ptrshared_ptr&lt;Foo&gt; x; &#x2F;&#x2F; 线程 A 的局部变量shared_ptr&lt;Foo&gt; n(new Foo2); &#x2F;&#x2F; 线程 B 的局部变量-------------------------------------------线程 Ax &#x3D; g; （即 read g） &#x2F;&#x2F;代码1 :赋值指针,赋值 引用计数-------------------------------------------线程 Bg &#x3D; n;&#x2F;&#x2F;代码2 :动作A 清空原来G指向Foo1, 动作B 然后重新赋值 Foo2测试场景：线程A 智能指针x 读取Foo1,然后还重置Foo1计数。线程 B: 销毁了Foo1线程A重置计数是，foo1已经被销毁。 见thread_test_4.cpp 执行之后会概率性的segmentation fault; 首先 shared_ptr赋值 a=b有三步，一个步骤是修改裸指针指向(1)，一个步骤是a中指向的控制块的引用计数-1(2)，一个步骤是a根据b指向的控制块赋值自己的控制块指针，并把对应的引用计数+1(3); 下面的控制块计数前面的表示Foo1,后面的表示Foo2; 阶段1:x(null,null);g(Foo1,1);n(Foo2,1);控制块引用计数为1,1 阶段2:x(Foo1,null);g(Foo1,1);n(Foo2,1);控制块引用计数为1,1 //x = g 的指针赋值部分(1) 阶段3:x(Foo1,null);g(Foo2,1);n(Foo2,1);控制块引用计数为1,1 //g = n 的指针赋值部分(1) 阶段4:x(Foo1,null);g(Foo2,2);n(Foo2,2);控制块引用计数为0,2 //g = n 引用计数修改部分(2);导致了Foo1的引用计数为0，此时Foo1会被销毁,x.ptr变成空悬指针; 阶段5:x(Foo1,3);g(Foo2,3);n(Foo2,3);控制块引用计数为0,2 // x = g 的引用计数修改部分(3); 原理可以参考该博客; 互斥锁vs自旋锁 互斥锁存在的问题是， 线程的休眠和唤醒都是相当昂贵的操作;如果互斥量仅仅被锁住很短的一段时间， 用来使线程休眠和唤醒线程的时间会比该线程睡眠的时间还长， 甚至有可能比不断在自旋锁上轮训的时间还长。自旋锁的问题是， 如果自旋锁被持有的时间过长， 其它尝试获取自旋锁的线程会一直轮训自旋锁的状态， 这将非常浪费CPU的执行时间， 这时候该线程睡眠会是一个更好的选择。 在单核/单CPU系统上使用自旋锁是没用的， 因为当线程尝试获取自旋锁不成功的时候会一直尝试， 这会一直占用CPU， 其它线程不可能运行， 因为其他线程不能运行， 这个锁也就不会被解锁。在多核/多CPU的系统上， 特别是大量的线程只会短时间的持有锁的时候， 在使线程睡眠和唤醒线程上浪费大量的时间， 也许会显著降低程序的运行性能。 使用自旋锁， 线程可以充分利用调度程序分配的时间片(经常阻塞很短的时间， 不用休眠， 然后马上继续它们的工作了)， 以达到更高的处理能力和吞吐量。 实际使用：绝大部分现代的操作系统采用的是混合型互斥锁(hybrid mutexes)和混合型自旋锁(hybrid spinlocks)。 混合型互斥锁， 在多核系统上起初表现的像自旋锁一样， 如果一个线程不能获取互斥锁， 它不会马上被切换为休眠状态， 因为互斥量可能很快就被解锁， 所以这种机制会表现的像自旋锁一样。 只有在一段时间以后(或者尝试一定次数，或者其他指标)还不能获取锁， 它就会被切换为休眠状态。 如果运行在单核/单CPU上， 这种机制将不会自旋。 混合型自旋锁， 起初表现的和正常自旋锁一样， 但是为了避免浪费大量的CPU时间， 会有一个折中的策略。 这种机制不会把线程切换到休眠态(既然想要使用自旋锁， 那么你并不希望这种情况发生)， 也许会决定放弃这个线程的执行(马上放弃或者等一段时间)并允许其他线程运行， 这样提高了自旋锁被解锁的可能性。 死锁定义 死锁：指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。称此时系统处于死锁状态或系统产生了死锁。操作系统分配策略不合理导致 饥饿：由于长时间得不到想要的资源，导致各个进程阻塞，无法向前推进；操作系统分配策略不合理导致 死循环：代码逻辑错误导致；产生死锁的必要条件 互斥条件: 只有对必须互斥使用的资源的争抢才会导致死锁；比如下面问题中的哲学家的餐叉； 不可剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。 循环等待条件：循环等待条件:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。## 产生死锁的原因竞争临界资源和进程推进顺序不当。 死锁的处理 死锁预防: 破坏互斥条件：比如把一些互斥资源改成共享的；缺点：有些资源无法共享 破坏不可剥夺条件：比如当一个进程请求新的资源得不到满足的时候就释放手头的资源，以后需要的时候再申请；或者通过操作系统强行剥夺调度；缺点：实现复杂，系统开销大可能导致饥饿； 破坏请求和保持条件：比如静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了；缺点：资源利用率低可能导致饥饿 破坏循环等待条件：比如顺序资源分配方法，先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。缺点：不方便增加新设备，资源浪费 死锁避免： 安全序列：指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。 银行家算法 死锁检测： 操作系统可以基于资源分配图的方式检测。 linux提供了Lockdep，可以协助发现死锁；lockdep可以跟踪每个锁类的自身状态，也跟踪各个锁类之间的依赖关系，通过一系列的验证规则，确保锁类状态和锁类之间的依赖总是正确的。 死锁解除： 撤消所有的死锁进程 连续撤消死锁进程直至不再存在死锁 连续剥夺资源直到不再存在死锁 把每个死锁进程备份到前面定义的某个检查点，并重新启动所有进程 多线程基本模型这部分包含了这些模型的问题；具体解决思路和代码见model_example 生产者消费者模型一个系统中，存在生产者和消费者两种角色，他们通过内存缓冲区进行通信，生产者生产消费者需要的资料，消费者把资料做成产品；具体而言: 生产者生产数据到缓冲区中，消费者从缓冲区中取数据。 如果缓冲区已经满了，则生产者线程阻塞。 如果缓冲区为空，那么消费者线程阻塞。 读者写者问题有两组并发进程：读者和写者，共享一个文件F，要求: 允许多个读者同时执行读操作 任一写者在完成写操作之前不允许其它读者或写者工作 写者执行写操作前，应让已有的写者和读者全部退出对于该问题有三种解决的方向：读者优先，写者优先，读写公平 银行家算法这是一种死锁避免的实现: 假定小城镇银行家拥有资金数量为$\\Sigma$,被N个客户共享，银行家对客户提出下列约束条件:每个客户必须预先说明所要的最大资金量;每个客户每次提出部分资金量的申请并获得分配；如果银行满足客户对资金的最大需求量，那么客户在资金运作后，应在有限时间内全部归还银行。 只要客户遵守上述约束条件，银行家将保证做到：若一个客户所要的最大资金量不超过$\\Sigma$，银行一定会接纳此客户并满足其资金需求；银行在收到一个客户的资金申请时，可能会因资金不足而让客户等待，但保证在有限时间内让客户获得资金。 在银行家算法中，客户可看做进程，资金可看做资源，银行家可看做操作系统。银行家算法虽然能避免死锁，但是在操作系统中实际应用时却很难实现，因为要求所涉及的进程不相交，即不能有同步要求，而且要知道进程的总数和每个进程请求的最大资源数，这些都很难办到。 哲学家就餐问题假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌上有五碗意大利面，每位哲学家之间各有一支餐叉。因为用一支餐叉很难吃到意大利面，所以假设哲学家必须用两支餐叉吃东西。他们只能使用自己左右手边的那两支餐叉。 问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去。 线程安全相关线程安全TOBEDONE 可重入函数TOBEDONE 参考资料 C++并发编程 现代C++教程/并行并发 C++多线程专栏","tags":[{"name":"并发","slug":"并发","permalink":"http://tyler-ytr.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"}]},{"title":"hexo部署bug","date":"2023-08-20T15:11:43.000Z","path":"2023/08/20/hexo部署bug/","text":"问题 hexo在部署的时候使用hexo -d可能会出现如下报错 1git-ssh: connect to host github.com port 22: Connection timed out 排查与解决问题A 一个排查方向是git连不上了，使用的命令是ssh -T -p 443 git@ssh.github.com；如果成功的话输出应该类似如下: 1Hi Tyler-ytr! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 如果失败的话，输出类似如下: 123ssh: connect to host github.com port 22: Connection timed out# 或者ssh: connect to host github.com port 443: Connection timed out 解决: 创建密钥，并保证在GitHub上配置了该密钥的公钥 在C:\\Users\\你的用户名\\.ssh\\config这个文件中添加类似如下的配置: 12345Host github.com HostName ssh.github.com PreferredAuthentications publickey IdentityFile ~&#x2F;.ssh&#x2F;你的密钥 Port 443 如果成功的话再次使用ssh -T -p 443 git@ssh.github.com可以成功输出;","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"拷问","date":"2023-07-23T14:48:52.000Z","path":"2023/07/23/拷问/","text":"针对C++后端/鸡架面试题汇总，感谢贡献面经的大家；数据库我不太熟可能搜集的是偏内核的题目；博客与github仓库同步更新。欢迎在仓库贡献答案发起pull request。 系统体系结构 增加CPU的数量，会对CPU密集型或IO密集型的任务性能处理有提升吗？ CPU多级缓存，为什么这么设计？ 用户态和内核态区别是什么？ 用户态和内核态切换的主要开销在哪里 同步IO和异步IO的区别，阻塞IO和非阻塞IO的区别，是否存在同步非阻塞IO？ 物理地址在cache中的映射关系 讲一讲NUMA架构 cpu缓存机制的坏处 大型系统debug中应该怎么定位问题？如果硬件缺中断怎么办？操作系统 操作系统有哪些主要功能？ 常见的系统调用？ 什么是零拷贝？ 什么是RTOS？进程管理 进程和线程区别和联系 Python/Java/C++里面的线程有什么不一样？ 时间片是什么 进程、线程、协程切换的开销分别是什么 进程通信方式；管道和socket各自使用在什么场景里面呢？ 讲讲 fork() 函数 Linux 杀死进程的过程 知道哪些信号，什么时候产生？ 什么是协程？ 讲一讲调度算法。调度算法调度的是什么？目前Linux使用的是哪一个呢？ int i;while(true){i++;} 在自己的电脑上一秒钟大概的值；怎么估算；内存管理 操作系统页面置换算法 分段机制、分页机制，缺页中断、为什么有页表 Linux为啥要做分页？缺点是什么？为什么随机读写比顺序读写慢？ 操作系统里面分配内存和管理内存，怎么做的？如果是多核的情况应该怎么优化呢？ 为什么需要虚拟内存？ malloc()底层涉及了什么系统调用？mmap和brk的区别？ 内存池怎么实现？有什么优化点？文件系统 write操作发生了什么 write的用户态内核态操作，数据要拷贝到内核态吗，如果突然宕机了会有没写的吗？怎么刷新缓冲区呢？这块系统调用是什么呢？异步情况下缓冲区啥时候落盘会不会阻塞 讲一讲怎么看文件权限？文件权限是怎么实现的？ Linux 文件描述符 vs. 文件句柄 基本的IO模型有哪些 文件描述符有哪些种类？ ext2 的 inode里面大概有哪些内容？ read操作大概会发生什么？ 包括磁盘io 磁盘驱动那块怎么做 ext2中的目录树是怎样实现的并发 什么是线程安全？ 服务器多线程如何防止数据冲突 死锁产生的条件；设计一种通用性算法，怎么检测一个死锁； 说说(Java)ThreadLocal或(C++)thread_local (Java) 多线程wait notify join 自旋锁互斥锁 读写锁，公平锁/非公平锁， 乐观锁和排他锁是什么？ 生产者消费者模式下队列读写会有死锁吗？Linux 使用 用 cat 和 grep 根据关键字查找日志 grep 查找前边的十行，用什么参数 用什么工具调试内存泄漏，怎么定位？ Git 底层 是否用过 Linux，常用命令 你觉得linux操作系统可以怎么改进 linux里netfilter的原理是什么? linux启动gui还是文本框是怎么区分的？ linux中sudo提权的原理是什么？ linux实现软路由的原理是什么？ linux login之后的程序是什么？ linux中”hello world”发生了什么？ 什么是linux RCU机制？什么是watch dog机制 什么是中断？linux硬中断的流程是什么？linux中断的时候pcb存在什么位置？什么是中断底部中断顶部？ mmap在linux底层是怎么实现的？它是怎么把虚拟地址映射到物理地址的？ socket的文件拷贝流程是怎样的？可以怎么优化呢？sendfile的原理是什么？ memset有多少次缺页？ 共享内存怎么实现 网络架构 计网分层模型 介绍一下IP/TCP的每一层，以及每一层常见的协议 当我在浏览器上输入美团的招聘网站，直到页面出现，中间的流程是怎么样的 raft可以怎么优化低两层 介绍数据链路层 CSMA/CD 协议 描述一下ARP协议 / 在同一个子网里头，如何获取主机的 MAC 地址 / 不知道 MAC 地址，是怎么转发的:网络层 ping 的原理 traceroute 的原理 2.1 如果有多条平行路由路径，怎么把这些路径都探测出来？ 常见路由算法 BGP OSPF RIP LS/DV 一台机器上有两个网卡，如果把它们的 ip 地址配到同一个网段，会发生什么问题？传输层 TCP/UDP/QUIC UDP 和 TCP 的区别，谁有队头阻塞 包格式 TCP、UDP中的报文头有哪些字段 UDP的包有大小限制，是UDP协议自己的限制的吗？（是下层的IP协议的IP包大小限制）TCP没有限制吗？ 讲一讲TCP的flag字段有哪些？rst字段作用是什么？ TCP 连接管理 三次握手； 四次挥手，各个状态，time_wait和close_wait在挥手的哪个阶段；四次挥手大量的time_wait/close_wait状态是有哪些可能的原因 为什么需要第三次的ACK应答；第三次握手没有了会发生什么问题；TCP 为什么要三次握手，而不是两次握手 四次挥手为什么多一次？如果服务端发现没有数据需要发送，FIN 和 ACK 可以合并吗，协议支持吗 心跳探测 CLOSE_WAIT是什么？你说服务器上出现closewait，那么客户端上会出现closewait吗 SYN Flood 会怎么样，如何解决？ 可靠数据传输 TCP为啥是可靠的？咋保证的呢？ UDP怎么在应用层做一些可靠性保证 拥塞控制 流量控制 快速重传/超时重传：应用层 DNS 协议的详细流程 HTTP2 跟 HTTP1 的区别，谁有队头阻塞 了解哪些开源的 RPC 框架，gRPC 的特点 https和http，https加密的过程；https为什么不是只用非对称加密，非对称加密如何实现 HTTP长连接、短连接 对于文件上传问了挺多问题的 讲讲HTTP 3 cookie 和 session 的对比 MPI用过吗？ HTTP怎么解析？Linux内核网络 使用socket()开发时，客户端服务端分别会调哪些系统调用？追问如果服务端一直不accept()会发生什么情况？ 常用的IO多路复用技术 epoll 的数据结构； tcpdump 的原理 netfilter 的原理 如何在 Linux 上实现软路由 eBPF 的原理？编译完的eBPF跨内核版本/跨机器能不能通用？ Linux内核网络中，从socket()发送数据到出网卡的流程（包括四层处理、三层路由、二层ARP、驱动） 追问三层路由：ping本地网络中的另一台主机，查询到一条/16的linklocal路由以后要干什么？回答：用ARP解析对端MAC，但是面试官不满意 继续追问：发出ping的ICMP包后，内核是否会把/32路由插入本地路由表？回答：不会，只会插入二层neighbor表，面试官表示你确定？ Linux NAPI 机制 linux网卡收包过程: 多块网卡bond的技术是什么？ 负载均衡会不会 RSS RFS啥的会不会 三次握手和socket的状态变化关系 以及如果超时了会怎么样？linux这块超时是怎么设计的RDMA 讲一讲RDMA技术的优势 讲一讲RDMA WRITE操作的细节 RDMA为什么要注册一块内存 RDMA相对于TCP/UDP的集中类型（四种） RDMA相对于TCP/UDP的性能有没有测过（这个需要测？） 这块内存会swap到磁盘上吗（这个我不会 我回答的是我们一般开大页） RDMA和TCP协议栈有哪些不同 RDMA 真实场景下延迟大概多少 PFC 机制、PFC 风暴、 PFC 死锁DPDK 介绍一下DPDK的原理；介绍一下DPDK转发数据包（从网卡进到网卡出）的完整流程 追问：DPDK驱动使用了用户态轮询的机制，和中断相比好处是什么 C++/STL/算法 哈希如何实现的；哈希的时间空间复杂度，解决冲突的方式 hash表原理，扩容，什么时候扩容，扩多大；开链法如果链表很长，你有什么解决方法 说下hashmap插入一个节点的过程 ； concurrent hashmap C++怎么实现； 加锁导致性能下降，有什么解决办法？ 加了读写锁性能还是不够，有什么方法？读写公平锁怎么做的？ 哈希算法有几种、一次性哈希、如何判断这个哈希算法优秀 map unordered_map底层实现 怎么删除map里面index是偶数的kv unordered_map 哈希表 具体实现; unordered_map怎么扩容？以及vector 怎么扩容 vector初始化的时候预备空间(就是reserve指定的玩意)大小 thread-safe的concurrent hashmap C++怎么实现； 多态、重载（编译时还是运行时）、重写、泛型 C++三个特性是哪三个？继承封装多态是什么？继承封装多态是什么？ 你觉得OOP有什么好处 虚函数表是怎么实现的？对于对象A,A继承了对象B,C它的虚函数表怎么实现？爷爷父亲孙子这种呢？ 虚函数表是为了实现运行时多态还是编译时多态？虚函数能不能 static 快速排序的特点 什么情况下复杂度高；什么是稳定排序 什么是不稳定排序 数组和链表的区别 JVM 内存划分—&gt;C++ 程序的内存划分和生命周期（类的成员变量和方法是放在哪里的） LSM vs. B+Tree；为什么B+树要把数据都放在叶子节点；这种存储相对于B树有啥优点 跳表怎么实现？它的时间复杂度呢？ 反射机制以及应用；泛型机制以及应用 类的双亲委派模型 怎么看区别一个类和别的类（类加载器+全类名） ACID解释一下 线程池参数；线程池的关闭；线程的关闭；wait/sleep的区别；核心线程数一般是多少？线程池任务调度是怎么样的 如果用红黑树，红黑树适合什么场景，他的复杂度是多少 C++20的协程了解过吗 如果让你在C++写一个线程池，你会怎么写； 线程池里的线程执行任务之后直接就退出了，怎么保证还能持续从任务队列里面拿任务 什么是 CAS，什么是自旋； mutex的实现? 自旋锁怎么实现？自旋锁和互斥锁各自适合什么场景？优缺点是什么？ C++内存屏障 什么场景下用 shared_ptr 什么场景下用 unique_ptr 讲一讲shared_ptr unique_ptr;哪一个快，shared_ptr是线程安全的吗； dfs和bfs的区别；一棵瘦高的树用dfs还是bfs LRU怎么实现 内存2g 磁盘500g 文件大小20g 每行一个数字 怎么对文件排序 悲观锁和乐观锁 类加载过程 static关键字的用处是什么？ include&lt;&gt;和include“”的区别是什么 const关键字的使用；const int *p，int * const p等组合的区别 new和malloc的区别是什么？ 动态链接静态链接区别是什么？ cpp为什么开源库的结构体要对齐成128kb 什么是好的并发算法 讲一讲完美转发 segment fault 错误的原因、有用gdb 调试coredump吗 char s = (char )malloc(100); s[100] = ‘a’ 内存实际分配在什么时候，如果物理内存不够，第一行出错还是第二行 CPP为什么开源库的结构体要对齐成128Kb C++异步IO怎么实现;future promise 原理 B+树并发算法怎么做 Extern “c”的含义是什么 用什么数据结构可以用于快速找到满足范围要求的多维数据，比如RGB三维数据表示颜色，怎么快速找到符合RGB要求的颜色; CPP atomic 内存模型 C++中纯虚函数怎么实现？父类实现了纯虚函数，子类还需要实现吗？ 数据库 说一说mysql的索引，为什么使用B+树（跟B树和hash比）B树和B+树查询有啥区别？IO上有啥区别？还有哪些索引? redis的数据结构 redis的string怎么实现的，二进制的结构是什么样子的（没回答上来） 介绍下ES，ES是做什么的，ES为什么能从doc中快速查找 mysql主键和非主键区别 2pc提交 MapReduce原理；怎么手写 mysql的火山模型 mysql左连接 右连接 内连接 全外连接 两个表，A左连接B，建立索引怎么高效 ACID解释一下；各个隔离性级别和实现；事务的隔离级别，哪一个隔离级别解决了脏读、幻读 二级索引解释一下；主索引/辅助索引； Mysql有哪些存储引擎；InnoDB和MyIsam的区别 聚簇索引 表有字段姓名 性别 年龄 班级 该怎么建立索引提高查找效率 mvcc机制 写个sql,今日消费最多的前10个人 说说 MySQL 索引（B-Tree索引、哈希索引、R-Tree索引、全文索引等等） 数据一致性检验 mysql日志：redo log、binlog、undo log 区别与作用 讲一讲bufferpool机制，是为了优化什么场景？ 中间件、微服务 消息队列作用、为什么要引入；MQ消息丢失问题 缓存穿透\\击穿\\雪崩场景解释，缓存穿透解决方法 zookeeper的作用，怎么做负载均衡基于什么理论，部署zookeeper集群对网络和机房的要求 kafka：如果leader挂了，怎么恢复任务，怎么保证数据最终一致性 负载均衡机制，负载均衡算法 设计模式 了解的设计模式，有哪些讲下策略模式 单例 懒汉饿汉模式讲一下 算法题 二叉树的右视图 岛屿数量 k个一组反转链表，自己处理输入输出 输出有效括号对 两个大整数相加；字符串给出的两个大整数相加 返回字符串 0或1组成的数组，最多允许你把k个0变成1，求变换后数组最长连续1的个数 一堆工作1-5-3-2-1 k工人 最短完成时间 m * n的二维矩阵，行列有序，找到第k个大的数。 小顶堆插入数字的调整，用数组实现一下 归并排序 走格子，上下左右走，14,23=1+4+2+3=10超过阈值k=8的走不到，问能走到多少格子 topk 一个字符串找出里面出现最多的一个字符 约瑟夫环，报数123 合并区间 实现对一个数开平方 反转链表 给二叉树的中序序列和后序序列，求前序序列 有向图找环 去除数组中的重复数字 下一个更大元素 II 将点分十进制表示的IPv4地址（本质上是一个32位二进制数）转化为一个十进制数（难崩 实操中我是用chatgpt+python做的） 二叉树的层序遍历 最大子数组和 跳台阶，可以跳 1-n 级 有序链表合并 一亿个浮点数，找到最大的10000个 算法: 实现一个能够完成定时任务的类 链表的区间反转 白板写整型转8进制，需要运行，只能使用char数组，不能使用任何库函数，得到char数组后最后返回值可以转string 快乐数 |x!*y-y-n|最小 循环数组找最小值(二分即可，关键是条件判断) 到来一个序列找中位数(维护两个堆，一个小的部分一个大的部分，保证他们的数量相差不超过1即可) 二叉树最大宽度 https://leetcode.cn/problems/maximum-width-of-binary-tree/ 两个有序数组找中位数 累加数 leetcode306 实现 memmove 库函数 实现atoi 实现inet_ntop 有一副手牌，只能打同花和顺子，输出如果能打完手牌，打出的牌的系列 给一亿个ipv4地址怎么排序；TOP100呢 kmp算法口嗨 二叉搜索树和双向链表 剑指36; 带括号的计算器实现智力题/数学题 找硬币 9个，有一个不知道轻重，最多几次 四个球中有一个是假货，只有一个天平，没有砝码，有供比较的标准球;问怎么找到假货以及知道假货是偏轻还是偏重 连续扔一枚硬币，直到连续两次正面超上，问你期望投掷次数 m 枚正品硬币，n枚次品硬币，次品硬币两面都是国徽。随手掏出一枚硬币，连续投掷r次都是国徽，问你是正品硬币的概率是多少 九辆赛车，有一条跑道可以同时比较三辆赛车；目标是找到速度前两名；请问需要几次； 64匹马比赛，每次比8匹，找出1234，最小次数 100瓶水 有一瓶是慢性毒药 请问最少需要几只老鼠","tags":[{"name":"个人总结","slug":"个人总结","permalink":"http://tyler-ytr.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"}]},{"title":"linux文件系统","date":"2023-04-25T04:57:53.000Z","path":"2023/04/25/linux文件系统/","text":"linux文件系统参考linux文件系统九讲 内核文件表inode 对于硬盘文件的表述 inode包含的部分： 必须包含: mode size reference count block addresses 可选: timestamps(atime,ctime,mtime) uid/gid minor/major device numbers 不包含: file name 文件描述符 linux的逻辑中，不同进程具有task_struct，task_struct中包含file_struct，用于表明进程打开的多个文件，file_struct中包含了file，里面有用于表明file的引用计数的原子变量f_count，表明位置的f_pos等以及inode变量f_inode；逻辑关系(linux 2.6.13)如下图: 目前的版本把file_struct中的fd二维数组解耦到了新的fdtable也就是file descripter table中； unix的文件描述分为三层: file descripter table (file descripter flags 比如FD_CLOEXEC,表示该文件描述符在执行exec后会被自动关闭；FD_NONBLOCK：表示该文件描述符是非阻塞的（non-blocking），即读取或写入操作不会阻塞进程。) dup[2]不会保留flag file entry table(w/r file offset) （file status flags 比如O_NONBLOCK 用于表示该文件表示非阻塞,读取或写入操作将立即返回，而不会等待数据就绪或写入完成。） dup[2]/fork[2]会保留flag值 inode table 两次open vs open之后dup/fork: file descripter table是每一个进程有一个的; file table和inode table是全局的 file current offest 在 file table里面;file current size在inode table里面 如果一个文件open两次，那么会有两个file table entries，每一个FD有自己的offset； 如果open之后再dup，那么会有一个file table entry，它的引用计数是2，相当于两个file descripter(FD) 指针指向同一个文件(inode的引用计数是1)； 如果是open之后再fork，那么会有两个FD指针指向同一个file table entry，inode的引用计数还是1；它们共享相同的offset；(和dup基本一致，只不过file descriptors在不同进程中) inode ext2文件系统的inode: inode的大小是128，因此1KB的block中有8个inode; 通过直接+三重间接的方式最多可以存$12+256+256^{2}+256^{3}=16843020$个文件block，也就是说文件最大的大小考虑到1KB block大约是16.063GB; 因此ext2比较适合小文件，大文件需要额外的开销; 该实现中，文件易于在尾部插入(O(1));在文件中间插入一个字节比较困难(类似于数组插入); ext4中不使用indirect blocks而是使用extent tree代替;另外使用extent(映射到连续范围的物理block)代替了direct blocks，一个extent最多可以在4KB block中映射128MB的空间;一个inode有四个extents;超过512MB的内容使用tree进行index; Ext2与Ext4对比: 使用df -i可能看到inode的使用;小文件占用inode比较多； 大文件占用storage比较多 最大文件大小: Ext4中一个文件系统能用拥有$2^{48}$的物理block，一个文件能拥有$2^{32}$的逻辑block; 从Linux系统的角度而言，inode=file；或者说inode相当于基类，它的子类有(regular file.directory,symbolic link,character device,block device,FIFO,socket); inode里面一定包含:file size,refcount,block addresses,mode,timestamps; 一定不包含:file name,file offset; 文件系统抽象(简化): 123456789101112class FileSystem&#123;public: using inode_num_t = uint32_t; explicit Filesystem(BlockDevice* dev); inode_num_t lookup(string_view path); shared_ptr&lt;Inode&gt; getInode(inode_num_t);private: BlockDevice* dev_; SuperBlock ssb_; Map&lt;string, inode_num_t&gt; dirs_; Array&lt;Inode&gt; sinodes_;&#125;; inode抽象(简化): 12345678910111213struct Inode&#123; using block_num_t = uint64_t; bool isDir( ) const;//提示文件类型 bool isFile() const; bool isSymLink( ) const; int64_t file_size; int ref_count; block_num_t getBlockNum(uint32 idx); bool appendBlock(block_num_t blk);#dev private: vector&lt;block_num_t&gt; blocks; // two ways&#125;; 目录 unix 层次文件系统的五大亮点: 层次化文件系统，可以支持目录和子目录 万物皆文件(文件，设备等使用相同的接口) 能够起进程的能力(fork) shell 很多子功能 比如make等; 目录过去以链表的形式实现: 如图所示.是本目录,..是父目录，然后用链表连接entry，里面包含了文件名和inode(i1就表示inode); 可以理解为: 123struct Directory&#123; list&lt;pair&lt;inode_num_t,string&gt;&gt; entries;&#125;; 在ext2中，目录项可以理解为如下结构: 1234567struct ext2_dir_entry_2&#123; _le32 inode;// Inode number _le16 rec_len;// Directory entry length_u8 name_len;// Name length _u8 file_type;// New in v2 char name[];// File name, up to 255&#125;; 下面的命令造成的效果如图: 123mkdir testtouch hellomv hello muduo mv操作会在后面空闲的pad中创建muduo，然后把hello那部分释放; 移动指针的方式: 1de=(ext2_dirent *) ((char *) de + rec_len);//相当于next ext2使用16bit来指示目录中的引用数，这给文件数量带来了限制；另外因为使用链表实现目录，也给数量带来了限制；一个目录下大概可以有10-15k个文件； 另外目录是不会收缩的，可见的里面会有很多碎片；因此rsync(1)会在复制文件前创建好所有的目录，从而减少大目录的碎片 打开文件(open (“./chen/shuo/hello.txt”))的ext2的调用树(ftrace生成): Ext4目录: 使用哈希表代替了链表; 123struct Directory&#123; HashMap&lt;string,inode_num_t&gt; entries;&#125;; 目录API： fcntl.h: open(2); unistd.h:read(2)/write(2)/close(2) &lt;sys/stat.h&gt;:fstat(2) 可以对目录open(2)或者fstat(2)；但是read(2)会返回EISDIR；因为目录的格式是和文件系统相关的，不同的格式不一样； 要读的话使用用户态的:&lt;dirent.h&gt;：opendir(3)/fdopendir(3)/readdir(3)/closedir(3); 这部分会调用getdents64(2);从而获得给用户看的目录信息，格式如下: 1234567struct dirent &#123; ino_t d_ino;// Inode number off_t d_off;// Not an offset; uint16_t d_reclen;// Length of this record uint8_t d_type; // Type of file; char d_name[256];// Null-terminated filename&#125;; 其他的api：scandir(3),rewinddir(3),telldir(3); 磁盘布局 Ext2 中 block group每一个为8M或者128M(取决于block大小);每一个block group中的内容如下: 其中，group 0和group 1是一样的，从而备份super group; group 2里面的布局就是一般的存放数据的block的布局; block bitmap与block的数量相关，因为其中的一个bit对应一个block； group 0中的group descripter的结构如下: 12345678910//Structure of a blocks group descriptorstruct ext2_group_desc ll sizeof(*this) == 32&#123; u32 bg_block_bitmap; // Blocks bitmap block u32 bg_inode_bitmap;//Inodes bitmap block u32 bg_inode_table;//Inodes table block u16 bg_free_blocks_count;// Free blocks count u16 bg_free_inodes_count;// Free inodes count u16 bg_used_dirs_count;// Directories count&#125;;//处于group 0 中; 创建500M文件系统rev.1 image的命令案例: 1234dd if=/dev /zero of=m580M bs=1M count=500mkfs.ext2 m580M# 查看信息:dumpe2fs m500M 创建一个文件系统并且mount的案例: 12345dd if=/dev/zero of=ext2.img bs=1M count=500mkfs.ext2 -r 0ext2.imgsudo mount ext2.img /mnt / smal#copy files to it, then umountdebugfs -w ext2.img 1000MB，4KB block，256000 blocks，32768 blocks per group，8 groups；256B inode，16 nodes per block，8000 inodes per group，500 inode blocks per group案例： Ext4上述配置的案例: super block: 12345678910111213141516171819/**Structure of the super block*/struct ext2_super_block &#123; __u32s_inodes_count;/*Inodes count*/ __u32s_blocks_count;/*Blocks count */ __u32 s_r_blocks_count;/* Reserved blocks count */ //下面这两个会很容易产生竞争，因为与文件创建有关系； __u32 s_free_blocks_count;/*Free blocks count */ __u32 s_free_inodes_count;/* Free inodes count*/ __u32s_first_data_block;/* First Data Block */ __u32 s_log_block_size;/*Block size */ __s32 s_log_frag_size;/*Fragment size */ __u32 s_blocks_per_group; /*#Blocks per group */ __u32 s_frags_per_group;/*# Fragments per group*/ __u32 s_inodes_per_group;/*#Inodes per group */ //...&#125; Magic Numbers: Ext2/Ext3/Ext4: 0xEF53 UFS1/UFS2: 0x19540119 (Marshall Kirk McKusick的生日) 根据inode以及super block的参数就可以定位inode的位置: 123456789ino &gt; 0,0 is invalid value.group = (ino-1) / inodes_per_group //得到groupoffset_in_group = (ino-1) % inodes_per_group //inode是group中的第几个block = group_descs[group].bg_inode_table + offset_in_group / inodes_per_block //其实就是起始偏移量加数量;offset_in_block = offset_in_group % inodes_per_block //block的第几号struct ext2_inode inodes[inodes_per_block];//inode缓冲区dev-&gt;readBlock(block, inodes); //把对应的block读到结构体数组中return inodes[offset_in_block];//得到inode; 案例: Ext2和Ext4对比: Ext2/Ext4中inode的最大数量是$2^{32}$,因为inode number是32-bit; 文件的数量一般在创建文件系统的时候固定为:block size/ inode size; 文件名的长度:255; 每一个inode的链接的数量:i_links_count是16-bit，对于Ext2为32000，对于Ext4为65000，这限制了每一个目录里面的子目录数量; Ext2中因为是线性搜索所以对目录里面的条目有限制，否则会效率大大降低；Ext4支持一个目录中有上百万个文件； 补充：Linux文件权限在Linux操作系统中，每个文件和目录都有三种不同的权限：读取权限、写入权限和执行权限。这些权限是用来控制不同用户对文件和目录的访问权限的。 具体来说，每个文件和目录都有一个所有者（owner）和一组用户组（group），还有其他用户（others）。每个用户可以被分配到这些角色之一，以确定他们对文件和目录的访问权限。 这些权限用数字或者字母表示，分别是4(r)、2(w)、1(x)。数字4表示读取权限，数字2表示写入权限，数字1表示执行权限。这些数字可以组合在一起来表示所有者、用户组和其他用户的权限。例如，数字755(rwxr-xr-x)表示所有者(4+2+1=7)有读取、写入和执行权限，用户组(4+1)和其他用户(4+1)只有读取和执行权限。 数字与字母符号的对应关系表格如下: 数字 字母符号 权限 0 — 没有任何权限 1 –x 执行权限 2 -w- 写入权限 3 -wx 写入和执行权限 4 r– 读取权限 5 r-x 读取和执行权限 6 rw- 读取和写入权限 7 rwx 读取、写入和执行权限 使用ls-l的时候可以显示文件和目录的权限，第一个字符表示文件类型（d表示目录，-表示常规文件），后面的9个字符表示文件的权限，其中前三个字符表示所有者的权限，中间三个字符表示用户组的权限，最后三个字符表示其他用户的权限。例如: 12-rw-r--r-- 1 user user 4096 Apr 30 23:00 example.txtdrwxr-xr-x 2 user user 4096 Apr 30 22:59 example-dir 补充：Linux权限管理linux操作系统有严格linux操作系统有着严格、灵活的权限访问控制。主要体现在两方面：1、文件权限2、进程权限文件权限：文件除了r,w,x之外还有s,t,i,a权限。具体可以参考博文 进程是用户访问计算机资源的代理，用户执行的操作其实是带有用户身份信息的进程执行的操作。进程id有以下三种： RUID - 真实用户ID，标识运行程序的用户 EUID - 有效ID，告诉内核进程的特权 SUID - 当进程更改其UID时使用的保存用户ID可以使用如下命令查看进程的用户id:123ps -C test_id -o pid,tty,ruser,user,cmd PID TT RUSER USER CMD3250 pts&#x2F;1 joe root .&#x2F;test_id 在文件权限和进程权限id里，s文件权限和euid权限id是sudo实现提升权限的根本。一个进程是否能操作某个文件，取决于进程的euid是否拥有这个文件的相应权限，而不是ruid。也就是说，如果想要让进程获得某个用户的权限，只要把进程的euid设置为该用户id就可以了。在具体一点，我们想要让进程拥有root用户的权限，我只要想办法把进程的euid设置成root的id：0就可以了。 Linux提供了一个seteuid的函数，可以更改进程的euid。函数声明在头文件里。1int seteuid(uid_t euid); 但是，如果一个进程本身没有root权限，也就是说euid不是0，是无法通过调用seteuid将进程的权限提升的，调用seteuid会出现错误。 那该怎么把进程的euid该为root的id：0呢？那就是通过s权限。 如果一个文件拥有x权限，表示这个文件可以被执行。shell执行命令或程序的时候，先fork一个进程，再通过exec函数族执行这个命令或程序，这样的话，执行这个文件的进程的ruid和euid就是当前登入shell的用户id。 当这个文件拥有x权限和s权限时，在shell进行fork后调动exec函数族执行这个文件的时候，这个进程的euid将被系统更改为这个文件的拥有者id。 比如，一个文件的拥有者为user_1，权限为rwsr-xr-x，那么你用user_2的文件执行他的时候，执行这个文件的进程的ruid为user_2的id，euid为user_1的id。 创建一个main.c文件，并写入如下代码：12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc, char* argv[])&#123; printf(&quot;ruid: %d\\n&quot;,getuid()); printf(&quot;euid: %d\\n&quot;,geteuid()); return 0;&#125;编译代码1gcc .&#x2F;main.c -o .&#x2F;main编译运行，结果如下：12ruid: 1000euid: 1000通过chmod和chown为文件更改拥有者和添加s权限12sudo chown root .&#x2F;mainsudo chmod +s .&#x2F;main再次运行，结果如下：12ruid: 1000euid: 0此时由于文件的s权限，euid已经变为了root的id：0 将代码修改如下：12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int maind(int argc, char* argv[])&#123; printf(&quot;ruid: %d\\n&quot;,getuid()); printf(&quot;euid: %d\\n&quot;,geteuid()); if(execvp(argv[1], argv+1) &#x3D;&#x3D; -1)&#123; perror(&quot;execvp error&quot;); &#125;; return 0;&#125;编译1gcc .&#x2F;main.c --o main执行如下命令123sudo chown root .&#x2F;mainsudo chmod +s .&#x2F;main.&#x2F;main apt update可以看到，已经成功运行apt并进行了软件列表的更新。 查看sudo的权限1ls -al &#x2F;usr&#x2F;bin&#x2F;sudo输出如下1-rwsr-xr-x 1 root root可以看到，sudo就是一个拥有者为root且拥有s权限的可执行文件。 当然sudo的实现要比这复杂的很多，比如sudo通过检查配置文件，来决定哪些用户可以使用sudo，为了安全考虑sudo还要求验证ruid的用户密码等。 总结：如果文件拥有s权限，那么可以让使用者拥有创建该文件的用户的权限；sudo的原理之一就是root用户是sudo的创建者并且sudo程序文件拥有s权限。","tags":[{"name":"linux","slug":"linux","permalink":"http://tyler-ytr.github.io/tags/linux/"}]},{"title":"Infiniband Network Architecture 阅读笔记","date":"2022-12-19T13:47:01.000Z","path":"2022/12/19/RDMA原语编程笔记/","text":"核心概念 Infiniband的优势： 支持大量协议：包括通过IB光纤的非IB协议的隧道包，例如IPv6、Ethertype包； 高带宽，吞吐量可实现2.5Gb/s，10Gb/s，30Gb/s； 低延时，应用程序时延 &lt;3us； 高可扩展性的拓扑结构； 非特权应用发送接收信息时，内核不用进行特权模式的切换； 每个信息都由CA（通道适配器）的硬件DMA直接传输，而不用处理器的参与，也就是RDMA； 大部分协议都可以在芯片上实现，减少软件和处理器的负荷。 一些专业术语： 处理器节点（processor Node）：一组或多组处理器以及其内存，并通过主机通道适配器（HCA）与IBA光纤连接，每个HCA都有一个或多个端口； 端口（port）：IBA设备与IBA链路连接的双向接口； 链路（link）：用于两台IBA设备的两个端口间的双向高速连接。具体应用中以serdes实现，单条链路的传输速率可达2.5Gb/s，250MB/s的吞吐率（由于serdes中8b/10b的原因）。此外，还可以用4条或12条链路，达到1GB/s和3GB/s的吞吐率； 通道适配器Channel Adapter（CA）：每个CA port在配置时就具有唯一地址，当一个CA必须发送信息或者读取信息时，首先需要发送一个请求报文，该报文带有destination port ID，通过交换机和路由器的帮助，CA最终抵达目标CA。 IO单元与IO控制器（IOU and IOC）：IOU的组成包括，连接到IBA的目标通道适配器；一个或多个IO控制器提供的IO接口，其实现形式会是一个大量的存储矩阵； 子网：一些有相同子网ID和相同的子网管理器的端口和链路的集合。 子网管理器（SM）会在子网启动时发现所有设备，配置它们，并在后续周期性检查子网的拓扑结构是否被修改； 在配置过程中，子网管理器会为每个端口配置一个独有的本地ID和一个相同的子网ID，用以标识子网和端口位置； 能交换数据包的所有的CA、路由器端口以及交换机端口都可以被叫做在同一个子网下； 子网间可以通过路由器进行相互连接。 报文：详细见之前的博客；报文是用来在两个CA之间发送请求（request）或者响应（response）信号，一个报文的有效荷载（payload）部分最大可以包含4KB数据。CA如果需要发送的报文大于此长度，需要对此进行切分，分为多个包传输。每个报文分为payload、路由报文头（header）、CRC校验等；header包括本地路由头部(LRH)，全局路由头部（GRH），基础传输头部（BTH） 系统案例： 当一个请求报文由CA发送后，会有以下两种情况： 源CA和目标CA直接连接：这种情况下，报文通过唯一链路，对头部中的DLID信息解码后直接找到目标CA port，目标CA接受请求后，并作出对应处理； 源CA和目标CA非直接连接：请求报文不能直接抵达目标CA，所以其需要先前往交换机或者路由器的port。 交换机和路由器规则： 交换机规则：负责在同一子网内报文的路由，根据DLID查找交换机内部的转发表（由软件在启动阶段配置），确定报文需要从交换机的哪个端口输出。（一个报文在抵挡目标CA前可能需要经过多个交换机） 路由器规则：当源CA和目标CA不在同一子网下，请求报文会带有GRH。交换机会在子网下不断路由报文，直到抵挡路由器的一个port，然后路由器根据GRH：DGID确定目标CA在哪个子网下，与交换机类似，路由器内部存在路由表。（一个报文在抵挡目标CA前可能需要经过多个交换机） 报文传输类型 IB协议中的消息传递是建立在CA间的，其本质是CA间的内存空间进行数据交换。 三类消息传输： 从本地CA的内存传输信息到目标CA的内存; 信息发送操作：请求信息不会通知CA数据该写到哪块内存中，而是对端CA自行决定数据的存放地址； RDMA写操作：请求报文会指定数据需要写到对端CA的哪块内存中，报文包括了有效荷载，请求报文的内存起始地址、报文长度和允许该RDMA写操作的一个密钥。 从目标CA的内存读取信息，并存储在本地CA的内存中; CA向对端CA发出读指定内存中数据的请求，对端CA接收该请求后，会返回一个或多个响应报文，请求端将返回报文中的数据存储到指定内存中。 对目标CA的内存执行原子操作（读/改/写），并将返回的数据存储在本地CA的内存。 原子读取和加法操作：收到请求后，目标CA从其本地的指定内存中读取数据，将Add值与读取数据相加，并将结果写回本地内存。目标CA将读回的初始值以原子响应包的形式返回给请求端CA。收到响应数据包后，请求端CA将读数据写入自己的本地内存； 原子比较和交换操作：收到请求后，目标CA从其本地的指定内存中读取数据，将读取的数据与Compare值比较，若相等，将值写入指定位置，返回的响应操作与上述加法原子操作一致。 Single packet &amp; Multiple packet： IBA标准中最大包的长度限制为4KB，大约4KB的信息并非不能传输，而是需要拆分为多包传输（multiple packet）。 如果信息总长在4KB~8KB，multiple packet将分为Send First操作与Send Last操作； 如果信息总长大于8KB，将分为Send First、Send Middle和Send Last操作，其中，非第一包和最后一包的数据都为Send Middle操作。 # 属性与管理器 略 QP：消息传递机制QP是一个双向的消息传输引擎 每一个CA实现数量多达$2^{24}$对QP；QP包含两个队列： 发送队列：软件将消息传输请求(WQE)发送到SQ，执行时，SQ将出站消息传输请求发送到对端QP的RQ； 接收队列：软件将工作请求(WQE)发送到此队列，以处理通过对端QP的SQ传输到RQ的不同类型的入站消息传输请求。 QP的SQ会以一系列的，一个或多个请求包的形式向远端QP的RQ传输消息传输请求; 根据QP类型，远端QP的RQ可以通过向对应的SQ发送一系列的，一个或多个响应数据包来响应接收到的消息传输请求。 报文序列号PSN： SQ生成的每个请求包都包含一个PSN，收到请求数据包后，RQ将验证数据包是否与期望的PSN (ePSN)一致。 与之对应的，RQ生成的每个响应包都包含一个PSN，该PSN将它与从远端SQ接收到的请求包关联,SQ收到每个响应包时， 将验证包的PSN是否与之前发出的请求相关联。 QP服务类型 可靠连接 RC（Reliable Connected）QP； 非可靠连接 UC（UnReliable Connected）QP； 可靠数据报 RD (Reliable Datagram) QP； 非可靠数据报 UD (Unreliable Datagram) QP； 类似与隧道包，对非IBA协议的包进行封装的 RAW QP。 QP类型RC QP特性 建立QP 初始化本地CA的端口号用于发送接收信息； 初始化QPN，用来指示远端CA的RC QP 初始化远程 RC QP 所在的远程 CA 端口的端口地址 私有的传输信道： RC QP只会和对端的RC QP接受和发送信息 Ack/Nak协议： 如果成功接受并且执行了Send和Write请求的话会返回Ack包 以下情况会返回Nak： RNR Nak（Receiver Not Ready）;这种情况发送方的QP可能会持续的重复发送请求包直到悲成功执行或者达到发送方的重传计数 PSN Sequence Error Nak；这种情况意味着一个或者多个包丢失了；这里会倒回并且重传直到远端接收到了或者重传次数耗尽； Fatal Nak error code；如果远端QP的RQ逻辑在请求包或者试图执行的时候触发了错误；这种情况不会尝试重传，错误会被报告给发送端软件； RDMA Read Reponse packet：这是RDMA Read请求的回复；一般以一系列，一个或者多个RDMA Read Response包进行返回； Atomic Response packet：这是原子请求的回复，请求的数据会以一个单独的Atomic response 包返回； reliable的原因： 远端QP的RQ逻辑会对于每一个请求包确认PSN来保证信息的请求报文都是按照顺序接受的，并且没有遗漏；如果请求报文接受超过一次那么只会执行一次（有一个例外：在接收到重复的内存读的请求之后数据会再次从内存读取）； 发送端QP的SQ逻辑会对于每一个请求报文检查应有的回复；如果接收到RNR Nak或者PSN Sequence Error Nak，SQ逻辑无需软件就能自动尝试恢复； 带宽利用：由于会产生Ack和Nak，该协议会占用大量的IBA带宽； 信息长度：每一个信息包含0-2GB的数据 UC QP 特性 建立QP： 初始化本地CA的端口号用于发送接收信息； 初始化QPN，用来指示远端CA的UC QP 初始化远程UC QP 所在的远程 CA 端口的端口地址 私有的传输信道： UC QP只会和对端的UC QP接受和发送信息 无Ack/Nak协议：对于所有的请求不保证被对端QP RQ逻辑正确接受； 带宽利用：因为不产生Ack、Nak所以UC协议相对于RC协议显著减少了带宽消耗； 消息长度：每一个信息包含0-2GB的数据 RD( Reliable Datagram) QP 特性 通用的(传输信道)： RD QP能够和任意数量的RD QPs发送和接受数据；实现的原理是它在本地CA和一个或者更多的远端CA之间建立一个或者更多的“通道”；”通道“称作Reliable Datagram Channel (RDC)； QP发送的请求包中包含对于本地CA中的RDC的信息转发请求；RDC经过编程会发送和接受通过一个特定本地CA端口的所有包；The RDC is also programmed with the address of a port on the remote CA behind which the other end of the RDC resides, as well as the address of the otherend of that RDC. 多目的地的传输信道： RD QP可以对于其他CA的多个RD QPs发送和接受信息 Ack/Nak协议：和RC的这部分一样 带宽利用：由于会产生Ack和Nak，该协议会占用大量的IBA带宽； 消息长度：每一个信息包含0-2GB的数据 UD QP 特性 通用： UD QP能够与任意数量的其他UD QPs发送和接受数据，并且每一个请求报文接收到之后不需要Ack或者Nak 对于本地CA端口的QP Bound：软件初始化之后，UD QP会在本地CA上面初始化，并且附有一个用于接受和发送信息的端口号；在这之后，它只能通过该端口和远端UD QPs发送和接受信息 多目的地的传输信道： UD QP可以对于其他CA的多个UD QPs发送和接受信息 无Ack/Nak协议 带宽利用：因为不产生Ack、Nak所以UD协议相对于RC,RD协议显著减少了带宽消耗； 消息长度：传输的消息的长度不能超过单个数据包的载荷； Raw QP Raw QP用于与不是IBA协议的例如IPv6或者以太网协议发送和接受信息；交换机与路由器需要保证能把他们传到最终目的地 QP的SQ和RQ逻辑QP的SQ逻辑 处理软件传入的work requests；一旦一个WR被传给SQ，它就会被认为是WQE，work queue entry；这些WQE会被QP的SQ逻辑一次一个的按照他们传入的顺序进行处理； 处理WR的传输，也就是如果请求数据包发送方期望ACK那么SQ的逻辑会等待Ack报文，当接收到的时候检验顺序的正确性以及他们没有错误 处理带内的RDMA读响应报文的数据；这些数据根据SQ WQE里面的指针写入到CA本地内存中 处理带内的原子请求返回的数据项；同样这些数据会根据SQ WQE里面的指针写入到CA本地内存中 QP的RQ逻辑 当接收到请求包的时候检验PSN是期望的PSN(expected PSN,ePSN); 当接收到请求包的时候，如果请求包的接收者期望ACK，那么RQ逻辑会发送ACK报文给远端的QP的SQ逻辑；Ack的PSN和被确认的那个请求包的PSN相同 如果请求包是Send，那么请求报文的数据负载会使用当前位于RQ顶部的WQE指定的Scatter Buffer List写入CA的本地内存；在收到Send的最后一个或者唯一的数据包之后，RQ逻辑会从RQ中停用顶部条目；此外它会将一个完成队列条目CQE发布到与QP的RQ关联的CQ里卖弄；如果可选的32位及时数据值存在于最后一个或者仅有的Send请求包中，那么RQ逻辑会把及时数据值存储于新发布的CQE中； 如果请求包是Write；那么请求的数据包负载会更具RDMA写请求的第一个请求报文中提供的指针写入到CA的本地内存中； 如果请求包是最后一个或者唯一的Write并且该数据包含有可选的32位及时(immediate)数据值，RQ可以会停用顶端的条目，另外会发布一个CQE到关联与QP的RQ的CQ中并且在这个CQE中存储刚刚的及时数据值； 如果请求是一个Read，那么QP的RQ逻辑会根据RDMA Read请求报文中提供的起始内存地址来读取数据；折后这些数据会通过一系列一个或者多个RDMA Read响应报文发回远端QP的SQ中； 如果请求是一个原子操作，那么RQ逻辑会根据报文中指定的地址在本地内存中执行操作，并且把在该位置读取的数据返回给远端QP的SQ逻辑； Verb layer 是操作系统-独立的API我认为这里的Verb layer指的就是Send，Receive，Write，Read等动词； 对于每个verb，规范定义了: 输入的参数 返回结果，输出的参数 verb的操作类型 这里verb layer能够触及HCA 硬件接口（例如寄存器组）来通过HCA达成想要的动作；另外，Verb layer还能够： 在需要的时候调用操作系统；例如它可以调用OS的内存管理器，为verb或者HCA的使用分配物理内存； 必须通过verb调用请求的操作，才能访问主存。例如，在特定的操作系统环境中，软件应用可以在主存中构建一个消息传输工作请求(WR)，然后执行Post Send Request verb调用，将WR发布到QP的SQ中进行处理。它将在主存中提供WR的起始地址作为Post Send Request verb的输入参数之一，然后verb将访问主存以读取WR，将WR发送到目标QP的SQ。 QP Context中定义了QP的可选特征在使用QP进行发送或接收信息前，软件会先创建一个QP，并提供一些其在发送、接收过程中需要用到的特征。 以RC类型的QP为例，QP Context大致会包含以下内容： 本地端口号（在QP创建时确定）； QP类型；（包括RC,UC,RD,UD,Raw） SQ开始PSN（SQ发送的第一包插入开始PSN，后续实时更新current PSN）； RQ期望PSN（RC协议里面会检查到来的包的PSN是不是下一个期望的PSN，如果不是会返回PSN Sequence Error Nak；如果正确则返回Ack）； 最大payload尺寸（0.25KB、0.5KB、1KB、2KB、4KB，也被称作path maximum transfer unit，PMTU；这里PMTU相当于从起点到目的地经过的路径中的MTU最小值）； 目标端的本地ID；（指的是远端QP所在的CA的端口的destination local ID address） 期望的本地QoS；（可以通过指定所需要的服务级别(SL)来指示所需要的QoS，这是一个4-bit的值用于决定从源端口发送的速度；另外交换机也会查看SL值来确定数据包以多快的速度转发） 报文注入延迟（IPD；因为链路的宽度不同，内部报文延迟也不同，防止快速链路的流量超过较慢链路的流量，QP会附一个IPD来定义将数据包发送到目标IP之间必须遵守的间隔）； 本地应答超时（指定时间内没收到ack报文，即为应答超时，需要重发对应报文）； Ack timeout/丢包重传计数； RNR重传计数；（值由远端QP在两个QP第一次建立的时候提供，定义了SQ在接收到远端QP的RNR Nak之后重传的次数；远端QP在临时没法处理请求的时候会发送RNR Nak；典型的例子是接收到了请求数据包但是没有WOE发布到接收方的RQ中来处理这个请求） 源端口本地ID；（设置软件会给端口分配基本LID地址以及能够从该地址开始的LIDs数量；QP的SQ逻辑发送请求数据包给它分配的端口来传输的时候需要给端口指示要在数据包的SLID字段插入的LID地址，指示的方法是通过给出相对于基本LID地址的偏移；当QP设置的时候，它会被编程到RC,UC或者UD QP的QP上下文里面，称为Source Path Bits） 全局的源端/目标端地址；（如果目标CA和源CA不在一个子网，那么数据包就必须包含Global Router Header(GRH)，因为数据包需要经过一个甚至更多的路由来到达目标CA；GRH包含了源端口的128-bit的Source Global ID(SGID)以及目标CA端口的128-bit的Destination Global ID(DGID)） DGID：当QP设置的时候，软件需要提供远端QP所在的目标CA的DGID；然后这个DGID地址会插入到之后的每一个该QP的SQ逻辑产生的请求数据包里面 SGID： 首先，每一个端口至少有一个设备制造商分配给它的64位GUID地址，该GUID地址存在于端口的GUIDInfo属性的条目0里面；SM可以使用条目1到n来给这个端口分配额外的GUID； 然后SGID的前64位是由端口的64位子网ID(GIDPrefix属性)提供的；设置RC,UC或者UD QP的时候，软件将指示哪一个本地端口的GUIDs会插入到QP生成的每一个数据包的SLID字段里面；此信息以端口的GUIDinfo属性提供给QP上下文； 额外的全局地址信息： Traffic Class(TClass): 此值指示请求数据包跨多个子网到达目标 CA 端口想要的 Qos Flow Label: 如果非0的话，那么要求路径上的所有路由器保证具有相同流标签值的所有数据包按照正确的顺序传递给目标CA端口 Hop Limit: 路径上每一个路由器都会降低Hop Limit。如果耗尽就会丢掉这个包； QP传输实例实例场景 都是RC服务类型的QP； SQ PSN起始地址在CA X为100，CA Y为2000； 两个QP刚刚创建并且还没有发送任何包 RQ 期望PSN CA X为2000，CA Y为100； 需要发送的信息为5KB，报文payload最大尺寸限制为2KB； Ack重传计数为7，RNR重传计数为7； Source CA与destination CA在同一子网下； 发送端示例 1. Posting the Message Receive Request在CA X 的QP的SQ逻辑会在本地内存读一个5KB的信息然后发送给目标的QP的RQ逻辑；在接收到信息之后，RQ逻辑会用当前发布到RQ的顶端的WQE来确定在它本地内存的哪一个位置写接收到的数据；因此第一步是CA Y预先往本地QP的RQ里面发一个WR，以下是软件执行的步骤： 通过场外手段协商得知到来的包大小或者先不决定包大小，第一个包来了返回RNR Nak，然后往CA的寄存器设置标志位来指示发布一个WR来处理预期的重传；然后对应的软件就会触发中断，检查状态，往指示的QP的RQ发布报文来处理重传； 场景假设是在接受第一个请求报文之前发布WR，这里在CA Y的软件通过执行 Post Receive Request verb 来发布WR，传入的WR有以下输入参数： QP handle用来指示往哪一个QP发布；（这个由调用Create QP 返回） 一个特定的64-bit WR ID；该WR ID将存放在CQE里面；CQE会在所有的信息写入到CA T的本地内存之后再RQ的CQ里创建； 操作类型：Receive Scatter Buffer List，用于指示写带内数据的位置； 在接受到WR之后，Post Receive Request verb 会让WR发布到QP的RQ的下一个条目上；此时WR可以称为WQE(Work Queue Entry) 2. Posting the Message Send Request软件通过如下步骤让QP的SQ传信息到另一个CA的QP的RQ中： 首先在本地内存里创建信息； 通过调用 Post Send Request verb ，并传入具有以下参数的WR： Create QP 返回的 QP handle 一个特定的64-bit WR ID 操作类型：Send Gather Buffer List来指明要发送的5KB信息的本地内存地址 可选的32位临时数据值；在接收到5KB 信息之后，远端CA的QP的RQ逻辑会把这个值存在它在QP关联的CQ里面创建的CQE中；该值可以用来提醒响应的软件有关其收到的信息的性质； 接收到WR之后， Post Send Request verb会让WR发布到QP的SQ的下一个条目上；此时WR可以称为WQE。 ### 3. 发送第一个请求报文 SQ开始处理顶层条目，WQE指定一个多个包的Send操作，将5KB消息从HCA本地内存发送到对端CA的QP； SQ检查QP Context中的PMTU来决定请求报文的最大数据大小，在本例中，SQ会选择前2KB数据作为第一个请求报文发送； SQ在第一包的Opcode内容中填入Send first，向对端RQ表示，该包是第一发送包，(对端在接收到Send last包之前是不知道Send操作的长度的) SQ往PSN字段填入发送逻辑的cPSN(当前PSN)，因为是起始，以及上述案例条件所以是100； SQ根据QP context内容设置DestQP字段； SQ将请求包转发到端口X进行传输时，向端口提供基本LID地址的偏移量，以替代包的SLID； SQ将第一个请求包内的DLID设置为目标CA端口的QP的DLID，DLID来自QP Context； SQ根据QP context内容设置服务等级(Service Level)； 如果请求操作中存在全局ID，SQ需要在第一包中插入GRH（但在本例中不需要）； Send操作的第一个请求包被发送到网络层，然后转发到HCA端口(X)的链路层。此外，SQ还做以下工作: 将nPSN从100更新到101，这是将在发送的下一个请求包中插入的PSN。 等待收到“Send First”请求包的对应Ack包。 形成下一个请求包发送到链路层进行传输。 当从网络层接收到第一个报文后，端口的链路层将： 在端口的base LID上加入偏移，并将此LID插入在请求报文中的SLID中； 如果目标CA和源CA不在同一子网下，会生成一个128-bits的SGID； 在配置过程中，SM设置了端口的SLtoVLMappingTable属性表，将16个可能的SL值映射到特定的链路层传输缓冲区。SM还建立了一个仲裁方案，为每个传输缓冲区分配一个重要级别。定义了传输缓冲区以什么顺序将数据包传输到端口的物理层； 请求包被发布到链路层选择的传输缓冲上； 当该VL传输缓冲区进行报文传输时，端口的链路层将请求报文转发给端口的物理层进行传输。数据包的VL字段标识了各自的VL接收缓冲区，该缓冲区将在与该端口连接的物理链路的另一端接收数据包。 从X链路层端口流出的请求报文将根据serdes的规范，编码为10-bits的串行流； 请求包经过一个或多个链路，最后到达目标端口。每个交换机查找内部转发表，并根据包内的DLID确认向何处转发； 目标QP端口对从物理层收到的数据解串行化，恢复8-bits数据流，并传递给链路层； 链路层解析包内的DLID项，确定数据前往哪个端口; 链路层将数据传输到数据包指示的VL接收缓冲区； 请求包转发至网络层； 网络层根据DestQP项将数据传递到对应RQ； RQ将请求包的PSN与ePSN比较，确定是否出现丢包（如果PSN为之前请求包范围内的PSN，代表是一个重复包，不需要响应其动作，但要回复ack）； RQ将检查包的opcode，确认是否需要WQE将报文写入CA Y的本地内存中。如果opcode是send或RDMA write with Immediate操作，那么需要RQ有一个WQE。如果RQ当前没有发布WQE，则需要返回对端SQ一个RNR NAK包； RQ逻辑检查opcode确保有效，比如这里应该是”Send first”而不是”Send Middle”或者其他；若有效则继续执行 RQ返回一个Ack包给发送端的QP的SQ逻辑；SQ的处理在下一个部分”First Ack Packet Returned”； RQ逻辑使用在RQ顶部的WQE信息确定数据包的载荷应该写的内存的位置； 使用来自RQ WQE的Scatter Buffer List把请求报文的数据载荷写入本地内存 RQ逻辑更新RQ WQE里面的指向剩余内存部分的内存指针（也就是下一个Send操作包应该写的位置）； RQ逻辑更新自己的ePSN为ePSN+1(这里为ePSN=101s)，并且等待下一个包 4. 第一个Ack报文返回在接收到”Send First”报文之后，接收端RQ逻辑会往请求方发送一个Ack包，Ack包的PSN和”Send First”请求包的PSN一致；Ack的传输如下： 接收端的QP的RQ逻辑将ack包发送到网络层，然后转发至端口的链路层 Ack报文不包含数据载荷层；而是包含了一个Acknowledge opcode和Acknowledge Extended Transport Header(AETH)层；opcode暗示这是一个ACK报文，AETH中包含了ACK报文的信息: positive Ack或者 Negative Ack(Nak)，如果是Nak的话，会包含Nak的原因； Ack的DestQP中装载了QPN用于指定请求的QP 在本案例中AETH暗示了这是一个positive Ack Ack中使用的SL需要和请求报文里面的SL一致 请求包中的SLID和DLID在Ack包中是相反的（源–目的调换） 接收端端口的链路层借助Ack报文中的SL值，对于SLtoVLMappingTable进行查表来决定使用链路层的哪一个VL(Virtual Lane) transmit buffer来发送Ack报文 Ack报文发送到指定的VL transmit buffer中 当VL transmit buffer轮到该Ack报文的时候，端口的链路层把Ack报文转发到物理层进行传输；Ack报文的VL字段显示了另一端的物理层（要么是交换机端口要么是对端CA的目标端口）应该接受这个Ack报文的VL receive buffer Ack报文的链路层的8-bit 字节流在物理层编码成了10-bit字符然后转换成序列比特流在线上传输 Ack报文经过一或多条链路直到到达目标端口 目标端口的物理层对数据进行解序列，从10-bit字节解码成8-bit字节，并且转发给端口的链路层 链路层解码逻辑解码DLID字段确定自己就是目标端口 链路层接受Ack包字节流到VL receive buffer里面，这个buffer是由Ack报文的中的VL值指定的； Ack报文转发到网络层 网络层把Ack报文发给SQ逻辑； SQ逻辑通过AETH来确定是positive Ack还是Nak；本例中是前者； SQ逻辑比较Ack报文的PSN来确定属于以下哪种情况： Ack报文的PSN和最老的unAck的请求报文的PSN相等（本例为100）；在本例中属于该情况，因此会把unAck的窗口的底端往后挪一个（本例为101） Ack报文的PSN&gt;SQ的起始PSN但是比最老的unAck报文的PSN小，此时属于重复的Ack报文 Ack报文的PSN比最老的unAck的请求报文的PSN大但是小于发出的请求报文的最高的PSN Ack报文的PSN小于SQ的起始PSN或者大于发出的请求报文的最高的PSN（意味这这是一个不合法的Ack数据包） 5. 发送’Send Middle’ 请求报文，然后Ack返回需要注意的是请求方的QP的SQ逻辑在发送下一个请求包前不会等待刚刚发送的请求包的Ack 请求方QP的SQ逻辑会如下继续: 使用SQ顶端的条目，它会利用在SQ顶端的WQE的Gather Buffer List从内存中读取2KB数据 调整WQE的读指针 把PSN(101)放到”Send Middle” 请求报文中 把请求报文传给请求方的QP。它的opcode是”Send Middle” 在接收到请求报文之后，接收端的QP采取如下行为： 接收方QP逻辑比较请求包的PSN(这里是101)和它当前的ePSN(这里是101)： 如果PSN=ePSN，那么继续执行 如果包的PSN&gt;ePSN，那么RQ逻辑会给远端QP的SQ逻辑发送一个PSN Sequence Error Nak数据包，并且不会执行包请求的操作 如果包的PSN处于先前接受过的PSN范围内，那么RQ逻辑不会重新执行包的请求，但是会安排一个Ack返回； RQ逻辑会检查包的opcode来保证这是有意义的，比如这里应该是”Send Middle”或者”Send Last” 而不是”Send First”; 数据包的2KB载荷会根据顶端RQ WQE的Scatter Buffer List指针写入到CA的内存中； RQ逻辑会更新该指针； RQ逻辑更新ePSN到ePSN+1(102)； 接收端的RQ逻辑会生成一个发向请求端的SQ的Ack报文，PSN与请求报文的PSN一致；如果这个Send操作有更长的信息就会重复上述动作； 6. 发送’Send Last’ 请求报文请求端的QP的SQ逻辑继续以下动作： 利用在SQ顶端的WQE的Gather Buffer List从内存中读取最后1KB数据，放入包的载荷中 请求包的PSN是102 发送带有opcode为”Send Last”的请求包 在接收到”Send Last”请求包之后，接收方的QP的RQ逻辑执行以下步骤： 接收方RQ逻辑比较到来的请求包的PSN和ePSN，处理逻辑和上一节一致 RQ逻辑会检查包的opcode来保证这是有意义的 数据包的1KB载荷会根据顶端RQ WQE的Scatter Buffer List指针写入到CA的内存中； 这个信息的所有数据包都被接受并且写入内存了，然后RQ逻辑会更新ePSN到ePSN+1，等待下一个信息的第一个请求数据包； 让RQ顶端的WQE“退役”，在RQ对应的CQ中创建一个CQE，包含了这个信息接受操作的状态；另外如果”Send Last”操作中包含了ImmDtETH(Immediate Data Extended Transport Header)信息，那么会在CQE中存储这个32-bit的数据 完成了对于这个信息的接受 当CQE发布到和任何QP的SQ或者RQ有关联的CQ的时候，CA会生成一个中断 7. 返回Final Ack接收端的QP的RQ逻辑生成一个positive Ack包发送给请求段的QP的SQ逻辑；Ack的PSN(102)与”Send Last”请求报文一致；当Ack到达请求端的SQ逻辑的时候，SQ执行以下动作： SQ逻辑验证Ack报文的AETH字段确定它是positive Ack还是Nak，案例中是positive Ack 由于Ack “ack” 了”Send Last”请求报文，SQ逻辑执行以下动作： 让SQ的顶端的WQE”退役” SQ对应的CQ中创建一个CQE，包含了对于这个发送操作消息的完成状态 这就完成了消息发送操作； 传输类型略 IB协议的信息传输操作介绍 发送消息的方式：IB网络中，消息传输的流程是：软件通过执行Post Send Request往请求方QP的SQ发送一个Work Request; 接受Send和RDMA Write With Immedaite的方式：接收方的软件需要通过执行Post Receive Request来往接收方QP的RQ发送一个WR； Send Queue(SQ)的操作类型有以下五类： Send：从本地指定内存中获取数据，发送给对端RQ，对端RQ顶端的WR将指示RQ接收的数据该存到哪块内存中；该操作支持所有QP服务类型； RDMA Read：SQ发起读请求，对端RQ接收请求后，读取指定内存中数据并返回，SQ接收所需数据后，写入本地内存；仅支持RC和RD； RDMA Write：将本地数据写到对端指定内存中（RDMA write和Send的区别在于，Send前往对端的数据是由RQ顶端的WR来决定数据的存放位置，但是RDMA Write是由发送方提前将存放位置确定并指示RQ的）；仅支持RC,UC和RD； Atomic RMW：当某任务需要连续访问同一块内存时，需要保证在这期间禁止别的任务对这一内存进行修改，在IBA中，使用一个状态标志，表示内存数据是否处于不可修改状态； Memory Window Bind 另外比较大的信息会被分片成多个数据包 ，因此传输一个信息的状态如下： 单个包 两个包：一个”First”，一个”Last” 三个及以上 一个”First” 大于等于一个的”Middle” 一个”Last” BTH如下图所示: Packets Opcode 详情可见书81-84 SQ动词类型及操作Send 操作略 Read操作 RDMA Read 操作 RDMA Read操作是请求对端从内存读数据然后发回请求方，具体操作如下： 被读取方CA在本地构建一个信息 向SQ发布Send操作，CA通过软件向对端CA通知，本地信息已经可以读取；需要向另一个CA提供如下信息： 本地内存的起始virtual memory address（VA）； Remote access key（R_Key），RDMA读权限（包含了区域长度以及该区域的权限，例如这里只能读不能写）； 可被读取的数据大小 读取方CA接收到上述信息之后向SQ发送WR，里面确定了： VA R_key Scatter Buffer List ，用于指定内存buffer用于写入即将读取的数据； 要读取的数据大小 执行SQ WQE，SQ会携带3中的信息，组成RDMA read请求包； 对端RQ通过包中R_Key信息，验证该请求是否得到权限； 如果R_Key验证正确，RQ会从指定内存读取数据，并组成响应包返还给SQ； SQ收到响应包，并利用Scatter Buffer List将payload写入内存； SQ完成全部传输后，弹出WQE，创建一个CQE； PS:需要注意的是响应方的QP不需要往RQ里面发布一个WQE来处理READ请求 软件发布RDMA READ WR的时候需要提供以下参数： QP的handle RDMA read操作类型； Scatter buffer list以及其中的元素个数；其中的每一个元素都定义了本地内存的起始地址以及它的长度； 目标的相应QPN以及Q_key(RD使用) RC中不使用Q_key 相应的QPN存在请求方的QP中 VA 虚拟地址 R_key(Remote access key) 数据长度 READ操作支持RC和RD 数据包内容： 请求数据包：BTH中有OPCODE，此时为RDMA Read Request；RETH(RDMA Extended Transport Header)中包含了VA,R_Key以及创数长度；数据包不包含数据载荷 响应数据包： 如果数据载荷小于等于PMTU，那么只会有一个RDMA Read Response包 BTH中的Opcode：RDMA Read Response Only 数据载荷的大小是0-PMTU bytes; 相应包的PSN和请求包PSN一样 如果数据载荷可以放到两个相应包里面： 第一个包BTH的opcode是RDMA Read Response First；数据载荷包含了PMTU bytes，PSN和请求包的PSN一样 第二个也就是最后的请求包的opcode是RDMA Read Response Last；数据载荷大小是1-PMTU bytes；它的PSN比请求报文大一 如果数据载荷需要三个及以上的数据包 第一个包BTH的opcode是RDMA Read Response First；数据载荷包含了PMTU bytes，PSN和请求包的PSN一样 中间的包的opcode是 RDMA Read Response Middle；数据载荷包含了PMTU bytes，PSN比之前的包大一 最后的包的opcode是RDMA Read Response Last；数据载荷包含了1-PMTU bytes；PSN比之前的数据包大一 另外，在发出请求之后，请求者QP的SQ可以发出额外的RDMA读请求(或其他类型的消息传输请求)，不需要等待之前请求的读数据返回。但有一个例外：在RD服务类型中，SQ可能不会开始下一个消息传输，直到完全确认前一个消息传输。 如果响应端QP的RQ支持多个未完成的Atomic或RDMA Read操作，则它将接收到的每个请求按先进先出的顺序存储在特定队列中；FIFO的深度在连接建立阶段进行协商： 任何一次针对响应端QP的未完成RDMA读请求的最大数量在连接建立时协商； 响应端QP可以将一个连接限制为一个未完成的RDMA读请求，换句话说，这个队列的最小深度可能只有一个条目。 Write操作 RDMA Write 操作 RDMA Write操作是请求方逻辑向响应方内存通过RDMA Write request写入数据，具体步骤如下： 响应方CA预先准备好数据以及准备好访问这块内存的R_Key 通过Send操作，响应方CA把如下信息发送给请求方CA来告诉对方哪些区域准备好接受信息： VA R_key 内存区域长度 请求方CA接收到上述信息之后，发布RDMA Write WR到本地QP的SQ中，WR指定了如下内容： VA R_key Gather Buffer List，这里面指定了大于等于一个的本地内存buffer，里面包含了要SQ逻辑被读取的数据 要写的数据大小 可选的：32-bit immediate 数据项，这会放在信息的最后一个包的ImmDtETH中 请求方的SQ逻辑发起第一个RDMA Write请求报文到响应方的RQ逻辑；第一个报文包含了RDMA ETH，里面制定了VA,R_key，信息长度(最大2GB)；另外如果整个信息包含在这一个包中并且WR指定了可选的32-bit immedaite数据项，那么此时的Opcode是RDMA Write Only With Immedaite，并且包含ImmDtETH头 到来的RMDA Write不由响应端的QP的RQ的WQE处理，而是RQ逻辑把它发布到一个特定的，设备相关的队列中 响应方使用R_Key鉴权 如果鉴权成功，那么响应方的RQ逻辑会把数据载荷写入本地内存 如果是多个包的信息，那请求方的SQ逻辑会发送剩余的包，响应方的RQ逻辑随之完成对内存的写入 在整个完成的时候，如果最后的包含了ImmDtETH，那么这32-bit的immediate data会存在CQE中，响应方QP会弹出RQ中的WQE创建CQE， RDMA Write除了RDMA Write With Immediate Data之外不会使用RQ的WQE； RDMA Write支持RC RD 和UC 数据包内容： 请求数据包： 单个数据包RDMA Write操作 整个信息包含在数据负载中，包含了0-PMTU bytes数据 Opcode是RMDA Write Only或者RDMA Write Only With Immediate 数据包在RETH包含了VA,R_Key以及传输长度 两个数据包RDMA Write操作 第一个包的opcode是RDMA Write First；数据载荷包含了PMTU bytes数据；数据包在RETH中包含了VA,R_Key以及传输长度 第二个包的opcode是RDMA Write Last或者RDMA Write Last With Immedaite；数据载荷包含了1-PMTU数据 三个及以上数据包RDMA Write操作 第一个opcode是RDMA Write First；数据载荷包含了PMTU bytes数据；数据包在RETH中包含了VA,R_Key以及传输长度 中间的包的opcode是RDMA Write Middle；数据载荷包含了1-PMTU数据 最后一个包的opcoed是RDMA Write Last或者RDMA Write Last With Immedaite；数据载荷包含了1-PMTU数据 Immediate Option的用途： RDMA Write实际上在结束的时候在发送方会产生CQE，如果有immediate option会在接收方产生CQE，进入通知软件已经完成了写入 另外immediate可以用于表示这块信息的来源 Atomic RMW 操作介绍 该操作可以用于信号量，锁等并发场景; 两种原子RMW操作类型 FAA fetch and add CaS compare and swap 每一种操作都包含了一个请求包和一个Ack包；这两个包都没有数据载荷，相关数据存在ETH头里面； 准确的说此类请求包都包含一个AtomicETH field，里面包含了如下元素： 四字对齐的该信号量的虚拟地址 R_key，需要保证有读写权限 修改的值(Add_data或者CaS_data) 另外，响应包中带有AtomicAckETH，里面包含了信号量在更新之前的数据； 原子操作额外的操作特性： 如果CA支持RMW操作，那么CA能够处理的未收到的请求数量是在连接建立阶段协商的 当接收到原子操作请求报文的时候，响应方的QP的RQ会把它发布到用户相关的队列中 标准建议原子操作的实现由硬件达成 CA的实现可以选择性的保护RMW相关的内存与其他CA,IO设备以及CPU的原子性； 原子请求包的VA必须是四字对齐的，否则会返回一个Invalid Request Nak. 原子操作 Atomic Fetch and Add 操作 FaA操作需要响应方的QP的RQ执行以下动作： 根据虚拟地址/8这个位置，读取64-bit数据 根据报文中的AtomiETH字段的64-bit Add Data字段，执行无符号加法 把结果写回到先前的位置 该操作需要具有原子性； 请求方需要在请求报文中指定： 远程数据地址，R_key 要加的数据 响应方会返回该信号量修改之前的原始数据 具体流程如下图： Atomic Compare and Swap if Equal Operation 操作 Cas操作需要响应方的QP的RQ执行以下动作： 根据虚拟地址/8这个位置，读取64-bit数据 把该值和AtomicETH中的Compare Data field中的64-bit值作比较 根据比较结果做出如下动作： 如果相等那么把AtomicETH中的Swap data写入到信号量的地址 如果不相等，那么不会改变信号量； 然后会把信号量原来的值返回给请求方逻辑； 请求方需要在请求报文中指定： 信号量的起始地址VA R_Key 64-bit Swap data 64-bit Compare data 上面的Swap data，Compare data，以及原先的值都是在包头传输的，并且是big-endian format；在响应方的读写以及返回的数据的存储都是native endian format的； 具体流程如下图： Bind Memory Window 操作这部分与memory protection有关；主要作用是把先前创建的内存窗口和先前创建的内存区域关联起来，用于定义访问权限；不会导致任何的包传输； 具体流程是首先创建region和window，然后软件发布一个Bind Memory Window WR到SQ上面；WR指定了： Region的handle Window的handle R_key window的起始VA和长度 对于请求方QPs的权限s； 通过对于该WR执行Post Send Request动词会返回与这个窗口相关的R_key； SQ操作与服务类型 SQ操作与服务类型 RQ动词操作 往RQ上发布WR可以处理： Send操作 RDMA Write With Immediate 操作 通过执行Post Receive Request动词来发布WR，WR执行以下功能之一： 通过Scatter Buffer List来确定到来的Send数据写入的位置 通过一个没有Scatter Buffer List的”假”WR来接受RDMA Write With Immediate的immediate数据 WR中指定的VA的范围应该在软件在本地QP中创建的地址空间内； RQ对于Send操作的处理： 如果没有RQ WQE处理的化，接收方会返回一个Receiver Not Ready Nak； IBA协议层参考 https://docs.nvidia.com/networking/display/RDMAAwareProgrammingv17/Programming+Examples+Using+IBV+Verbs#ProgrammingExamplesUsingIBVVerbs-VerbsAPIforExtendedAtomicsSupport Infiniband network architecture https://blog.csdn.net/sz_woshishazi/category_12032159.html","tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://tyler-ytr.github.io/tags/RDMA/"}]},{"title":"InfiniBand 数据包格式，ROCE 以及ROCEV2 (IP ROUTABLE ROCE)","date":"2022-11-19T11:01:45.000Z","path":"2022/11/19/InifiniBand数据包格式/","text":"InfiniBand 数据包格式，ROCE 以及ROCEV2 (IP ROUTABLE ROCE)本部分来自于对于IB Specification Vol 1-Release-1.5-2021-08-06b中的CHAPTER 5: DATA PACKET FORMAT以及ANNEX A16: RDMA OVER CONVERGED ETHERNET (ROCE)和ANNEX A17: ROCEV2 (IP ROUTABLE ROCE)的整理； CHAPTER 5：数据包格式 IBA communication Stack 在IB协议中，message被分段成数据包然后在Fabric中传输； IBA messages to packets 数据包类型数据包有以下类型： 不可分割的数据传输和路由单元 确认单元 消息分段和重组单元 链路级流控制单元 另外可以分为： IBA Packets，包含了IBA transport headers Raw Packets，不包含IBA transport headers但是可以在IBA结构上路由。我的理解是这是IB结构对于其他数据包的兼容。 数据包格式在transport header以及payload之前有两个路由头： local route header对于所有包都是需要的 global route header对于要路由到不同子网的所有数据包以及所有组播数据包是必要的 global route header可以放置在除了子网管理数据包(subnet management packets)之外的任何数据包上 InfiniBand设备生成的数据包应该符合下面两图的结构以及大小位置要求； 另外IBA数据包(IBA Packets)的结尾是一个非变体CRC然后是一个变体CRC;Raw Packets结尾是一个变体CRC。 IBA数据包简介 完整版本的IBA数据包格式 LOCAL ROUTE HEADER(LRH)-8 BytesLRH用于在IBA子网内部的本地路由 LRH Global Route Header(GRH)-40 BytesGRH用于在子网之间的路由。GRH是否存在由上面的LRH中的LNH字段指示。GRH的布局与RFC2460中的IPv6头部一致（但是要注意这里没有定义GID与IPv6之间的映射）。 GRH Base Transport Header(BTH)-12 Bytes BTH_1 BTH_2 BTH是否存在由上一个header的”下一个标头”字段表示(LRH:LNH or GRH:NextHdr)； 细节部分见9.2。 Reliable Datagram Extended Transport header(RDETH)-4 BytesRD数据包应该满足如下表的格式，RDETH包含了用于可靠数据包服务的附加传输字段，他仅仅用于Reliable Datagram 数据包中。细节部分见9.3.1。 RDETH RDMA Extended transport header(RETH)-16 Bytes由支持RDMA操作的InfiniBand设备生成的数据包应该符合如下表的RETH数据包包头格式。 在RETH中包含了RDMA操作的其他传输字段。RETH仅仅存在于RDMA请求的第一个数据包中。 RETH 细节见9.3.3； Atomic Extended Transport Header(AtomicETH)-28 Bytes由支持原子操作的InifiniBand设备生成的数据包应该符合下表的AtomicETH的数据包包头格式。 AtomicETH中包含了额外的用于原子数据包的传输字段。数据包的BTH部分的Opcode字段指示了该数据包是否是Atomic packets(原子数据包)。AtomicETH只出现于Atomic packets里面。 AtomicETH 细节见9.3.4 XRC Extended Transport Header(XRCETH)XRC Extended Transport Header (XRCETH) contains the Destination XRC SRQ identifier. XRCETH ACK Extended Transport Header(AETH)-4 BytesAETH包含了ACK数据包的额外的传输字段。AETH只会出现在Acknowledge, RDMAREAD Response First, RDMA READ Response Last, and RDMA READ Response Only packets,这些包是由BTH头的Opcode字段指示的。 AETH 细节见9.3.5 Atomic ACK Extended Transport Header(AtomicAckETH)-8 BytesAtomicAckETH仅仅出现在Atomic-Acknowledge数据包中，这也是由BTH中的Opcode字段指示的。 AtomicAckETH 细节见9.3.5.3 Immediate Data Extended Transport Header(ImmDt)-4 BytesImmDt包含了放置在receive Completion Queue Element(CQE)中的额外数据。ImmDt仅仅出现在Send 或者RDMA-Write with Immediate Data数据包中。这也是由BTH中的Opcode字段指示的。 ImmDt 细节见9.3.6 Invalidate Extended Transport Header(IETH)-4 BytesIETH 包含了一个R_key,which is used by the responder to invalidate a memory region or memory window once it receives and executes the SEND with Invalidate request. IETH 细节见9.3.7 PayloadPYLD包含了端到端的应用数据。它不会出现在RDMA Read Requests, Acknowledge,CmpSwp, FetchAdd, and Atomic Acknowledge packets里面，只会出现在其他类的op-codes 包里面。 Payload的长度是[0,MTU]； 除了最后一个数据包之外，需要携带有效负载的数据包应该填充到完整MTU大小。 在使用InfiniBand传输的数据包中，数据包里面应该包含0-3字节的Pad字段，用于将有效负载与4字节背书对齐。Pad字段的长度应该在BTH中的PadCnt部分注明。 Invariant CRCICRC包含了从源到目的地数据包中不会更改的字段。它只出现在IBA packets中，不会出现在Raw Packets里面。 细节见7.8.1 Variant CRC包含了链接到链接之间可变的字段，VCRC出现在所有的包里面，包含了IBA以及Raw Packets。 Raw Packets略。 IBA Packets 案例 IBA Packets 案例 To be done(抓包的实际案例) ANNEX A16：RoCE协议RoCE协议的目标 在二层以太网提供RDMA服务 保持现有的动词定义以及相应实现的合规性 维护基本规范中定义的现有内存管理范例 维护现有的InfiniBand传输架构，包括RC,UC,UD,RD和XRC服务以及原子操作 RoCE格式RoCE与前面第五章定义的现有IB数据包有相同的布局与定义，除了以下部分： 每一个RoCE数据包都有GRH。 每一个RoCE数据包都包含一个MAC头来代替IB的LRH。MAC头的目的是提供有关数据包源和目标的信息来让底层网络（以太网）通过子网能够成功交换数据包。 每一个RoCE数据包都包含为以太网帧定义的 FCS。 RoCE数据包格式如下： RoCE数据包格式 另外： MACheader中EtherType的字段应该是0x8915，并且DMAC和SMAC字段应该填充RoCE数据包的L2目标和L2源端口的相应MAC地址。 RoCE数据包不得包含变体的CRC。RoCE数据包应该包含适用于所用以太网网络的FCS。 每一个RoCE数据包应该有一个有效的GRH。 ANNEX A17：RoCEv2RoCE简介RDMA over Converged Ethernet (RoCE)是一个InfiniBand标准用于保证在以太网上的InifiniBand传输。RoCE保留了InfiniBand动词语义以及传输和网络协议，把InfiniBand 链路层以及物理层的部分替换成了以太网的那些部分。RoCE的网络管理基础架构也是以太网的。 协议栈比较 RoCE的包格式如下图所示，它的问题在于没有包含以太网头，因此只能在以太网L2域内提供RDMA服务。 RoCE包格式 RoCEv2（IP Routable RoCE）RoCEv2是RoCE协议的拓展版本，主要是对RoCE数据包格式进行了修改： RoCEv2包格式 参考 IB Specification Vol 1-Release-1.5-2021-08-06b","tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://tyler-ytr.github.io/tags/RDMA/"}]},{"title":"C++各类题目整理","date":"2022-11-17T08:38:30.000Z","path":"2022/11/17/C-各类题目整理/","text":"C++各类题目算法位运算快速判断二进制编码中“1”有奇数个还是偶数个12345678int odd_ones(unsigned x) &#123; x = x ^ (x &gt;&gt; 16); x = x ^ (x &gt;&gt; 8); x = x ^ (x &gt;&gt; 4); x = x ^ (x &gt;&gt; 2); x = x ^ (x &gt;&gt; 1); return x &amp; 1; &#125; 对于二进制数1101，判断1数量奇偶的最基本的方法是逐个按位异或，也就是1^1^0^1，这里异或与加法（不进位）类似； 现在考虑优化的办法，思想类似于二分； 1234int x=1101x^=(x&gt;&gt;2);x^=(x&gt;&gt;1);int result=x&amp;1; x^=(x&gt;&gt;2) 相当于折半；1101^0011=1110 此时最后两位10相当于前者保存了第二位+第四位，后者保留了第一位+第三位的结果；最后这两个异或就是最终结果也就是代码倒数第二行的部分； int一共32位，思想类似；","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"}]},{"title":"ibv_post_send的机制","date":"2022-10-27T05:54:43.000Z","path":"2022/10/27/ibv_post_send的机制/","text":"概括本文介绍了发生在CPU和网卡之间通过PCIe来传输信息和基于Inifiniband互联发送完成信号的一系列协调事件 正文在Inifiband上面发送信息的传统方法是通过Verb API. libibverbs是这个API的标准实现，目前由Linux-RDMA社区维护。 Verbs可以分为两类：慢速和快速函数( slow-path and fast-path functions) Slow-path 函数比如ibv_open_device, ibv_alloc_pd等等与创建或者配置资源（比如Context, Protection Domain, and Memory Region）有关，他们慢的原因是因为这部分涉及内核，因此会产生昂贵的上下文开销。 Fast-path函数比如ibv_post_send, ibv_poll_cq处理操作的初始化或者完成，他们快的原因是因为他们绕过了内核，因此相对于slow-path的那些函数要快。 通信的关键路径由fast-path函数构成，偶尔包括slow-pathhanshu ,比如用ibv_reg_mr来动态注册内存（取决于通信中间件）。 这篇文章主要介绍程序员执行ibv_post_send之后的机制 PCIe的简要背景网卡通过PCIe(PCI Express)插槽连接到服务器。Root Complex 简称RC，是CPU和PCIe总线之间的接口，他把处理器和内存连接到PCIe。连接到PCIe末端结构的外围设备成为PCIe端点。 PCIe结构 PCIe协议由三层组成：事务层，数据链路层和物理层(the Transaction layer, the Data Link layer, and the Physical layer); 最上层也就是事务层描述事务发生的类型；对于本文而言两种类型的事务层包(Transaction Layer Packets (TLPs))是相关的：MemoryWrite (MWr), and Memory Read (MRd). 与独立的MWr TLP不同，MRd TLP与来自目标 PCIe端点的数据完成事务耦合，完成事务包含了发起方请求的数据； 数据链路层保证了所有事务的成功执行，主要是基于数据链路层包确认(Data Link Layer Packet (DLLP) acknowledgements (ACK/NACK)) 以及基于信用的流控机制(a credit-based flow-control mechanism)；只要发起方有足够的信用额度就可以发送事务，当它从邻居收到更新的流控制的数据链路层包(DLLP)的时候就会补充信用；这种流控机制允许PCIe协议具有多个未完成的事务。 基本机制首先，本文描述如何使用完全卸载(completely offloaded)的方法来发送消息，也就是CPU只通知网卡有信息要发送，网卡会执行其他所有操作来传输数据。在这种方法中，CPU对于计算活动更加可用，然而这种方法不利于小消息传输的性能，为了提高这种情况下的通信性能，Infiniband提供了一些下一节讲描述的操作特性。 从CPU程序员的角度来看，存在一个传输队列(the send queue in Verbs is the Queue Pair (QP))以及一个完成队列(long for CQ in Verbs)。用户发布消息描述符(MD;Verbs里面的工作队列元素WQE)到传输队列，之后他们在CQ上面轮询来确认已经发布的消息的完成。用户还可以请求收到有关完成的终端通知。但是轮询的方法是延迟导向的( latency-oriented)，因为在关键路径上没有到内核的上下文切换。 如下图，通过网络传输信息是通过处理器和网卡之间的协调进行的，使用内存映射I/O(MMIO)和直接内存访问(DMA)读取和写入。 基本机制 步骤如下： 用户首先把MD排队进入TxQ，然后网络驱动程序准备特定于设备的MD，其中包含网卡的头以及指向有效负载的指针 CPU（网络驱动程序）使用8字节的原子写入内存映射位置，通知网卡消息已经准备好发送，这成为doorbell。RC使用MWr PCIe事务来执行doorbell。 doorbell响起之后，网卡通过DMA读来获取MD。主要通过MRd PCIe事务 来执行DMA读取。 然后网卡使用另一个DMA读取(另外一个MRd TLP)来从注册的内存区域里面获得有效负载。注意必须先将虚拟地址转换成物理地址，网卡才能够执行DMA读取。 一旦网卡接收到负载，他会通过网络传输读取的数据，成功传输之后网卡会接受目标网卡的确认ACK。 收到ACK之后，网卡用DMA写(使用MWr TLP)写入完全队列条目(CQE,在Mellanox InfiniBand中为64字节)到与TxQ关联的CQ。然后CPU将轮询到此完成。 总而言之，每一个post的关键路径需要一次MMIO写入，两次DMA读取和一次DMA写入。DMA读取实际上是往返的PCIe延迟比较昂贵，比如ThunderX2机器上的往返PCIe是125 纳秒。 Operational features 优化小消息通信Postlist，内联(inlining)，无信号完成(unsignaled completions)以及可编程I/O( Programmed I/O )是IB的操作功能(operational features)，有助于减少上述开销。下面描述中假设QP的深度为n。 Postlist: IB不是每一个ibv_post_send只发布一个WQE，而是允许应用程序发布WQE的链接列表，这只需要调用一次ibv_post_send，从而把n次Doorbell的开销降低到1. Inlining: CPU（网络驱动程序）将数据复制到 WQE 中。因此，通过对 WQE 的第一次 DMA 读取，NIC 也获得了有效负载，从而消除了对有效负载的第二次 DMA 读取。 Unsignaled completions: 如果每n个WQE至少有一个是发出信号的，IB就允许应用程序关闭WQE的完成，而不是为每一个WQE发送完成信号。关闭完成操作可以减少网卡的CQE的DMA写入。另外，应用程序轮询的CQE更少，这减少了开销。 BlueFlame: BlueFlame是Mellanox对编程I / O的术语 - 它将WQE与门铃一起写入，切断WQE本身的DMA读取。请注意，BlueFlame 仅在没有 Postlist 的情况下使用。使用Postlist，NIC将对链表中的WQE进行DMA读取。 为了减少PCIe往返延迟的开销，开发者一般对小的消息使用inlining和blueflame，它可以消除两个PCIe往返延迟。Postlist和unsignaled completions的使用主要依赖于用户的程序设计选择和应用程序的语义。 具体代码实现小消息通信优化在ibv_post_send中的wr中利用IBV_SEND_INLINE和IBV_SEND_SIGNALED进行优化; IBV_SEND_SIGNALED参考： Rohit Zambre的How does InfiniBand work? 【精讲】PCIe基础篇——Switch/Bridge/Root Complex/EndPoint https://www.rdmamojo.com/2014/06/30/working-unsignaled-completions/","tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://tyler-ytr.github.io/tags/RDMA/"}]},{"title":"hexo表格生成问题","date":"2022-10-19T15:08:23.000Z","path":"2022/10/19/hexo表格生成问题/","text":"问题hexo对于表格的解析存在几种问题： 表格前后需要空一行不然无法渲染(typora可以渲染)| a | b || —- | —- || c | d |另外在缩进的情况下也无法渲染表格 测试： 表格如下： | a | b || —- | —- || c | d | 正常的表格12345678文字：1. 测试| a | b || ---- | ---- || c | d |文字 效果：文字： 测试 a b c d 文字 另外如果要左对齐的话要每一列都加上:才行，也就是： |:—- |:—- | 效果： 文字： 测试 a b c d 文字","tags":[{"name":"hexo配置","slug":"hexo配置","permalink":"http://tyler-ytr.github.io/tags/hexo%E9%85%8D%E7%BD%AE/"}]},{"title":"socket编程","date":"2022-10-19T11:34:55.000Z","path":"2022/10/19/socket-learning/","text":"socket编程socket与计算机网络两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。 能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。 Socket抽象层 socket通信流程 socket连接过程 流程如上图所示； 联想三次握手： 三次握手 socket建立连接 经过对比会发现socket的流程中建立连接的部分就是三次握手； socket API与编程服务端 创建套接字对象 123456/* * _domain 套接字使用的协议族信息 * _type 套接字的传输类型 * __protocol 通信协议 * */ int socket (int __domain, int __type, int __protocol) __THROW; 参数： 第一个参数，协议族信息可选如下： (在Linux系统中AF_和PF_是等价的。在内核源码中net目录下面有Af_开头的一系列文件(如:Af_inet.c、Af_inet6.c、Af_unix.c等)，每一个文件分别代表了一种协议族。) 地址族 含义 AF_INET IPv4网络协议中采用的地址族 AF_INET6 IPv6网络协议中采用的地址族 AF_UNIX, AF_LOCAL 本地通信中采用的UNIX协议的地址族（用的少） AF_PACKET 链路层通信 ​ 第二个参数：套接字类型： 参考内核源码: 123456789101112131415161718192021222324/** * enum sock_type - Socket types * @SOCK_STREAM: stream (connection) socket * @SOCK_DGRAM: datagram (conn.less) socket * @SOCK_RAW: raw socket * @SOCK_RDM: reliably-delivered message * @SOCK_SEQPACKET: sequential packet socket * @SOCK_DCCP: Datagram Congestion Control Protocol socket * @SOCK_PACKET: linux specific way of getting packets at the dev level. * For writing rarp and other similar things on the user level. * * When adding some new socket type please * grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS * overrides this enum for binary compat reasons. */enum sock_type &#123; SOCK_STREAM = 1, SOCK_DGRAM = 2, SOCK_RAW = 3, SOCK_RDM = 4, SOCK_SEQPACKET = 5, SOCK_DCCP = 6, SOCK_PACKET = 10,&#125;; 套接字类型 含义 SOCKET_RAW 原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、 ICMP协议。 SOCK_STREAM SOCK_STREAM是数据流，一般为TCP/IP协议的编程。 SOCK_DGRAM SOCK_DGRAM是数据报，一般为UDP协议的网络编程； 第三个参数：最终采用的协议；常见的协议有IPPROTO_TCP、IPPTOTO_UDP。如果第二个参数选择了SOCK_STREAM，那么采用的协议就只能是IPPROTO_TCP；如果第二个参数选择的是SOCK_DGRAM，则采用的协议就只能是IPPTOTO_UDP。 向套接字分配网络地址 123456/* * __fd:socket描述字，也就是socket引用* myaddr:要绑定给sockfd的协议地址* __len:地址的长度*/int bind (int __fd, const struct sockaddr* myaddr, socklen_t __len) __THROW; 第一个参数：socket文件描述符__fd即套接字创建时返回的对象； 第二个参数：myaddr则是填充了一些网络地址信息，包含通信所需要的相关信息，其结构体具体如下： 12345struct sockaddr &#123; sa_family_t sin_family; /* Common data: address family and length. */ char sa_data[14]; /* 地址数据 */ &#125;; 这里根据socket源码:typedef unsigned short sa_family_t;表示地址族，可选参数如下: 123456789101112131415161718192021222324252627282930313233343536373839/* Supported address families. */#define AF_UNSPEC 0#define AF_UNIX 1 /* Unix domain sockets */#define AF_LOCAL 1 /* POSIX name for AF_UNIX */#define AF_INET 2 /* Internet IP Protocol */#define AF_AX25 3 /* Amateur Radio AX.25 */#define AF_IPX 4 /* Novell IPX */#define AF_APPLETALK 5 /* AppleTalk DDP */#define AF_NETROM 6 /* Amateur Radio NET/ROM */#define AF_BRIDGE 7 /* Multiprotocol bridge */#define AF_ATMPVC 8 /* ATM PVCs */#define AF_X25 9 /* Reserved for X.25 project */#define AF_INET6 10 /* IP version 6 */#define AF_ROSE 11 /* Amateur Radio X.25 PLP */#define AF_DECnet 12 /* Reserved for DECnet project */#define AF_NETBEUI 13 /* Reserved for 802.2LLC project*/#define AF_SECURITY 14 /* Security callback pseudo AF */#define AF_KEY 15 /* PF_KEY key management API */#define AF_NETLINK 16#define AF_ROUTE AF_NETLINK /* Alias to emulate 4.4BSD */#define AF_PACKET 17 /* Packet family */#define AF_ASH 18 /* Ash */#define AF_ECONET 19 /* Acorn Econet */#define AF_ATMSVC 20 /* ATM SVCs */#define AF_RDS 21 /* RDS sockets */#define AF_SNA 22 /* Linux SNA Project (nutters!) */#define AF_IRDA 23 /* IRDA sockets */#define AF_PPPOX 24 /* PPPoX sockets */#define AF_WANPIPE 25 /* Wanpipe API Sockets */#define AF_LLC 26 /* Linux LLC */#define AF_CAN 29 /* Controller Area Network */#define AF_TIPC 30 /* TIPC sockets */#define AF_BLUETOOTH 31 /* Bluetooth sockets */#define AF_IUCV 32 /* IUCV sockets */#define AF_RXRPC 33 /* RxRPC sockets */#define AF_ISDN 34 /* mISDN sockets */#define AF_PHONET 35 /* Phonet sockets */#define AF_IEEE802154 36 /* IEEE802154 sockets */#define AF_MAX 37 /* For now.. */ 一般情况下会用这个sockaddr的变体sockaddr_in进行字段的初始化: 123456struct sockaddr_in&#123; sa_family_t sin_family; //前面介绍的地址族 uint16_t sin_port; //16位的TCP/UDP端口号 struct in_addr sin_addr; //32位的IP地址 char sin_zero[8]; //不使用&#125; 其中in_addr 结构定义如下： 123456/* Internet address. */typedef uint32_t in_addr_t;struct in_addr&#123; in_addr_t s_addr;&#125;; 其中s_addr是一种uint32_t类型的数据，而且在网络传输时，统一都是以大端序的网络字节序方式传输数据；但我们通常习惯的IP地址是点分十进制，比如“219.228.148.169”；可以使用如下函数转化把IP地址转换成32位的整数并且进行网络字节转换： 123in_addr_t inet_addr (const char *__cp) __THROW;//或者int inet_aton (const char *__cp, struct in_addr *__inp) __THROW; //windows无此函数 如果单纯要进行网络字节序地址的转换，可以采用如下函数： 1234567891011121314151617/*Functions to convert between host and network byte order. Please note that these functions normally take `unsigned long int' or `unsigned short int' values as arguments and also return them. But this was a short-sighted decision since on different systems the types may have different representations but the values are always the same. */// h代表主机字节序// n代表网络字节序// s代表short(4字节)// l代表long(8字节)extern uint32_t ntohl (uint32_t __netlong) __THROW __attribute__ ((__const__));extern uint16_t ntohs (uint16_t __netshort) __THROW __attribute__ ((__const__));extern uint32_t htonl (uint32_t __hostlong) __THROW __attribute__ ((__const__));extern uint16_t htons (uint16_t __hostshort) sin_zero 无特殊的含义，只是为了与下面介绍的sockaddr结构体一致而插入的成员。 在具体调用bind的函数的时候，用强制类型转换把sockaddr_in转化为sockaddr即可; 123struct sockaddr_in serv_addr;...bind(serv_socket, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)； 进入等待连接请求状态 1234/* Prepare to accept connections on socket FD. N connection requests will be queued before further requests are refused. Returns 0 on success, -1 for errors. */extern int listen (int __fd, int __n) __THROW; 给套接字分配了所需的信息后，就可以调用listen()函数对来自客户端的连接请求进行监听（客户端此时要调用connect()函数进行连接） 第一个参数：socket文件描述符__fd，分配所需的信息后的套接字。 第二个参数：连接请求的队列长度，如果为6，表示队列中最多同时有6个连接请求。 这个函数的fd(socket套接字对象)就相当于一个门卫，对连接请求做处理，决定是否把连接请求放入到server端维护的一个队列中去。 受理客户端的连接请求 123456789/* Await a connection on socket FD. When a connection arrives, open a new socket to communicate with it, set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting peer and *ADDR_LEN to the address's actual length, and return the new socket's descriptor, or -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */extern int accept (int __fd, struct sockaddr *addr, socklen_t *addr_len); listen()中的sock(__fd : socket对象)发挥了服务器端接受请求的门卫作用，此时为了按序受理请求，给客户端做相应的回馈，连接到发起请求的客户端，此时就需要用accept再次创建另一个套接字; 函数成功执行时返回socket文件描述符，失败时返回-1。 第一个参数：socket文件描述符__fd，要注意的是这个套接字文件描述符与前面几步的套接字文件描述符不同。 第二个参数：保存发起连接的客户端的地址信息。 第三个参数： 保存该结构体的长度。 send/write发送信息 linux下面的发送函数： 1234/* Write N bytes of BUF to FD. Return the number written, or -1.(往__fd里面写N个__buf里面的bytes；返回写入的数字或者-1) This function is a cancellation point and therefore not marked with __THROW. */ ssize_t write (int __fd, const void *__buf, size_t __n) ; windows下面的发送函数： 1ssize_t send (int sockfd, const void *buf, size_t nbytes, int flag) ; recv/read接受信息 linux下的接收函数为 123456/* Read NBYTES into BUF from FD. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */ssize_t read (int __fd, void *__buf, size_t __nbytes); 而在windows下的接收函数为 1ssize_t recv(int sockfd, void *buf, size_t nbytes, int flag) ; 关闭连接 12345/* Close the file descriptor FD. This function is a cancellation point and therefore not marked with __THROW. */int close (int __fd); 退出连接，此时要注意的是：调用close()函数即表示向对方发送了EOF结束标志信息。 客户端 服务端的socket套接字在绑定自身的IP即 及端口号后这些信息后，就开始监听端口(listen)等待客户端的连接(connect)请求，此时客户端在创建套接字后就可以按照如下步骤与server端通信： 创建套接字对象(如上) 请求连接 12345678/* Open a connection on socket FD to peer at ADDR (which LEN bytes long). For connectionless socket types, just set the default address to send to and the only address from which to accept transmissions. Return 0 on success, -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */int connect (int socket, struct sockaddr* servaddr, socklen_t addrlen); 几个参数的意义和前面的accept函数意义一样。要注意的是服务器端收到连接请求的时候并不是马上调用accept()函数，而是把它放入到请求信息的等待队列中。 读写信息 关闭连接 套接字的多种可选项 函数： 1234567891011121314#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's actual length. Returns 0 on success, -1 for errors. */extern int getsockopt (int sock, int __level, int __optname, void *__optval, socklen_t *optlen) __THROW;/* Set socket FD's option OPTNAME at protocol level LEVEL to *OPTVAL (which is OPTLEN bytes long). Returns 0 on success, -1 for errors. */extern int setsockopt (int sock, int __level, int __optname, const void *__optval, socklen_t __optlen) __THROW; 参数： sock：网络文件描述符；也就是前面sock函数的返回值 __level：选项所在协议层。 可选的协议层如下： 协议层 功能 SOL_SOCKET 套接字相关通用可选项的设置 IPPROTO_IP 在IP层设置套接字的相关属性 IPPROTO_TCP 在TCP层设置套接字相关属性 __optname：需要访问的选项名 （取决于level） ： __optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。 __optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度。 PS:__THROW是linux平台C库才有的东西，类似于throw() 使用案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651. closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket：BOOL bReuseaddr=TRUE;setsockopt (s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&amp;bReuseaddr,sizeof(BOOL));2. 如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程：BOOL bDontLinger = FALSE;setsockopt (s,SOL_SOCKET,SO_DONTLINGER,(const char*)&amp;bDontLinger,sizeof(BOOL));3. 在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：int nNetTimeout=1000;//1秒//发送时限setsockopt (socket，SOL_S0CKET,SO_SNDTIMEO，(char *)&amp;nNetTimeout,sizeof(int));//接收时限setsockopt (socket，SOL_S0CKET,SO_RCVTIMEO，(char *)&amp;nNetTimeout,sizeof(int));4. 在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：// 接收缓冲区int nRecvBuf=32*1024;//设置为32Ksetsockopt (s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));//发送缓冲区int nSendBuf=32*1024;//设置为32Ksetsockopt (s,SOL_SOCKET,SO_SNDBUF,(const char*)&amp;nSendBuf,sizeof(int));5. 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能：int nZero=0;setsockopt (socket，SOL_S0CKET,SO_SNDBUF，(char *)&amp;nZero,sizeof(nZero));6. 同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)：int nZero=0;setsockopt (socket，SOL_S0CKET,SO_RCVBUF，(char *)&amp;nZero,sizeof(int));7. 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：BOOL bBroadcast=TRUE;setsockopt (s,SOL_SOCKET,SO_BROADCAST,(const char*)&amp;bBroadcast,sizeof(BOOL));8. 在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可以设置connect()延时,直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的作用，在阻塞的函数调用中作用不大)BOOL bConditionalAccept=TRUE;setsockopt (s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const char*)&amp;bConditionalAccept,sizeof(BOOL));9 . 如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket(),以前我们一般采取的措施是\"从容关闭\"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体应用的要求(即让没发完的数据发送出去后在关闭socket)？struct linger &#123;u_short l_onoff;u_short l_linger;&#125;;linger m_sLinger;m_sLinger.l_onoff=1;//(在closesocket()调用,但是还有数据没发送完毕的时候容许逗留)// 如果m_sLinger.l_onoff=0;则功能和2.)作用相同;m_sLinger.l_linger=5;//(容许逗留的时间为5秒)setsockopt (s,SOL_SOCKET,SO_LINGER,(const char*)&amp;m_sLinger,sizeof(linger)); getaddinfo函数以及addrinfo结构体getaddinfo函数IPv4中使用gethostbyname()函数完成主机名到地址解析，这个函数仅仅支持IPv4，且不允许调用者指定所需地址类型的任何信息，返回的结构只包含了用于存储IPv4地址的空间。IPv6中引入了getaddrinfo()的新API，它是协议无关的，既可用于IPv4也可用于IPv6。getaddrinfo函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个addrinfo的结构（列表）指针而不是一个地址清单。这些addrinfo结构随后可由套接口函数直接使用。 头文件1#include &lt;netdb.h&gt; 函数原型1int getaddrinfo( const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result ); hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串) service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等 hints：该参数指向用户设定的 struct addrinfo 结构体，只能设定该结构体中 ai_family、ai_socktype、ai_protocol 和 ai_flags 四个域，其余部分必须设置为0或者NULL。如果设置全为0，等价于 ai_socktype = 0， ai_protocol = 0，ai_family = AF_UNSPEC， ai_flags = 0 调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。 result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。 返回值：0——成功，非0——出错 EAI_ADDRFAMILY 指定的主机上没有请求的address family对应的网络地址. EAI_AGAIN DNS(name server)返回临时性错误. 可以稍后重试. EAI_BADFLAGS hints.ai_flags 包含了无效的标志; 或者 hints.ai_flags 包含了 AI_CANONNAME 标志但是 name 是 NULL. EAI_FAIL DNS(name server)返回永久性错误 EAI_FAMILY 不支持的 address family(hints.ai_family). EAI_MEMORY 内存耗尽. EAI_NODATA 指定的网络主机存在，但是其未定义任何网络地址. EAI_NONAME nodename 或者 servname 未知;或者两者都设置为NULL;或者设置了 AI_NUMERICSERV 标志但是 servname 不是一个数字化的端口名字符串。 EAI_SERVICE 请求的socket类型不支持请求的服务类型.例如服务类型是 “shell” (基于流的socket服务)，但是 hints.ai_protocol 是 IPPROTO_UDP 或者hints.ai_socktype 是 SOCK_DGRAM;或者 servname 不是NULL 但是 hints.ai_socktype 是 SOCK_RAW (原始套接字不支持服务的概念). EAI_SOCKTYPE 不支持请求的socket类型. 例如, hints.ai_socktype 和 hints.ai_protocol 冲突 (例如分别是SOCK_DGRAM、IPPROTO_TCP). EAI_SYSTEM 系统调用错误，检查 errno. addrinfo结构体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;/* ======================Types of sockets====================== */enum __socket_type &#123; SOCK_STREAM = 1, /* Sequenced, reliable, connection-based byte streams. */ SOCK_DGRAM = 2, /* Connectionless, unreliable datagrams of fixed maximum length. */ SOCK_RAW = 3, /* Raw protocol interface. */ SOCK_RDM = 4, /* Reliably-delivered messages. */ SOCK_SEQPACKET = 5, /* Sequenced, reliable, connection-based,datagrams of fixed maximum length. */ SOCK_DCCP = 6, /* Datagram Congestion Control Protocol. */ SOCK_PACKET = 10, /* Linux specific way of getting packets at the dev level. For writing rarp and other similar things on the user level. */ /* Flags to be ORed into the type parameter of socket and socketpair and used for the flags parameter of paccept. */ SOCK_CLOEXEC = 02000000, /* Atomically set close-on-exec flag for the new descriptor(s). */ SOCK_NONBLOCK = 00004000 /* Atomically mark descriptor(s) as non-blocking. */&#125;;/* ============Protocol families(只列出常用几个)================= */#define PF_UNSPEC 0 /* Unspecified. */#define PF_LOCAL 1 /* Local to host (pipes and file-domain). */#define PF_INET 2 /* IP protocol family. */#define PF_IPX 4 /* Novell Internet Protocol. */#define PF_APPLETALK 5 /* Appletalk DDP. */#define PF_INET6 10 /* IP version 6. */#define PF_TIPC 30 /* TIPC sockets. */#define PF_BLUETOOTH 31 /* Bluetooth sockets. *//* ==============Address families(只列出常用几个)================= */#define AF_UNSPEC PF_UNSPEC#define AF_LOCAL PF_LOCAL#define AF_UNIX PF_UNIX#define AF_FILE PF_FILE#define AF_INET PF_INET#define AF_IPX PF_IPX#define AF_APPLETALK PF_APPLETALK#define AF_INET6 PF_INET6#define AF_ROSE PF_ROSE#define AF_NETLINK PF_NETLINK#define AF_TIPC PF_TIPC#define AF_BLUETOOTH PF_BLUETOOTH/* ====Possible values for `ai_flags' field in `addrinfo' structure.===== */#define AI_PASSIVE 0x0001 /* Socket address is intended for `bind'. */#define AI_CANONNAME 0x0002 /* Request for canonical name. */#define AI_NUMERICHOST 0x0004 /* Don't use name resolution. */#define AI_V4MAPPED 0x0008 /* IPv4 mapped addresses are acceptable. */#define AI_ALL 0x0010 /* Return IPv4 mapped and IPv6 addresses. */#define AI_ADDRCONFIG 0x0020 /* Use configuration of this host to choose returned address type. */#ifdef __USE_GNU#define AI_IDN 0x0040 /* IDN encode input (assuming it is encoded in the current locale's character set) before looking it up. */#define AI_CANONIDN 0x0080 /* Translate canonical name from IDN format. */#define AI_IDN_ALLOW_UNASSIGNED 0x0100 /* Don't reject unassigned Unicode code points. */#define AI_IDN_USE_STD3_ASCII_RULES 0x0200 /* Validate strings according to STD3 rules. */#endif#define AI_NUMERICSERV 0x0400 /* Don't use name resolution. *//* =======================struct addrinfo======================= */struct addrinfo &#123;int ai_flags; /* 附加选项,多个选项可以使用或操作结合 */int ai_family; /* 指定返回地址的协议簇,取值范围:AF_INET(IPv4)、AF_INET6(IPv6)、AF_UNSPEC(IPv4 and IPv6) */ int ai_socktype; /* enum __socket_type 类型，设置为0表示任意类型 */int ai_protocol; /* 协议类型，设置为0表示任意类型,具体见上一节的 Ip Protocol */socklen_t ai_addrlen; /* socket address 的长度 */struct sockaddr *ai_addr; /* socket address 的地址 */char *ai_canonname; /* Canonical name of service location. */struct addrinfo *ai_next; /* 指向下一条信息,因为可能返回多个地址 */&#125;; 与socket接口的交互案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/******************************************************************************* Function: sock_connect** Input* servername: URL of server to connect to (NULL for server mode)* port: port of service** Output* none** Returns* socket (fd) on success, negative error code on failure** Description* 连接socket，如果指定了服务器名称，那么会启动一个client连接到指定的服务器以及端口；* 否则会在指定窗口上监听可能进入的连接。* Connect a socket. If servername is specified a client connection will be* initiated to the indicated server and port. Otherwise listen on the* indicated port for an incoming connection.*******************************************************************************/static int sock_connect(const char *servername, int port)&#123; struct addrinfo *resolved_addr = NULL; struct addrinfo *iterator; char service[6]; int sockfd = -1; int listenfd = 0; int tmp; struct addrinfo hints = &#123; .ai_flags = AI_PASSIVE, .ai_family = AF_INET, .ai_socktype = SOCK_STREAM&#125;; if (sprintf(service, \"%d\", port) &lt; 0) goto sock_connect_exit; /* Resolve DNS address, use sockfd as temp storage */ sockfd = getaddrinfo(servername, service, &amp;hints, &amp;resolved_addr); if (sockfd &lt; 0) &#123; fprintf(stderr, \"%s for %s:%d\\n\", gai_strerror(sockfd), servername, port); goto sock_connect_exit; &#125; /* Search through results and find the one we want */ for (iterator = resolved_addr; iterator; iterator = iterator-&gt;ai_next) &#123; sockfd = socket(iterator-&gt;ai_family, iterator-&gt;ai_socktype, iterator-&gt;ai_protocol); if (sockfd &gt;= 0) &#123; if (servername)&#123; /* Client mode. Initiate connection to remote */ if ((tmp = connect(sockfd, iterator-&gt;ai_addr, iterator-&gt;ai_addrlen))) &#123; fprintf(stdout, \"failed connect \\n\"); close(sockfd); sockfd = -1; &#125; &#125; else &#123; /* Server mode. Set up listening socket an accept a connection */ listenfd = sockfd; sockfd = -1; if (bind(listenfd, iterator-&gt;ai_addr, iterator-&gt;ai_addrlen)) goto sock_connect_exit; listen(listenfd, 1); sockfd = accept(listenfd, NULL, 0); &#125; &#125; &#125;sock_connect_exit: if (listenfd) close(listenfd); if (resolved_addr) freeaddrinfo(resolved_addr); if (sockfd &lt; 0) &#123; if (servername) fprintf(stderr, \"Couldn't connect to %s:%d\\n\", servername, port); else &#123; perror(\"server accept\"); fprintf(stderr, \"accept() failed\\n\"); &#125; &#125; return sockfd;&#125; PS socket非阻塞和阻塞模式 使用epoll,poll,select的案例 参考 https://github.com/Tyler-ytr/Socket-Program 简单理解Socket setsockopt与getsockopt unix网络编程 socket函数的domain、type、protocol解析 https://www.cnblogs.com/fnlingnzb-learner/p/7542770.html","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CPU缓存一致性笔记","date":"2022-10-19T06:09:09.000Z","path":"2022/10/19/CPU缓存一致性笔记/","text":"CPU缓存一致性存储体系结构 计算机存储分了很多层次，扬长避短，有寄存器、L1 cache、L2 cache、L3 cache、主存（内存）和硬盘等。 缓存工作原理： cache line（缓存行）是缓存进行管理的最小存储单元，也叫缓存块，每个 cache line 包含 Flag、Tag 和 Data ，通常 Data 大小是 64 字节，但不同型号 CPU 的 Flag 和 Tag 可能不相同。从内存向缓存加载数据是按整个缓存行加载的，一个缓存行和一个相同大小的内存块对应。在图中横向是组(Set)，纵向是路(Way)。每一个元素是缓存行(cache line)。 给定addr定位缓存的方式： 首先找到组号：Set Index = (addr &gt;&gt; 6) % M;(左移6位是因为 Block Offset 占 addr 的低 6 位，Data 为 64 字节) 然后遍历所有的路，找到cache line中的tag和addr中tag相等为止，所有路都没有成功那么缓存没有命中 整个缓存容量 = 组数 × 路数 × 缓存行大小 相关shell命令： lscpu getconf -a| grep CACHE 缓存行替换策略，一般是LRU，可以通过位矩阵实现： 算法：首先初始化行列与缓存相同的矩阵，当访问某一个路对应的缓存行的时候，首先把该路对应的所有行置为1，然后把该路对应的所有列置为0；最近最少使用的缓存行对应的矩阵行中1的个数最少最先被替换出去； 例子里面首先是3，因此D3那一行首先都是1，然后把D3那一列变成0；然后是1，那么就把D1那一行都变成1然后把D1那一列都变成0…… 缓存一致性协议单核时代不存在这个问题，但是到了多核时代，引入了缓存一致性的我呢提，如果一个核心修改了缓存行里面的某一个值，那么需要有一种机制保证其他核心能够观察这个修改； 缓存写 从缓存和内存的更新关系来看，分为： 写回（write-back）对缓存的修改不会立刻传播到内存，只有当缓存行被替换时，这些被修改的缓存行才会写回并覆盖内存中过时的数据。 写直达（write through）缓存中任何一个字节的修改，都会立刻穿透缓存直接传播到内存，这种比较耗时。 从写缓存时 CPU 之间的更新策略来看，分为： 写更新（Write Update）每次缓存写入新的值，该核心必须发起一次总线请求，通知其他核心更新他们缓存中对应的值。 坏处：写更新会占用很多总线带宽； 好处：其他核心能立刻获得最新的值。 写无效（Write Invalidate）每次缓存写入新的值，都将其他核心缓存中对应的缓存行置为无效。 坏处：当其他核心再次访问该缓存时，发现缓存行已经失效，必须从内存中重新载入最新的数据； 好处：多次写操作只需发一次总线事件，第一次写已经将其他核心缓存行置为无效，之后的写不必再更新状态，这样可以有效地节省核心间总线带宽。 从写缓存时数据是否被加载来看，分为： 写分配（Write Allocate）在写入数据前将数据读入缓存。当缓存块中的数据在未来读写概率较高，也就是程序空间局部性较好时，写分配的效率较好。 写不分配（Not Write Allocate）在写入数据时，直接将数据写入内存，并不先将数据块读入缓存。当数据块中的数据在未来使用的概率较低时，写不分配性能较好。 MESI协议MESI协议是⼀个基于失效的缓存⼀致性协议，是⽀持写回（write-back）缓存的最常⽤协议。 为了解决多个核心之间的数据传播问题，提出了总线嗅探（Bus Snooping）策略。本质上就是把所有的读写请求都通过总线（Bus）广播给所有的核心，然后让各个核心去嗅探这些请求，再根据本地的状态进行响应。 四种状态 已修改Modified (M)：缓存⾏是脏的，与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存⾏必须回写到主存，状态变为共享(S). 独占Exclusive (E)：缓存⾏只在当前缓存中，但是⼲净的，缓存数据等于主存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。 共享Shared (S)：缓存⾏也存在于其它缓存中且是⼲净的。缓存⾏可以在任意时刻抛弃。 ⽆效Invalid (I)：缓存⾏是⽆效的。 这些状态信息实际上存储在缓存行（cache line）的 Flag 里。 事件以及状态机 处理器对缓存的请求: PrRd：核心请求从缓存块中读出数据； PrWr：核心请求向缓存块写入数据。 总线对缓存的请求: BusRd：总线嗅探器收到来自其他核心的读出缓存请求； BusRdX：总线嗅探器收到另一核心写⼀个其不拥有的缓存块的请求； BusUpgr：总线嗅探器收到另一核心写⼀个其拥有的缓存块的请求； Flush：总线嗅探器收到另一核心把一个缓存块写回到主存的请求； FlushOpt：总线嗅探器收到一个缓存块被放置在总线以提供给另一核心的请求，和 Flush 类似，但只不过是从缓存到缓存的传输请求。 image-20221019145117675 当前状态 事件 响应 M PrRd ⽆总线事务⽣成状态保持不变读操作为缓存命中 PrWr ⽆总线事务⽣成状态保持不变写操作为缓存命中 BusRd 状态变为共享(S)Shared发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存） BusRdX 状态变为⽆效(I)Invalid发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存） E PrRd ⽆总线事务⽣成状态保持不变读操作为缓存命中 PrWr ⽆总线事务⽣成状态变为已修改(M)Modified向缓存块中写⼊修改后的值 BusRd 状态变为共享(S)Shared发出总线FlushOpt信号并发出块的内容 BusRdX 状态变为⽆效发出总线FlushOpt信号并发出块的内容 S PrRd ⽆总线事务⽣成状态保持不变读操作为缓存命中 PrWr 发出总线事务BusUpgr信号状态转换为已修改(M)Modified其他缓存看到BusUpgr总线信号，标记其副本为为无效(I)Invalid BusRd 状态变为共享(S)Shared可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据） BusRdX 状态变为⽆效(I)Invalid可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据） I PrRd 给总线发BusRd信号其他处理器看到BusRd，检查⾃⼰是否有有效的数据副本，通知发出请求的缓存如果其他缓存有有效的副本，其中⼀个缓存发出数据，状态变为(S)Shared如果其他缓存都没有有效的副本，从主存获得数据，状态变为(E)Exclusive PrWr 给总线发BusRdX信号状态转换为(M)Modified如果其他缓存有有效的副本, 其中⼀个缓存发出数据；否则从主存获得数据如果其他缓存有有效的副本, ⻅到BusRdX信号后⽆效其副本向缓存块中写⼊修改后的值 BusRd 状态保持不变，信号忽略 BusRdX/BusUpgr 状态保持不变，信号忽略 image-20221019145117675 状态机动图 内存屏障编译器和处理器都必须遵守重排序规则。在单处理器的情况下，不需要任何额外的操作便能保持正确的顺序。但是对于多处理器来说，保证一致性通常需要增加内存屏障指令。即使编译器可以优化掉字段的访问（例如因为未使用加载到的值），编译器仍然需要生成内存屏障，就好像字段访问仍然存在一样（可以单独将内存屏障优化掉）。 内存屏障只与内存模型中的高级概念（例如 acquire 和 release）间接相关。内存屏障指令只直接控制 CPU 与其缓存的交互，以及它的写缓冲区（持有等待刷新到内存的数据的存储）和它的用于等待加载或推测执行指令的缓冲。这些影响可能导致缓存、主内存和其他处理器之间的进一步交互。 几乎所有的处理器都至少支持一个粗粒度的屏障指令（通常称为 Fence，也叫全屏障），它保证了严格的有序性：在 Fence 之前的所有读操作（load）和写操作（store）先于在 Fence 之后的所有读操作（load）和写操作（store）执行完。对于任何的处理器来说，这通常都是最耗时的指令之一（它的开销通常接近甚至超过原子操作指令）。大多数处理器还支持更细粒度的屏障指令。 LoadLoad Barrier（读读屏障） 指令 Load1; LoadLoad; Load2 保证了 Load1 先于 Load2 和后续所有的 load 指令加载数据。通常情况下，在执行预测读（speculative loads）或乱序处理（out-of-order processing）的处理器上需要显式的 LoadLoad Barrier。在始终保证读顺序（load ordering）的处理器上，这些屏障相当于无操作（no-ops）。 StoreStore Barrier（写写屏障） 指令 Store1; StoreStore; Store2 保证了 Store1 的数据先于 Store2 及后续 store 指令的数据对其他处理器可见（刷新到内存）。通常情况下，在不保证严格按照顺序从写缓冲区（store buffers）或者 缓存（caches）刷新到其他处理器或内存的处理器上，需要使用 StoreStore Barrier。 LoadStore Barrier（读写屏障） 指令 Load1; LoadStore; Store2 保证了 Load1 的加载数据先于 Store2 及后续 store 指令刷新数据到主内存。只有在乱序（out-of-order）处理器上，等待写指令（waiting store instructions）可以绕过读指令（loads）的情况下，才会需要使用 LoadStore 屏障。 StoreLoad Barrier（写读屏障）刷新写缓冲区，最耗时 指令 Store1; StoreLoad; Load2 保证了 Store1 的数据对其他处理器可见（刷新数据到内存）先于 Load2 及后续的 load 指令加载数据。StoreLoad 屏障可以防止后续的读操作错误地使用了 Store1 写的数据，而不是使用来自另一个处理器的更近的对同一位置的写。因此只有需要将对同一个位置的写操作（stores）和随后的读操作（loads）分开时，才严格需要 StoreLoad 屏障。StoreLoad 屏障通常是开销最大的屏障，几乎所有的现代处理器都需要该屏障。之所以开销大，部分原因是它需要禁用绕过缓存（cache）从写缓冲区（Store Buffer）读取数据的机制。这可以通过让缓冲区完全刷新，外加暂停其他操作来实现，这就是 Fence 的效果。一般用 Fence 代替 StoreLoad Barrier ，所以事实上，执行 StoreLoad 指令同时也获得了其他三个屏障的效果，但是通过组合其他屏障通常不能获得与 StoreLoad Barrier 相同的效果。 各处理器支持的内存屏障和原子操作： 另外原文中还有写屏障，读屏障读写屏障等详细说明这里不加赘述 单向屏障： 单向屏障 (half-way barrier) 也是一种内存屏障，但它不是以读写来区分的，而是像单行道一样，只允许单向通行，例如 ARM 中的 stlr 和 ldar 指令就是这样。 stlr 的全称是 store release register，包括 StoreStore barrier 和 LoadStore barrier（场景少），通常使用 release 语义将寄存器的值写入内存； ldar 的全称是 load acquire register，包括 LoadLoad barrier 和 LoadStore barrier（对，你没看错，我没写错），通常使用 acquire 语义从内存中将值加载入寄存器； release 语义的内存屏障只不允许其前面的读写向后越过屏障，挡前不挡后； acquire 语义的内存屏障只不允许其后面的读写向前越过屏障，挡后不挡前 StoreLoad barrier 就只能使用 dmb（全屏障） 代替了。 参考资料 CPU缓存一致性：从理论到实战","tags":[{"name":"并发","slug":"并发","permalink":"http://tyler-ytr.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"并发算法理论","date":"2022-10-06T09:38:37.000Z","path":"2022/10/06/并发算法理论/","text":"并发算法理论[toc] 内存模型Sequential Consistency model n个线程一个共享的内存memory，每一个读都是最近的写入的值；（交错，通过枚举行为得到所有可能的行为） image-20221005142819393 SC是比较强的内存模型；比如如下例子： Init x=y=0 x=1 \\ \\ y=1 r1=y \\ \\ r2=x 在SC model不会出现r1=r2=0;但是在x86或者java会出现； 弱内存模型设计标准 DRF(data race freedom) guarantee 数据竞争保证：满足DRF的程序在弱内存模型下的行为和SC模型的行为一样；（其中怎么看待一个程序是不是DRF的指的是这个程序在SC下面是不是DRF的） DRF定义： 当出现两个并发的冲突操作的时候会出现数据竞争： 冲突：两个操作都访问一块内存区域并且至少一个是写操作 并发： 在不同模型不一样 在java里面，就是两个操作没有happen-before顺序； 如果是SC model；那么一个线程内部前后操作c1,c2；或者两个线程的通过锁保护的部分有happen-before关系；(也就是 $program ~order~\\cup~synchronize-with$) 可以被实现(不能特别强) 优化：支持通常的优化（编译器的优化） 硬件：允许正常的map到现代体系结构的compilation scheme 保证内存安全和安全保证（不能特别弱）,不能出现一些凭空出现的行为 弱内存模型不好设计，编译器的优化会令人惊讶。 java memory model的核心——happen-before memory model(hmm) 相对于SC的枚举定义行为的方式，HMM使用声明式(declarative semantics)定义程序的行为（给一个行为判定是不是满足weak memory model约束） Happen before order 程序执行：事件集合，他们之间存在顺序(po(program order)+sw(synchronize-with)): happen before order:$po\\cup sw$的传递闭包: 约束，Read能看到的： 在它之前happen-before最近的写 与他毫无happen-before的写 上图中r可以看到w1也可以看到w2 判定程序行为的方式： 画执行图 给一个行为，判断合不合理（先猜然后解读，形成环） 存在good speculation和bad speculation;HMM可以产生out-of-thin-air read(凭空产生的读) 在HMM之上为了区分good/bad speculation 加入了很多复杂的内容形成了JMM 并发的基本操作语义basic domain $r\\in Reg$ 表示寄存器，本地变量 $x\\in Loc$ 共享的，地址 $v\\in Val$ 值，包含0 $i\\in Tid={1,..,N}$ 线程标识 Expressions and commands $e::=r|v|e+e|e-e|e*e|e/e$ $c::=skip|if~e~then~c~else~c|while~e~do~c|c;c|r:=e|r:=x|x:=e|r:=FAA(x,e)|r:=CAS(x,e,e)|fence $ FAA(x,e): fetch and add:读取x里面的值，存到局部变量r里面，然后加上e，这个是原子发生的； CAS(x,e,e):Compare-and-Swap:比较memory里面的东西是否和前面一个e一样，如果一样就设置为新的值(后面的e)，如果不一样就什么都不做；这也是原子操作；返回值表示是否成功(成功r为1否则为0) fence: SC下啥都不做；weak memory model里面x=1;fence;y=x;fence会保证x一定已经写入了memory； Program$P:Tid\\rightarrow Cmd,written ~as~P=c_1||…||c_N$ 描述程序含义$P,S,M\\Rightarrow P’,S’,M‘$ S表示线程的寄存器集合，M表示共享内存，P表示程序； 初始状态，程序在状态上执行i:l步，转换成另外一种状态； 上述可以分为两个子系统，线程子系统，存储子系统；另外还需要把这两个子系统合起来 线程子系统简述 线程代码c， 自己的寄存器是s:$c,s\\stackrel{l}{\\longrightarrow}c’,s’$ 顺序程序 提升到程序步骤:$P,S\\stackrel{i:l}{\\longrightarrow}P’,S’$ 存储子系统简述 描述内存访问以及fence $M\\stackrel{i:l}{\\longrightarrow}M’$ 线程子系统 image-20221005174019875 横线上是前提，下面是结论；如果不需要前提直接可以走上面就没有；$\\epsilon$ 表示空指令; U(x,v,v+s(e))表示update，既可以读memory也可以写memory； 合成到并发程序级别 image-20221005203506160 这里l表示和memory model的交互；i是线程的id； Transition表示只有线程i相关的部分(程序和register)发生了变化，表示：每次都是任取一个线程i走一步，然后代码就是线程i执行之后的结果，其他线程的部分不变 存储子系统Sequential Consistency model 存储子系统 SC model： TSO 存储子系统 TSO存储模型，用于x86： 每一个线程都有一个buffer，写的时候不会直接写而是写到buffer里面；然后不定时的把清空buffer，把里面的值写入到memory里面；读的时候先看buffer，有的话直接读取buffer否则读memory； 存在情况，线程A写到了自己的buffer里面，线程B读的是memory里面的值； 相对于上面只有一个接口l，现在下面这部分需要考虑buffer和memory这块接口以及把他们合起来的方法； TSO存储子系统的状态： A memory M:$Loc\\rightarrow Val$ 通过Loc可以获得值 A function B: $Tid\\rightarrow (Loc,Val)^*$ 每一个线程都有自己的buffer，buffer里面是一串写操作(通过(Loc，Val)对表示)； 初始状态：$&lt;M_0,B_0&gt;$ 1. $M_0=\\lambda x.0$ 所有位置都是0 2. $B_0=\\lambda i.\\epsilon$ 所有buffer都是空的 TSO存储子系统的状态转化： WRITE表示在原来的基础上增加一个$&lt;x,v&gt;$操作； PROPAGATE表示把buffer里面的内容写入memory；buffer里面越往右越旧，所以先写右边的内容； READ操作表示的是buffer里面有就读buffer否则就读memory，并且M,B不变； RMW read modify write(指FAA,CAS这类指令)要求buffer为空，并且会对memory做更新； FENCE 这个操作要求当前线程的buffer是空的； TSO模型的例子: | 例子 | store | buffering || —- | —– | ——— || x=1 | || | y=1 || r1=y | || | r2=x | r1=r2=1? TSO模型可以（两边都读的旧值），SC模型不行 存储，线程合并起来SC model image-20221005211134906 初始的执行若干步($\\Rightarrow *$)能够产生O说明这个O是被允许的； TSO model image-20221005213210938 并发的声明式语义(Declarative semantics for concurrency) 总体思想：不去想程序怎么执行（操作语义这么整），而是产生一系列程序有可能执行的图，然后通过规则判定这些图上哪一些能够被model解释 具体而言： Define the notion of a program execution (generalization of an execution trace) Map a program to a set of executions (与程序有关) Define a consistency predicate on executions (定义公理，比如happen-before等约束) Semantics = set of consistent executions of a program (上述满足约束的所有程序) 例子： 例子中有事件： Reads, Writes, Updates, Fences 有两种关系：程序执行顺序(Program order,po;或者“sequenced-before”, sb)，黑色实线; Reads-from 顺序, rf，绿色虚线 执行图的定义 Label：有以下格式： $R~x~v_rW~x~v_w U(x~v_r~ v_w) ~~F$ 其中$x \\in Loc$ and $v_r , v_w \\in Val$. Event：是一个元组$&lt;id, i, l&gt;$: $id\\in N$表示事件标识符 $i \\in Tid \\cup {0}$ 是线程标识符 l是一个label 执行图(execution graph)：是一个元组$&lt;E, po, rf&gt;$： E是events的有限集合 po (“program order”) 是 E 上的偏序关系 rf (“reads-from”) 是 E 上的二元关系： For every $&lt;w, r&gt;\\in rf$: $typ(w) \\in {W, U}$ w操作要么是写要么是更新(U) $typ(r) \\in {R, U}$ r操作要么是读要么是更新 $loc(w) = loc(r)$ 读写的位置一样 $val_w(w) = val_r(r)$ 读写的值一样 $rf^{ −1}$ is a function,that is: if $&lt;w_1, r&gt;$, $&lt;w_2, r&gt;$,then $w_1 = w_2$ ；表示读只能读一个写 其他一些标记： 程序映射到执行图 例子，与程序有关的图： 线程子系统将一个顺序(sequential)执行图与每个命令关联起来。通过连接组成线程的顺序执行图可以得到程序的执行； 如果满足以下性质，一个图是sequential的（也就是与一个线程有关的执行图的性质）： $tid(a) = 0$ for every $a \\in G.E$ （与下面第四点Thread restriction有关，表示只有一个线程） $G.po$ is a total order on $G.E$ （一个线程中的事件一定是有序的） $G.rf = \\empty$ 命令的执行图的定义： 与内存有交互的命令会产生执行图的变化 Thread restriction： 给定线程号$i\\in Tid$，以及一个执行图G，$G^i$表示把G的事件限制成只有与线程i相关的事件:${a\\in G.E|tid(a)=i}$，并且把他们的线程标识都改成0，丢弃所有rf边； Execution graph of a program: $G$ is an execution graph of a program $P $ (with an outcome $O)$ if $G_i$ is an execution of $P(i) $ (with final store O(i)) for every$i \\in Tid$. 一致性谓词(consistency predicate) 假设X是执行图上的一些一致性谓词，那么程序P在X下允许出现的结果O，定义为如果存在一个执行图G满足： G is an execution graph of P with outcome O. G是P的执行图能产生O G is X-consistent. G满足X-一致性 或者，“catch-fire” semantics定义：(对应于C/C++的undefined behavior，此时任何的O都可以产生) 存在一个执行图G满足： G is an execution graph of P. G是P的执行图 G is X-consistent. G满足X-一致性 G is “bad”. Completeness定义： 一个执行图G成为completeness，如果codom(G.rf) = G.R使得每一个read都能从一些write read from 也就是图上所有的read都通过rf边连接到write Sequential consistency任何执行的结果都与所有处理器的操作按照程序指定的顺序按某种顺序执行是一样的。 SC-consistent 定义：假设sc是G,E上面的全序；如果下列情况满足，则称G是关于sc SC -consistent的： If $&lt;a, b&gt; \\in G.po$ then $&lt;a, b&gt;\\in sc$. (program order 里的都满足sc) If $&lt;a, b&gt; \\in G.rf$ then $&lt;a, b&gt; \\in sc $ and there does not exist $c \\in G.W_{loc}(b)$ such that $&lt;a, c&gt; \\in sc$ and $&lt;c, b&gt; \\in sc$. (不同线程之间读应该读上一次写，中间有write是不可能的) 一个执行图如果满足下列条件那么是SC-consistent的： G is complete. G is SC-consistent wrt some total order sc on G.E. (所有事件之间要有一个sc order) 例子： forbidden部分因为sc下一定会形成一个环，此时这个不是order了，因此不允许； allowed部分可以先R y 0然后W y 1，此时就可以构成全序了； Sequential consistency 另外的定义 Modification order定义: $mo$ is called a modification order for an execution graph G if $mo = \\cup _{x\\in Loc} mo_x$ where each $mo_x$ is a total order on $ G.Wx$ . mo只在这张图的write之间建立，同一个loc上的write上面有一条边，称为$mo_x$，所有$mo_x$的并形成了mo； SC的另一种定义： 所有的po,rf,mo,rb边合起来是无环的； rb的定义就是rf取逆然后加上mo，比如$Wy0 \\rightarrow Wy1 (mo),Wy0\\rightarrow Ry0(rf)$，因此$Ry0\\rightarrow Wy0(rf^{-1})$，有$Ry0\\rightarrow Wy1(rb)$ rb的定义去掉id是考虑到U的情况（因为U和W可以有mo关系也可以有rf关系，有可能形成自环） 两种定义是等价的，证明如下： image-20221006154701915 Relax Sequential consistency原因：在硬件里面实现SC非常昂贵，并且SC禁止了许多对于顺序代码的优化 大多数硬件保证SC-per-location，又称作coherence；如果一个执行图是coherent的那么有如下性质： G is complete 对于所有的位置x，在所有对x的访问上存在一个全序关系$sc_x$: if $&lt;a,b&gt;\\in [RW_x];G.po;[RW_x]$,then $&lt;a,b&gt;\\in sc_x$ $Rw_X$表示对x的读写操作; $&lt;a,b&gt;\\in A;B$: 这条的意思是a,b是和x的读写有关的，如果它们之间是program order的关系，那么它们要属于$sc_x$ If $&lt;a, b&gt; \\in [W_x];G.rf; [Rx]$ , then $&lt;a, b&gt; \\in sc_x$ and there does not exist $c \\in G.W_x$ such that $&lt;a, c&gt; \\in sc_x$ and$&lt;c, b&gt; \\in sc_x$ . 与前面的定义相似，主要区别是对于x的位置限定 另外一个版本的定义： 主要区别是在同一个location上面不能成环； 个人总结：所有的对于同一个loc的write之间有一个全序mo，在某一个loc的read一定有rf关系（先写再write），然后所有的R,W之间有一个全序关系（program order）;取rf的反向边为fr，那么rb=fr+mo（类似于向量运算）；上面这些不能成环； 反例： no-future-read,rmw-1： coherence-ww,coherence-rw,coherence-wr,coherence-rr: 下面程序对应于最后一个执行图，是不行的（有环） rmw-2,atomicity 另外一个版本的定义（对应于上面这些图）： 假设mo是执行图G的modification order，那么G关于mo是coherent的当且仅当以下性质成立： rf; po is irreflexive. (no-future-read) mo; po is irreflexive. (coherence-ww) mo; rf; po is irreflexive. (coherence-rw) rf−1; mo; po is irreflexive. (coherence-wr) rf−1; mo; rf; po is irreflexive. (coherence-rr) rf is irreflexive. (rmw-1) mo; rf is irreflexive. (rmw-2) rf−1; mo; mo is irreflexive. (rmw-atomicity) 实际操作的时候，首先根据程序得到po，然后根据read的值得到rf关系，最后嵌入mo（多种嵌入方式分开讨论验证） coherence相对还是太弱了，没有办法让锁真正应用（因为lock之后对于其他地方的修改其实该一致性不做限制） Release/acquire (RA) memory model 注：$(a,b)\\in (po\\cup rf)^+$ 后者表示闭包，也就是a,b之间po,rf边出现一次或者多次；实际上比po要延续更长的距离，让model更强 RA实际上就是把coherence的po换成了$(a,b)\\in (po\\cup rf)^+$: 具体定义： 另一种定义： $(po \\cup rf)^+$ is irreflexive. (no-future-read) 也就是po,rf无环；不会是某一个事件a开始经过若干个po,rf然后回到a； $mo; (po \\cup rf)^+$ is irreflexive. (coherence-ww) 不会是某一个事件a开始首先经过mo然后经过若干个po,rf然后回到a； $rf^{−1}; mo; (po \\cup rf)^+$ is irreflexive. (coherence-wr) $rf^{−1}; mo; mo$ is irreflexive. (rmw-atomicity) Access model大致思想是混合coherence model和RA memory model； 每一个内存访问都有一个模式： Reads: rlx or acq Writes: rlx or rel RMWs: rlx, acq, rel or acq-rel PS: rl 是 relax的缩写，指的是满足coherence model一致性；rel,release缩写，acq,acquire缩写，满足RA memory model一致性 强度顺序,$\\sqsubset$定义： 中间的表示读是rlx然后写不一样 Happen before 同步(Synchronization)： image-20221008155231257 表示的是W要么是release要么比release更强；R同理 Happen-before: $G.hb = (G.po \\cup G.sw)^+$ C/C++11 memory model 简介 定义：实际上是把coherence model的po用hb进行了”增强”： C/C++11 memory model 下面的强度关系：(比access model 更多一点类型) $non-atomic\\sqsubset relaxed\\sqsubset release/acquire\\sqsubset sc$ non-atomic用于没有数据竞争的代码（默认） fence也有以上四种类型","tags":[{"name":"并发","slug":"并发","permalink":"http://tyler-ytr.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"RDMA-learning4","date":"2022-04-23T12:47:37.000Z","path":"2022/04/23/RDMA-learning4/","text":"RDMA技术整理4 RDMA编程入门连通测试物理拓扑：服务器6和8之间有一根直连网线；两台服务器各有一张cx5网卡，支持RoCe 使用ibdev2netdev查看设备： 使用show_gids看看网卡支持的RoCe版本 这里的IPv4地址是通过nmtui进行配置的 服务器8根据如上的信息使用ib_send_bw -d mlx5_1 -x 2，作为信号的接收端；另一台服务器6使用sudo ib_send_bw -d mlx5_3 192.168.42.8 --report_gbits -F -x 2进行信息的发送；（5_3是服务器6里面有ipv4地址并且up的设备） 测试结果: 接收端： 发送端： RDMA 常用命令参考自https://blog.csdn.net/bandaoyu/article/details/115798693 命令 操作 备注 ibv_devinfo 显示device信息（简略） ibv_devinfo mlx5_0 显示设备mlx5_0的详细信息 ibv_devinfo -v 显示网卡信息（详细） ibv_devices 列出device ibvdev2netdev 显示device和网口的对应关系 mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令 show_gids 显示gid列表 mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令 show_drop 查看端口包丢弃情况 mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令 ibstatus 查看核更改网卡工作模式：Ethernet 或infiniband模式 ibv_asyncwatch 监视 InfiniBand 异步事件 iblinkinfo.pl 或 iblinkinfo 显示光纤网络中所有链路的链路信息 sminfo 用法sminfo –help;查询 IB SMInfo 属性 ibstat 或 ibsysstat 查询 InfiniBand 设备状态或 IB 地址上的系统状态 hca_self_test.ofed RDMA网卡自测 mellonx /etc/infiniband/info Mellanox OFED 安装的信息 mellonx cat /etc/infiniband/openib.conf 看自动加载的模块列表 mellonx `lspci grep Mellanox` 检查Mellanox网卡是否安装和版本 RDMA 编程入门RDMA 编程入门1这部分来自the-geek-in-the-corner的01_basic-client-server； 在上述配置中的运行方法和连通实验类似： 在两个服务器使用make； 服务器8作为server使用./server，程序告知端口号是36436； 服务器6作为client使用./client 192.168.42.8 36436；这里的IP地址和上面连通测试使用的IP地址一样 运行结果： server8，服务端： 1234567temp@R750-427Server8:~/worker/the-geek-in-the-corner/01_basic-client-server$ ./serverlistening on port 36436.received connection request.received message: message from active/client side with pid 21871connected. posting send...send completed successfully.peer disconnected. server6，客户端： 1234567temp@R750-427Server6:~/worker/the-geek-in-the-corner/01_basic-client-server$ ./client 192.168.42.8 36436address resolved.route resolved.connected. posting send...send completed successfully.received message: message from passive/server side with pid 14356disconnected. 这部分代码的目标是连接两个应用程序，让他们能够交换数据。这部分的关键是QP pair和CP，连接的每一端都有发送-接受队列和一个完成队列。构建队列并且对他们相互连接的步骤如下： 创建保护域（关联队列对、完成队列、内存注册等）、完成队列和发送-接收队列对。 确定队列对的地址。 将地址传送到另一个节点（通过某些带外机制）。 将队列对转换为“随时可以接收”（RTR） 状态，然后转换为“准备发送”（RTS） 状态。 根据需要发布发送、接收等操作 主动端（请求端）和被动端（响应端）的具体步骤如下： 被动端： 创建一个事件通道，以便我们可以接收 rdmacm 事件，例如连接请求和连接建立的通知。 绑定到地址。 创建侦听器并返回端口/地址。 等待连接请求。 创建保护域、完成队列和发送-接收队列对。 接受连接请求。 等待建立连接。 根据需要发布操作。 主动端： 创建一个事件通道，以便我们可以接收 rdmacm 事件，例如地址解析、路由解析和连接建立的通知。 创建连接标识符。 解析对等方的地址，这会将连接标识符绑定到本地 RDMA 设备。 创建保护域、完成队列和发送-接收队列对。 解析到对等方的路由。 连接。等待建立连接。 根据需要发布操作。 双方将共享相当数量的代码 - 被动端的步骤 1、5、7 和 8 大致相当于主动端的步骤 1、4、7 和 8。一旦建立了连接，与套接字一样，双方都是对等的。利用连接需要我们在队列对上发布操作。接收操作（不出所料）发布在接收队列上。在发送队列上，我们发布发送请求、RDMA 读/写请求和原子操作请求。 Passive/Server side上面交代了被动端设置的部分，现在是详细的代码部分。因为几乎所有的内容都是异步处理的；因此这项工作首先需要构建一个事件处理循环和一组时间处理器： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;rdma/rdma_cma.h&gt; #define TEST_NZ(x) do &#123; if ( (x)) die(\"error: \" #x \" failed (returned non-zero).\" ); &#125; while (0)#define TEST_Z(x) do &#123; if (!(x)) die(\"error: \" #x \" failed (returned zero/null).\"); &#125; while (0) static void die(const char *reason); int main(int argc, char **argv)&#123; return 0;&#125; void die(const char *reason)&#123; fprintf(stderr, \"%s\\n\", reason); exit(EXIT_FAILURE);&#125; 接下来设置一个事件通道，创建一个ramdacm ID(相当于套接字)，绑定之后再循环中等待事件，这部分是修改main()函数： 12345678910111213141516171819202122232425262728293031323334353637static void on_event(struct rdma_cm_event *event); int main(int argc, char **argv)&#123; struct sockaddr_in addr; struct rdma_cm_event *event = NULL; struct rdma_cm_id *listener = NULL; struct rdma_event_channel *ec = NULL; uint16_t port = 0; memset(&amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; TEST_Z(ec = rdma_create_event_channel()); TEST_NZ(rdma_create_id(ec, &amp;listener, NULL, RDMA_PS_TCP)); TEST_NZ(rdma_bind_addr(listener, (struct sockaddr *)&amp;addr)); TEST_NZ(rdma_listen(listener, 10)); /* backlog=10 is arbitrary */ port = ntohs(rdma_get_src_port(listener)); printf(\"listening on port %d.\\n\", port); while (rdma_get_cm_event(ec, &amp;event) == 0) &#123; struct rdma_cm_event event_copy; memcpy(&amp;event_copy, event, sizeof(*event)); rdma_ack_cm_event(event); if (on_event(&amp;event_copy)) break; &#125; rdma_destroy_id(listener); rdma_destroy_event_channel(ec); return 0;&#125; ec 是指向 rdmacm 事件通道的指针。listener是指向侦听器的 rdmacm ID 的指针。我们在创建它时指定了RDMA_PS_TCP，这表明我们需要一个面向连接的可靠队列对。RDMA_PS_UDP将指示无连接、不可靠的队列对。 然后，我们将此 ID 绑定到套接字地址。通过将端口（addr.sin_port）设置为零，我们指示 rdmacm 选择一个可用端口。我们还指出，我们希望侦听任何可用 RDMA 接口/设备上的连接。 我们的事件循环从 rdmacm 获取事件，确认事件，然后对其进行处理。未能确认事件将导致rdma_destroy_id（） 阻塞。连接的被动端的事件处理程序仅对三个事件感兴趣： 12345678910111213141516171819static int on_connect_request(struct rdma_cm_id *id);static int on_connection(void *context);static int on_disconnect(struct rdma_cm_id *id); int on_event(struct rdma_cm_event *event)&#123; int r = 0; if (event-&gt;event == RDMA_CM_EVENT_CONNECT_REQUEST) r = on_connect_request(event-&gt;id); else if (event-&gt;event == RDMA_CM_EVENT_ESTABLISHED) r = on_connection(event-&gt;id-&gt;context); else if (event-&gt;event == RDMA_CM_EVENT_DISCONNECTED) r = on_disconnect(event-&gt;id); else die(\"on_event: unknown event.\"); return r;&#125; 从上述代码结合前面的main函数break的条件可以看出来，这里只关注on_event里面的三种事件，如果不是这三种就会继续循环（等待）； rdmacm 允许我们将 void *上下文指针与 ID 相关联。我们将使用它来附加连接上下文结构： 123456789struct connection &#123; struct ibv_qp *qp; struct ibv_mr *recv_mr; struct ibv_mr *send_mr; char *recv_region; char *send_region;&#125;; 它包含一个指向队列对（冗余，但略微简化了代码）、两个缓冲区（一个用于发送，另一个用于接收）和两个内存区域（用于发送/接收的内存必须“注册”到谓词库）的指针。当我们收到连接请求时，如果尚未构建动词上下文，我们首先构建该上下文。然后，在构建了连接上下文结构之后，我们预先发布了我们的接收信息（稍后会详细介绍），并接受连接请求： 1234567891011121314151617181920212223242526272829static void build_context(struct ibv_context *verbs);static void build_qp_attr(struct ibv_qp_init_attr *qp_attr);static void post_receives(struct connection *conn);static void register_memory(struct connection *conn); int on_connect_request(struct rdma_cm_id *id)&#123; struct ibv_qp_init_attr qp_attr; struct rdma_conn_param cm_params; struct connection *conn; printf(\"received connection request.\\n\"); build_context(id-&gt;verbs); build_qp_attr(&amp;qp_attr); TEST_NZ(rdma_create_qp(id, s_ctx-&gt;pd, &amp;qp_attr)); id-&gt;context = conn = (struct connection *)malloc(sizeof(struct connection)); conn-&gt;qp = id-&gt;qp; register_memory(conn); post_receives(conn); memset(&amp;cm_params, 0, sizeof(cm_params)); TEST_NZ(rdma_accept(id, &amp;cm_params)); return 0;&#125; 我们推迟构建谓词上下文，直到收到第一个连接请求，因为rdmacm listener ID 不一定绑定到特定的 RDMA 设备（以及关联的谓词上下文）。但是，我们收到的第一个连接请求将在id-&gt;verbs` 处具有有效的谓词上下文结构。构建谓词上下文涉及设置静态上下文结构、创建保护域、创建完成队列、创建完成通道以及启动线程以从队列中提取完成： 123456789101112131415161718192021222324252627282930313233struct context &#123; struct ibv_context *ctx; struct ibv_pd *pd; struct ibv_cq *cq; struct ibv_comp_channel *comp_channel; pthread_t cq_poller_thread;&#125;; static void * poll_cq(void *); static struct context *s_ctx = NULL; void build_context(struct ibv_context *verbs)&#123; if (s_ctx) &#123; if (s_ctx-&gt;ctx != verbs) die(\"cannot handle events in more than one context.\"); return; &#125; s_ctx = (struct context *)malloc(sizeof(struct context)); //设置静态上下文结构、创建保护域、创建完成队列、创建完成通道 s_ctx-&gt;ctx = verbs; TEST_Z(s_ctx-&gt;pd = ibv_alloc_pd(s_ctx-&gt;ctx)); TEST_Z(s_ctx-&gt;comp_channel = ibv_create_comp_channel(s_ctx-&gt;ctx)); TEST_Z(s_ctx-&gt;cq = ibv_create_cq(s_ctx-&gt;ctx, 10, NULL, s_ctx-&gt;comp_channel, 0)); TEST_NZ(ibv_req_notify_cq(s_ctx-&gt;cq, 0)); TEST_NZ(pthread_create(&amp;s_ctx-&gt;cq_poller_thread, NULL, poll_cq, NULL));&#125; 使用完成通道允许我们阻塞轮询器线程等待完成。我们创建完成队列，并将cqe设置为 10（cqe是ibv_create_cq 函数里面的第二个参数），表示我们希望在队列上留出 10 个条目的空间。此数字应设置得足够大，以便队列不会溢出。轮询器在通道上等待，确认完成，重新排列完成队列（使用 ibv_req_notify_cq()），然后从队列中提取事件，直到没有事件留下： 123456789101112131415161718static void on_completion(struct ibv_wc *wc); void * poll_cq(void *ctx)&#123; struct ibv_cq *cq; struct ibv_wc wc; while (1) &#123; TEST_NZ(ibv_get_cq_event(s_ctx-&gt;comp_channel, &amp;cq, &amp;ctx)); ibv_ack_cq_events(cq, 1); TEST_NZ(ibv_req_notify_cq(cq, 0)); while (ibv_poll_cq(cq, 1, &amp;wc)) on_completion(&amp;wc); &#125; return NULL;&#125; 回到我们的连接请求。构建动词上下文后，我们必须初始化队列对属性结构： 12345678910111213void build_qp_attr(struct ibv_qp_init_attr *qp_attr)&#123; memset(qp_attr, 0, sizeof(*qp_attr)); qp_attr-&gt;send_cq = s_ctx-&gt;cq; qp_attr-&gt;recv_cq = s_ctx-&gt;cq; qp_attr-&gt;qp_type = IBV_QPT_RC; qp_attr-&gt;cap.max_send_wr = 10; qp_attr-&gt;cap.max_recv_wr = 10; qp_attr-&gt;cap.max_send_sge = 1; qp_attr-&gt;cap.max_recv_sge = 1;&#125; 我们首先将结构清零，然后设置我们关心的属性。 send_cq 和 recv_cq分别是发送和接收完成队列。qp_type 设置为表明我们想要一个可靠的、面向连接的队列对。队列对功能结构 qp_attr-&gt;cap 用于与动词驱动程序协商最小功能。在这里，我们请求十个挂起的发送和接收（在它们各自的队列中的任何时间），以及每个发送或接收请求一个分散/收集元素（SGE；实际上是一个内存位置/大小元组）。建立队列对初始化属性后，我们调用 rdma_create_qp() 来创建队列对。然后我们为我们的连接上下文结构（结构连接）分配内存，并为我们的发送和接收操作分配/注册内存： 12345678910111213141516171819const int BUFFER_SIZE = 1024; void register_memory(struct connection *conn)&#123; conn-&gt;send_region = malloc(BUFFER_SIZE); conn-&gt;recv_region = malloc(BUFFER_SIZE); TEST_Z(conn-&gt;send_mr = ibv_reg_mr( s_ctx-&gt;pd, conn-&gt;send_region, BUFFER_SIZE, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE)); TEST_Z(conn-&gt;recv_mr = ibv_reg_mr( s_ctx-&gt;pd, conn-&gt;recv_region, BUFFER_SIZE, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE));&#125; 在这里，我们分配两个缓冲区，一个用于发送，另一个用于接收，然后用动词注册它们。我们指出需要对这些内存区域进行本地写入和远程写入访问。连接请求事件处理程序中的下一步（变得相当长）是预先发布接收。在接受连接之前必须发布接收工作请求 （WR） 的原因是，基础硬件不会缓冲传入消息 — 如果接收请求尚未发布到工作队列，则传入消息将被拒绝，对等方将收到接收器未就绪 （RNR） 错误。我将在另一篇文章中进一步讨论这个问题，但现在只需说必须在发送之前发布接收。我们将通过在接受连接之前发布收到的邮件，并在建立连接后发送发送来强制执行此操作。发布接收需要我们构建一个接收工作请求结构，然后将其发布到接收队列： 12345678910111213141516void post_receives(struct connection *conn)&#123; struct ibv_recv_wr wr, *bad_wr = NULL; struct ibv_sge sge; wr.wr_id = (uintptr_t)conn; wr.next = NULL; wr.sg_list = &amp;sge; wr.num_sge = 1; sge.addr = (uintptr_t)conn-&gt;recv_region; sge.length = BUFFER_SIZE; sge.lkey = conn-&gt;recv_mr-&gt;lkey; TEST_NZ(ibv_post_recv(conn-&gt;qp, &amp;wr, &amp;bad_wr));&#125; （任意）wr_id字段用于存储连接上下文指针。最后，完成所有这些设置后，我们已准备好接受连接请求。这是通过调用rdma_accept（）来完成的。 我们需要处理的下一个事件是RDMA_CM_EVENT_ESTABLISHED，这表示已建立连接。这个处理程序很简单 - 它只是发布一个发送工作请求： 12345678910111213141516171819202122232425int on_connection(void *context)&#123; struct connection *conn = (struct connection *)context; struct ibv_send_wr wr, *bad_wr = NULL; struct ibv_sge sge; snprintf(conn-&gt;send_region, BUFFER_SIZE, \"message from passive/server side with pid %d\", getpid()); printf(\"connected. posting send...\\n\"); memset(&amp;wr, 0, sizeof(wr)); wr.opcode = IBV_WR_SEND; wr.sg_list = &amp;sge; wr.num_sge = 1; wr.send_flags = IBV_SEND_SIGNALED; sge.addr = (uintptr_t)conn-&gt;send_region; sge.length = BUFFER_SIZE; sge.lkey = conn-&gt;send_mr-&gt;lkey; TEST_NZ(ibv_post_send(conn-&gt;qp, &amp;wr, &amp;bad_wr)); return 0;&#125; 这与我们用于发布接收的代码没有根本的不同，除了发送请求指定了操作码。此处，IBV_WR_SEND指示必须与对等体上的相应接收请求匹配的发送请求。其他选项包括 RDMA 写入、RDMA 读取和各种原子操作。在 wr.send_flags 中指定IBV_SEND_SIGNALED表示我们需要此发送请求的完成通知。 我们要处理的最后一个 rdmacm 事件是RDMA_CM_EVENT_DISCONNECTED，我们将在其中执行一些清理： 1234567891011121314151617181920int on_disconnect(struct rdma_cm_id *id)&#123; struct connection *conn = (struct connection *)id-&gt;context; printf(\"peer disconnected.\\n\"); rdma_destroy_qp(id); ibv_dereg_mr(conn-&gt;send_mr); ibv_dereg_mr(conn-&gt;recv_mr); free(conn-&gt;send_region); free(conn-&gt;recv_region); free(conn); rdma_destroy_id(id); return 0;&#125; 我们所要做的就是处理从完成队列中提取的完成： 1234567891011121314void on_completion(struct ibv_wc *wc)&#123; if (wc-&gt;status != IBV_WC_SUCCESS) die(\"on_completion: status is not IBV_WC_SUCCESS.\"); if (wc-&gt;opcode &amp; IBV_WC_RECV) &#123; struct connection *conn = (struct connection *)(uintptr_t)wc-&gt;wr_id; printf(\"received message: %s\\n\", conn-&gt;recv_region); &#125; else if (wc-&gt;opcode == IBV_WC_SEND) &#123; printf(\"send completed successfully.\\n\"); &#125;&#125; 回想一下，在 post_receives（） 中，我们设置了对连接上下文结构的wr_id。就是这样！建造很简单，但不要忘记-lrdmacm。此处提供了被动端/服务器和主动端/客户端的完整代码。（在之后的部分作者讨论了优化） 参考资料 the-geek-in-the-corner Building an RDMA-capable application with IB verbs, part 1: basics RDMA tutorial PDFs","tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://tyler-ytr.github.io/tags/RDMA/"}]},{"title":"项目开发记录","date":"2022-04-19T03:16:27.000Z","path":"2022/04/19/项目开发记录/","text":"院系项目开发记录参与院系项目开发，对开发过程中的一些配置进行记录； 配置 Node需要大于16，采用了项目https://github.com/jasongin/nvs 进行项目的配置；在win里面输入nvs就可以下载以及选择对应的node版本号； yarn使用npm i -g yarn","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://tyler-ytr.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"RDMA技术整理3","date":"2022-04-18T06:30:04.000Z","path":"2022/04/18/RDMA-learning3/","text":"RDMA技术整理3 RDMA基本功能RDMA基本元素参考于知乎专栏 | 缩略语 | 全称 | 含义 || —— | ———————— | ———————————————————— || WQ | Work Queue | 储存工作请求的队列 || WQE | Work Queue Element | 工作队列里面的元素 || QP | Queue Pair | 一对WQ，包括了SQ,RQ；通信的基本单元 || SQ | Send Queue | QP中的发送端队列 || RQ | Receive Queue | QP中的接受端队列 || SRQ | Shared Receive Queue | 共享接收队列，几个QP共享同一个RQ时，我们称其为SRQ || CQ | Completion Queue | 完成队列，承载CQE的容器，一个先进先出的队列 || CQE | Completion Queue Element | 如果WQE是软件下发给硬件的“任务书”的话，那么CQE就是硬件完成任务之后返回给软件的“任务报告”。 || WR | Work Request | 工作请求，WQE和CQE在用户层的“映射” || WC | Work Completion | 工作完成，WQE和CQE在用户层的“映射” | RMDA基本操作RDMA有two-sided和one-sided的区别，一般情况下涉及大量数据的收发更多使用的是one-sided操作，另外在resource-disaggregation的场景中也一般使用one-sided的操作，因为memory节点在设计中往往不会给强力的CPU； RDMA双端操作 SEND &amp; RECV双端操作的含义是：完成一次通信过程需要两端CPU的参与，并且接收端需要提前显式下发WQE( Work Queue Element)； 在SEND-RECV操作中，不仅仅发送端需要下发WQE，接收端也需要下发WQE，目的是告诉硬件收到的数据要放到哪一个地址，发送端并不知道发送的数据会放到哪里，因此每一次发送数据的时候接收端需要提前准备好接受Buffer；具体如上图（另外执行顺序并不完全和上面的顺序一致，比如步骤8 11 12和步骤9 10的先后是不一定的） 这部分在下一篇博客中有具体的实现。 RDMA one-sided 操作 WRITE &amp; READone-sided的含义在于，除了准备阶段，服务端的CPU都不需要参与，也不需要感知数据写入和结束接受的过程，因此称为是one-sided的。 在进行WRITE和READ操作之前，首先会经历准备阶段，也就是请求端需要获得响应端某块内存的权限，具体而言：对于RDMA，响应者的buffer被描述成为一个虚拟地址(VA,Virtual Address)和一个R-KEY;在WRITE或者READ操作开始之前，响应方会把这个buffer的控制权传递给请求方，请求方会控制缓冲区，知道控制权传回到响应程序；这个准备过程通常可以用SEND/RECV来完成。完成了之后响应端的CPU就不会再参与数据收发的过程，解放了远端CPU，降低了通信时延。另外虚拟地址–物理地址的转换是通过RDMA网卡来完成的。 接下来是WRITE操作的流程： 请求端APP以WQE（WR）的形式下发一次WRITE任务。 请求端硬件从SQ中取出WQE，解析信息。 请求端网卡根据WQE中的虚拟地址，转换得到物理地址，然后从内存中拿到待发送数据，组装数据包。 请求端网卡将数据包通过物理链路发送给响应端网卡。 响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，将数据放置到指定内存区域。 响应端回复ACK报文给请求端。 请求端网卡收到ACK后，生成CQE，放置到CQ中。 请求端APP取得任务完成信息。 READ是WRITE相反的过程，是请求端主动读取响应端内存的行为，要注意到”读“这个动作的数据是附带在响应端回复的报文里面的，具体流程如下： 请求端APP以WQE的形式下发一次READ任务。 请求端网卡从SQ中取出WQE，解析信息。 请求端网卡将READ请求包通过物理链路发送给响应端网卡。 响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，从指定内存区域取出数据。 响应端硬件将数据组装成回复数据包发送到物理链路。 请求端硬件收到数据包，解析提取出数据后放到READ WQE指定的内存区域中。 请求端网卡生成CQE，放置到CQ中。 请求端APP取得任务完成信息。 通过RDMA的READ,WRITE操作，其实可以发现这个和本地内存拷贝非常像，只不过一个是用RDMA网卡一个使用CPU来做罢了。 参考资料 RDMA用户编程手册 IB Specification Vol 1-Release-1.5-2021-08-06b.pdf RDMA杂谈","tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://tyler-ytr.github.io/tags/RDMA/"}]},{"title":"RDMA技术整理2","date":"2022-04-16T09:24:19.000Z","path":"2022/04/16/RDMA-learning2/","text":"RDMA技术整理2 RDMA概述RDMA背景TCP/IP通信使用传统的TCP/IP通信，数据需要通过用户空间发送到远端的用户空间，就需要经历若干次内存拷贝。 TCP/IPvsRDMA 数据发送方需要讲数据从用户空间 Buffer 复制到内核空间的 Socket Buffer 数据发送方要在内核空间中添加数据包头，进行数据封装 数据从内核空间的 Socket Buffer 复制到 NIC Buffer 进行网络传输 数据接受方接收到从远程机器发送的数据包后，要将数据包从 NIC Buffer 中复制到内核空间的 Socket Buffer 经过一系列的多层网络协议进行数据包的解析工作，解析后的数据从内核空间的 Socket Buffer 被复制到用户空间 Buffer 这个时候再进行系统上下文切换，用户应用程序才被调用 这就带来了高速网络环境下面，TCP/IP在主机侧数据移动和复制操作的高开销，影响了带宽。 针对这个问题提出了多种解决方案，主要介绍如下两种： TCP offloading engine RDMA TCP offloading engine这个技术主要就是把CPU进行的多层网络协议数据包处理工作，比如数据复制、协议处理和中断处理等等操作转移到支持offloading的网卡上。如下图所示 TCP offloading engine TOE(TCP offloading engine)技术将原来在协议栈中进行的IP分片、TCP分段、重组、checksum校验等操作，转移到网卡硬件中进行 普通网卡处理每个数据包都要触发一次中断，TOE 网卡则让每个应用程序完成一次完整的数据处理进程后才触发一次中断，显著减轻服务器对中断的响应负担。 TOE 网卡在接收数据时，在网卡内进行协议处理，因此，它不必将数据复制到内核空间缓冲区，而是直接复制到用户空间的缓冲区，这种“零拷贝”方式避免了网卡和服务器间的不必要的数据往复拷贝。 RDMARDMA的目的是更快更轻量级的网络通信，利用了Kernel Bypass和Zero Copy技术的低延迟特性，减少了CPU占用和内存带宽瓶颈。对外RDMA提供了基于IO的通道，允许一个应用程序通过RDMA设备对远程的虚拟内存进行直接的读写。它的整体架构图如下： RDMA整体架构 RDMA技术有以下特点： CPU Offload：无需CPU干预，应用程序可以访问远程主机内存而不消耗远程主机中的任何CPU。远程主机内存能够被读取而不需要远程主机上的进程（或CPU)参与。远程主机的CPU的缓存(cache)不会被访问的内存内容所填充 Kernel Bypass：RDMA 提供一个专有的 Verbs interface 而不是传统的TCP/IP Socket interface。应用程序可以直接在用户态执行数据传输，不需要在内核态与用户态之间做上下文切换 Zero Copy：每个应用程序都能直接访问集群中的设备的虚拟内存，这意味着应用程序能够直接执行数据传输，在不涉及到网络软件栈的情况下，数据能够被直接发送到缓冲区或者能够直接从缓冲区里接收，而不需要被复制到网络层。 RDMA架构目前主要有三种硬件实现，可以使用同一套API： Infiniband：基于 InfiniBand 架构的 RDMA 技术，由 IBTA（InfiniBand Trade Association）提出。搭建基于 IB 技术的 RDMA 网络需要专用的 IB 网卡和 IB 交换机。从性能上，很明显Infiniband网络最好，但网卡和交换机是价格也很高，然而RoCEv2和iWARP仅需使用特殊的网卡就可以了，价格也相对便宜很多。 iWARP：Internet Wide Area RDMA Protocal，基于 TCP/IP 协议的 RDMA 技术，由 IETF 标 准定义。iWARP 支持在标准以太网基础设施上使用 RDMA 技术，而不需要交换机支持无损以太网传输，但服务器需要使用支持iWARP 的网卡。与此同时，受 TCP 影响，性能稍差。 RoCE：基于以太网的 RDMA 技术，也是由 IBTA 提出。RoCE支持在标准以太网基础设施上使用RDMA技术，但是需要交换机支持无损以太网传输，需要服务器使用 RoCE 网卡，性能与 IB 相当。 下面以Infiniband技术为例介绍它的分层架构： 这部分来自于前面的博客以及Introduction to InfiniBand Infiniband分层与架构Inifiniband包含了多种设备，channel adapter、switch、router、subnet manager，它提供了一种基于通道的点对点消息队列转发模型，每个应用都可通过创建的虚拟通道直接获取本应用的数据消息，无需其他操作系统及协议栈的介入。Channel adapter是安装在主机或者其他任何系统(如存储设备)上的网络适配器，这种组件为数据包的始发地或者目的地；Switch包含了多个InfiniBand端口根据每个数据包 LRH 里面的 LID，负责将一个端口上收到的数据包发送到另一个端口。Router根据 L3 中的 GRH，负责将 Packet 从一个子网转发到另一个子网，当被转到到另一子网时，Router 会重建数据包中的 LID。Subnet Manager负责配置本地子网，使其保持工作。 image-20220418135934106 image-20220418140051181 InfiniBand 有着自己的协议栈，从上到下依次包括传输层、网络层、数据链路层和物理层： image-20220418140528211 如上图是数据包的封装。 物理层物理层支持光线和铜，绝大多数采用4 Link； 链路层这部分是架构的核心，包含了如下部分： Packets：链路层由两种类型的Packets，Data Packet 和 Management Packet，数据包最大可以为 4KB，数据包传输的类型包括两种类型 Memory：RDMA read/write，atomic operation（其实就是内存操作） Channel：send/receive，multicast transmission Switching：在子网中，Packet 的转发和交换是在链路层完成的 一个子网内的每个设备有一个由 subnet manager分配的 16 bit Local ID (LID) 每个 Packet 中有一个 Local Route Header (LRH) 指定了要发送的目标 LID 在一个子网中通过 LID 来负责寻址 Qos：链路层提供了 QoS 保证，不需要数据缓冲 Virtual Lanes：一种在一条物理链路上创建多条虚拟链路的机制。虚拟通道表示端口的一组用于收发数据包的缓冲区。支持的 VL 数是端口的一个属性。 每个 Link 支持 15 个标准的 VL 和一个用于 Management 的 VL15，VL15 具有最高等级，VL0 具有最低等级 Service Level：InfiniBand 支持多达 16 个服务等级，但是并没有指定每个等级的策略。InfiniBand 通过将 SL 和 VL 映射支持 QoS Credit Based Flow Control：发送数据包之前，发送方和接收方需要协商数据量credit，接收方保证有足够的Buffer，之后传输才能进行。 Data Integrity：链路层通过 Packet 中的 CRC 字段来进行数据完整性校验，其组成包括 ICRC 和 VCRC。 image-20220418141433546 网络层网络层负责将 Packet 从一个子网路由到另一个子网： 在子网之间发送的数据包包含全局路由标头 （GRH）。GRH 包含数据包源和目标的 128 位 IPv6 地址。数据包通过基于每个设备的 64 位全局唯一 ID （GUID） 的路由器在子网之间转发。路由器在每个子网中使用正确的本地地址修改 LRH。因此，路径中的最后一个路由器将 LRH 中的 LID 替换为目标端口的 LID。 下面是 GRH 报头的格式，长40字节，可选，用于组播数据包以及需要穿越多个子网的数据包。它使用 GID 描述了源端口和目标端口，其格式与 IPv6 报头相同。 image-20220418142238178 传输层传输层负责 Packet 的按序传输、根据 MTU 分段和很多传输层的服务(reliable connection, reliable datagram, unreliable connection, unreliable datagram, raw datagram)。InfiniBand 的传输层提供了一个巨大的提升，因为所有的函数都是在硬件中实现的。 RDMA技术相对于传统技术在技术整理1中介绍了DMA的知识；RDMA与DMA相似，它的含义是远程直接地址访问；通过RDMA，本端节点可以“直接”访问远端节点的内存。所谓直接，指的是可以像访问本地内存一样，绕过传统以太网复杂的TCP/IP网络协议栈读写远端内存，而这个过程对端是不感知的，而且这个读写过程的大部分工作是由硬件而不是软件完成的。 传统以太网socket通信 在传统的以太网socket通信中，一次收发过程如下： 发送端和接收端通过Socket库提供的接口建立链接（就是在两个节点间建立了一条逻辑上的道路，数据可以沿这条道路从一端发送到另一端）并分别在内存中申请好发送和接收Buffer。 发送端APP通过Socket接口陷入内核态，待发送数据经过TCP/IP协议栈的一层层封装，最后被CPU复制到Socket Buffer中。 发送端通过网卡驱动，告知网卡可以发送数据了，网卡将通过DMA从Buffer中复制封装好的数据包到内部缓存中，然后将其发送到物理链路。 接收端网卡收到数据包后，将数据包放到接收Buffer中，然后CPU将通过内核中的TCP/IP协议栈对报文进行层层解析，取出有效的数据。 接收端APP通过Socket接口陷入内核态，CPU将数据从内核空间复制到用户空间。 socket数据流向 因此数据相当于如上图流向，需要从用户空间复制到内核空间（CPU）然后网卡从内核空间把处理好的数据从物理链路发送到对端网卡；对端网卡过程相似。 RDMA把模型分成了两部分，一部分是控制通路一部分是数据通路，控制通路需要进入内核态准备通信所需的内存资源，而数据通路指的是实际数据交互过程中的流程。具体的通信过程如下： 发送端和接收端分别通过控制通路陷入内核态创建好通信所需要的内存资源。 在数据通路上，接收端APP通知硬件准备接收数据，告诉硬件将接收到的数据放在哪片内存中。 在数据通路上，发送端APP通知硬件发送数据，告诉硬件待发送数据位于哪片内存中。 发送端RDMA网卡从内存中搬移数据，组装报文发送给对端。 对端收到报文，对其进行解析并通过DMA将有效载荷写入内存。然后以某种方式通知上层APP，告知其数据已经接受并且存放到指定位置 具体的数据流向如下： RDMA数据流向 可以看出这部分减少了CPU的参与，报文的组装和解析通过硬件而不是CPU完成。这就是RDMA技术的优势所在。 参考博客 https://houmin.cc/posts/454a90d3/ https://www.cnblogs.com/bandaoyu/p/15478210.html RDMA杂谈 https://zhuanlan.zhihu.com/p/139548242","tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://tyler-ytr.github.io/tags/RDMA/"}]},{"title":"RDMA技术整理1","date":"2022-04-16T07:35:20.000Z","path":"2022/04/16/RDMA-learning/","text":"RDMA技术整理1 DMA技术概述RDMA全称是Remote Direct Memory Access，基本理念可以看成是远程的DMA技术，目的是为了解决网络传输中数据处理的延迟。因此首先了解一下DMA技术 DMA技术与零拷贝参考于该博客 该技术用于I/O过程。众所周知，磁盘速度相对于内存以及CPU cache非常慢，因此有很多用于优化磁盘的技术比如零拷贝，异步I/O等等。DMA也是其中的技术之一。 DMA背景DMA技术之前，I/O过程如下图： 传统IO CPU 发出对应的指令给磁盘控制器，然后返回； 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断； CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。 这种策略需要CPU亲自参与数据的搬运，在传输大量数据的时候用CPU搬运显然是开销过大的；因此开发了新设备DMA控制器负责数据的搬运。具体过程如下图： 有DMA的IO 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态； 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务； DMA 进一步将 I/O 请求发送给磁盘； 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满； DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务； 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU； CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； 可以看出在数据传输的过程中，CPU不再参与数据搬运的工作，这部分由DMA做完了，CPU要做的是进行DMA的调用。DMA一开始是存在于主板，现在一般处于各个I/O设备中。 文件传输过程如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。传统的方法需要两个系统调用: 12read(file, tmp_buf, len);write(socket, tmp_buf, len); 传统传输文件 如上图发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，每一次调用都意味着：用户态保留现场，转换到内核态处理，转换到用户态这样的过程，每一次切换都需要耗时几十纳秒到几微秒，高并发情况下会影响系统性能。 另外发生了四次拷贝： 磁盘通过DMA拷贝到内核缓冲区 内核缓冲区数据拷贝到用户缓冲区 用户缓冲区拷贝到内核缓冲区 内核缓冲区通过DMA拷贝到网卡缓冲区 数据拷贝也会消耗CPU资源降低系统性能。 总共发生了四次上下文切换和四次数据拷贝。 零拷贝为了优化文件传输的性能，主要从两个方面下手：减少用户态和内核态上下文的切换（也就是减少系统调用），减少数据拷贝的次数； 为了实现零拷贝，目前主要由两种方式： mmap+write sendfile mmap+write使用read()会把内核缓冲区的数据拷贝到用户缓冲区中，使用mmap()会直接把内核缓冲区映射到用户空间，减少了内核和用户空间之间的数据拷贝： 12buf = mmap(file, len);write(sockfd, buf, len); mmap+write 如上图：调用了mmap()之后，DMA就会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；然后使用write()会让系统直接把内核缓冲区的数据拷贝到socket缓冲区中，最后DMA把socket缓冲区的数据拷贝到网卡缓冲区中。 因此mmap()代替read()可以减少一次数据拷贝。最后需要四次上下文切换，三次数据拷贝。 sendfile在linux 2.1内核中出现了sendfile()系统调用: 12#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。 它可以代替read(),write()系统调用，减少了一次系统调用（相当于减少了两次上下文切换）；另外它可以直接把内核缓冲区的数据拷贝到socket缓冲区中不需要拷贝到用户态，最后只有两次上下文切换和三次数据拷贝。 sendfile1 如果网卡支持SG-DMA(The Scatter-Gather Direct Memory Access)，那么可以进一步减少通过CPU把内核缓冲区拷贝到socket缓冲区的过程； linux系统可以通过如下命令查看是否支持: 12$ ethtool -k eth0 | grep scatter-gatherscatter-gather: on 如果支持该功能，并且linux内核&gt;=2.4，那么sendfile()的过程会发生如下变化： 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝； sendfile2 这就是零拷贝，因为没有通过CPU来进行数据搬运的过程； 最后总共使用了两次上下文切换和两次数据拷贝，并且都不需要走CPU，都是DMA进行的拷贝；可以把传输文件的性能提高至少一倍以上。","tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://tyler-ytr.github.io/tags/RDMA/"}]},{"title":"算法框架","date":"2022-02-15T02:50:07.000Z","path":"2022/02/15/算法框架/","text":"参考https://labuladong.gitee.io/ 进行模板的整理 数据结构二叉树 image-20220215105403320 二叉搜索树 image-20220222115911238 对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。 对于 BST 的每一个节点 node，它的左侧子树和右侧子树都是 BST。 BST 的中序遍历结果是有序的（升序）。 1234567void traverse(TreeNode root) &#123; if (root == null) return; traverse(root.left); // 中序遍历代码位置 print(root.val); traverse(root.right);&#125; 进行BST验证的时候不能仅仅只考虑左右以及根节点，因为root的整个左子树都要小于root.val，右子树同理。 123456789101112131415boolean isValidBST(TreeNode root) &#123; return isValidBST(root, null, null);&#125;/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) &#123; // base case if (root == null) return true; // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST if (min != null &amp;&amp; root.val &lt;= min.val) return false; if (max != null &amp;&amp; root.val &gt;= max.val) return false; // 限定左子树的最大值是 root.val，右子树的最小值是 root.val return isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);&#125; BST搜索元素记得左小右大就行了，插入元素同理（找到root==nullptr的时候插入一个新的节点）。 遍历DFS 遍历框架 123456789101112void traverse(TreeNode root)&#123; if (root == null) &#123; return; &#125; // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 &#125; 层序遍历框架： 12345678910111213141516171819202122&#x2F;&#x2F; 输入一棵二叉树的根节点，层序遍历这棵二叉树void levelTraverse(TreeNode root) &#123; if (root &#x3D;&#x3D; null) return; Queue&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;(); q.offer(root); &#x2F;&#x2F; 从上到下遍历二叉树的每一层 while (!q.isEmpty()) &#123; int sz &#x3D; q.size(); &#x2F;&#x2F; 从左到右遍历每一层的每个节点 for (int i &#x3D; 0; i &lt; sz; i++) &#123; TreeNode cur &#x3D; q.poll(); &#x2F;&#x2F; 将下一层节点放入队列 if (cur.left !&#x3D; null) &#123; q.offer(cur.left); &#125; if (cur.right !&#x3D; null) &#123; q.offer(cur.right); &#125; &#125; &#125;&#125; BFS框架： 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离int BFS(Node start, Node target) &#123; Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构 Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路 q.offer(start); &#x2F;&#x2F; 将起点加入队列 visited.add(start); int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数 while (q not empty) &#123; int sz &#x3D; q.size(); &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F; for (int i &#x3D; 0; i &lt; sz; i++) &#123; Node cur &#x3D; q.poll(); &#x2F;* 划重点：这里判断是否到达终点 *&#x2F; if (cur is target) return step; &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F; for (Node x : cur.adj()) &#123; if (x not in visited) &#123; q.offer(x); visited.add(x); &#125; &#125; &#125; &#x2F;* 划重点：更新步数在这里 *&#x2F; step++; &#125;&#125; 算法排序归并排序 归并排序的逻辑，若要对 nums[lo..hi] 进行排序，我们先对 nums[lo..mid] 排序，再对 nums[mid+1..hi] 排序，最后把这两个有序的子数组合并，整个数组就排好序了。 12345678910void sort(int[] nums, int lo, int hi) &#123; int mid = (lo + hi) / 2; sort(nums, lo, mid); sort(nums, mid + 1, hi); /****** 后序遍历位置 ******/ // 合并两个排好序的子数组 merge(nums, lo, mid, hi); /************************/&#125; 快速排序 快速排序的逻辑是，若要对 nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。 12345678910111213141516171819202122232425//严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) &#123; int pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; --high; &#125; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low; &#125; void QuickSort(int A[], int low, int high) //快排母函数 &#123; if (low &lt; high) &#123; int pivot = Paritition1(A, low, high); QuickSort(A, low, pivot - 1); QuickSort(A, pivot + 1, high); &#125; &#125;","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"spark学习笔记","date":"2022-01-12T05:00:30.000Z","path":"2022/01/12/spark-learning/","text":"spark学习笔记idea maven加速 右键项目中的pom.xml等，在Maven中选择修改setting.xml，如果没有这个配置文件会有create setting.xml的选项， 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 添加如上的mirrors Spark 依赖这部分需要在项目的pom.xml中进行配置，主要是增加了dependencies那部分内容: 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;testclasses&lt;/artifactId&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spark-core&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.12&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 要注意的是，可以通过右击pom.xml然后maven然后reload project来完成这部分依赖的下载 HADOOP 环境依赖如果没有HADOOP环境依赖就会报一个恶心的错误 Could not locate executablenull\\bin\\winutils.exe in the Hadoop binaries以及这个诱发的奇奇怪怪的错误。可能可以采用https://github.com/steveloughran/winutils；实操使用的是尚硅谷给的配置文件，已经上传到了百度网盘。 12链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1z23GQYaPmzq7VDS_f2646A 提取码：piza 然后配置一下环境变量，HADOOP_HOME 给 hadoop-3.1.0；然后Path环境变量加一个%HADOOP_HOME%\\bin，重启IDEA就行了 wordcount这部分参考了尚硅谷的教程，文件结构如下图： image-20220113170935084 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.test.spark.core.wcimport org.apache.spark.rdd.RDDimport org.apache.spark.&#123;SparkConf, SparkContext&#125;object spark01_wordcount &#123; def main(args: Array[String]): Unit = &#123; //Application //Spark框架 //TODO 建立和Spark框架的连接 //JDBC：Connection // 创建 Spark 运行配置对象 val sparkConf: SparkConf = new SparkConf().setMaster(\"local\").setAppName(\"WordCount\") // 创建 Spark 上下文环境对象（连接对象） val sc = new SparkContext(sparkConf) //TODO 执行业务操作 //1.读取文件，获取一行一行的数据 //Hello World val lines: RDD[String] = sc.textFile(\"datas\") //2.将一行数据进行拆分，形成一个个的单词（分词=&gt;扁平化：将整体拆分成个体的操作） //\"Hello World\" =&gt; Hello,World... //val words: RDD[String] = lines.flatMap(s =&gt; s.split(\" \")) val words: RDD[String] = lines.flatMap(_.split(\" \")) //3.将数据根据单词进行分组，便于统计 //(hello,hello...),(world,world,world...) val wordGroup: RDD[(String, Iterable[String])] = words.groupBy(word =&gt; word) //4.将分组后的数据进行转换 //(hello,hello...),(world,world,world...) //(hello,2),(world,3) val res: RDD[(String, Int)] = wordGroup.map &#123; case (word, list) =&gt; &#123; (word, list.size) &#125; &#125; //5.将转换的结果采集到控制台打印出来 val array: Array[(String, Int)] = res.collect() array.foreach(println) //TODO 关闭 Spark 连接 sc.stop() &#125;&#125; scala快速入门因为spark由scala编写而成，因此快速入门一下scala,学习了这个专栏https://zhuanlan.zhihu.com/p/32859134 scala是一种函数式语言，其函数也能当成值来使用。Scala提供了轻量级的语法用以定义匿名函数，支持高阶函数，允许嵌套多层函数，并支持柯里化。Scala的case class及其内置的模式匹配相当于函数式编程语言中常用的代数类型。可以利用Scala的模式匹配，编写类似正则表达式的代码处理数据。 从并发角度而言：Scala使用Actor作为其并发模型，Actor是类似线程的实体，通过“邮箱”发收消息。Actor可以复用线程，因此可以在程序中可以使用数百万个Actor，而线程只能创建数千个。在2.10之后的版本中，使用Akka作为其默认Actor实现。 主要内容 变量 函数 数组 映射和元组转换 类与对象 继承与特质 集合 模式匹配和样例 变量 不强制指定变量的类型可以编译器推断出来 12scala&gt; 8*5res0:Int=40 val值不能改变它的内容，鼓励使用val 可变的变量用var 变量或者函数的类型写在变量或者函数的后面，有点像go 1val test:String=\"test\" 不需要使用分号最后，仅当同一行代码中存在多条语句时才需要分号隔开。 常用的数据类型与Java一样，Byte、Char、Short、Int、Long、Float、Double及Boolean，这些都是类。 +-*/%等操作符实际上是方法。 对于BigInt和BigDecimal对象，可以以常规的方式使用数学操作符（但在Java中同样的操作要写成x.multiply(x)）。 12scala&gt;val x:BigInt=11111111222222222333333333333scala&gt;x*x 函数 表达式有值，语句执行动作。 函数式中不使用return。 语句中，分号不是必需的。 代码块也有值，最后一个表达式就是值。if表示式有值。 Scala中，几乎所有构造出来的语法结构都有值，不像Java中把表达式和语句（if语句）分为两类。 条件表达式 在Scala中if/else表达式有值，这个值就是在if或else之后的表达式的值。 12345678scala &gt; var x = 10 x : Int = 10 scala &gt; val r = if ( x &gt; 0 ) 1 else - 1 r : Int = 1 scala &gt; var x = 0 x : Int = 0 scala &gt; val r = if ( x &gt; 0 ) 1 else - 1 r : Int = - 1 可能if没有输出值，但在Scala中，每个表达式都有某种值。 1234scala &gt; var x = 0 x : Int = 0 scala &gt; val r = if ( x &gt; 0 ) 1 r : AnyVal = ()## 因为x=0，所以此时未定义 块表达式 在Scala中{}块包含一系列表达式，其结果也是一个表达式。块中最后一个表达式的值就是块的值。 对于某个val的初始化需要分多步完成的情况很实用。 1val dis = &#123; val dx = x - x0 ; val dy = y - y0 ; sqrt ( dx * dx + dy * dy )&#125; 循环 while 循环和java一样 for循环： 123for ( i &lt;- 1 to n ) &#123; r = r * i &#125; 1 to n：[1,n] 1 until n:[1,n) 增强for循环 可以多个生成器，用分号隔开 1scala &gt; for ( i &lt;- 1 to 3 ; j &lt;- 1 to 3 ) print (( 10 * i + j ) + \" \" ) 每个生成器都可以带一个守卫，以if开头的Boolean表达式 (if前并没有分号) 1scala &gt; for ( i &lt;- 1 to 3 ; j &lt;- 1 to 3 if i != j ) print (( 10 * i + j ) + \" \" ) for推导式：for循环的循环以yield开始，则该循环会构造出一个集合，每次迭代生成集合中的一个值。和python yield一样 12scala&gt; for(i &lt; -1 to 10) yield i%3res2:scala.collection.immutable.IndexedSeq[Int]=Vector(1,2,0,1,2,0,1,2,0,1) 函数 需要给出函数名、参数和函数体 必须给出所有参数的类型 1def abs(x:Double)= if (x&gt;=0)x else -x 递归函数必须指定返回值类型 1def fac(n:Int):Int = if(n&lt;=0)1 else n* fac(n-1) 不需要return 用=连接函数体 默认参数以及带名参数 123scala&gt;def decorate(str:String,left:String=\"[\",right:String=\"]\")=left+str+rightscala&gt;decorate(\"test\")scala&gt;decorate(\"test\",\"&#123;\",\"&#125;\") 也可以指定参数，此时顺序可以不一样 可以混用未命名以及指定参数，未命名的排在前面，和C++一样 可以实现接受可变长列表的参数，用* 1234567scala&gt;def sum(arg:Int*)=&#123; var result=0 for(arg &lt;- args)result+=arg result &#125;scala&gt;val s = sum(1,2,3,4)s: Int = 10 可以用_*把一个整数区间转换成参数序列： 对于上面的sum，应该输入一个列表，因此输入sum(1 to 5)是错的，需要输入sum(1 to 5: _*) 如果函数体包含在花括号当中，但没有前面的 =号，返回类型是Unit，这样的函数被称做过程。过程不返回值，调用它仅仅是为了它的副作用。 当val被声明为lazy时，它的初始化将被推迟，直到首次对它取值。 12lazy val words = scala . io . Source . fromFile ( \"/usr/share/dict/words\" ). mkString##可以故意把文件名写错，试一下在初始化语句被执行的时候会不会报错（只有访问words时才提示文件未找到） 数组 长度固定使用Array，长度有变化使用ArrayBuffer 提供初始值时不要使用new 用()来访问元素 for(elem &lt;- arr)遍历元素 for(elem &lt;- arr if …) yield …将原数组转为新数组 定长数组 整数初始化为0，string用new初始化为null，提供初始值不需要new，用()访问（相当于C++[]） 123scala&gt; val nums = new Array[Int](10)scala&gt; val str1 = Array(\"Hello\", \"Scala\")scala&gt; val s = str1(0) 变长数组 使用ArrayBuffer，需要import scala.collection.mutable.ArrayBuffer 初始化: 1scala&gt; val b = ArrayBuffer[Int]() +=追加元素或者多个用括号包起来的 12scala&gt; b+=1scala&gt; b+=(2,3) ++=追加任何集合 1scala&gt; b++=Array(4,5,6) 用b.trimEnd(2)移除最后两个元素 可以在任何地方插入或者移除(不高效，需要移动后面的所有元素) 1scala&gt; b.insert(2,3,4) ## 在下标2的地方插入3,4，比如(1,2,9)变成了(1,2,3,4,9) 使用toArray变成定长，toBuffer变成变长 遍历12345scala&gt; for (i &lt;- 0 until b.length) println(i + \":\" + b(i))##或者不用下标scala&gt; for(elem &lt;- b) println(elem) 数组转换 for推导式，从一个数组转换，生成一个全新的数组 12scala&gt; val a = Array(2, 3, 5, 7)scala&gt; val res = for(elem &lt;- a) yield 2 * elem ArrayBuffer同理 映射和元组转换映射 这是键值对的集合，相当于字典 例子: 12345678910111213141516171819202122## 不可变映射，值不能够被改变scala&gt; val scores = Map(\"Alice\" -&gt; 90, \"Bob\" -&gt; 88)## 可变映射scala&gt; val scores1 = scala.collection.mutable.Map(\"Alice\" -&gt; 90, \"Bob\" -&gt; 88)## 构造一个空映射，需要选定一个映射实现并给出类型参数(注意最后是 方括号[] )scala&gt; val scores2 = new scala.collection.mutable.HashMap[String, Int]## 使用()获取键值scala&gt; val aliceScore = scores(\"Alice\")## 判断映射中是否包括某个指定键的值，用contains方法scala&gt; val bobScore = if(scores.contains(\"Bob\")) scores(\"Bob\") else 0## 等价于:scala&gt; val bobScore1 = scores.getOrElse(\"Bob\", 0)## 可变映射中更新某个映射中的值或添加一个新的映射关系scala&gt; val scores1 = scala.collection.mutable.Map(\"Alice\" -&gt; 90, \"Bob\" -&gt; 88)scores1(\"Bob\") = 99scores1(\"Fred\") = 79 ##Fred不存在，会添加一个新的关系## 使用+=操作来添加多个关系(key不存在就添加，存在就更新)scores1 += (\"Yezhiwei\" -&gt; 100, \"Fred\" -&gt; 90)## 使用-=操作来移除某个键值对scores1 -= \"Bob\"## 不可变映射同样的操作不会改变原来的值，但是会返回一个新的对象## 可以使用scores.keys或者scores.values来访问键或者值 元组 元组是不同类型的值的聚集，用圆括号包裹 1scala&gt; (1, 3.14, &quot;Fred&quot;) 元组的组元从1开始，比如可以: 1234scala&gt; (1, 3.14, \"Fred\")res11: (Int, Double, String) = (1,3.14,Fred)scala&gt; res11._1res12: Int = 1s 可以使用模式匹配来获取组元 123scala&gt; val (first, second, third) &#x3D; res11## 不需要的值用_scala&gt; val (first, second, _) &#x3D; res11 元组可以用于函数需要返回不止一个值的情况 12scala&gt; \"Hello Scala\".partition(_.isUpper)res13: (String, String) = (HS,ello cala) 类定义与构造器 每一个类有一个主构造器，它执行类中所有的语句 类中自带getter以及setter方法(jvm getter/setter方法) 用@BeanProperty注解生成JavaBean的getXxx/setXxx方法 辅助构造器是可选的，它们都叫做this 类定义例子： 12345scala&gt; class Counter &#123; | private var value = 0 | def increment() &#123;value += 1&#125; | def current() = value&#125; Scala生成面向JVM的类时，其中有一个私有的age字段及相应的两个公有的getter和setter方法； 对于私有字段，getter和setter方法也是私有的； 在Scala中，getter和setter分别叫做age和age_= (注意下划线和等号间没有空格) 重新定义getter和setter方法，如：年龄不能设置成比现在的更小 123456scala&gt; class Person&#123; | private var privateAge = 0 | def age = privateAge | def age_= (newValue: Int) &#123; | if (newValue &gt; privateAge) privateAge = newValue | &#125; 如何控制Scala对每个字段生成getter和setter的方法？ 如果字段是私有的，则getter和setter方法也是私有的 如果字段是val， 则只生成getter方法 如果不需要任何getter和setter，将字段声明为private[this]即可 用@BeanProperty注解生成JavaBean的getXxx/setXxx方法 123scala&gt; import scala.reflect.BeanPropertyscala&gt; class Person&#123; | @BeanProperty var name: String = _ 将会生成四个方法： name: String name_=(new Value: String): Unit getName(): String setName(newValue: String): Unit 构造器 主构造器例子: 1234567891011// Scalaclass Person(val name: String, val age: Int) &#123;&#125;// 以上代码相当于Java的以下代码public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // getter and setter ...&#125; 除了主构造器之外可以定义任意多的辅助构造器，辅助构造器的名称为this，每一个辅助构造器都需要以一个对先前定义的其他辅助构造器或者主构造器的调用开始 12345678910111213141516class Person &#123; private var name &#x3D; &quot;&quot; private var age &#x3D; 0 def this(name: String) &#123; &#x2F;&#x2F; 调用主构造器 this() this.name &#x3D; name &#125; def this(name:String,age: Int)&#123; &#x2F;&#x2F; 调用前一个辅助构造器 this(name) this.age&#x3D;age &#125; &#125; 单例对象参考单例对象 继承参考继承 特质参考特质 我感觉是一种聚合的形式 高阶函数同时可以参考这个博客 匿名函数,并且可以放到变量中,或者直接传递给另一个函数 12scala &gt; val test=(x:Double) =&gt; 3 * xscala &gt; Array(3.14,1.42).map((x:Double)=&gt;3*x) 在变量中存储非你梦函数需要_，这个表示这个函数: 12scala &gt; def fun ( msg : String ) &#123; println ( msg )&#125;scala &gt; val f = fun _ 带函数参数的函数： 123456789scala &gt; def mulBy ( factor : Double ) = ( x : Double ) =&gt; factor * xmulBy : ( factor : Double ) Double =&gt; Double scala &gt; val q = mulBy ( 5 ) q : Double =&gt; Double = &lt;function1&gt; scala &gt; q ( 20 ) res14 : Double = 100.0 // val q = mulBy(5) 相当于 val q = (x: Double) =&gt; 5 * x// 123456789101112131415161718//函数可以作为参数，进行传递（大多数情况都是通过匿名函数的形式）//定义一个函数calculator，该函数接收一个函数类型的参数op，op定义了对两个整数要进行什么样的操作def calculator(a:Int,b:Int,op:(Int,Int)=&gt;Int): Int =&#123; op(a,b)&#125;//定义一个函数f1,完成两个整数的加法运算def op(a:Int,b:Int):Int=&#123; a + b&#125;//println(calculator(10,20,op))println(calculator(50, 20, (a: Int, b: Int) =&gt; &#123; a - b&#125;))println(calculator(50, 20, _ - _))println(calculator(50, 20, _ + _))*/ 函数可以作为返回值进行返回: 函数的嵌套 函数链式调用，通过参数传递数据，在执行的过程中，函数始终占据栈内存，容易导致内存溢出 1234567891011121314//函数可以作为返回值进行返回----函数的嵌套 def f1():()=&gt;Unit =&#123; def f2(): Unit =&#123; println(\"f2函数被调用了\") &#125; //将f2作为返回值返回给f1 f2 _ &#125; //ff就是f2 //var ff = f1() //ff() //f1()() 闭包 闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。 闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。 内层函数访问外层函数的局部变量，会自动延长外层函数局部变量的生命周期，与内层函数形成一个闭合的效果，我们称之为闭包 12345678910111213141516171819202122232425262728293031323334353637/* def f1(): (Int)=&gt;Int =&#123; var a:Int = 10 def f2(b:Int): Int =&#123; a + b &#125; f2 _ &#125; */ //执行f1函数返回f2,将返回的f2赋值给ff变量 //val ff: Int =&gt; Int = f1() //闭包：内存函数f2要访问外层函数f1局部变量a，当外层函数f1执行结束之后，f1会释放栈内存，但是会自动的延长f1函数的局部变量的生命周期， // 和内层函数f2形成一个闭合的效果，我们将这种闭合的效果称之为闭包 //如果存在闭包，那么编译器会生成包含$anonfun$的字节码文件 //闭包 = 外层函数的局部变量 + 内层函数 //调用ff函数，其实就是调用f2 //println(ff(20)) //也可以直接通过如下方式调用 //println(f1()(30)) println(\"-----------------------------------\") //以上代码可以转换为如下代码 /* def f3() =&#123; var a:Int = 10 (b:Int) =&gt; a + b &#125; f3()(30) */ 柯里化 将一个参数列表中的多个参数，拆分为多个参数列表 好处1：每一个参数列表表示函数清晰明确 好处2：简化闭包代码的编写 123456789101112131415//柯里化 //将一个函数的一个参数列表中的多个参数，拆分为多个参数列表 //简化闭包代码的编写 def f4()(b:Int):Int = &#123; var a:Int = 10 a + b &#125; println(f4()(20)) //f4在执行的时候，其实会转换为以下结构 /* def f4() =&#123; var a:Int = 10 (b:Int) =&gt; a + b &#125; PS: Python 闭包中自由变量与全局变量的区别;python闭包 模式匹配和样例类 mathch表达式是一个更好的switch，不会有穿透到下一个分支的问题 与if类似，match也是表达式，而不是语句 1234567891011object Test &#123; def main(args: Array[String]) &#123; println(matchTest(3)) &#125; def matchTest(x: Int): String = x match &#123; case 1 =&gt; \"one\" case 2 =&gt; \"two\" case _ =&gt; \"many\" &#125;&#125; 结果为: 123$ scalac Test.scala $ scala Testmany scala模式匹配不会自动进入下一个分支，不需要再每一个分支后面使用break case _等价于default match可以使用任意类型，不一定需要数字 还可以给模式添加守卫，比如匹配所有的数字: 123456789101112object Test &#123; def main(args: Array[String]) &#123; println(matchTest(3)) &#125; def matchTest(x: Int): String = x match &#123; case 1 =&gt; \"one\" case 2 =&gt; \"two\" case _ if Character.isDigit(x)=&gt;Character.digit(x,10) case _ =&gt; \"many\" &#125;&#125; 还可以对类型匹配，比如case x:Int=&gt;x这样 另外还有一些技巧见原文 样例类，常用于模式匹配: 123456789101112131415161718object Test &#123; def main(args: Array[String]) &#123; val alice = new Person(\"Alice\", 25) val bob = new Person(\"Bob\", 32) val charlie = new Person(\"Charlie\", 32) for (person &lt;- List(alice, bob, charlie)) &#123; person match &#123; case Person(\"Alice\", 25) =&gt; println(\"Hi Alice!\") case Person(\"Bob\", 32) =&gt; println(\"Hi Bob!\") case Person(name, age) =&gt; println(\"Age: \" + age + \" year, name: \" + name + \"?\") &#125; &#125; &#125; // 样例类 case class Person(name: String, age: Int)&#125; 输出： 12345$ scalac Test.scala $ scala TestHi Alice!Hi Bob!Age: 32 year, name: Charlie? PS:在声明样例类时，下面的过程自动发生了： 构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做； 在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象； 提供unapply方法使模式匹配可以工作； 生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。","tags":[{"name":"分布式系统","slug":"分布式系统","permalink":"http://tyler-ytr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"spark","slug":"spark","permalink":"http://tyler-ytr.github.io/tags/spark/"}]},{"title":"分布式缓存1","date":"2022-01-07T06:18:05.000Z","path":"2022/01/07/分布式缓存1/","text":"分布式缓存1：CPU与分布式系统这部分主要参考博客https://xie.infoq.cn/article/fa1f0f9ac1cfee7845f7b29fe 中的内容 单个存储器读吞吐没有办法满足要求的情况下，往往会在存储器上面增加一个或者多个缓存，但是因为相同的数据被复制到同一个或者多个地方，就会产生数据一致性的问题。不一致的数据可能出现在同级 Cache 之间 (Cache Coherence) 和上下级 Cache 之间。解决这些数据一致性问题的方案可以统称为 Cache Policies。从本质上看，所有 Cache Policies 的设计目的都可以概括为：在增加一级缓存之后，系统看起来和没加缓存的行为一致，但得益于局部性原理，系统的读吞吐量提高、时延减少。 考虑的缓存的位置，以下主要从： 单核处理器 多核处理器 Cache/DB架构 三个部分进行讨论。 单核处理器中的Cache policy","tags":[{"name":"分布式系统","slug":"分布式系统","permalink":"http://tyler-ytr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"分布式系统","date":"2021-12-26T03:35:38.000Z","path":"2021/12/26/distributed-system/","text":"分布式系统的特征以及系统模型什么是分布式系统 分布式系统是若干独立计算机的集合，在用户看来是一个单一相关系统。 例如:分配给用户的工作站网络、机房中动态分配的处理器池、单个文件系统等。 分布式系统涉及到网络、处理器、内存、存储、协议等。 分布式系统的目标 使资源可访问 透明性 开放性 可扩展性 为什么要分布式 经济：相比于大型机，微型处理器的性价比更高 速度：分布式系统比大型机计算能力更强 内在分布：一些应用需要在不同空间的机器上运行 可靠性：当某一台机器挂掉时，分布式系统仍能运行 可增加：通过增加分布式系统的组件使其计算能力增强 使资源可访问 分布式系统的最主要目标是使用户能够方便地访问远程资源，并且以一种受控方式与其他用户共享这些资源。 透明性 对用户和应用程序员屏蔽分布式系统组件和分散性，系统被认为是一个整体，而不是独立的组件集合。透明性对用户和应用程序员隐藏了与手头任务无直接关系的资源，并匿名使用，使得分布的某些特性对应用程序员具有不可见性，这样应用程序员只要关心特定应用的设计问题。 开放性 能与其他开放的系统进行交互，不考虑底层环境，要求系统： 良好说明的接口 支持程序的可移植性 系统容易交互 可拓展性 三个方面： 规模上可扩展（用户和处理器数目） 地域上可扩展（节点最大距离） 管理上可扩展（管理域数） 分布式系统的类型 分布式计算系统： 集群计算：本质是通过高速局域网连接的一组高端系统，每个节点运行相同的操作系统，硬件几乎相同，只有一个管理节点，同构性 网格计算：异构性，硬件、操作系统、网络、管理域都不尽相同，可以跨广域网 分布式信息系统： 事务处理系统：有ACID四种特性，主要应用于数据库，邮件系统，财务系统等 原子性：对于外部来说，事务处理不可见 一致性：事务处理不会违反系统的不变性 独立性：并发的事务不会相互干扰 持久性：事务处理一旦提交，所发生改变是永久性的 分布式普适系统：新兴的下一代分布式系统，其中节点小，移动，并且经常嵌入在更大的系统中，其特征在于系统自然地混合到用户环境中； 如何理解机制与策略 在开放的分布式系统中要获得灵活性，就要把系统组织成规模相对较小且容易修改和替换的组件，需要将策略和机制分离。 分布式操作系统、网络操作系统和基于中间件的系统 分布式操作系统：配置在分布式系统上的操作系统，能够直接对分布式系统中的各种资源进行动态分配，并能有效地控制和协调分布式系统中各任务的并行执行，同时还向用户提供了一个方便的、透明的使用整个分布式系统的界面。 网络操作系统：是在网络环境下实现对网络资源的管理和控制的操作系统，是用户与网络资源之间的接口。网络操作系统是建立在独立的操作系统之上，为网络用户提供使用网络系统资源的桥梁。在多个用户争用系统资源时，网络操作系统进行资源调剂管理，它依靠各个独立的计算机操作系统对所属资源进行管理，协调和管理网络用户进程或程序与联机操作系统进行交互。 基于中间件的系统：在网络操作系统之上增加一个中间层，屏蔽各底层平台之间的异构性，从而增加分布式系统的透明性 分布式系统架构分布式系统架构的风格 组织成逻辑上不同的组件，并且将这些组件分布在不同的机器上 分层体系结构（client-server架构） Object-based style for distributed object systems 对于分布式对象系统使用基于对象的风格 在空间（匿名）时间（异步）的解耦过程中产生了替代的样式（Decoupling processes in space (“anonymous”) and also time (“asynchronous”) has led to alternative styles） 以数据为中心的体系结构 思想：进程通信需要一个公用仓库（共享的分布式文件系统） 基于事件的体系结构 a图是空间解耦，进程通过事件的传播来通信，事件传播可以有选择地携带数据，分布式系统的事件传播通常与发布/订阅系统有关； b图是时间空间都解耦，将基于事件的体系结构与以数据为中心的体系结构组合形成共享数据空间 分布式系统组织形式 集中式 客户端服务器模式： 提供服务器的进程 提供客户端的进程 客户端和服务器可以在不同的机器上运行 客户端遵守请求/回复行为来使用服务 为了在客户和服务器之间划分界限，使用了应用分层： 用户接口层：含有与用户交互所需的一切如显示管理 处理层：应用程序 数据层：使用的实际数据 多层体系结构 单层：哑终端/主机 双层：客户端/单服务器 三层：每一层都在不同的机器上运行 其中a-c式瘦客户，后面的是胖客户 非集中式 结构化的点对点系统： 比如chord，CAN等等，特点在于节点以特定的分布式数据结构进行组织。在一个结构化的覆盖网络(如逻辑环或超立方体)中组织节点，并使特定节点仅根据其ID负责某些服务。 非结构化的点对点系统 构建类似于随机图的覆盖网络，基本模型是每一个节点都维护一个含有c个邻节点的列表。随机选择一个邻居v，如果v有答案，它会回答，否则v随机选择它的一个邻居。（维护一个超级节点） 混合式 它将客户服务器体系结构和非集中式体系结构组合在了一起 边界服务器系统：用于内容分发网络，在进行过滤和编码转换后提供内容服务，还可用于优化内容和应用程序的分布性。 协作分布式系统：比如BitTorrent文件共享，点对点文件下载： 一旦一个节点确定了从哪里下载文件，它就加入了一群下载者的行列，这些下载者并行地从源文件获取文件块，但也在彼此之间分发这些文件块。 分布式系统组织为中间件 中间件在应用程序和分布式平台之间形成了一个层，可以提供分布式透明性。 image-20211226214734990 方式之一为中断器：作为一种软件结构，能中断正常的控制流，从而允许其他代码运行。 进程与线程进程线程的定义 进程是特定上下文里一个执行的流，可以包含多个线程，有自己独立的内存管理单元，切换时也需要一个进程所拥有的全部内容。线程是一段执行流，是轻量级的进程，只需要简单切换堆栈和寄存器内的值即可，共享内存单元。 LWP 轻量级进程，这个采用了用户级线程和内核级线程的混合形式, 其中对于用户级线程： 所有的线程都在用户的进程地址空间中创建。 优点：所有的操作都能在单个进程中完成，导致实现起来很高效。 缺点：难以从操作系统和block中得到支持。内核提供的所有服务都是代表线程所在的进程执行的，如果内核决定阻塞一个线程，那么整个进程将被阻塞。 内核级线程： 可以解决上述问题 但是由于每一个线程操作（创建删除同步化）都需要内核来进行执行，需要系统调用，导致内核级线程的开销可能和进程差不多大 LWP： 运行在单个重量级进程的上下文中，每一个进程都可以包含多个LWP。另外系统还提供用户级线程包，包括了用于线程同步的工具，这部分内容完全在用户空间实现。并且可以被多个LWP共用。 优点在于：线程创建，销毁，同步化工作开销小不需要内核干预，并且如果进程中有足够数量的LWP，阻塞的系统调用将不需要整个进程被挂起，另外应用程序不需要知道LWP存在，事实上只能见到用户级线程，并且通过在不同CPU执行不同的LWP，可以在多处理器系统中方便的使用 缺点在于：必须进行LWP的创建和销毁工作，开销不必内核级线程小，但是只需要偶尔进行，并且受到操作系统的完全控制 代码迁移 代码迁移的方法： 代码段(Code Segment)：包含实际的代码 数据段(Data Segment)：包含状态 执行状态(Execution State)：包含线程执行对象代码的上下文 强弱迁移 弱迁移：只迁移代码部分和数据部分，最后被目标进程或另外一个独立进程执行 强迁移：迁移执行部分，要么复制进程，要么克隆(所有数据完全复制，和原来的进程并行) 通信通信的类型 瞬时通信(Transient Commnunication)：通讯系统只有在发送和接收应用程序正在运行时才能存储消息 持久通信(Persistent Communication)：提交传输的消息一直由通信中间件存储，直到该消息被传送给接收方为止 异步通信(Asynchronous Communication)：发信方发信后立即继续，消息存储在发信方主机或者通信服务器的缓冲区中。 同步通信(Synchronous Communication)：发信方在到达同步点前保持阻塞。 远程过程调用RPC PS: 一般程序的调用： image-20211227153318439 RPC的工作过程： 客户过程以正常的方式调用客户存根(client stub)； 客户存根生成一个消息，然后调用本地操作系统； 客户端操作系统将消息发送给远程操作系统； 远程操作系统将消息交给服务器存根； 服务器存根调将参数提取出来，而后调用服务器； 服务器执行要求的操作，操作完成后将结果返回给服务器存根； 服务器存根将结果打包成一个消息，而后调用本地操作系统； 服务器操作系统将含有结果的消息发送给客户端操作系统； 客户端操作系统将消息交给客户存根； 客户存根将结果从消息中提取出来，返回给调用它的客户存根 故障处理 5 种故障 客户端不能定位服务器：使用特定的返回值 (异常处理) 例如：服务器故障，服务器进化但客户端使用过期的客户端存根可能的解决方案：用特殊代码（如-1）作为返回值声明故障；抛出异常或信号 客户端到服务器的请求消息丢失：设置一个计时器 超时重发。 服务器发给客户的应答消息丢失：设置一个计时器，对于不幂等的请求 为客户请求分配序号 服务器区别不同的请求。 服务器在收到消息后崩溃(接受后执行前崩溃或者执行后发送前崩溃)：等待服务器启动 然后重发请求(至少一次)；或者立即放弃并报告失败(至多一次)；或者不做任何保证 ; 客户机在发送消息后崩溃： 客户端在发送请求后，在收到服务器响应前故障，通讯是活跃的，但没有parent 在等待响应，形成孤儿 消除 extermination: 在日志文件中纪录 RPC 请求 重启后清除孤儿 。 再生 reincarnation: 按时间顺序编号不同的时间段。当客户端重启时，广播 一条消息宣布新的时间段开始，当广播到达时终止所有远程计算，无需日志。(服务端杀死所有的)（另一种说法：设置一个epoch,每个客户端进程重启为一个新的epoch。新epoch到达意味着之前的计算全部杀死） 温和再生 gentle reincarnation: 与再生相似，但是当广播到达时，每台机器会寻找远程计算的所有者，仅当找不到所有者时，计算才会被终止 。（服务端杀死掉线的）（另一种说法：设置一个epoch,每个客户端进程重启为一个新的epoch。新epoch 到达意味着将没有主的孤儿进程杀死 ） 过期 expiration: 赋予每个RPC一个标准时间配额，未完成任务明确申请额外配额。 动态绑定 绑定：一种让客户端找到服务器的方法 静态绑定：将服务器地址（IP、端口）硬编码到客户端代码中 动态绑定过程： 服务器启动时向Binder 注册Register 请求：参数:ID、名字、版本、地址Unregister 请求：参数:ID、名字、版本 客户端存根向Binder 查找服务器接口Lookup 请求：参数: 名字、版本；返回：ID、地址调用：客户端根据地址发送RPC 调用 优点：灵活性，可以支持多个支持同一接口的服务器，绑定程序可以验证客户端和服务器都使用相同版本的接口 缺点：导出/导入接口的额外开销花费时间，绑定程序可能成为大型分布式系统中的瓶颈 基于消息的通信 瞬时通信(Transient Commnunication)：通讯系统只有在发送和接收应用程序正在运行时才能存储消息 持久通信(Persistent Communication)：提交传输的消息一直由通信中间件存储，直到该消息被传送给接收方为止 异步通信(Asynchronous Communication)：发信方发信后立即继续，消息存储在发信方主机或者通信服务器的缓冲区中。 同步通信(Synchronous Communication)：发信方在到达同步点前保持阻塞。 面向流的通信 分类 连续数据流：支持异构数据传输的通信设施 离散媒体：数据项在时间上的联系不重要 连续媒体：不同数据项在时间上的联系非常重要，如：音频、视频、动画 不同传输模式 异步传输模式（离散媒体）：没有时间限制 同步传输模式（连续媒体）：没有最大延迟时间 等时传输模式（连续媒体）：最大延迟时间、最小延迟时间 流与Qos 利用区分服务为不同类型的数据提供服务 利用缓冲区减少延时抖动 交错传输来降低丢包影响 PS：流媒体看直播卡顿的解决的方法： 利用区分服务为不同类型的数据提供服务 利用缓冲区减少延时抖动 交错传输来降低丢包影响 使用更好的带宽估计算法 同步和资源管理Lamport时钟 参考了该博客 先后关系：把事件 a 发生在 b 之前定义为 a → b，以下三种条件满足a → b： a和b是同一个进程内的事件，a发生在b之前，则 a → b。 a和b在不同的进程中，a是发送进程内的发送事件，b是同一消息接收进程内的接收事件，则 a → b。 如果a → b并且b → c，则a → c。 如果a和b没有先后关系，则称两个事件是并发的，记作 a || b。例子： ​ 这个例子中： a → b → c → d a → b → e f → c → d a || f e || d b || f e || c 逻辑时钟算法：分布式系统中每个进程Pi保存一个本地逻辑时钟值Ci，Ci (a) 表示进程Pi发生事件a时的逻辑时钟值，Ci的更新算法如下： 进程Pi每发生一次事件，Ci加1。 进程Pi给进程Pj发送消息，需要带上自己的本地逻辑时钟Ci。 进程Pj接收消息，更新Cj为 max (Ci, Cj) + 1。 上述例子的逻辑时钟： 从以上算法可以很容易地得出下面两个结论： 同一个进程内的两个事件a和b，如果 a → b，那么 Ci (a) &lt; Ci (b)。 a是Pi进程的消息发送事件，b是Pj进程该消息的接收事件，那么 Ci (a) &lt; Cj (b)。 另外如果 C (a) &lt; C (b)，那么可以得出 a → b 吗？ 答案是不能，举个反例，图二中C (e) = 2，C (d) = 3，虽然 C (e) &lt; C (d)，但并不能得出 e → d，e和d实际上是并发关系 e || d，也就是说由于并发的存在，导致反向的推论并不成立。 向量时钟 在向量时钟中如果C (a) &lt; C (b)，可以得出 a → b，它的思想是进程间通信的时候，不光同步本进程的时钟值，还同步自己知道的其他进程的时钟值。 分布式系统中每个进程Pi保存一个本地逻辑时钟向量值VCi，向量的长度是分布式系统中进程的总个数。VCi (j) 表示进程Pi知道的进程Pj的本地逻辑时钟值，VCi的更新算法如下： 初始化VCi的值全为0：VCi = [0, … , 0] 进程Pi每发生一次事件，VCi[i]加1。 进程Pi给进程Pj发送消息，需要带上自己的向量时钟VCi。 进程Pj接收消息，需要做两步操作。 对于VCj向量中的每个值VCj[k]，更新为 max (VCi[k], VCj[k])。 将VCj中自己对应的时钟值加1，即VCj[j]加1 例子： image-20211227223758776 向量时钟中的向量的偏序关系定义如下： 如果向量VCi中的每个元素VCi[k]都小于等于VCj中的对应元素VCj[k]，则VCi ≤ VCj。 如果VCi中的每个元素VCi[k]都和VCj中的对应元素VCj[k]相等，则VCi = VCj。 如果VCi和VCj不能比较大小，则称两个向量是并发的 VCi || VCj。 因此可以有以下推论： 同一个进程内的两个事件a和b，如果 a → b，那么 VCi (a) &lt; VCi (b)。 a是Pi进程的消息发送事件，b是Pj进程该消息的接收事件，那么 VCi (a) &lt; VCj (b)。 然后可以推出：对于任意两个事件a和b，如果 a → b，那么 VC (a) &lt; VC (b)。 证明VC(a) &lt; VC(b) 可以推导a → b： 如果事件a和b在同一个进程内，很显然 a → b。 如果事件a和b在不同进程内，比如Pa和Pb。 设VCa = [m ,n], VCb = [s, t]。 因为VCa &lt; VCb，所以m ≤ s，所以必然在不早于a之前和不晚于b之后的时间内，Pa向Pb发送了消息，否则Pb对Pa的计数器得不到及时刷新，s就不会小于m。 实际上可以分为如下四种情况： 当a = c且d = b，易得a → b。 当a = c且d → b，由传递性，得a → b。 同样对于d = b且a → c的情况。 当a → c且d → b，根据进程内的算法逻辑性和传递性，也很容易得出结论。 综上: VCa &lt; VCb 推导出 a → b 得证。 分布式系统中的互斥访问 集中式算法：基于上述的选举算法，选出一个进程作为集中协调者，该协调者同时管理一个请求等待队列。当队列为空时，协调者对临界区请求应答。当队列不为空或者临界区尚未释放时，把请求添加到等待队列的队尾，然后或者对请求不予应答，或者直接拒绝（此时该请求会一直查询临界区使用状态），直至从队头取出该请求后再允许其进入临界区。 优点： 保持互斥 公平 无饥饿 容易失效：请求、授权、释放 缺点： 单点故障 性能瓶颈 无法区分coordinator 失效or 权限拒绝 PS: 非集中式 多个leader 分布式算法：基于时间戳； 进程如果想进入临界区，那么构建含临界区名字、进程编号、当前时间的消息发给所有进程； 进程收到请求消息： 如果接收方未在临界区 想进入临界区：对比消息的timestamp，如果接收消息的timestamp比较早，返回OK；否则缓存请求，返回空 不想进入临界区：返回OK 如果接收方已在临界区，缓存请求 令牌环算法： 用软件的方法，按照进程的地址或者编号等，为总线型的网络构造一个逻辑环。一个令牌环只能对应进入一个临界区。 过程：令牌环绕进程环依次传递，如果接受进程如果不需要进入临界区，则继续传递给下一个进程，如果接受进程需要进入临界区，那么此时传递暂停，令牌等待，直到进程从临界区返回后继续。 缺点：令牌丢失的检测和再生因为无法确定时间间隔而非常困难；进程崩溃虽然可以恢复，但是需要通过每个进程向前继进程发送确认消息来实现，也就需要每个进程都维护当前的配置信息。 比较： 分布式系统中的选举机制 bully算法： 发起选举的条件，一是任何进程发现原有协调者崩溃时，可以发起选举；二是原来崩溃的进程P恢复以后，可以重新发起选举，但是最后不一定会赢得选举，因为可能还有编号比P大的进程在P崩溃期间已经开始运行。 选举过程： 发起选举的进程Q只能向编号比自己大的进程发起election消息 如果Q一直没有接受到OK应答消息，则由Q获胜充当协调者，否则，退出选举 因此最大的进程总是取胜，所以叫 bully(欺凌)算法 例子： 环算法： 发起选举的条件：所有进程已经按照编号进行排序并且链接成环，任何一个或者多个进程发现原有协调者崩溃或者没有响应时，开始发起选举。 选举过程：发起消息者构造election消息，依次向后传递。传递过程中如果后继进程已经崩溃，则绕过（不仅仅是刚刚崩溃了的协调者），如果后继进程正在运行，则把编号添加进election消息成员列表。待绕环一周返回到发起者后，根据选举消息中的编号（选取成员列表里面最大的那个）选出协调者，并用coordinator消息绕环通知所有进程，循环一周后该消息被删除。 栗子： 复制与一致性复制的优势和不足（分布式系统多副本的优点和缺点） 优点： 可靠性：避免单点故障 性能：对服务器数量和地理区域上的扩展 不足： 复制透明性：某个用户不知道某个对象是复制的 一致性问题：更新过程开销大，可能影响系统可用性 一致性模型实质上是进程和数据存储之间的一个约定，也就是如果进程同意遵守某些规则，那么数据存储将正常运行 PS：一致性模型的类型： 面向数据一致性模型：本地数据存储的组织通常在分布在多个进程，并进行复制 面向客户的一致性模型：保证单个客户端访问数据存储的一致性 数据一致性模型 参考了博客1以及博客2 image-20211228142648852 不引入同步操作的一致性模型 严格一致性（Strict Consistency）： 所有共享访问事项的绝对时间顺序 任何读操作返回与最新写操作结果对应的值 依赖绝对全局时间; 所有写入对所有进程都即时可见，并维护绝对全局时间顺序 分布式系统中无法实现 线性一致性（Linearizability），又称为强一致性或者原子一致性： 所有进程都必须以相同的顺序查看所有共享访问。此外，访问根据（非唯一）全局时间戳排序; 一旦某一个读操作返回了新值，之后所有的读（包括相同或不同的客户端）都必须返回新值 顺序一致性(Sequential)： 所有进程都以相同的顺序查看所有共享访问。访问不是按时间排序； 与线性一致性类似，对时间顺序无要求 从单个处理器 (线程或者进程)的角度来看，执行指令的顺序以编程中的顺序为准。 从所有的处理器(线程或者进程)的角度来看，指令的执行保持一个单一的顺序。 与线性一致性比较的例子： 因为a中可以找到一个执行序列： Write(&quot;y&quot;, 1) -&gt; Read(&quot;x&quot; -&gt; 0) -&gt; Write(&quot;x&quot;, 1) -&gt; Read(&quot;y&quot; -&gt; 1) 满足顺序一致性。但是从时间角度看Write(&quot;x&quot;,1) 要先于 Read(&quot;x&quot;) -&gt; 0 执行，但是 Read 却没有读取到最新值，所以不满足线性一致性。 b中都满足 c中找不到这样的执行序列，所以不满足顺序一致性； 顺序一致性和线性一致性都是要找到一个满足 “写后读” 的一组操作历史，差异在于线性一致性要求严格的时间序，而顺序一致性只要求满足编程顺序。 因果一致性（Causal Consistency） 所有进程都以相同的顺序查看与因果相关的共享访问 有因果关系的写操作，不同的进程看到相同的顺序 没有因果关系的写操作，不同的进程可以看到不同顺序 来自这个知乎的例子: 管道一致性（FIFO Consistency/PRAM） 所有进程都按使用顺序看到彼此的写入；不同进程的写入可能并不总是按相同的顺序显示 由同一个进程进行的写操作，必须看到相同的顺序 不同进程的写操作，不同进程可以看到不同顺序 这个算是一种弱一致性 引入同步操作的一致性模型 弱一致性（Weak Consistency） 只有在同步完成后，才能让共享数据保持一致；（有一个同步事件S，保证在S之后的读能看到S之前的读写顺序。） 具体限制： 对数据存储所关联的同步变量的访问是顺序一致的；说明了所有进程都以相同的顺序看到对同步变量进行的所有操作 每个拷贝完成所有先前执行的写操作之前，不允许对同步变量进行任何操作（说明了同步”清空管道”） 所有先前对同步变量执行的操作都执行完毕之前，不允许对数据项进行任何读或写操作（说明访问数据项时，无论读数据或写数据,所有先前的同步都已经完成。） 释放一致性（Release Consistency） 退出关键区域时，共享数据保持一致（写数据时加全局锁，加锁之后的顺序就不能乱来，不加锁的话读到什么都可以。还锁的时候同步） 获取操作：用于通知数据存储进程进入临界区的操作 释放操作︰表明进程刚刚离开临界区的操作 具体限制： 对共享数据执行读操作或写操作之前，所有进程先前执行的获取操作都必须已经成功完成 在释放操作被允许执行前，所有进程先前执行的读操作和写操作都必须已经完成 对同步变量的访问是FIFO一致的(不需要顺序一致) 入口一致性： 进入共享数据对应临界区时，共享数据一致（每个数据的读写都要加锁，不加锁读数据，不保证给出什么东西，给出nil都可以。拿锁的时候同步） 要求每个普通的共享数据项都要与某种同步变量关联 具体限制为 在一个进程可以获取一个同步变量之前，所有的由此同步变量保护的共享数据的更新都必须已经相对于该进程执行完毕 执行获取操作时，所有的受保护数据的远程改变都必须已经可见 在一个进程对一个同步变量的独占访问被允许执行之前，其他的进程不可以拥有这个同步变量，甚至也不能以非独占的方式拥有这个同步变量 更新共享数据项之前，必须以独占的方式进入临界区 一个进程对一个同步变量执行独占访问之后，在对该同步变量的所有者进行检查之前，任何其他的进程都不能执行下一个非独占访问 非独占方式进入临界区之前，必须检查保护这个临界区同步变量的所有者,以获得受保护的共享数据的最新副本 以客户为中心的一致性模型 最终一致性 如果在一段相当长的时间内没有更新操作, 那么所有的副本将逐渐成为一致的 单调读： 如果一个进程数据项x 的值，那么该进程对x 执行的任何后续读操作将总是得到第一次读取的那个值或更新的值，保证之后不会看到x的更老的版本（读出来一个值之后再读一次，不会读出更老的值。） 单调写： 一个进程对数据项x 执行的写操作必须在该进程对x 执行任何后续写操作之前完成；写操作必须顺序完成，不能交叉（写完一个值之后，才能继续写下一个，不允许写的过程中开始一个新的写时间(read your write):写了之后，后续的读一定能读到这个值，而不会读到旧值写的时候，保证所替换掉的是之前读出来的值） 写后读 Read your writes（读写一致性）： 一个进程对数据项x 执行一次写操作的结果总是会被该进程对x执行的后续读操作看见；保证读取最新（写了之后，后续的读一定能读到这个值，而不会读到旧值） 读后写 writes-follow-reads consistency （写读一致性）： 同一个进程对数据项x 执行的读操作之后的写操作，保证发生在与x 读取值相同或比之更新的值上；更新作为前一个读操作结果传播（写的时候，保证所替换掉的是之前读出来的值） 数据一致性协议实例 基于法定数量的协议 Quorum-based protocols 对于一个具有 N 个副本的文件 客户要读取时，必须组织一个服务器数量为 Nr 的读团体(read quorum) 客户要修改时，必须组织一个服务器数量为 Nw 的写团体(write quorum) 其中，Nr 与 Nw 满足以下限制条件 Nr+Nw&gt;N: 用于防止读写冲突 Nw&gt;N/2: 用于防止写写冲突 image-20211228171012230 容错可靠（Dependable System）的系统的特征 有群友总结为 ASMR 可用性：在任意给定的时刻，系统都可以正确及时地工作，并执行用户的请求。 A 安全性：系统偶然出现故障时还能正确操作和执行。 S 可维护性：表示发生故障后系统能被恢复到可用性的难易程度 M 可靠性：系统可以无故障持续运行； R PS 基础定义： error → fault → failure fault: 造成error 的原因 error：系统错误的状态，可能导致failure failure：没有满足承诺，无法提供服务 故障分类： Crash failure（服务器重启，重启正常） Omission failure（遗漏错误） Timing failure（超时） Responsne failure Byzantine faiure 提高系统可信性的途径 使用冗余来掩盖故障： 信息冗余：添加额外的位或码恢复错乱的信息。 时间冗余：多次执行需要的动作。可以使用事务。适用于临时性或者间歇性的错误。 物理冗余：添加额外的装备（硬件）或者进程（软件）使系统整体容忍部分错误。 K容错系统 参考博客 K容错：系统能够经受k个组件的故障并且还能满足规范要求。当这些组件是失败沉默的情况下，需要k+1个组件可以提供k容错；如果发生拜占庭失败，至少需要2k+1个进程才能获得k容错。 课本P242页 怎么证明可以参考这个知乎 拜占庭问题 在容错计算机系统中，经常需要部件之间的信息传递与分发，而一个失效的部件将会向其他部件发送错误的消息。容错计算机中失效部件向不同部件发送错误消息的问题，可被抽象为拜占庭将军问题： 算法流程： 每个将军向其他n-1 个将军告知自己的兵力（真实或说谎） 每个将军将收到的消息组成一个长度为n 的向量 每个将军将自己的向量发送给其他n-1 个将军 每个将军检查每个接收到的向量中的第i 个元素，将其众数作为其结果向量的第i个元素 例子： image-20211228194256257 系统恢复 恢复：发生故障的进程能够恢复到正确的状态 两种形式 后向恢复：从当前错误状态回退到先前正确状态 前向恢复：尝试从某点继续执行，把系统带入一个正确的新状态 检查点：系统定时记录状态到稳定存储 每个进程独立地设置本地检查点，依赖项的记录方式使进程可以联合回滚到一致的全局状态 但每个进程回退的状态可能不一致，需要继续回退，可能造成多米诺效应 协调的检查点： 所有进程同步地把各自状态写到本地稳定存储中 PS 两阶段提交 二阶段提交 为什么两阶段提交叫做阻塞提交协议？ 当所有参与者都从协作者那里接收到信息变成READY状态的时候，并且同时协作者崩溃的时候就会发生阻塞 分布式一致性协议Paxos协议 参考的知乎 Paxos 保证了：安全性 和 最终一致性（Eventual liveness）： 安全性：只有被提议的值才可能会被选择，只有一个值会被选择，只有最终被选择的值才会被进程所保存。 Eventual liveness, 如果系统正常运行下去，在未来的某一个点，最终会达成共识。 通信实例 Raft协议 用户选举 Log Replication Gossip协议 需要O(logN)轮才能把信息传播到所有节点，push SI总共传播的信息数量O(NlogN);Pulland push-pull SI 需要传播的信息数量O(NloglogN) 大数据处理系统 对于DAG型作业Spark+Yarn的优势在哪里？ DAG型的每个中间结果hadoop会有频繁的磁盘IO，spark用分布式弹性数据集把中间结果存在内存中，避免了DAG中间结构的频繁IO hadoop+hdfs的集群，集群需要同时进行资源管理和任务控制，耦合度高。Yarn只负责资源管理，将任务控制交给应用去设计，耦合度低。虽然Yarn应用的逻辑变复杂了，但可以支持更多的编程模型和设备。 容错 拜占庭协定 沉默错 k+1 2k+1 拜占庭错 2k+1 3k+1 (所有挂k个，表格里面是总量) 沉默错拜占庭协定2k+1: 挂掉的节点k个醒了之后需要k+1个正确的来达成一致性 容错取众数，拜占庭协定需要两轮，可以参考这个知乎","tags":[{"name":"分布式系统","slug":"分布式系统","permalink":"http://tyler-ytr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"PDF技巧记录","date":"2021-12-25T15:25:19.000Z","path":"2021/12/25/pdf-trick/","text":"PDF书签编辑使用PdgCntEditor可以对PDF文件书签整体进行编辑。 可以通过这个网盘链接下载，密码是9dyu； PDF点击书签之后的缩放这个居然在Adobe Acrobat Pro里面难以解决，除非一个一个书签点击属性加入缩放比率：适合可见； 使用PdgCntEditor之后可以通过点击PDF图标然后进行点击目录后页面缩放的选项就好了；","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"java_learning","date":"2021-12-01T06:34:39.000Z","path":"2021/12/01/java-learning/","text":"java学习笔记学习参考资料： 深入理解java虚拟机-JVM高级特性与最佳实践（第三版） jvm系列总结 JVMjava类的加载JVM内存结构JVM垃圾收集器","tags":[{"name":"jvm","slug":"jvm","permalink":"http://tyler-ytr.github.io/tags/jvm/"},{"name":"java","slug":"java","permalink":"http://tyler-ytr.github.io/tags/java/"}]},{"title":"shell命令杂记","date":"2021-11-10T07:58:23.000Z","path":"2021/11/10/shell-collect/","text":"用于记录一些遇到过的shell; 一些shell命令含义的记录 1&gt;/dev/null 2&gt;&amp;1的含义 > 代表重定向到哪里，例如：echo “123” &gt; /home/123.txt 1 表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null” 2 表示stderr标准错误 &amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 因此该语句： 1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 /dev/zero文件代表一个永远输出 0的设备文件，使用它作输入可以得到全为空的文件。因此可用来创建新文件和以覆盖的方式清除旧文件。","tags":[{"name":"shell","slug":"shell","permalink":"http://tyler-ytr.github.io/tags/shell/"}]},{"title":"vscode+latex 配置","date":"2021-11-08T02:45:56.000Z","path":"2021/11/08/vscode-latex-setting/","text":"安装texlive，验证的方式: 1234tex -vlatex -vxelatex -vpdflatex -v vscode 安装 Latex Workshop插件以及Code Spell Checker插件 配置json，打开配置的方法是Ctrl+shift+p然后搜索setj选择 首选项：打开设置: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273\"latex-workshop.latex.recipes\": [ &#123; \"name\": \"xelatex -&gt; bibtex -&gt; xelatex*2\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", \"xelatex\" ] &#125; ], \"latex-workshop.latex.tools\": [ &#123; \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOCFILE%\" ] &#125;, &#123; \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOCFILE%\" ] &#125;, &#123; \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOCFILE%\" ] &#125;, &#123; \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] &#125; ], \"latex-workshop.view.pdf.viewer\": \"tab\", \"latex-workshop.latex.clean.fileTypes\": [ \"*.aux\", \"*.bbl\", \"*.blg\", \"*.idx\", \"*.ind\", \"*.lof\", \"*.lot\", \"*.out\", \"*.toc\", \"*.acn\", \"*.acr\", \"*.alg\", \"*.glg\", \"*.glo\", \"*.gls\", \"*.ist\", \"*.fls\", \"*.log\", \"*.fdb_latexmk\" ], \"latex-workshop.latex.autoClean.run\": \"onBuilt\" 快捷键： ctrl+alt+b 编译latex； ctrl+alt+x：显示LaTeX面板(左侧编译命令面板和文档大纲) ctrl+alt+c：清除辅助文件（目前的设置是自动清除的所以不太需要） ctrl+alt+v：查看编译的pdf文件 ctrl+alt+j：正向搜索。固定光标到tex文件的某一个位置能够在pdf那里自动定位到该位置，需要在上面的自动清楚设置里面不清除.gz文件 ctrl: 反向搜索，在阅读vscode里面预览的pdf的时候按住ctrl然后点击某位置，左边的tex会自动定位到该位置； 中文支持: xelatex： 加入: 1\\usepackage&#123;ctex&#125; pdflatex： 1234\\usepackage&#123;CJKutf8&#125;\\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125; \\end&#123;CJK&#125;","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"邮件处理","date":"2021-11-02T13:08:35.000Z","path":"2021/11/02/email_note/","text":"邮件批量发送主要依赖yagmail库进行邮件的批量发送，样例脚本如下 12345678910111213141516171819202122232425262728293031323334#殷天润制作#使用说明:在批好的作业的文件夹下面: python py_email.py即可## 记得改一下subject 和 passwdimport yagmailimport osdef get_id(filename): for index in range(0,len(filename)-1): if filename[index]=='1' or filename[index]=='2': print(filename[index:index+9]) return filename[index:index+9] elif filename[index]=='M' or filename[index]=='D' or filename[index]=='m' or filename[index]=='d': print(filename[index:index+10]) return filename[index:index+10]user='mg21330xxx@smail.nju.edu.cn'passwd=\"passwd\"smtp_host=\"smtp.exmail.qq.com\"mail=yagmail.SMTP(user=user,password=passwd,host=smtp_host,port=465)path=\"./\"filelist=os.listdir(path)# 遍历输出每一个文件的名字和类型for item in filelist: # 输出指定后缀类型的文件 if(item.endswith('.pdf')): file=item uid=get_id(item) uid_email=uid+\"@smail.nju.edu.cn\" #print(uid_email) print(uid_email) mail.send(to=[uid_email],subject='计算机网络作业批改_xxx', contents='批改见附件', attachments=[file] ) ## 记得改一下subject 邮件附件批量下载 主要参考了https://club.excelhome.net/thread-563004-1-1.htmlhttps://blog.csdn.net/qq_35132089/article/details/115509617 主要是借助VBA以及outlook； 流程如下: 在outlook的收件箱新建文件夹，命名为:homework; homework 然后把要处理的邮件批量放进去，这一步可以现在腾讯企业邮箱批量的把邮件移动到某文件夹然后再放进去； 然后在D盘创建文件夹，比如名字为temp; 然后对outlook进行信任部分的设置，具体操作是打开选项： trust setting1 然后信任中心，信任中心设置，启用所有宏： trust setting2 最后打开outlook,按住alt+f11，调出VBA编辑的页面，填入如下代码: 1234567891011121314151617Sub Savetheattachment() Dim olApp As New Outlook.Application Dim nmsName As Outlook.NameSpace Dim vItem As Object Set nmsName = olApp.GetNamespace(\"MAPI\") Set myFolder = nmsName.GetDefaultFolder(olFolderInbox) Set fldFolder = myFolder.Folders(\"homework\") For Each vItem In fldFolder.Items '-----Save Attachment------ For Each att In vItem.Attachments att.SaveAsFile \"D:\\temp\\\" &amp; att.FileName Next '------Save Attachment------- Next Set fldFolder = Nothing Set nmsName = NothingEnd Sub running VBA 然后如图示点击运行即可","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"python心得","slug":"python心得","permalink":"http://tyler-ytr.github.io/tags/python%E5%BF%83%E5%BE%97/"}]},{"title":"hacker's delight 阅读","date":"2021-10-29T04:29:48.000Z","path":"2021/10/29/hacker-delight-reading/","text":"主要是P4使用中可能会需要一些骚操作，遂阅读此书； 默认字长为32位； ch2 最右边的位元： 考虑用x+1,x-1配上与或非取反进行操作，比如$x \\&amp; (x-1)$; $\\neg x\\&amp;(x+1)$,$\\neg x\\&amp;(x-1)$,$\\neg x |(x+1)$…… 这块建议查书； 从右到左的可计算性： 如果一个函数能够以位元为单位从右到左计算出来，那么它肯定可以用加法减法按位和按位与以及按位取反及其复合指令实现；反之，如果这些基本指令描述一个函数，那么它必然可以通过从右到左的按位运算做出来； 我觉得可能要反复揣摩这个定理： 根据书上的特例可以很清晰的理解它要表达的用于构造的例子： 上面的可以通过下面的获得，第二行第三行按位与然后和第一行按位或然后和第四行按位与（先执行操作然后对位置定位） 与此同时有一些问题没法用五个基本运算组合得出，这里就要看想要获得的结果与原始输入之间的关系，是不是从右到左的，也就是说最右边的值不应该和它左边的有联系，比如如下的例子：","tags":[{"name":"hacker's delight","slug":"hacker-s-delight","permalink":"http://tyler-ytr.github.io/tags/hacker-s-delight/"}]},{"title":"p4_overview","date":"2021-10-25T05:05:18.000Z","path":"2021/10/25/p4-overview/","text":"主要来自对https://github.com/jafingerhut/p4-guide/blob/master/README-p4lang-repos.md 的学习 文档与博客官方文档 p4文档页面 p4runtime文档 p4_16语言文档 p4_16 Portable Switch Architecture (PSA)文档 p4 Portable NIC Architecture (PNA) 文档 博客 P4语言编程详解 p4 lang组织下面的仓库 p4lang organization 是github的一个组织。以下是该组织2019-3.31的所有仓库,并按类别进行了归类： 规范文件 p4-spec - Containsspecification documents for the P4_14 language, the P4_16 language,and Portable Switch Architecture (PSA). p4runtime - Specification documents for the P4Runtime control-plane API p4-applications - P4 Applications WG repo 文档、研究论文和教程 papers - Repository for papers related to P4 tutorials - P4 language tutorials education - P4 for Education p4lang.github.io -P4.org website P4 编译器 some only front end, some front end plus back end for one or more P4 targets p4c - P4_16 prototype compiler (also compiles P4_14 programs) p4c-bm - Generates the JSON configuration for the behavioral-model (bmv2), as well as the C/C++ PD code p4-hlir - P4_14 compiler, written in Python, which stops at generating an intermediate representation, from which one can start in writing a back end compiler p4c-behavioral - P4 compiler for the behavioral model. Deprecated. P4 行为模型，用于在通用计算机上运行 P4 程序 behavioral-model - Rewrite of the behavioral model as a C++ project withoutauto-generated code. Also known as bmv2. p4c-behavioral - P4 compiler for the behavioral model. Deprecated. P4Runtime API 规范和一些实现代码，包括客户端和服务器代码 p4runtime - Specification documents for the P4Runtime control-plane API PI - An implementation framework for a P4Runtime server grpc - grpc - (forked from grpc/grpc) The C based gRPC (C++, Python, Ruby, Objective-C, PHP,C#) (forked from grpc/grpc) protobuf - Protocol Buffers Google’s data interchange format (forked fromprotocolbuffers/protobuf) 由 p4.org 以外的组织创建的开源工具，供一个或多个p4lang存储库使用 grpc - grpc - (forked from grpc/grpc) The C based gRPC (C++, Python, Ruby, Objective-C, PHP,C#) (forked from grpc/grpc) protobuf - Protocol Buffers Google’s data interchange format (forked fromprotocolbuffers/protobuf) rules_protobuf - Bazel rules for building protocol buffers and gRPC services (java, c++,go, …) (forked from pubref/rules_protobuf) mininet - Emulator for rapid prototyping of Software Defined Networks http://mininet.org (forked from mininet/mininet) SAI - Switch Abstraction Interface (forked from opencomputeproject/SAI) scapy-vxlan - A scapy clone, with support for additional packet headers third-party - Third-party dependencies for p4lang software thrift - Mirror of Apache Thrift (forked fromapache/thrift) 用于创建和运行自动化测试 mininet - Emulator for rapid prototyping of Software Defined Networks http://mininet.org (forkedfrom mininet/mininet) ntf - Network Test Framework ptf - Packet Test Framework scapy-vxlan - A scapy clone, with support for additional packet headers 可能不再维护的部分 p4-build - Infrastructure needed to generate, build and install the PD library for a given P4 program p4app - (No description) p4factory - Compile P4 and run the P4 behavioral simulator. Deprecated. p4ofagent - Openflow agent on a P4 dataplane switch - Consolidated switch repo (API, SAI and Netlink) 编译命令Sample command lines to compile P4 source file foo.p4 to bmv2 JSON configuration file: # foo.p4 is P4_14 source code p4c-bmv2 --json foo.json foo.p4 p4c --target bmv2 --arch v1model --std p4-14 foo.p4 # foo.p4 is P4_16 source code p4c --target bmv2 --arch v1model foo.p4 Sample command line for converting P4_14 source code to P4_16 source code: p4test --std p4-14 --pp foo-translated-to-p4-16.p4 foo-in-p4-14.p4 P4依赖关系图可以参考https://github.com/jafingerhut/p4-guide/blob/master/dependencies.pdf p4语言概览 相对于C P4删除了 loops, recursive calls, pointers, malloc, and free 删除 loops, recursive calls,对于每一个包的工作可以限制在一个特定的时间，更加适合高性能的P4可编程平台 删除 pointers, malloc, 以及自用的通用数据结构，从而不可能又任意大小的数据结构，但是我们可以实现具有固定深度的树 增加了解析器parser, 重点关注将接收到的数据包的内容解析为一系列报头时最需要的功能 解析器被定义为有限状态机，其中的状态必须命名并定义它们之间可能的转换。实际上，允许在解析器有限状态机中有循环，但最高性能目标通常会将您限制为可展开到编译时已知最大迭代次数的循环，例如，用于解析长度最多为5个报头的MPLS报头序列（其中5或其他值是您在源代码中选择的数字）。 P4专注于数据包报头处理。对于P4程序而言，数据包中任何未解析为某个报头的部分都被视为数据包的“有效载荷”，通常在处理完数据包后，数据包会随数据包一起携带，未经修改。您可以随意修改标题字段 增加了tables这样的数据结构，每一个表都有一个搜索的键值，并且可以定义一个或者多个操作 不同的交换机体系结构可能还有一些另外的库，比如PSA（ Portable Switch Architecture ）里面的packet/byte counters等等 字段以及变量可以是任意位宽的整数（有最大位数限制），P4不支持浮点数运算，同时P4实现哦那个杨不需要实现乘法除法模运算，因为大多数包处理应用程序通常用不到 没有浮点数咋整相关的文章integer arithmetic is sufficient for implementing fixed point operations P4_14 和 P4_16的比较16相对于14的好处 更加像C++等语言的语法 p4_14没有参数和返回值，需要操作全局变量；p4_16没有全局变量，但是有in,out,inout 等具有方向性的参数 tables 以及 externs 的设计； 16相对于14的缺点18年的时候16的支持不如14，但是时代变了； bmv2使用","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"},{"name":"p4 guide","slug":"p4-guide","permalink":"http://tyler-ytr.github.io/tags/p4-guide/"}]},{"title":"Hello World","date":"2021-09-16T15:19:03.152Z","path":"2021/09/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"ns_learning","date":"2021-09-11T10:00:15.000Z","path":"2021/09/11/ns-learning/","text":"ns3学习总结ns3简介ns3关键概念节点ns3是一个网络simulator,为了防止混淆，使用节点来代替主机，用来表示基本设备的抽象； 使用Node类来进行描述，具体调用科研使用NodeContainer 类，比如: 12NodeContainer nodes;nodes.Create (2)&#39;&#39; 应用需要被仿真的用户程序被抽象成为应用，在Application类中进行了描述；它的实例还有UdpEchoClientApplication以及UdpEchoServerApplication等等，前者用来回显服务端所回复的分组； 信道网络中数据里流过的媒介成为信道，在channel类中进行了描述，它提供了管理通信子网对象和把节点连接到它们的各种方法，几个信道模型的实例包括：CsmaChannel,PointToPointChannel 以及WifiChannel; 网络设备这个概念相当于硬件设备以及软件驱动的总和，网络设备在ns3中安装在节点上面，使得节点通过信道和其他节点通信，一个节点可以通过多个网络设备同时连接到多条信道上面。主要在NetDevice类中进行了描述，这部分也允许开发者自定义。几个网络设备的实例包括：CsmaNetDevice,PointToPointNetDevice以及Wi-FiNetDevice。 拓扑帮助可以使用拓扑生成器来让配置IP等等任务变得容易。同时拓扑生成器还能帮助整合例如创建网络设备，配置MAC地址，把网络设备装到节点上面，设置节点协议栈，连接网络设备到信道等等分立的工作。这部分主要在Helper类中。 ns3优化技术logging系统logging等级一共由低到高提供了7个等级： LOG_ERROR—记录错误信息; LOG_WARN—记录警告信息; LOG_DEBUG—记录一些调试信息; LOG_INFO—记录一些程序相关的信息; LOG_FUNCTION一当有函数被调用时，该调用信息就被记录; LOG_LOGIC—对于整体逻辑的描述; LOG_ALL-包含上述的所有信息。 脚本中设置记录模块在脚本中可以使用进行记录， 12LogComponentEnable ( \"UdpEchoClientApplication\"，LOG_LEVEL_INFO) ;LogcomponentEnable (\"UdpEchoserverApplication\"，LOG_LEVEL_INFO); 在first.cc这个例子中，大致的效果为: image-20211009205558340 在环境变量中设置可以使用: 1export 'NS_LOG=UdpEchoClientApplication=level_all|prefix_func|prefix_time:UdpEchoServerApplication=level_all|prefix_func|prefix_time' 在外部环境变量设置等级，并且覆盖文件中的等级的效果，现在大致的效果如下: image-20211009205733732 prefix_func增加了函数调用信息，prefix_time增加了时间信息； 自定义logging代码在first.cc中有一句代码: 1NS_LOG_COMPONENT_DEFINE(\"FirstscriptExample\"); 这个代码向ns-3系统中注册了“FirstScriptExample”这个组件，通过记录组件，可以在仿真脚本中使用Logging系统进行自定义的输出语句； 然后可以在代码中创建节点之前的位置添加: 1NS_LOG_INFO(\"Creating Topology\"); 此时重新编译是没有效果的，因为没有激活这个组件，可以用如下两种方法激活: 在代码中添加: 1LogComponentEnable (&quot;FirstScriptExample&quot;, LOG_LEVEL_INFO); 在外部环境变量激活 1export NS_LOG=FirstScriptExample=info 效果如下: 方法1 方法1没有覆盖之前的环境变量。 方法2 ns3安装参考http://www.soolco.com/post/94032_1_1.html； 尝试了使用官方文档https://www.nsnam.org/wiki/Installation 的bake进行安装但是比较不成功，建议参考上述博客进行安装。安装依赖建议使用清华源。安装过程和编译过程比较消耗时间，建议虚拟机或者真机保证4GB以上的内存。 ns3依赖12345678910111213141516171819202122# ubuntu18.04 使用;使用-y可以自动确认，可以改成.sh脚本，chmod赋予权限之后使用。sudo apt-get -y install g++ python3sudo apt-get -y install g++ python3 python3-dev pkg-config sqlite3sudo apt-get -y install python3-setuptools gitsudo apt-get -y install qt5-default mercurialsudo apt-get -y install gir1.2-goocanvas-2.0 python-gi python-gi-cairo python-pygraphviz python3-gi python3-gi-cairo python3-pygraphviz gir1.2-gtk-3.0 ipython ipython3sudo apt-get -y install openmpi-bin openmpi-common openmpi-doc libopenmpi-devsudo apt-get -y install autoconf cvs bzr unrarsudo apt-get -y install gdb valgrindsudo apt-get -y install uncrustifysudo apt-get -y install doxygen graphviz imagemagicksudo apt-get -y install texlive texlive-extra-utils texlive-latex-extra texlive-font-utils dvipng latexmksudo apt-get -y install python3-sphinx diasudo apt-get -y install gsl-bin libgsl-dev libgsl23 libgslcblas0sudo apt-get -y install tcpdumpsudo apt-get -y install sqlite sqlite3 libsqlite3-devsudo apt-get -y install libxml2 libxml2-devsudo apt-get -y install cmake libc6-dev libc6-dev-i386 libclang-6.0-dev llvm-6.0-dev automakesudo apt-get -y install python3-pipsudo apt-get -y install libgtk-3-devsudo apt-get -y install vtun lxc uml-utilitiessudo apt-get -y install libboost-signals-dev libboost-filesystem-dev 123456# 这部分pip相关 如有需要请换源之后处理sudo pip3 install --upgrade pippython3 -m pip install --user cxxfiltpip3 install pygccxmlpip3 install CastXMLpip3 install PyBindGen ns3安装在右侧链接地址https://www.nsnam.org/releases/下载想要的版本。然后根据一下指令解压安装，版本号自行修改，我安装的是3.34 1234tar xjf ns-allinone-3.34.tar.bz2 # 解压chmod -R 777 ns-allinone-3.34 # 修改权限lscd ns-allinone-3.34 # 切换到解压目录下 使用以下编译: 1.&#x2F;build.py --enable-examples --enable-test 之后根据编译的提示来进行另外的调整 查看一些细节可以: 12cd ns-3.34.&#x2F;waf --build-profile&#x3D;debug --enable-examples --enable-test configure 最后进行测试: 这部分巨花时间，大概得2-3个小时 1.&#x2F;test.py 验证是否安装成功 1.&#x2F;waf --run hello-simulator # 验证是否安装成功 我使用virtualbox虚拟机大概做了一个18.04的镜像，账户是cs144，密码是123456，如有需要自行取用。","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"实验基础","slug":"实验基础","permalink":"http://tyler-ytr.github.io/tags/%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80/"},{"name":"ns3","slug":"ns3","permalink":"http://tyler-ytr.github.io/tags/ns3/"}]},{"title":"mininetlab 学习","date":"2021-09-03T07:55:16.000Z","path":"2021/09/03/mininetlab/","text":"Mininet 学习来自https://www.51openlab.com/college/ 的教程，以下是学习总结 Mininet 简介Mininet 基于Linux Container这一个内核虚拟化技术开发，利用linux的network namespace机制在一台电脑上创建多台虚拟主机，此外，Mininet建立的网络拓扑的交换节点可以是Open vSwitch、Linux Bridge等软件交换机，交换节点之间的链路采用Linux的veth pair (virtual Ethernet pair)机制实现，控制器可以部署在网络可达的任意地方。因此，Mininet可以定制任意灵活的SDN网络拓扑，为实验用户提供快捷可靠的实验环境。 Mininet架构按datapath的运行权限不同，分为kernel datapath和userspace datapath两种，其中kernel datapath把分组转发的逻辑编译进入Linux内核，效率非常高; userspace datapath把分组转发逻辑实现为一个应用程序，叫做ofdatapath,效率虽不及kernel datapath，但更为灵活，更容易重新编译。 Mininet的kernel datapath架构如下图所示，控制器和交换机的网络接口都在root 命名空间中，每个主机都在自己独立的命名空间里，这也就表明每个主机在自己的命名空间中都会有自己独立的虚拟网卡eth0。控制器就是一个用户进程，它会在loopback上预留的6633端口监听来自交换机安全信道的连接。每个交换机对应几个网络接口，比如sO-eth0、sO-eth1以及一个ofprotocol进程，它负责管理和维护同一控制器之间的安全信道。 image-20210903160253663 Mininet的userspace datapath架构如下图所示，与kernel datapath架构不同，网络的每个节点都拥有自己独立的namespace。因为分组转发逻辑是实现在用户空间，所以多出了一个进程叫ofdatapath。另外，Mininet除了支持kernel datapath和userspace datapath这两种架构以外，还支持OVS交换机。OVS充分利用内核的高效处理能力，它的性能和kernel datapath相差无几 Mininet 安装 下载github源码然后编译安装， 12sudo apt-get update git clone http:&#x2F;&#x2F;github.com&#x2F;mininet&#x2F;mininet.git 其中./install.sh是安装的命令，格式如下: 1.&#x2F;install.sh [options] options如下 -a : 完整安装，默认在home目录下，包括 Mininet VM,以及Open vSwich的依赖关系，OpenFlow, Wireshark分离器以及POX -nfv 安装mininet核心文件及其依赖，OpenFlow 和 Open vSwitch -s mydir: 可以把源代码建立到一个特定的目录中 查看mininet版本 12cd mininetcat INSTALL|more 安装 12cd util.&#x2F;install.sh -a 测试基本功能 1mn --test pingall 查看安装好的mininet版本: 1mn --version Mininet 拓扑构建与命令使用 MiniEdit: 这个可以可视化的在界面编辑任意拓扑，然后生成python自定义拓扑脚本，Mininetnet2.20+内置，在mininet/examples里面提供mininetedit.py脚本； Mininet参数 topo： 用于指定网络拓扑，Mininet支持minimal,singel,linear 和tree 三种 minimal: 创建一个交换机和两个主机相连的简单拓扑。默认无—topo参数的情况下就是这样。其内部实现就是调用了single,2对应的函数。 single,n:设置一个交换机和n个主机相连的拓扑。 linear,n:创建n个交换机，每个交换机只连接一个主机，并且所有交换机成线型排列。 tree,depth=n,fanout=m:创建深度为n，每层树枝为m的树型拓扑。因此形成的拓扑的交换机个数为(mn-1) /(m-1)，主机个数为mn。 –custom:在上述已有拓扑的基础上，Mininet支持自定义的拓扑，使用一个简单的Python API即可。–custom需和–topo一起使用，如mn –custom file.py –topo mytopo。 内部交互命令: | 参数 | 作用 || ———————————- | —- || -h | show this help message and exit || –switch=SWITCH | [kernel user ovsk] || –host=HOST | [process] || –controller=CONTROLLER | [nox_dump none ref remote nox_pysw] || –topo=TOPO | [tree reversed single linear minimal],arg1,arg2,…argN || -c,–clean | clean and exit || –custom=CUSTOM | read custom topo and node params from .py file || –test=TEST | [cli build pingall pingpair iperf all iperfudp none] || -x,–xterms | spawn xterms for each node || –mac | set MACs equal to DPIDs || –arp | set all-pairs ARP entries || -v VEIBOSITY,–verbosity=VEIBOSITY | [info warning critical error debug output] || –ip=IP | [ip address as a dotted decimal string for aremote controller] || –port=PORT | [port integer for a listening remote controller] || –innamespace | sw and ctrl in namespace || –listenport=LISTENPORT | [base port for passive switch listening controller] || –nolistenport | don’t use passive listening port || –pre=PRE | [CLI script to run before tests] || –post=POST | [CLI script to run after tests] | Mininet常用命令总结： |命令|作用||—-|—-||help|默认列出所有命令文档，后面加命令名将介绍该命令用法 dump打印节点信息||gterm|给定节点上开启gnome-terminal 注：可能导致mn崩溃||xterm|给定节点上开启xterm||intfs|列出所有的网络接口||iperf|两个节点之间进行简单的iPerf TCP测试||iperfudp|两个节点之间用制定带宽UDP进行测试||net|显示网络链接情况||noecho|运行交互式窗口，关闭回应（echoing）||pingpair|在前两个主机之间互Ping测试||source|从外部文件中读入命令||dpctl|在所有交换机上用dptcl执行相关命令，本地为tcp 127.0.0.1:6634||link|禁用或启用两个节点之间的链路||nodes|列出所有的节点信息||pingall|所有主机节点之间互Ping||py|执行Python表达式||sh|运行外部shell命令||quit/exit|退出| 实际构建拓扑 构建single拓扑: 1sudo mn --topo&#x3D;single,3 exit退出 single拓扑中整个网络拓扑中交换机有且仅有一个，交换机下面可以挂一个或者多个主机；本例会创建一个交换机，3个主机，3个主机挂在一个交换机下面 构建linear拓扑 1sudo mn --topo&#x3D;linear,3 线性拓扑中交换机连接呈线性排列，每一个交换机连接的主机数目只有一个，本例创建了3个交换机，3个主机，3个主机挂在各自交换机下面并且交换机之间互相连接 构建tree拓扑 1sudo mn --topo&#x3D;tree,depth&#x3D;2,fanout&#x3D;2 创建了一个数，s1为根，下面是s2,s3,然后s2,s3各自挂两个主机；depth表示交换机深度，fanout表示每一层的节点数量； 创建自定义拓扑 12cd &#x2F;home&#x2F;openlab&#x2F;openlab&#x2F;mininet&#x2F;customsudo mn --custom topo-2sw-2host.py --topo mytopo python 脚本如下: 内部交互命令 使用net显示连接信息 使用nodes查看节点信息 使用links查看连路鲁棒性信息 使用pingall验证所有主机间通信查看结果 使用xterm h1 h2进入设备可视化操作界面 exit退出 mn -c 清楚释放Mininet构建配置的交换机及主机 可视化构建 使用MiniEdit 在mininet/examples下执行miniedit.py 1sudo .&#x2F;miniedit.py 如下图，可以选择的助教有：主机，OpenFlow交换机，传统交换机，传统路由器，链路，控制器： Miniedit属性配置 在左侧设备列表中选中需要的设备，在右侧空白区域单击，设备即添加成功。设备及链路上可进行鼠标右击长按，选择Properties即可对其进行配置。在控制器上进行鼠标右击长按，选择Properties即可对控制器进行配置: 然后修改了交换机，选择Porperties，配置了16位的DPID： 然后修改了主机的IP地址： 修改的同时miniedit.py会在窗口中显示修改的设备属性 image-20210903180633749 全局配置 Miniedit左上角Edit可以剪切删除设备，对整个网络进行全局配置 点击左下角run即可运行设置好的网络拓扑 然后此时对交换机主机右击常看可以查看交换机的bridge信息以及打开host终端 Minideit保存脚本 File–Export Level 2 Scirpt可以保存为python脚本，默认在mininet/examples下面，用 chomod给权限之后直接运行可以直接重现 比如 12chmod -R 777 temp.pysudo .&#x2F;temp.py Mininet 调用API扩展自定义拓扑 Mininet作为一个基于Python的网络仿真工具，可以分为两大部分:Python库和运行文件。前者对网络中元素进行抽象和实现，例如定义主机类来表示网络中的一台主机;后者则基于这些库完成模拟过程。topo 类中包含构建网络的函数如： addHost(“host name”): 添加主机 addSwitch(“sw name”): 添加交换机 addLink(node,node): 添加链路 attach(port):添加端口 首先使用自定义拓扑: 1sudo mn --custom topo-2sw-2host.py --topo mytopo 添加主机h3 1py net.addHost(‘h3’) 添加s3与主机h3之间的链路 1py net.addLink(s3,net.get(‘h3’)) 在Mininet交互环境中添加端口 1py s3.attach(‘s3-eth3’) 在Mininet交互环境中对主机进行配置IP地址 1py net.get(‘h3’).cmd(‘ifconfig h3-eth0 10.3’) 查看节点信息 12dumpnodes 验证连通性 12h1 ping h3pingall Mininet 流表应用实战1——手动添加流表 自定义拓扑脚本文件exper1.py，脚本代码如下： 123456789101112131415161718192021222324#!/usr/bin/pythonfrom mininet.topo import Topofrom mininet.net import Mininetfrom mininet.node import RemoteControllerfrom mininet.link import TCLinkfrom mininet.util import dumpNodeConnectionsclass MyTopo( Topo ): \"Simple topology example.\" def __init__( self ): \"Create custom topo.\" # Initialize topology Topo.__init__( self ) # Add hosts and switches Host1 = self.addHost(h1) Host2 = self.addHost(h2) Host3 = self.addHost(h3) Switch1 = self.addSwitch(s1) Switch2 = self.addSwitch(s2) # Add links self.addLink( Host1, Switch1 ) self.addLink( Host2, Switch1 ) self.addLink( Host3, Switch2 ) self.addLink( Switch1, Switch2 )topos = &#123;mytopo: ( lambda: MyTopo() ) &#125; 运行脚本并且远程指定一个不存在的控制器，使交换机不受控制器控制； 1sudo mn --custom exper1.py --topo mytopo --controller&#x3D;remote,ip&#x3D;127.0.0.1,port&#x3D;6653 使用如下命令打开可视化终端: 1xterm h1 h2 h3 使用如下命令dpctl dump-flows查看交换机当前的flow table信息。 可以看到交换机s1 s2中没有流表 h2中使用tcp dump -n -i h2-eth0抓取网卡h2-eth0上的数据包 h3中使用tcp dump -n -i h3-eth0抓取网卡h2-eth0上的数据包 在主机h1中执行如下命令分别ping主机h2和h3 12# ping -c 3 10.0.0.2# ping -c 3 10.0.0.3 在主机h2和h3上查看tcpdump抓包结果。 发现主机h1ping h2和h3都失败了，主机h2和h3么有收到任何ICMP ecjp reqiest packet。原理解析：ping操作时，由于拓扑里没有SDN控制器，也没有用dptcl给OpenFlow交换机添加任何flow entry,所以交换机不会做转发决定，并直接丢弃h1到h2及h1到h3的ping包。 添加流表 执行如下命令添加交换机端口流表使主机h1和h2通信。 12mininet&gt; dpctl add-flow in_port&#x3D;1,actions&#x3D;output:2mininet&gt; dpctl add-flow in_port&#x3D;2,actions&#x3D;output:1 然后使用dpctl dump-flows查看流表，发现添加成功: 再次 ping,发现h2可以ping通,h3不可以: 原理解析：用dpctl对交换机添加flow，让交换机从s1-eth1这个端口接收到的所有traffic都从s1-eth2这个端口发出去。用dpctl给交换机添加双向流表，因为ping包除了echo request还有echo reply。所以还需要用dpctl对交换机添加flow，让交换机从s1-eth2这个端口接收到的所有traffic都从s1-eth1这个端口发出去。添加这两条flow后，h1能够ping通h2，但是并没有为h1和h3之间添加对应的端口流表，所以h1与h3不通。 添加协议流表使h1/h2通信: 执行如下命令删除之前通过端口添加的流表并且查看，确保交换机流表为空: 12dpctl del-flowsdpctl dump-flows 执行如下命令添加两条traffic类型为IPV4协议相关的flow entry并且查看下发的流表: 123dpctl add-flow dl_type&#x3D;0x0800,nw_dst&#x3D;10.0.0.2,actions&#x3D;output:2dpctl add-flow dl_type&#x3D;0x0800,nw_dst&#x3D;10.0.0.1,actions&#x3D;output:1dpctl dump-flows 执行命令ping h2 和h3： ![image-20210907030326211](/picture/image-20210907030326211.png) ​ 可以看到无法ping通 在主机h2,h3上面查看: 原理解析：用dpctl对交换机添加flow，让交换机把所有EtherType为0x0800（IPv4）并且destiation IP为10.0.0.2的traffic从s1-eth2这个端口发出去。用dpctl对交换机添加flow，让交换机把所有EtherType为0x0800（IPv4）并且destiation IP为10.0.0.1的traffic从s1-eth1这个端口发出去。但处在同一网段下的主机，它们之间的交流是L2 forwarding，需要靠ARP来解析MAC地址，之前只匹配了0x0800(IPv4)协议，并没有匹配到0x0806(ARP)，这样当交换机收到h1的ARP包后，因为没有控制器，flow table里面也没有相应的flow告诉它如何转发这个ARP包，交换机只能将它丢弃，从而导致h1 ping h2失败，所以需要添加ARP协议的流表来使通信。 执行命令dpctl add-flow dl_type=0x0806,actions=NORMAL添加ARP(0x0806)协议相关的流表，让交换机以NORMAL形式（广播）将所有ARP包从各个端口广播出去: 执行dpctl dump-flows查看: 然后ping h2和h3 发现可以ping通h2: Mininet流表应用实战——控制器下发流表协议分析 实验原理：在SDN环境下，当交换机收到一个数据包并且交换机中没有与改数据包匹配的流表项的时候，交换机将此数据包发给控制器，由控制器决策数据包如何处理，控制器下发决策后，交换机根据控制器下发的信息来进行数据包的处理，即转发或者丢弃这个数据包。 这个实验做了一下，基本就是控制器，主机两个，主机上进行抓包然后分析协议 Mininet 多数据中心网络拓扑流量带宽实验 使用mininet中的iperf工具在网络中生成UDP流量，iperf客户端传送数据流到iperf的服务端，由服务端接收并记录相关信息。网络性能评估中一个巨大的挑战就是如何生成真实的网络流量，可以通过程序来创造人工的网络流量，通过建立测试环境来模拟真实的状况。此应用主要以数据中心网络为目标场景，在mininet仿真环境中尽可能地还原数据中心内部的真实流量情况。 Mininet数据中心应用价值： 树状拓扑结构容错能力强 降低数据中心成本消耗 提供重新排列的全带宽无阻碍路径 提高带宽利用率 分析数据中心网络流量性能 为真实数据中心和仿真测试床提供有用信息 在mininet中进行自定义命令iperfmulti功能拓展主要分为4步： 1.修改mininet/net.py 2.修改mininet/cli.py 3.修改bin/mn 4.重新安装Mininet核心文件：~/mininet/util/install.sh -n 实验拓扑: 实验设备： 编写网络带宽测试程序 在mininet/net.py中的”def iperf”下面添加定义iperf_single()函数实现两个主机间的iperf udp 测试,代码如下: 123456789101112131415161718192021 def iperf_single( self,hosts=None, udpBw='10M', period=60, port=5001): \"\"\"Run iperf between two hosts using UDP. hosts: list of hosts; if None, uses opposite hosts returns: results two-element array of server and client speeds\"\"\" if not hosts: return else: assert len( hosts ) == 2 client, server = hosts filename = client.name[1:] + '.out' output( '*** Iperf: testing bandwidth between ' ) output( \"%s and %s\\n\" % ( client.name, server.name ) ) iperfArgs = 'iperf -u ' bwArgs = '-b ' + udpBw + ' ' print \"***start server***\" server.cmd( iperfArgs + '-s -i 1' + ' &gt; /home/sdnlab/log/' + filename + '&amp;') print \"***start client***\" client.cmd( iperfArgs + '-t '+ str(period) + ' -c ' + server.IP() + ' ' + bwArgs +' &gt; /home/sdnlab/log/' + 'client' + filename +'&amp;') 在Mininet类中添加自定义命令iperfmulti()函数，这个函数的作用使实现为每一台主机随机选择另一台主机作为iperf的服务器段，通过调用iperf_single，自身以客户端的身份按照指令参数发送UDP流，服务器生成的报告以重定向的方式输出到文件中。使用iperfmulti命令，主机随机地向另一台主机发起一个恒定带宽的UDP数据流。 1234567891011121314151617181920212223def iperfMulti(self, bw, period=60): base_port = 5001 server_list = [] client_list = [h for h in self.hosts] host_list = [] host_list = [h for h in self.hosts] cli_outs = [] ser_outs = [] _len = len(host_list) for i in xrange(0, _len): client = host_list[i] server = client while( server == client ): server = random.choice(host_list) server_list.append(server) self.iperf_single(hosts = [client, server], udpBw=bw, period= period, port=base_port) sleep(.05) base_port += 1 sleep(period) print \"test has done\" 打开/mininet/cli.py文件，加入如下代码，注册iperfmulti命令: 12345678910111213def do_iperfmulti( self, line ): \"\"\"Multi iperf UDP test between nodes\"\"\" args = line.split() if len(args) == 1: udpBw = args[ 0 ] self.mn.iperfMulti(udpBw) elif len(args) == 2: udpBw = args[ 0 ] period = args[ 1 ] err = False self.mn.iperfMulti(udpBw, float(period)) else: error('invalid number of args: iperfmulti udpBw period\\n' +'udpBw examples: 1M 120\\n') 使用sudo vim mininet/bin/mn，加入iperfmulti可执行命令: 执行如下命令重新编译Mininet: 12cd openlab&#x2F;mininet&#x2F;util.&#x2F;install.sh -n 使用sudo mn 创建一个topo查看是否存在iperfmulti命令，作为验证： 构建多数据中心拓扑 在/mininet/custom中创建fattree.py，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python\"\"\"Custom topology exampleAdding the 'topos' dict with a key/value pair to generate our newly definedtopology enables one to pass in '--topo=mytopo' from the command line.\"\"\"from mininet.topo import Topofrom mininet.net import Mininetfrom mininet.node import RemoteController,CPULimitedHostfrom mininet.link import TCLinkfrom mininet.util import dumpNodeConnectionsclass MyTopo( Topo ): \"Simple topology example.\" def __init__( self ): \"Create custom topo.\" # Initialize topology Topo.__init__( self ) L1 = 2 L2 = L1 * 2 L3 = L2 c = [] a = [] e = [] # add core ovs for i in range( L1 ): sw = self.addSwitch( 'c&#123;&#125;'.format( i + 1 ) ) c.append( sw ) # add aggregation ovs for i in range( L2 ): sw = self.addSwitch( 'a&#123;&#125;'.format( L1 + i + 1 ) ) a.append( sw ) # add edge ovs for i in range( L3 ): sw = self.addSwitch( 'e&#123;&#125;'.format( L1 + L2 + i + 1 ) ) e.append( sw ) # add links between core and aggregation ovs for i in range( L1 ): sw1 = c[i] for sw2 in a[i/2::L1/2]: # self.addLink(sw2, sw1, bw=10, delay='5ms', loss=10, max_queue_size=1000, use_htb=True) self.addLink( sw2, sw1 ) # add links between aggregation and edge ovs for i in range( 0, L2, 2 ): for sw1 in a[i:i+2]: for sw2 in e[i:i+2]: self.addLink( sw2, sw1 ) #add hosts and its links with edge ovs count = 1 for sw1 in e: for i in range(2): host = self.addHost( 'h&#123;&#125;'.format( count ) ) self.addLink( sw1, host ) count += 1topos = &#123; 'mytopo': ( lambda: MyTopo() ) &#125; Mininet创建网络拓扑的代码中，可以通过改变代码中定义的L1变量来设置核心交换机的数量，并通过添加额外的交换机和链路来构成更复杂的数据中心网络拓扑。随着边缘交换机的增加，主机个数也随之增长，利用Mininet的易用性和扩展性，可以创建基于多种数据中心场景下的网络拓扑，达到更好更全面的实验效果。 在控制器主机上面用ifconfig看主机的ip: 在host，也就是mininet所在的主机上面使用如下命令生成测试拓扑结构: 1sudo mn --custom fattree.py --topo mytopo --controller&#x3D;remote,ip&#x3D;30.0.1.69,port&#x3D;6653 这里ip以上面查出来的为准； 用pingall验证连通性 控制器上通过OPENDAYLIGHT，在浏览器:http://30.0.1.69:8181/index.html中可以看到ODL控制器。查看拓扑如下: 在mininet主机上面可以iperf h1 h2测主机间带宽 使用iperfmulti 0.025M可以看到8太主机随机向另外的主机发数据包，然后数据记录在/home/sdnlab/log里面。 这个实验可以用来借鉴测试速度之类的实验","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"mininet","slug":"mininet","permalink":"http://tyler-ytr.github.io/tags/mininet/"},{"name":"实验基础","slug":"实验基础","permalink":"http://tyler-ytr.github.io/tags/%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80/"}]},{"title":"cs144_1","date":"2021-08-02T08:21:32.000Z","path":"2021/08/02/cs144-1/","text":"CS144整体参考https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html;https://juejin.cn/post/6929693406528536583#heading-6 整体实验来自https://cs144.github.io/ 查重可以参考 https://github.com/jplag/jplag；简略说明：https://canjuly.github.io/2019/04/15/JPlag/ Lab0工作量 5-8小时 可能？ 虚拟机安装 安装虚拟机镜像之后，记得修改内存，处理器； 在windows terminal 使用ssh -p 2222 cs144@localhost，或者在mobaxterm 访问地址为127.0.0.1 名称为cs144 端口号为22的session GUI:sudo apt-get install --reinstall lightdm 启动GUIsudo systemctl start lightdm Networking by hand 访问 http://cs144.keithw.org/hello 如果不想安装图形界面，可以安装w3m,然后使用w3m http://cs144.keithw.org/hello访问网页 使用telnet访问http://cs144.keithw.org/hello 的时候要注意根据文件提示使用 如果用了退出键会进入telnet &gt; 发邮件那个实验可以参考163邮箱发邮件这个博客 https://blog.csdn.net/qq_33862644/article/details/79339532 qq邮箱参考 https://www.cnblogs.com/cthon/p/9151467.html 以下是QQ邮箱： base64编码: 601576661 NjAxNTc2NjYx amd1dXd6ZnN3dG1uYmNn??== 这个由设置-&gt; 账户-&gt; POP3/ SMTP服务开启之后得到的权限码获得的 然后经过base64编码之后的产物,最后两位5我用??代替 操作过程 12345678910111213141516171819202122232425262728293031323334cs144@cs144vm:~$ telnet smtp.qq.com 25Trying 203.205.232.7...Connected to smtp.qq.com.Escape character is &#39;^]&#39;.220 newxmesmtplogicsvrsza28.qq.com XMail Esmtp QQ Mail Server.helo larry250-newxmesmtplogicsvrsza28.qq.com-10.62.17.92-20691606250-SIZE 73400320250 OKauth login334 VXNlcm5hbWU6NjAxNTc2NjYx334 UGFzc3dvcmQ6amd1dXd6ZnN3dG1uYmNn??&#x3D;&#x3D;235 Authentication successfulmail from:&lt;601576661@qq.com&gt;250 OK.rcot to:&lt;492671684@qq.com&gt;502 Invalid input from 100.107.4.130 to newxmesmtplogicsvrsza28.qq.comrcpt to:&lt;492671684@qq.com&gt;250 OKdata354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;. &#x2F;&#x2F;注意这个是end data的方法to: hello &#x2F;&#x2F;这个显示出来是 发件人: hellofrom: test &#x2F;&#x2F;这个显示出来是 收件人: testsubject: this is a test.&#x2F;&#x2F;这个是标题hello telnet.250 OK: queued as.502 Invalid input from 100.107.4.130 to newxmesmtplogicsvrsza28.qq.comquit&#x2F;&#x2F;使用quit退出 netcat 小实验 体验一下，可以用tmux分屏 Writing a network program using an OS stream socket 这块需要阅读文档，重点要阅读TCPSocket 类 里面的样例 具体实现不是那么复杂 有可能有必要演示怎么debug 用vscode+插件 An in-memory reliable byte stream 这块编程是C++ 11;可能预先需要讲一下面向对象？https://github.com/0voice/cpp_new_features 需要提示一下STL库啥的 Lab1 比较复杂，为了提高速度需要利用STL的set或者其他基于红黑树的数据结构 任务目标是实现一个流重组器（stream reassembler），可以将带索引的字节流碎片重组成有序的字节流。 可能需要提前教授GDB，或者VS code 代码调试的方法 大概需要1-2天 5-10小时 建议提示使用STL set，可能得给一个类似于线段树的数据结构？ Lab2 实现TCP Receiver，这是TCP实现中处理传入字元流的部分。TCPReceiver在传入的TCP段(通过Internet携带的数据报的有效负载)和传入的字节流之间进行转换； 总的来说接收端除了写入到来的流，还有两个工作： 告诉发送端ackno; This is the first byte that the receiver needs from the sender. 告诉发送端window size:the distance between the “first unassembled” index and the “first unacceptable” index 第一部分是实现wrapping_integers，这个用途是实现序列号、绝对序列号与流索引间的转换。 这一部分不是很困难，我觉得1个小时连带搜索应该可以解决；如果要提示的话可以提示比特运算，与或什么的；同时可以提供C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast 这类作为写32位数字的提示；另外需要提醒他们查一查位运算，比如bithacks,无符号长整型1(1ul)； 第二部分时实现TCP_receiver;这部分会讲TCP段的格式，需要实现一个接收器，基于滑动窗口算法； 文档比较丰富，这块会比较花时间；与此同时 细节比较多 segment_received接口从bool改成了void; 之前的如果段的任何部分在窗口内，则返回true；现在直接是void;这部分业务工作不确定是不是调整到了lab4;讲义中并没有找到; 事实上我做的时候觉得没有博客那么复杂，因为减少了一个判断在不在窗口这个部分;实际上要考虑的就是SYN，初始化ISN，计算要装入Lab1 ressembler里面的东西的index以及payload即可; Lab3 本节比较复杂，需要花一段时间理解逻辑 Lab4复刻的困难是这个用到了斯坦福的服务器，具体看https://github.com/CS144/sponge/blob/lab4-startercode/tun.sh;服务器的配置在https://github.com/CS144/sponge/blob/lab4-startercode/etc/tunconfig;他们的服务器是169.254.1.1/24 可能也有169.254.1.0/24； 另外在https://github.com/CS144/sponge/blob/lab4-startercode/txrx.sh 里面也有用到服务器的地方;","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"cn_lab1","date":"2021-08-01T08:35:02.000Z","path":"2021/08/01/cn-lab1/","text":"Lab1根据https://pavinberg.gitbook.io/nju-network-lab/lab-1 进行实验 遇到的问题 安装虚拟机报错； 在安装给的虚拟机的时候无法创建，报错明细如下； Implementation of the USB 2.0 controller not found! Because the USB 2.0 controller state is part of the saved VM state, the VM cannot be started. To fix this problem, either install the ‘Oracle VM VirtualBox Extension Pack’ or disable USB 2.0 support in the VM settings. Note! This error could also mean that an incompatible version of the ‘Oracle VM VirtualBox Extension Pack’ is installed (VERR_NOT_FOUND).” 根据https://zhaokaifeng.com/?p=443 给的解决方法，通过禁用USB解决了这个问题；首先进入设置-&gt;USB设备-&gt;把启用USB控制器的勾点掉 修改分辨率那块我觉得除了VB那里安装拓展之外，内部还需要在设置(setting)里面进入display进行分辨率的设置，可以参考https://blog.csdn.net/colin_lisicong/article/details/70193556","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://tyler-ytr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Summer_plan","date":"2021-07-30T02:53:56.000Z","path":"2021/07/30/Summer-plan/","text":"期望学习的知识： Haskell Javascript Leetcode刷题 C++ STL P4 计算机网络实验部分 初期计划（7.30+7） Haskell 安装之后，每日一个chapter Leetcode每日一题 https://github.com/youngyangyang04/leetcode-master 算法基础leetcode 35, 看完P4的PDF Javascript DOM 编程艺术 1 C++ STL每日一到两个视频 调研计网实验 To be done","tags":[{"name":"plan","slug":"plan","permalink":"http://tyler-ytr.github.io/tags/plan/"}]},{"title":"数据分析和拟合","date":"2021-07-12T11:01:42.000Z","path":"2021/07/12/数据分析和拟合/","text":"python数据拟合和分析以下内容是我在进行webRTC拥塞控制部分进行训练集traces分析和生成的总结；举办方提供了一部分真实环境的数据，但我认为对于训练来说可能不够，因此需要自己生成一部分; 数据拟合使用fitter库进行数据的拟合；大概的效果如下图所示： image-20210712190334719 fitter 库fitter库的源码位置:https://github.com/cokelaer/fitter 安装fitter库: pip install fitter fitter库的文档:https://fitter.readthedocs.io/en/latest/ fitter库使用案例生成模拟数据: 123&gt;&gt;&gt; # First, we create a data sample following a Gamma distribution&gt;&gt;&gt; from scipy import stats&gt;&gt;&gt; data &#x3D; stats.gamma.rvs(2, loc&#x3D;1.5, scale&#x3D;2, size&#x3D;20000) 使用 fitter库进行拟合: 1234567891011121314151617&gt;&gt;&gt; # We then create the Fitter object&gt;&gt;&gt; import fitter&gt;&gt;&gt; f &#x3D; fitter.Fitter(data)&gt;&gt;&gt; # just a trick to use only 10 distributions instead of 80 to speed up the fitting&gt;&gt;&gt; f.distributions &#x3D; f.distributions[0:10] + [&#39;gamma&#39;]&gt;&gt;&gt; # fit and plot&gt;&gt;&gt; f.fit()&gt;&gt;&gt; f.summary() sumsquare_errorgamma 0.000095beta 0.000179chi 0.012247cauchy 0.044443anglit 0.051672[5 rows x 1 columns] 它在使用fit函数的时候如果没有额外的参数会用scipy的80多个分布进行逐个拟合，默认的拟合时间是30秒； fitter库参数 fitter 1class fitter.fitter.Fitter(data, xmin=None, xmax=None, bins=100, distributions=None, timeout=30, density=True) data (list) –输入的样本数据； xmin (float) – 如果为None，则使用数据最小值，否则将忽略小于xmin的数据； xmax (float) – 如果为None，则使用数据最大值，否则将忽略大于xmin的数据； bins (int) – 累积直方图的组数，默认=100； distributions (list) – 给出要查看的分布列表。 如果没有，则尝试所有的scipy分布(80种),常用的分布distributions=[‘norm’,‘t’,‘laplace’,‘cauchy’, ‘chi2’,’ expon’, ‘exponpow’, ‘gamma’,’ lognorm’, ‘uniform’]； verbose (bool) – timeout – 给定拟合分布的最长时间，（默认=10s） 如果达到超时，则跳过该分布。 123456from fitter import Fitter# may take some time since by default, all distributions are tried# but you call manually provide a smaller set of distributionsf &#x3D; Fitter(data, distributions&#x3D;[&#39;gamma&#39;, &#39;rayleigh&#39;, &#39;uniform&#39;])f.fit()f.summary() 进行fitter了之后可以调用一下函数 12345678f.fit() #fit(amp&#x3D;1, progress&#x3D;False, n_jobs&#x3D;-1)f.df_errors #返回这些分布的拟合质量（均方根误差的和）f.fitted_param #返回拟合分布的参数f.fitted_pdf #使用最适合数据分布的分布参数生成的概率密度f.summary() #返回排序好的分布拟合质量（拟合效果从好到坏）,并绘制数据分布和Nbest分布 summary(Nbest&#x3D;5, lw&#x3D;2, plot&#x3D;True, method&#x3D;&#39;sumsquare_error&#39;)f.get_best(method&#x3D;&#39;sumsquare_error&#39;) #返回最佳拟合分布及其参数f.hist() #绘制组数&#x3D;bins的标准化直方图f.plot_pdf(names&#x3D;None, Nbest&#x3D;3, lw&#x3D;2) #绘制分布的概率密度函数 plot_pdf(names&#x3D;None, Nbest&#x3D;5, lw&#x3D;2, method&#x3D;&#39;sumsquare_error&#39;) 使用注意点 我在使用上述函数的时候f.hist()之后并没有出现图片，通过研究了它源码的issue发现比较保险的方法是import matplotlib,在 f.hist()之后加上plt.show()或者savefig()等操作，这样就能够显示图片了; 12345import matplotlib.pyplot as plt.....f.hist()plt.show()plt.close() 实际使用的脚本123456789101112131415161718192021222324252627282930313233343536373839404142# 批处理版from __future__ import divisionimport jsonimport matplotlib as mplimport matplotlib.pyplot as pltimport globimport osimport numpy as npfrom fitter import Fitterf = glob.iglob(r'*.json') # 当前目录所有py文件，与glob区别，iglob每次只获取一个匹配路径old_picture = glob.iglob(r'*.jpg')result=\"最佳拟合分布\"for file in f: with open(file, 'r') as f: information=file+\"\\n\" trace_pattern = [] data = json.load(f) data_intervals = data[\"uplink\"][\"trace_pattern\"] capacity = [] for ele in data_intervals: capacity.append(ele[\"capacity\"]) print(\"capacity_mean\", np.mean(capacity)) capacity.sort() length = len(capacity) capacity = capacity[0:length-5] filter1 = Fitter(capacity,distributions=[\"lomax\",\"pareto\",\"johnsonsu\",\"exponweib\",\"powerlognorm\"]) filter1.fit() print(type(filter1.summary())) print(filter1.get_best(method='sumsquare_error')) summary=str(filter1.summary()) information=information+\"summary\\n\"+summary+\"\\n\" best_method=str(filter1.get_best(method='sumsquare_error')) information=information+best_method filter1.plot_pdf(names=None, Nbest=3, lw=2) filter1.plot_pdf(names=None, Nbest=3, lw=2) #plt.show() plt.savefig(\"fit_&#123;&#125;.jpg\".format(file)) plt.close() result=result+\"\\n\"+informationwith open(\"fit_result.txt\",'w') as f: f.write(result) 效果是批处理如下json格式的数据，会统计一个文件夹中的数据，给每一个数据绘图，并且把summary写道fit_result.txt中 12345678910111213141516171819202122&#123; \"type\": \"video\", \"downlink\": &#123;&#125;, \"uplink\": &#123; \"trace_pattern\": [ &#123; \"duration\": 200, \"capacity\": 0, \"loss\": 0, \"jitter\": 0, \"time\": 0.0 &#125;, &#123; \"duration\": 200, \"capacity\": 0, \"loss\": 0, \"jitter\": 0, \"time\": 0.0 &#125; ] &#125; &#125; 数据折线图12345678910111213import matplotlib.pyplot as plt.....plt.plot(time_x,time_capacity)xlabels = [\"&#123;&#125;\".format(i) for i in time_x] #修改x轴的刻度plt.xticks(time_x, xlabels) plt.xlabel('row')plt.ylabel('column')plt.legend()plt.savefig(\"time_&#123;&#125;.jpg\".format(file))plt.close() 数据生成经过查阅scipy的文档以及简单了看了fitter项目的源码，上面get_best()得到的形如: 1&#39;johnsonsu&#39;: (-0.43618926054816165, 1.8086581271068694, 26026.47774558232, 26854.12469365103) 表示的参数为a, b, loc, scale; 具体含义见下图: image-20210712190221706 通过上面fitter得到的参数，可以使用如下的代码进行数据的生成，生成的格式是narray: 1234import scipy.stats as stsize_t&#x3D;1500params&#x3D;(-0.43618926054816165, 1.8086581271068694, 26026.47774558232, 26854.12469365103)data&#x3D;list(st.johnsonsu.rvs(*params,size&#x3D;int(size_t))) # 格式是numpy 数据筛选1234567# 数据筛选data1&#x3D;data[:]for ele in data1: if ele &lt; 0.0: data.remove(ele) if ele &gt; 400.0: data.remove(ele) 如果没有data1=data[:]的操作会出现无法删除的问题","tags":[{"name":"python心得","slug":"python心得","permalink":"http://tyler-ytr.github.io/tags/python%E5%BF%83%E5%BE%97/"}]},{"title":"git以及ssh代理的配置","date":"2021-07-02T07:43:45.000Z","path":"2021/07/02/git以及ssh代理的配置/","text":"git以及ssh代理的配置鄢老师提供的方案并根据自己的情况进行了调整； 修改ssh的config文件文件位置在C:\\Users\\用户名\\.ssh 目前的版本 12Host github.com ProxyCommand connect -H 127.0.0.1:7890 %h %p 修改gitconfig文件文件位置在C:\\Users\\用户名\\.gitconfig里面; 目前的版本: 1234567891011121314[user] email &#x3D; 邮箱 name &#x3D; 名字[core] autocrlf&#x3D;input[socks] proxy&#x3D;127.0.0.1:7890[http &quot;http:&#x2F;&#x2F;github.com&quot;] proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890[filter &quot;lfs&quot;] clean&#x3D;git-lfs clean -- %f smudge&#x3D;git-lfs smudge -- %f process&#x3D;git-lfs filter-process required&#x3D;true 如果改了代理的客户端请修改端口7890即可","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"学校服务器访问外网的配置","date":"2021-07-02T07:37:05.000Z","path":"2021/07/02/学校服务器访问外网的配置/","text":"访问外网的配置服务器1命令行中使用: 1setproxy 就可以通过代理服务器1的服务器1的端口访问外网。 NAT的方法(目前不用，仅作参考)服务器1可以上外网；服务器2不能上外网，但是在内网与服务器1互通；下面的操作是用iptables在服务器1上对服务器2搭建一个NAT; 并且修改服务器2的默认路由，达到服务器2访问外网的目的； 服务器11iptables -t nat -A POSTROUTING -s 服务器2 -j MASQUERADE 查看iptables： 1sudo iptables -t nat -L 带检索的查看iptables: 1sudo iptables -t nat -L POSTROUTING --line-numbers 删除刚刚操作之后的表项:(请根据查询的编号决定是不是1) 1sudo iptables -t nat -D POSTROUTING 1 服务器2查看路由 1route -n 增加默认路由:(这个操作可能会让ssh连接断掉) 1sudo route add default gw 服务器1 删除路由: 1sudo route del default gw 服务器1 具体实现流程:A表示服务器1；B表示服务器2 首先用在A上iptables -t nat -A POSTROUTING -s B的地址 -j MASQUERADE；然后SSH连接B；B上用sudo route add default gw A的地址；此时SSH 会连接B失败；然后从A上用SSH连接B；此时连接的B可以通过A的NAT访问外网然后安装v2ray;然后删除路由;退出之后在A上删除刚刚的iptables表项 iptables那步的作用是搭建了A对于B开启了nat服务;B通过修改路由把数据包转发到A上，进而访问外网; 上面的方法也是一种上网方法；只不过不是很方便 配置完之后通过v2ray访问外网; 实现流程的反思实际上可能不需要那么复杂。在能出外网的服务器1上面安装v2ray，更改配置文件保证http,socks5的代理就行了；不能连接外网的服务器通过export ALL_PROXY=socks5://服务器1的地址:端口;就可以出去了 v2ray（目前使用）安装通过来自https://github.com/v2fly/fhs-install-v2ray的脚本安装; v2ray启用: 1sudo systemctl enable v2ray v2ray打开: 1sudo systemctl start v2ray v2ray关闭: 1sudo systemctl stop v2ray 每次修改完配置文件之后需要重启 服务器1配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;log&quot;: &#123; &quot;access&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;access.log&quot;, &quot;error&quot;: &quot;&#x2F;var&#x2F;log&#x2F;v2ray&#x2F;error.log&quot;, &quot;loglevel&quot;: &quot;warning&quot; &#125;, &quot;inbounds&quot;: [ &#123; &quot;port&quot;: 端口号, &quot;protocol&quot;: &quot;http&quot;, &quot;settings&quot;: &#123;&#125; &#125;, &#123; &quot;port&quot;: 端口号, &quot;protocol&quot;: &quot;socks&quot;, &quot;settings&quot;: &#123;&#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: &#123;&#125;, &quot;tag&quot;: &quot;direct&quot; &#125; ], &quot;routing&quot;: &#123; &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;, &quot;rules&quot;: [ &#123; &quot;type&quot;: &quot;field&quot;, &quot;outboundTag&quot;: &quot;direct&quot;, &quot;domain&quot;: [&quot;geosite:cn&quot;] &#125;, &#123; &quot;type&quot;: &quot;field&quot;, &quot;outboundTag&quot;: &quot;direct&quot;, &quot;ip&quot;: [ &quot;geoip:cn&quot;, &quot;geoip:private&quot; ] &#125; ] &#125;&#125; 上述配置文件实现了socks5和http的代理; 服务器2我在.bashrc里面最后添加了: 1alias setproxy&#x3D;&quot;export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;服务器1:端口号;echo &#39;You can use &#39;unset ALL_PROXY&#39; to unset it &#39;&quot; 使用setproxy即可通过服务器1访问外网;通过unset ALL_PROXY来修改回默认设置; 于此同时该服务器也安装了v2ray；有需求的同学可以自行配置; 使用 1wget www.baidu.com 来进行连通性的测试;（不知道什么原因ping不通baidu） 参考网站https://www.v2ray.com/ https://segmentfault.com/a/1190000039686752 https://blog.csdn.net/yelllowcong/article/details/75949296","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"p4学习-6:实现网络测量","date":"2021-04-20T04:16:42.000Z","path":"2021/04/20/p4学习-6/","text":"p4学习-6:实现网络测量实验目标这个练习的目标是写一个P4程序允许一个主机区检测网络中所有链路的利用情况。这个练习是在基础的IPV4 forwarding练习上搭建的。具体来说，我们将修改基本的P4程序，以处理源路由探测包，使其能够在每一跳提取出口链路利用率，并将其交付给主机进行监控。 探测包由下面三种header types组成: 123456789101112131415161718192021222324&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe&#x2F;&#x2F; packet has traversed so far.&#x2F;&#x2F;顶层的探测header,指出这个探测包经过了多少跳header probe_t &#123; bit&lt;8&gt; hop_cnt;&#125;&#x2F;&#x2F; The data added to the probe by each switch at each hop.&#x2F;&#x2F;每一个交换机加到探测包上面的数据header probe_data_t &#123; bit&lt;1&gt; bos;&#x2F;&#x2F;bottom of stack bit&lt;7&gt; swid;&#x2F;&#x2F;switch ID bit&lt;8&gt; port; bit&lt;32&gt; byte_cnt;&#x2F;&#x2F;和下面的寄存器应该对应 time_t last_time;&#x2F;&#x2F;和下面的寄存器应该对应 time_t cur_time;&#125;&#x2F;&#x2F; Indicates the egress port the switch should send this probe&#x2F;&#x2F; packet out of. There is one of these headers for each hop.&#x2F;&#x2F;指示交换机应该发送该探测报文的出口端口。每个跳跃都有一个这样的 headerheader probe_fwd_t &#123; bit&lt;8&gt; egress_spec;&#125; topology 拓扑如上，包含了四个主机连接到四个交换机上面，连接方式好像他们在fat tree 的pod上一样。 为了监控链路利用率，交换机将维持两个寄存器数组： byte_cnt_reg 自最后一个探测包从端口传输出去以来，每个端口传输出去的字节数。 last_time_reg保存探测包最后一次从每个端口发送出去的时间。 P4程序将被写成V1Model形式（bmv2交换机），V1model可以参考它的官方源码 补充： FatTree胖树拓扑结构传统结构： image-20210420125915925 传统数据中心采用多层级的树形结构，这种结构针对客户端/服务器（C/S）模式能有较好的效果。树形结构包括单根树和多根树。多根数的根节点往往作为备份节点存在（我们以方格代表交换机） 缺点：传统单根/多根拓扑结构有以下缺点：成本高，根部交换机必须要有足够大的带宽来满足下层服务器之间的通信；性能瓶颈，无法满足数据中心内部大规模的MapReduce和数据拷贝。 FatTree 拓扑结构： Fat-Tree是以交换机为中心的拓扑。支持在横向拓展的同时拓展路径数目；且所有交换机均为相同端口数量的普通设备，降低了网络建设成本。 整个拓扑网络分为三个层次：自上而下分别为边缘层（edge）、汇聚层（aggregate）和核心层（core），其中汇聚层交换机与边缘层交换机构成一个pod，交换设备均采用商用交换设备。 一个k元的Fat-Tree可以归纳为5个特征： 每台交换机都有k个端口； 核心层为顶层，一共有(k/2)^2个交换机； 一共有k个pod，每个pod有k台交换机组成。其中汇聚层和接入层各占k/2台交换机； 接入层每个交换机可以容纳k/2台服务器，因此，k元Fat-Tree一共有k个pod，每个pod容纳$kk/4$个服务器，所有pod共能容纳$kk*k/4$台服务器；任意 两个pod之间存在k条路径。 例子： 二叉FatTree 二叉FatTree 四叉FatTree 四叉FatTree 因此上面练习的拓扑就像四叉FatTree的一个pod 代码实现headers部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#x2F;* -*- P4_16 -*- *&#x2F;#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;const bit&lt;16&gt; TYPE_PROBE &#x3D; 0x812;#define MAX_HOPS 10#define MAX_PORTS 8&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;typedef bit&lt;48&gt; time_t;header ethernet_t &#123; macAddr_t dstAddr; macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;header ipv4_t &#123; bit&lt;4&gt; version; bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;&#x2F;&#x2F; Top-level probe header, indicates how many hops this probe&#x2F;&#x2F; packet has traversed so far.header probe_t &#123; bit&lt;8&gt; hop_cnt;&#125;&#x2F;&#x2F; The data added to the probe by each switch at each hop.header probe_data_t &#123; bit&lt;1&gt; bos; bit&lt;7&gt; swid; bit&lt;8&gt; port; bit&lt;32&gt; byte_cnt; time_t last_time; time_t cur_time;&#125;&#x2F;&#x2F; Indicates the egress port the switch should send this probe&#x2F;&#x2F; packet out of. There is one of these headers for each hop.header probe_fwd_t &#123; bit&lt;8&gt; egress_spec;&#125;struct parser_metadata_t &#123; bit&lt;8&gt; remaining;&#125;struct metadata &#123; bit&lt;8&gt; egress_spec; parser_metadata_t parser_metadata;&#125;struct headers &#123; ethernet_t ethernet; ipv4_t ipv4; probe_t probe; probe_data_t[MAX_HOPS] probe_data; probe_fwd_t[MAX_HOPS] probe_fwd;&#125; 比之前的IPV4 forwarding多了三个探测包的header Parser部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet; &#125; state parse_ethernet &#123; packet.extract(hdr.ethernet); transition select(hdr.ethernet.etherType) &#123; TYPE_IPV4: parse_ipv4; TYPE_PROBE: parse_probe; default: accept; &#125; &#125; state parse_ipv4 &#123; packet.extract(hdr.ipv4); transition accept; &#125; state parse_probe &#123; packet.extract(hdr.probe); meta.parser_metadata.remaining &#x3D; hdr.probe.hop_cnt + 1; transition select(hdr.probe.hop_cnt) &#123; 0: parse_probe_fwd; default: parse_probe_data; &#125; &#125; state parse_probe_data &#123; packet.extract(hdr.probe_data.next); transition select(hdr.probe_data.last.bos) &#123; 1: parse_probe_fwd; default: parse_probe_data; &#125; &#125; state parse_probe_fwd &#123; packet.extract(hdr.probe_fwd.next); meta.parser_metadata.remaining &#x3D; meta.parser_metadata.remaining - 1; &#x2F;&#x2F; extract the forwarding data meta.egress_spec &#x3D; hdr.probe_fwd.last.egress_spec; transition select(meta.parser_metadata.remaining) &#123; 0: accept; default: parse_probe_fwd; &#125; &#125;&#125; 流程是：先进入start状态，通过ethernet的etherType确定是 ipv4包还是探测包，如果是ipv4包，略；如果是探测包，那么看看是不是第一个跳，探测包经过第一跳的时候不会有其他信息，因此可以直接进入向前转发的状态；否则就更新matada里面的remaing，进入parse_probe_data状态解析probe_data.next的信息，知道解析到last.bos也就是栈底的时候再进入向前转发状态；向前转发状态(parse_probe_fwd)里面,使用hdr.probe.hop_cnt指出了哪一个egress_spec来处理向前转发，并且把这个端口号存在一个metadata的域里面； Ingress Control 部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec &#x3D; port; hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; hdr.ethernet.dstAddr &#x3D; dstAddr; hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; apply &#123; if (hdr.ipv4.isValid()) &#123; ipv4_lpm.apply(); &#125; else if (hdr.probe.isValid()) &#123; standard_metadata.egress_spec &#x3D; (bit&lt;9&gt;)meta.egress_spec; hdr.probe.hop_cnt &#x3D; hdr.probe.hop_cnt + 1; &#125; &#125;&#125; 比basic那个实验多了一个如果hdr.probe.isValid()（也就是这个包是探测包），就记录 egress_spec并且更新hdr.probe.hop_cnt Egress Control 部分 这部分是状态处理发生的地方，使用byte_cnt_regs寄存器在计算自最后一个探测包通过该端口以来通过每个端口的字节数； 这部分增加了一个新的probe_data ,并且填写了 bos (bottom of stack) 和 swid (switch ID)； 要做的部分是填写探测包字段的其余部分，以确保您可以正确地测量链路利用率 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G *********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; &#x2F;&#x2F; count the number of bytes seen since the last probe register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg; &#x2F;&#x2F; remember the time of the last probe register&lt;time_t&gt;(MAX_PORTS) last_time_reg; action set_swid(bit&lt;7&gt; swid) &#123; hdr.probe_data[0].swid &#x3D; swid; &#125; table swid &#123; actions &#x3D; &#123; set_swid; NoAction; &#125; default_action &#x3D; NoAction(); &#125; apply &#123; bit&lt;32&gt; byte_cnt; bit&lt;32&gt; new_byte_cnt; time_t last_time; time_t cur_time &#x3D; standard_metadata.egress_global_timestamp; &#x2F;&#x2F; increment byte cnt for this packet&#39;s port byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port); byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length; &#x2F;&#x2F; reset the byte count when a probe packet passes through new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt; byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt); if (hdr.probe.isValid()) &#123; &#x2F;&#x2F; fill out probe fields hdr.probe_data.push_front(1); hdr.probe_data[0].setValid(); if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123; hdr.probe_data[0].bos &#x3D; 1; &#125; else &#123; hdr.probe_data[0].bos &#x3D; 0; &#125; &#x2F;&#x2F; set switch ID field swid.apply(); &#x2F;&#x2F; TODO: fill out the rest of the probe packet fields &#x2F;&#x2F; hdr.probe_data[0].port &#x3D; ... &#x2F;&#x2F; hdr.probe_data[0].byte_cnt &#x3D; ... &#x2F;&#x2F; TODO: read &#x2F; update the last_time_reg &#x2F;&#x2F; last_time_reg.read(&lt;val&gt;, &lt;index&gt;); &#x2F;&#x2F; last_time_reg.write(&lt;index&gt;, &lt;val&gt;); &#x2F;&#x2F; hdr.probe_data[0].last_time &#x3D; ... &#x2F;&#x2F; hdr.probe_data[0].cur_time &#x3D; ... &#125; &#125;&#125; 解答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G *********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; &#x2F;&#x2F; count the number of bytes seen since the last probe register&lt;bit&lt;32&gt;&gt;(MAX_PORTS) byte_cnt_reg; &#x2F;&#x2F; remember the time of the last probe register&lt;time_t&gt;(MAX_PORTS) last_time_reg; action set_swid(bit&lt;7&gt; swid) &#123; hdr.probe_data[0].swid &#x3D; swid; &#125; table swid &#123; actions &#x3D; &#123; set_swid; NoAction; &#125; default_action &#x3D; NoAction(); &#125; apply &#123; bit&lt;32&gt; byte_cnt; bit&lt;32&gt; new_byte_cnt; time_t last_time; time_t cur_time &#x3D; standard_metadata.egress_global_timestamp; &#x2F;&#x2F; increment byte cnt for this packet&#39;s port byte_cnt_reg.read(byte_cnt, (bit&lt;32&gt;)standard_metadata.egress_port); byte_cnt &#x3D; byte_cnt + standard_metadata.packet_length; &#x2F;&#x2F; reset the byte count when a probe packet passes through new_byte_cnt &#x3D; (hdr.probe.isValid()) ? 0 : byte_cnt; byte_cnt_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, new_byte_cnt); if (hdr.probe.isValid()) &#123; &#x2F;&#x2F; fill out probe fields hdr.probe_data.push_front(1); hdr.probe_data[0].setValid(); if (hdr.probe.hop_cnt &#x3D;&#x3D; 1) &#123; hdr.probe_data[0].bos &#x3D; 1; &#125; else &#123; hdr.probe_data[0].bos &#x3D; 0; &#125; &#x2F;&#x2F; set switch ID field swid.apply(); hdr.probe_data[0].port &#x3D; (bit&lt;8&gt;)standard_metadata.egress_port; hdr.probe_data[0].byte_cnt &#x3D; byte_cnt; &#x2F;&#x2F; read &#x2F; update the last_time_reg last_time_reg.read(last_time, (bit&lt;32&gt;)standard_metadata.egress_port); last_time_reg.write((bit&lt;32&gt;)standard_metadata.egress_port, cur_time); hdr.probe_data[0].last_time &#x3D; last_time; hdr.probe_data[0].cur_time &#x3D; cur_time; &#125; &#125;&#125; 其余部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#x2F;************************************************************************************** C H E C K S U M C O M P U T A T I O N ****************************************************************************************&#x2F;control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; update_checksum( hdr.ipv4.isValid(), &#123; hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr &#125;, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16); &#125;&#125;&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet); packet.emit(hdr.ipv4); packet.emit(hdr.probe); packet.emit(hdr.probe_data); packet.emit(hdr.probe_fwd); &#125;&#125;&#x2F;************************************************************************************************ S W I T C H ********************************************************************************************************&#x2F;V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(),MyComputeChecksum(),MyDeparser()) main; probe_hdrs.py分析:123456789101112131415161718192021222324from scapy.all import *TYPE_PROBE &#x3D; 0x812class Probe(Packet): fields_desc &#x3D; [ ByteField(&quot;hop_cnt&quot;, 0)]class ProbeData(Packet): fields_desc &#x3D; [ BitField(&quot;bos&quot;, 0, 1), BitField(&quot;swid&quot;, 0, 7), ByteField(&quot;port&quot;, 0), IntField(&quot;byte_cnt&quot;, 0), BitField(&quot;last_time&quot;, 0, 48), BitField(&quot;cur_time&quot;, 0, 48)]class ProbeFwd(Packet): fields_desc &#x3D; [ ByteField(&quot;egress_spec&quot;, 0)]bind_layers(Ether, Probe, type&#x3D;TYPE_PROBE)bind_layers(Probe, ProbeFwd, hop_cnt&#x3D;0)bind_layers(Probe, ProbeData)bind_layers(ProbeData, ProbeData, bos&#x3D;0)bind_layers(ProbeData, ProbeFwd, bos&#x3D;1)bind_layers(ProbeFwd, ProbeFwd) 这部分是在控制平面用scapy定义了探测包的结构，从bind_layers可以看出，结构关系大概如下： 123456789101112131415Ethernet&#123; ..... Probe&#123; ProbeFwd&#123; ProbeFwd&#123; .... &#125; &#125; ProbeData&#123; ProbeData&#123; .... &#125; &#125; &#125;&#125; 这样其中ProbeFwd以及ProbeData可以嵌套；具体的结构在class里面进行了定义 send.py分析12345678910111213141516171819202122232425262728#!&#x2F;usr&#x2F;bin&#x2F;env pythonimport sysimport timefrom probe_hdrs import *def main(): probe_pkt &#x3D; Ether(dst&#x3D;&#39;ff:ff:ff:ff:ff:ff&#39;, src&#x3D;get_if_hwaddr(&#39;eth0&#39;)) &#x2F; \\ Probe(hop_cnt&#x3D;0) &#x2F; \\ ProbeFwd(egress_spec&#x3D;4) &#x2F; \\ ProbeFwd(egress_spec&#x3D;1) &#x2F; \\ ProbeFwd(egress_spec&#x3D;4) &#x2F; \\ ProbeFwd(egress_spec&#x3D;1) &#x2F; \\ ProbeFwd(egress_spec&#x3D;3) &#x2F; \\ ProbeFwd(egress_spec&#x3D;2) &#x2F; \\ ProbeFwd(egress_spec&#x3D;3) &#x2F; \\ ProbeFwd(egress_spec&#x3D;2) &#x2F; \\ ProbeFwd(egress_spec&#x3D;1)# 根据拓扑也就是s1-s1的4端口出到s4,s41端口出到s2…… while True: try: sendp(probe_pkt, iface&#x3D;&#39;eth0&#39;)# 每隔一秒发一个探测包 time.sleep(1) except KeyboardInterrupt: sys.exit()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 这部分要结合拓扑图来看: topology 这部分probe_pkt这个包其实仔细观察不难发现，它里面的ProbeFwd和拓扑图的路线完全一致，假设是s1进行了发包，那么就是从s1-s1的4端口出到s4,s4的1端口出到s2……然后完成了一个回路到了s1;下面的代码只是每隔一秒钟发一下罢了； receive.py分析1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;env pythonfrom probe_hdrs import *def expand(x): yield x while x.payload: x &#x3D; x.payload yield xdef handle_pkt(pkt): if ProbeData in pkt: data_layers &#x3D; [l for l in expand(pkt) if l.name&#x3D;&#x3D;&#39;ProbeData&#39;] print &quot;&quot; for sw in data_layers: utilization &#x3D; 0 if sw.cur_time &#x3D;&#x3D; sw.last_time else 8.0*sw.byte_cnt&#x2F;(sw.cur_time - sw.last_time) print &quot;Switch &#123;&#125; - Port &#123;&#125;: &#123;&#125; Mbps&quot;.format(sw.swid, sw.port, utilization)def main(): iface &#x3D; &#39;eth0&#39; print &quot;sniffing on &#123;&#125;&quot;.format(iface) sniff(iface &#x3D; iface, prn &#x3D; lambda x: handle_pkt(x)) #prn指定回调函数，每当一个符合filter的报文被探测到时，就会执行回调函数，通常使用lambda表达式来写回调函数if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() expand 这个就是一个走yield的递归的函数； handle_pkt这部分首先实会不停的往后整pkt得到ProbeData的部分然后存到data_layer里面，然后解析里面的内容，看utilization，计算公式就是以Bit为单位的数据除以时间； main还是里面的sniff是一个过滤器，其实是iface为”eth0”的包就扔到handle_pkt里面去处理； 实验过程 跑: 1make run 编译link_monitor.p4 在mininet里面启动如上面图片的拓扑并且将所有的交换机都设置好p4程序和相应的table entries 根据topology.json设置所有的主机 使用mininet打开h1端口，开两个 1mininet&gt; xterm h1 h1 在一个窗口里面跑send.py脚本可以开始每秒发送探测包。探测包的路线和拓扑图一样 1./send.py 在另一个窗口跑receive.py可以开始接受并且接受这些探测包 1./receive.py 报告的链路利用率和交换机端口号将始终为0，因为探测字段还没有填写。 在h1和h4之间开一个iperf流 1mininet&gt;iperf h1 h4 在所有窗口里面exit然后make stop 测量的链路利用率与iperf报告的不一致，因为探测包字段还没有填充。您的目标是填写探测包字段，以便两个测量结果一致。 控制平面的一些说明P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。 在这个练习中，我们已经为您实现了控制平面逻辑。作为启动Mininet实例的一部分，make run命令将在每个交换机的表中安装包处理规则。这些是在sX-runtime.json中定义的，其中X 对应开关号。 注意点：我们使用P4Runtime来安装控制平面规则。 sX-runtime.json文件的运行时的内容指的是表、键和动作的特定名称，如编译器生成的P4Info文件中定义的(在执行make run后查找 build/link_monitor.p4.p4info.txt文件)。P4程序中添加或重命名表、键或操作的任何更改都需要反映在这些 sX-runtime.json文件中。","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"匈牙利算法","date":"2021-04-13T07:12:02.000Z","path":"2021/04/13/匈牙利算法/","text":"匈牙利算法匈牙利算法适用于二分图匹配有关的问题 二分图（Bipartite graph）是一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相连。下图是典型的二分图。 img 可以看到，在上面的二分图中，每条边的端点都分别处于点集X和Y中。匈牙利算法主要用来解决两个问题：求二分图的最大匹配数和最小点覆盖数。 在图论中，一个“匹配”（matching）是一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。 邻接矩阵算法123456789101112131415161718192021222324int n,m;//m代表右侧集合的元素数量,n代表左侧集合的元素数量int map[MAXN][MAXN];//邻接矩阵存图int match[MAXN];//记录当前右侧元素所对一个的左侧元素bool vis[MAXN];//记录右侧元素是否被访问过bool find(int x)&#123; for(int i = 1; i &lt;= m; ++i)&#123; if(map[x][i] &amp;&amp; !vis[i]) &#123;//右边并且i没有被访问 vis[i] = true;//记录状态为访问过 if(match[i] == 0 || find(match[i]))&#123;//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配 match[i] = x;//当前左侧元素成为当前右侧元素的新匹配 return true;//返回匹配成功 &#125; &#125; &#125; return false;//循环结束，仍未找到匹配，返回匹配失败&#125;int Hungarian()&#123; for(int i = 1; i &lt;= n; ++i) &#123; memset(vis, 0 , sizeof(vis)); if(find(i)) ans ++; &#125; return ans;&#125; 邻接链表算法邻接链表数据结构1234567891011121314151617struct Edge&#123; int to,next;&#125;edge[maxn];//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键int head[maxn],tot;//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1void init()&#123; tot=0; memset(head,-1,sizeof(head));&#125;//初始化函数void addedge(int u,int v)&#123; edge[tot].to=v;//对边进行编号 edge[tot].next=head[u];//将U这个点上一次连接的点记录如果没有即为-1 head[u]=tot++;//等于边的编号，之后edge[head[u]]即可调用这个边&#125;//加边函数 理解一下邻接链表： 邻接矩阵如下，但是它不适合稀疏图 邻接矩阵 邻接链表适合稀疏图： 邻接链表 因此结合上面的代码，head数组相当于邻接链表的一个个头，head[a]可以得到a的第一个边，通过edge[head[a]]获得，然后edge[head[a]].next可以得到下一条边的编号…… 邻接链表匈牙利 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;const int maxn=200010;//边数的最大值//参考资料https://zhuanlan.zhihu.com/p/96229700；//整理的笔记:https://tyler-ytr.github.io/2021/04/13/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95///邻接链表定义struct Edge&#123; int to,next;&#125;edge[maxn];//to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键int head[maxn],tot;//tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1void init()&#123; tot=0; memset(head,-1,sizeof(head));&#125;//初始化函数void addedge(int u,int v)&#123; edge[tot].to=v;//对边进行编号 edge[tot].next=head[u];//将U这个点上一次连接的点记录如果没有即为-1 head[u]=tot++;//等于边的编号，之后edge[head[u]]即可调用这个边&#125;//加边函数//匈牙利算法int match[maxn];//记录当前右侧元素所对一个的左侧元素bool vis[maxn];//记录当前右侧元素有没有被访问过int N;//左侧元素的数量bool dfs(int u)&#123;//dfs左侧元素 for (int i=head[u];i!=-1;i=edge[i].next)&#123;//顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后 int v=edge[i].to; if(!vis[v])&#123; vis[v]=true;//记录状态为访问过 if(match[v]==-1||dfs(match[v]))&#123;//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配 match[v]=u;//当前左侧元素成为当前右侧元素的新匹配 return true;//返回匹配成功 &#125; &#125; &#125; return false;&#125;int Hungarian()&#123; int res=0; memset(match,-1,sizeof(match)); for(int i=0;i&lt;N;++i)&#123; memset(vis,false,sizeof(vis)); if(dfs(i))++res; &#125; return res;&#125; 例题问题 A: 二部图最大匹配 题目描述输入一个由X、Y两部分组成的二部图，试求图上最大匹配的规模（无需输出方案） 输入第1行输入两个数，分别代表X和Y部的顶点数 第2行~第x+1行，第i行的第一个数k表示X部第(i-1)个与Y部的k个点之间有边。接下来k个数为Y部与其有边的顶点的标号。（点的标号从1开始） 输入保证X部、Y部顶点数量均不超过10^5，总边数不超过2*10^5。 输出输出1行，行内只有一个整数，为图上最大匹配的规模 样例输入123454 42 3 21 21 31 1 样例输出13 提示： 样例解释：一个最大匹配是{(X1, Y3), (X2, Y2), (X4, Y1)} 。 一个显而易见的事实是：你不应该尝试使用邻接矩阵存储图上的边。 事实上，正确执行的算法并不需要每次遍历整个图（就像样例这样，除了X2以外的点搜索的第一条边就可以加入匹配）。我们提供的绝大部分数据是稀疏图，如果你的算法对此做了正确设计，使用C/C++实现的程序执行时间应该明显低于1秒。如果你写出了时间复杂度Theta(V^2)的实现，那……也许你会在一部分数据上超时，也许不会 代码:(耗时99) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;const int maxn&#x3D;200010;&#x2F;&#x2F;边数的最大值&#x2F;&#x2F;参考资料https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;96229700；&#x2F;&#x2F;整理的笔记:https:&#x2F;&#x2F;tyler-ytr.github.io&#x2F;2021&#x2F;04&#x2F;13&#x2F;%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&#x2F;&#x2F;&#x2F;邻接链表定义struct Edge&#123; int to,next;&#125;edge[maxn];&#x2F;&#x2F;to 是该边指向的点 next表示源点为x的下一条边，这是遍历以x为源点的关键int head[maxn],tot;&#x2F;&#x2F;tot当前的边的数量;head[x]表示以x为源点的第一条边，初始值为-1void init()&#123; tot&#x3D;0; memset(head,-1,sizeof(head));&#125;&#x2F;&#x2F;初始化函数void addedge(int u,int v)&#123; edge[tot].to&#x3D;v;&#x2F;&#x2F;对边进行编号 edge[tot].next&#x3D;head[u];&#x2F;&#x2F;将U这个点上一次连接的点记录如果没有即为-1 head[u]&#x3D;tot++;&#x2F;&#x2F;等于边的编号，之后edge[head[u]]即可调用这个边&#125;&#x2F;&#x2F;加边函数&#x2F;&#x2F;匈牙利算法int match[maxn];&#x2F;&#x2F;记录当前右侧元素所对一个的左侧元素bool vis[maxn];&#x2F;&#x2F;记录当前右侧元素有没有被访问过int N;&#x2F;&#x2F;左侧元素的数量bool dfs(int u)&#123;&#x2F;&#x2F;dfs左侧元素 for (int i&#x3D;head[u];i!&#x3D;-1;i&#x3D;edge[i].next)&#123;&#x2F;&#x2F;顺着边过去，一直遍历和这个点连接过的点和边;-1是邻接链表的最后 int v&#x3D;edge[i].to; if(!vis[v])&#123; vis[v]&#x3D;true;&#x2F;&#x2F;记录状态为访问过 if(match[v]&#x3D;&#x3D;-1||dfs(match[v]))&#123;&#x2F;&#x2F;如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配 match[v]&#x3D;u;&#x2F;&#x2F;当前左侧元素成为当前右侧元素的新匹配 return true;&#x2F;&#x2F;返回匹配成功 &#125; &#125; &#125; return false;&#125;int Hungarian()&#123; int res&#x3D;0; memset(match,-1,sizeof(match)); for(int i&#x3D;0;i&lt;N;++i)&#123; memset(vis,false,sizeof(vis)); if(dfs(i))++res; &#125; return res;&#125;int main()&#123;&#x2F;&#x2F;X为左侧，Y为右侧 int M; cin&gt;&gt;N&gt;&gt;M; &#x2F;&#x2F;printf(&quot;%d\\n&quot;,N); int tempnum; int tempy; int j&#x3D;0; init(); for(int i&#x3D;0;i&lt;N;i++)&#123; &#x2F;&#x2F;cin&gt;&gt;tempnum; scanf(&quot;%d&quot;,&amp;tempnum); &#x2F;&#x2F;printf(&quot;%d\\n&quot;,tempnum); for (j&#x3D;0;j&lt;tempnum;j++)&#123; &#x2F;&#x2F;cin&gt;&gt;tempy; scanf(&quot;%d&quot;,&amp;tempy); addedge(i,tempy); &#125; &#125; &#x2F;&#x2F;建图完毕 int result &#x3D; Hungarian(); printf(&quot;%d\\n&quot;,result); return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"C++预处理指令","date":"2021-04-13T05:14:06.000Z","path":"2021/04/13/C-预处理指令/","text":"C++翻译流程与预处理指令参考了C++语言构造手册,cppreference 翻译阶段复制自cppreference 翻译阶段编译器处理 C++ 源文件时，如同严格按照以下顺序进行各个阶段的处理： 阶段 11) （以实现定义方式）将源文件的各个单独字节，映射为基本源字符集的字符。特别是，操作系统相关的行尾指示符均被替换为换行字符。基本源字符集由以下 96 个字符组成： a) 5 个空白字符（空格 (space)、水平制表 (horizontal tab)、垂直制表 (vertical tab)、换页 (form feed)和 换行 (new-line)） b) 10 个数字字符，从 ‘0’ 到 ‘9’ c) 52 个字母，从 ‘a’ 到 ‘z’ 以及从 ‘A’ 到 ‘Z’ d) 29 个标点字符：_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \\ “ ‘ 2) 任何无法被映射到基本源字符集中的字符的源文件字符，均被替换为其通用字符名（用 \\u 或 \\U 转义），或某种被等价处理的由实现定义的形式。 3) 将各个三标符序列替换为其对应的单字符表示。 (C++17 前) 阶段 21) 当反斜杠出现于行尾（其后紧跟换行符）时，删除该反斜杠和换行符并将两个物理源码行组合成一个逻辑源码行。这是单趟操作：如果有一行以两个反斜杠结束且后随一个空行，这三行不会合为一行。若于此阶段组成了通用字符名（\\uXXXX），则行为未定义。 2) 若此步骤后，非空源文件不以换行符结束（无论是原本就无换行，还是以反斜杠结束），则其行为未定义 (C++11 前)在最后添加一个换行符 (C++11 起)。 阶段 31) 将源文件分解为注释，空白字符（空格、水平制表、换行、垂直制表和换页）的序列，和下列各种预处理记号： a) 头文件名，如 或 “myfile.h” b) 标识符 c) 预处理数字 d) ，包含用户定义的 (C++11 起)字符与字符串字面量 e) 运算符与标点（包括代用记号），如 +、&lt;&lt;=、&lt;%、## 或 and f) 不属于任何其他类别的单独非空白字符 2) 恢复在任何原始字符串字面量的首尾双引号之间在阶段 1 和 2 期间进行的所有变换。 (C++11 起) 3) 以一个空格字符替换每段注释。 保留换行符。未指明是否可将非换行空白字符序列缩减成单个空格字符。 若一个给定字符前的输入已被解析为预处理记号，下一个预处理记号通常会由能构成预处理记号的最长字符序列够成，即使这样处理会导致后续分析失败。这常被称为最大吞噬。 12345int foo &#x3D; 1;int bar &#x3D; 0xE+foo; &#x2F;&#x2F; 错误：非法的预处理数字 0xE+fooint baz &#x3D; 0xE + foo; &#x2F;&#x2F; OK int quux &#x3D; bar+++++baz; &#x2F;&#x2F; 错误：bar++ ++ +baz，而非 bar++ + ++baz。 最大吞噬规则仅有的例外是： 若以下一个字符开头的字符序列可作为原始字符串字面量的前缀和起始双引号，则下个预处理记号应当为原始字符串字面量。该字面量由匹配原始字符串模式的最短字符序列组成。#define R &quot;x&quot; const char* s = R&quot;y&quot;; // 非良构的原始字符串字面量，而非 &quot;x&quot; &quot;y&quot; const char* s2 = R&quot;(a)&quot; &quot;b)&quot;; // 原始字符串字面量后随普通字符串字面量若接下来三个字符是 **&lt;::**且后继字符不是 **:** 或者 **&gt;**，则把 **&lt;** 自身当做预处理记号（而非代用记号 &lt;: 的首字符）。struct Foo { static const int v = 1; }; std::vector&lt;::Foo&gt; x; // OK，&lt;: 未被当作 [ 的代用记号 extern int y&lt;::&gt;; // OK，同 extern int y[]。 int z&lt;:::Foo::value:&gt;; // OK，int z[::Foo::value]; (C++11 起) 头文件名预处理记号仅在 #include 指令中形成。 1std::vector&lt;int&gt; x; &#x2F;&#x2F; OK，&lt;int&gt; 不是头文件名 阶段 41) 执行预处理器。 2) #include 指令所引入的每个文件都经历阶段 1 到 4 的处理，递归执行。 3) 此阶段结束时，所有预处理器指令都应从源（代码）移除。 阶段 51) 将字符字面量及字符串字面量中的所有字符从源字符集转换到执行字符集（可以是 UTF-8 这样的多字节字符集，只要阶段 1 中所列的基本源字符集的 96 个字符都拥有单字节表示即可）。 2) 将字符字面量和非原始字符串字面量中的转义序列和通用字符名展开，并转换到执行字符集。 若某个通用字符名所指定的字符不是执行字符集的成员，则结果是由实现定义的，但保证不是空（宽）字符。 注意：某些实现能以命令行选项控制此阶段所进行的转换：gcc 和 clang 用 -finput-charset 指定源字符集的编码，用 -fexec-charset 和 -fwide-exec-charset 指定无编码前缀的 (C++11 起)字符串和字符字面量中的执行字符集的编码，而 Visual Studio 2015 Update 2 及之后版本分别用 /source-charset 和 /execution-charset 指定源字符集和执行字符集。 阶段 6拼接相邻的字符串字面量。 阶段 7进行编译：将各个预处理记号转换成记号。将所有记号当作一个翻译单元进行语法和语义分析并进行翻译。 阶段 8检验每个翻译单元，产生所要求的模板实例化的列表，其中包括显式实例化所要求的实例化。定位模板定义，并进行所要求的实例化，以产生实例化单元。 阶段 9将翻译单元、实例化单元和为满足外部引用所需的库组件汇集成一个程序映像，它含有在其执行环境中执行所需的信息。 注意某些编译器不实现实例化单元（又称为模板仓库或模板注册表），而是简单地在阶段 7 编译每个模板实例化，存储代码于其所显式或隐式要求的对象文件中，然后由连接器于阶段 9 将这些编译后的实例化缩减到一个。 引用 C++11 standard (ISO/IEC 14882:2011): C++98 standard (ISO/IEC 14882:1998): 预编译指令基本的预编译指令 $#$ 空指令 $#define$ 定义宏 $#include$ 包含一个源代码文件 $#undef$取消已经定义的宏 $#if$如果给定条件为真，则编译下面的代码 $#ifdef$如果宏已经定义就编译下面的代码 $#ifndef$如果宏没有定义，就编译下面的代码 $#elif$如果前面的$#if$给定条件不为真，当前条件为真，就编译下面的代码 $#endif$结束一个$#if….#else$条件编译块 $#error$停止编译并且显示错误信息 $# define$ 的一些使用预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。记住仅仅是进行标识符的替换。 例子如下： 用#define实现求最大值和最小值的宏 123456789101112131415161718#include &lt;stdio.h&gt;#define MAX(x,y) (((x)&gt;(y))?(x):(y))#define MIN(x,y) (((x)&lt;(y))?(x):(y))int main(void)&#123;#ifdef MAX //判断这个宏是否被定义 printf(\"3 and 5 the max is:%d\\n\",MAX(3,5));#endif#ifdef MIN printf(\"3 and 5 the min is:%d\\n\",MIN(3,5));#endif return 0;&#125;/* * (1)三元运算符要比if,else效率高 * （2）宏的使用一定要细心，需要把参数小心的用括号括起来， * 因为宏只是简单的文本替换，不注意，容易引起歧义错误。*/ 宏定义错误使用 12345678910111213141516#include &lt;stdio.h&gt;#define SQR(x) (x*x)int main(void)&#123; int b=3;#ifdef SQR//只需要宏名就可以了，不需要参数，有参数的话会警告 printf(\"a = %d\\n\",SQR(b+2));#endif return 0;&#125;/* *首先说明，这个宏的定义是错误的。并没有实现程序中的B+2的平方 * 预处理的时候，替换成如下的结果：b+2*b+2 * 正确的宏定义应该是：#define SQR(x) ((x)*(x)) * 所以，尽量使用小括号，将参数括起来。*/ 宏参数的连接 1234567891011121314151617#include &lt;stdio.h&gt;#define STR(s) #s#define CONS(a,b) (int)(a##e##b)int main(void)&#123;#ifdef STR printf(STR(VCK));#endif#ifdef CONS printf(\"\\n%d\\n\",CONS(2,3));#endif return 0;&#125;/* （绝大多数是使用不到这些的，使用到的话，查看手册就可以了） * 第一个宏，用#把参数转化为一个字符串 * 第二个宏，用##把2个宏参数粘合在一起，及aeb,2e3也就是2000*/ 用宏得到一个字的高位或低位的字节 1234567891011#include &lt;stdio.h&gt;#define WORD_LO(xxx) ((byte)((word)(xxx) &amp; 255))#define WORD_HI(xxx) ((byte)((word)(xxx) &gt;&gt; 8))int main(void)&#123; return 0;&#125;/* * 一个字2个字节，获得低字节（低8位），与255（0000,0000,1111,1111）按位相与 * 获得高字节（高8位），右移8位即可。*/ 用宏定义得到一个数组所含元素的个数 12345678910111213#include &lt;stdio.h&gt;#define ARR_SIZE(a) (sizeof((a))/sizeof((a[0])))int main(void)&#123; int array[100];#ifdef ARR_SIZE printf(\"array has %d items.\\n\",ARR_SIZE(array));#endif return 0;&#125;/* *总的大小除以每个类型的大小 */ $#ifdef$,$#ifndef$,$#endif$…的使用以上这些预编译指令，都是条件编译指令，也就是说，将决定那些代码被编译，而哪些不被编译 实例: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define DEBUGint main(void)&#123; int i &#x3D; 0; char c; while(1) &#123; i++; c &#x3D; getchar(); if(&#39;\\n&#39; !&#x3D; c) &#123; getchar(); &#125; if(&#39;q&#39; &#x3D;&#x3D; c || &#39;Q&#39; &#x3D;&#x3D; c) &#123;#ifdef DEBUG&#x2F;&#x2F;判断DEBUG是否被定义了 printf(&quot;We get:%c,about to exit.\\n&quot;,c);#endif break; &#125; else &#123; printf(&quot;i &#x3D; %d&quot;,i);#ifdef DEBUG printf(&quot;,we get:%c&quot;,c);#endif printf(&quot;\\n&quot;); &#125; &#125; printf(&quot;Hello World!\\n&quot;); return 0;&#125;&#x2F;*#endif用于终止#if预处理指令。*&#x2F; 其他指令1234#error指令将使编译器显示一条错误信息，然后停止编译。#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"}]},{"title":"机器学习导论-3","date":"2021-03-22T03:14:15.000Z","path":"2021/03/22/机器学习导论-3/","text":"线性模型 南瓜书本章连接 基本形式 线性模型一般形式$f(x)=w_1x_1+w_2x_2+\\cdots+w_dx_d+b$ 向量形式$f(x)=w^{T}x+b$ 线性回归 单一属性 基本目标:$f(x)=wx_{i}+b$使得$f(x_{i})\\simeq y_{i}$ 目的是把离散的(比如身高的高中低)转换成连续的量(比如高1.0中0.5),这种情况主要考虑”序”，比如青绿，黑色，蓝色可能没有序，这个时候不妨把它变成[0,1,0]这种向量编码(几个维度整几维); 回归:均方误差最小化 $(w^{},b^{})=arg\\ min_{(w,b)}\\sum_{i=1}^{m}(f(x_{i})-y_i)^2$ 可以使用最小二乘参数估计（求偏导让导数为零，例子要求w,b），计算暂略 偏导(w)整的主要是关于(w)的变化率，等于零的时候意味着到了极大/极小值; 多元属性 基本目标:$f(x_i)=w^Tx_i+b$使得$f(x_{i})\\simeq y_{i}$ 回归: $\\hat{w}^*=\\arg \\min_{\\hat{w}}(y-X\\hat{w})^T(y-X\\hat{w})$ 如果满秩:$\\hat{w}^*=(X^{T}X)^{-1}X^Ty$；$f(\\hat{x_{i}})=\\hat{x_{i}}^{T}(X^{T}X)^{-1}$ 如果不满秩,求助于归纳偏好或者引入正则化(regularization)(也就是加入限制) 求解非线性的模型——广义线性模型: 比如$\\ln y=w^Tx+b$,就可以用$e^{w^Tx+b}$来进行毕竟，称作对数线性回归; $g(\\cdot)$为联系函数(link function)，比如$g(\\cdot)=\\ln(\\cdot)$ 二分类任务 线性回归的实际输出:$z=w^{T}x+b$ 期望输出 $y\\in{0,1}$ 这个二分类任务就是为了找到一个z,y的联系函数 理想模型：单位阶跃函数 缺陷:数学性质很糟糕，不连续 替代函数——对数几率函数（logistic function）属于sigmoid函数的一种: logistic 和逻辑没有关系,logistic源于logit 不是logic; $y=\\frac{1}{1+e^{-z}}$ 可以表示成$y=\\frac{1}{1+e^{-z}}=\\frac{1}{1+e^{-(w^{T}x+b)}}$ 两边取对数: $\\ln\\frac{y}{1-y}=w^{T}x+b=\\ln\\frac{p(y=1|x)}{p(y=0|x)}$ $\\frac{y}{1-y}$称作几率(odds)，反映了x作为正例相对于负例的相对可能性;对数几率(log odds，亦称logit) 不需要假设数据分布,可以得到“类别”的近似概率预测，并且可以直接应用现有的数值优化算法求最优解，这是分类学习算法 使用极大似然法(maximum likelihood method)求解,给定数据集${(x_{i}, y_{i})}^{m}{i=1}$,对率回归模型最大化“对数似然”:$$l(w,b)=\\sum{i=1}^{m}\\ln p (y_i|x_i;w,b)$$ 似然:正例的可能性*正例+负例的可能性*负例","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"机器学习导论-2 模型评估与选择","date":"2021-03-22T02:18:18.000Z","path":"2021/03/22/机器学习导论-2/","text":"机器学习导论-2 模型评估与选择 南瓜书本章推理 空间 假设空间 假设满足XX条件的是好瓜 版本空间 有限训练集，已知XX是好瓜 归纳偏好 假设空间和训练集一致的假设 学习过程中对某种类型假设的偏好称为归纳偏好 No Free Lunch 奥卡姆剃刀：两个模型效果同样好，选择较为简单的 模型评估与选择 经验误差与过拟合 错误率率&amp;误差 错误率：错份样本的占$E=a/m$ 误差：样本真实输出与预测输出之间的差异 训练（经验）误差：训练集上 测试误差：测试集 泛化误差：初训练集外所有样本 过拟合 学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降 优化目标加正则项 Early stop 欠拟合 对训练样本的一般性质尚未学好 决策树：扩展分支 神经网络：增加训练层数 评估方法 留出法 直接将数据集划分为两个互斥集合 训练/测试集划分要尽可能保持数据分布的一致性 一般若干次随机划分，重复实验取平均值 训练/测试样本比例通常为2:1～4:1 交叉验证法 将数据集分层采样划分为$k$个大小相似的互斥子集 自助法 以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\\prime}$，$D\\backslash D^{\\prime}$用作测试集 性能度量 性能度量是衡量模型泛化能力的评价标准，反映任务的需求 回归任务最常用的是“均方误差”： $E(f:D)=\\frac{1}{m}\\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$ 查准率 $P=\\frac{TP}{TP+FP}$ 查全率 $R=\\frac{TP}{TP+FN}$ $P-R$曲线：根据学习器的预测结果对样例排序，“最可能”的正例的在前面，排在最后的是“最不可能”是正例的样本，按此顺序把样本作为整理进行预测，每一次计算出当前的P,R然后以P为纵轴，R为横轴作图 如何利用多次训练得到了多个混淆矩阵？ macro-F1:$$macro-P=\\frac{1}{n}\\sum^{n}_{i=1}P_i\\macro-R=\\frac{1}{n}\\sum^{n}_{i=1}R_i\\macro-F_1=\\frac{2\\times macro-P\\times macro-R}{macro-P+macro-R}$$也就是平均P,R之后再算 micro-F1:$$micro-P=\\frac{\\overline{TP}}{\\overline{TP}+\\overline{FP}}\\micro-R=\\frac{\\overline{TP}}{\\overline{TP}+\\overline{FN}}\\micro-F1=\\frac{2\\times micro-P\\times micro-R}{micro-P+micro-R}$$ $F1$ measure：$\\frac{2\\times TP}{N+TP-TN}$ AUC预测了排序质量,越高越好；$$AUC=\\frac{1}{2}\\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\\cdot(y_{i}+y_{i+1})$$AUC与排序的密切关系:考虑每一个正反例，若正例的预测值小于反例，那么就计算一个“罚分”：$$\\mathcal{l}{tank}=\\frac{1}{m^+m^-}\\sum{x^+\\in D^+}\\sum_{x^-\\in D^-}(\\mathbb{I}(f(x^+)&lt;f(x^-))+\\frac{1}{2}\\mathbb{I}(f(x^+)=f(x^-)))$$ $$AUC=1-\\mathcal{l}_{tank}$$ 代价敏感错误率: 损失是不一样大的一些任务里面，比如漏掉一个病人，放进去一个小偷等等，要考虑“非均等代价” 建立一个二分类代价矩阵里面有预测类别的cost,然后就就可以得到加权的代价敏感的错误率 这部分的重点是用户到底想要什么？标准型是什么？优化目标是什么？ 性能评估 关于性能比较:某种度量取得评估结果之后能不能直接评价优劣？ 测试性能并不等于泛化性能 测试性能随着测试集的变化而变化 很多机器学习算法本身有一定的随机性 直接选取相应评估方式在相应条件下评估并不可靠 二项检验 泛化错误率为$\\epsilon$，测试错误率为$\\hat{\\epsilon}$，嘉定测试样本从样本总体分布中独立采样而来，我们可以使用“二项检验”，对于$\\epsilon&lt;epsilon_{0}$进行假设检验。 假设$\\epsilon\\leq\\epsilon_{0}$，若测试错误率小于 $t$检验 统计学的原来的方法：t检验中训练的数据可能不是那么独立，也许是一个“过高”的估计 交叉验证$t$检验 5*2交叉验证的含义： 两折：把数据分成两部分，一部分训练一部分测验； 五次：把数据洗五次，每次做两折； 目的：减小某一个数据集的误导 McNemar检验: 关注正确-正确，错误-错误 多学习器比较: 使用Friedman+Nemenyi 算法的好坏不具有传递性：算法A比算法B好；算法B比算法C好；不等于A比C好 偏差和方差 对于测试样本$x$，令$y_{D}$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学的模型$f$在$x$上的预测输出。 以回归任务为例： 期望预期为：$\\bar{f}(x)=\\mathbb{E}_{D}[f(x;D)]$； 使用样本数目相同的不同训练集产生的方差为$var(x)=\\mathbb{E}_{D}[(f(x:D)-\\bar{f}(x))^{2}]$；(每次做的浮动范围) 噪声为$\\varepsilon^{2}=\\mathbb{E}{D}[(y{D}-y)^{2}]$: 本真误差 偏差$bias^2(x)=(\\overline{f}(x)-y)^2$ 期望输出和真实输出的差别 比较清晰的图示(周老师真nb): $E(f;D)=bias^{2}(x)+var(x)+\\varepsilon^2$ 一开始偏差(bias)起到主要的作用，后来是数据造成的扰动(方差)起到主要的作用，然后overfitting一般情况下是在后者气主要作用的时候产生的，因为其实学习的是数据本身的特征","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"机器学习导论-1 绪论与数学参考","date":"2021-03-08T02:18:18.000Z","path":"2021/03/08/机器学习导论-1/","text":"机器学习导论-1 绪论与数学参考 二刷机器学习导论 参考书: 统计机器学习 PRML(贝叶斯) ESL(统计学派) MLAPP UML 绪论 学习过程 训练数据，经过 学习算法训练，得到 模型(决策树，射精网络，支持向量机，Boosting，贝叶斯网……)，可以判断 新数据样本，得到结论 机器学习的局限性，失效条件: 特征信息不充分 样本信息不充分 机器学习的理论基础(计算学习理论),概率近似正确(PAC): $P(|f(x)-y|\\le \\epsilon)\\ge 1-\\delta$ f(x)是预测值,y是真实值,目的是尽可能贴近真实值也就是$|f(x)-y|\\le \\epsilon$,然后这件事情有一个概率的保证，一定大于$1-\\delta$的概率确保这件事情的完成。一句话总结就是很高的概率得到很好的结果的模型。 如果你能确定百分百正确，就不用整机器学习了 数学参考范数 在实数域中，数的大小和两个数之间的距离是通过绝对值来度量的。将数推广到向量就引入了范数。范数（Norm）是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。 在算例子的时候我觉得其实是不同维度到0点的距离 向量的范数 范数标准定义: 正定性:$||x||\\ge 0$,且$||x||= 0$当且仅当$x=0$; 齐次性:对任意实数 $\\alpha$ ，都有$||\\alpha x||=|\\alpha|\\ ||x||$ 三角不等式: 对任意$x,y\\in R^n$,都有$||x+y|| \\le ||x|| + ||y||$ 则称$||x||$为$R^n$上的向量范数 范数表达式:$$\\begin{align}\\left| \\left| x \\right| \\right|{p}\\; :=\\; \\left( \\sum{i=1}^{n}{\\left| x_{i} \\right|^{p} } \\right)^{\\frac{1}{p} }\\tag{1}\\end{align}$$ L1范数:$$||x||_1 = |x_1| + |x_2| + \\dots + |x_n| = \\sum_i^n |x_i|$$向量元素绝对值之和 L2范数:$$||x||_2 = (|x_1|^2 + |x_2|^2+\\dots+ |x_n|^2)^{\\frac{1}{2} } =\\sqrt{ \\sum_i^n x_i^2}$$Euclid范数(欧几里得范数，常用计算向量长度) Lp范数:$$||x||_p = (|x_1|^p + |x_2|^p+\\dots+ |x_n|^p)^{\\frac{1}{p} } =\\sqrt[p]{ \\sum_i^n x_i^p}$$ Lp的形状随p的变化的图 L$\\infty $范数:$$||x||{\\infty} = \\max\\limits{1\\le i\\le n} |x_i|$$ 所有向量元素绝对值中的最大值 L$-\\infty$范数: $$ ||x||{\\infty} = \\min\\limits{1\\le i\\le n} |x_i| $$ 所有向量元素绝对值中的最小值 L0范数: $$ ||x||_0 = \\sum_i^n I(x_i \\ne 0) $$ 也就是非零元素的数量 例子:$x=(1,4,3,0)^T$的常用范数: $||x||_0=3$ $||x||_1=|1|+|4|+|3|+|0|=8$ $||x||_2=\\sqrt{|1|^2+|4|^2+|3|^2+|0|^2}=\\sqrt{26}$ $||x||_{\\infty}=|4|=4$ 矩阵的范数 推广到矩阵，矩阵相容范数的定义: 正定性:$||A||\\ge 0$,且$||A||= 0$当且仅当$A=0$; 齐次性:对任意实数 $\\alpha$ ，都有$||\\alpha A||=|\\alpha|\\ ||A||$ 三角不等式: 对任意$A,B\\in R^{n\\times n}$,都有$||A+B|| \\le ||A|| + ||B||$ 相容性:对任意$A,B\\in R^{n\\times n}$,都有$||AB|| \\le ||A||\\ ||B||$ 则称$||A||$为$R^{n\\times n}$上的一个矩阵范数 列范数:$$||A||1 = \\max\\limits{1\\le j\\le n} \\sum_i^n |a_{ij}|$$$A$的每一列的绝对值的最大值，称作$A$的列范数 行范数:$$||A||{\\infty} = \\max\\limits{1\\le i\\le n} \\sum_j^n |a_{ij}|$$$A$的每一行的绝对值的最大值，称作$A$的行范数 L2范数:$$||A||2 = \\sqrt{\\lambda{max} (A^T A)}$$其中$\\lambda_{max}$表示$A^TA$的特征值的绝对值的最大值 F-范数(Frobenius):$$||A||_F = (\\sum_i^n \\sum_j^n a_{ij}^2)^{\\frac{1}{2} }=(tr(A^TA))^{1/2}$$它相当于矩阵$A$各项元素的绝对值平方的总和,也就是矩阵张成向量之后的L2范数 求导 一阶导数：雅可比矩阵 假设函数$F:{R_n} \\to {R_m}$是一个从欧式n维空间转换到欧式m维空间的函数.这个函数由m个实函数组成:$y1(x1,…,xn), …, ym(x1,…,xn)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵, 这就是所谓的雅可比矩阵：$$\\begin{bmatrix} \\frac{\\partial y_1}{\\partial x_1} &amp; \\cdots &amp; \\frac{\\partial y_1}{\\partial x_n} \\ \\vdots &amp; \\ddots &amp; \\vdots \\ \\frac{\\partial y_m}{\\partial x_1} &amp; \\cdots &amp; \\frac{\\partial y_m}{\\partial x_n} \\end{bmatrix}$$ 此矩阵表示为: ${J_F}({x_1}, \\ldots ,{x_n})$,或者$\\frac{ {\\partial {({y_1}, … ,{y_m})} } } { {\\partial {({x_1}, … ,{x_n})} } }$. hexo 两个{之间要加空格不然会报错: expected variable end 如果$p$是$R_n$中的一点，$F$在$p$点可微分，那么这一点的导数由$J_F(p)$给出.在此情况下, 由$F(p)$描述的线性算子即接近点$p$的$F$的最优线性逼近, $x$逼近于$p$: $$ F({\\bf{x} }) \\approx F({\\bf{p} }) + {J_F}({\\bf{p} }) \\cdot ({\\bf{x} } – {\\bf{p} }) $$ 二阶导数：海森矩阵 海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下：$$f({x_1},{x_2} \\ldots ,{x_n})$$如果$f$所有的二阶导都存在，那么有：$$H{(f)_{ij} }(x) = {D_i}{D_j}f(x)$$也就是:$$\\begin{bmatrix}\\frac{\\partial^2 f}{\\partial x_1^2} &amp; \\frac{\\partial^2 f}{\\partial x_1\\,\\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_1\\,\\partial x_n} \\ \\\\frac{\\partial^2 f}{\\partial x_2\\,\\partial x_1} &amp; \\frac{\\partial^2 f}{\\partial x_2^2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_2\\,\\partial x_n} \\ \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ \\\\frac{\\partial^2 f}{\\partial x_n\\,\\partial x_1} &amp; \\frac{\\partial^2 f}{\\partial x_n\\,\\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_n^2}\\end{bmatrix}$$ 链式法则的式子里面有转置的原因可以从维度的角度来思考; 奇异值 共轭:$z=a+bi$,z的共轭$\\bar{z}=a-bi$;实数的共轭是他自身; 矩阵概念: 对称矩阵: $A^T=A$ Hermite矩阵，将实数范围讨论的对称矩阵延伸到复数范围: 其中，用$\\bar{A}$表示以$A$的元素的共轭复数为元素构成的矩阵,那么$A^H=(\\bar{A}^T)$，这个称作$A$的复共轭转置矩阵; 特征值都是实数。 任意两个不同特征值所对应的特征向量正交。 正交矩阵: $A^TA=E$ 酉矩阵: $A^HA=E$ 这玩意其实就是正交矩阵在复数范围的推广 奇异矩阵: $|A|=0$称作奇异矩阵，否则称作非奇异矩阵;$A$是可逆矩阵的充要条件是$|A|\\neq0$,因此可逆矩阵就是非奇异矩阵 正规矩阵: $A^HA=AA^H$,如果都是实数矩阵，那么$A^T=A^H,A^TA=AA^T$ 幂等矩阵: $A^2=A$ 正定矩阵:它是对称矩阵/Hermite矩阵的进一步延伸 设$A$为n阶Hermite矩阵，如果对任意n维复向量$x$都有$x^HAx\\ge 0$,则称A是半正定矩阵;如果对任意n维复向量$x$都有$x^HAx&gt; 0$,则称A是正定矩阵。 Hermite矩阵$A$为正定（半正定）矩阵 $\\leftrightarrow$$A$的所有特征值是正数（非负数）。 Hermite矩阵$A$为正定矩阵 $\\leftrightarrow$存在n阶非奇异矩阵$P$，使得$A=P^HP$ Hermite矩阵$A$为半正定矩阵$\\leftrightarrow $存在n阶矩阵$P$，使得$A=P^HP$ 特征值与特征分解: 特征值特征向量定义：$\\lambda$是特征值,$x$是特征向量,A是方阵$$Ax=\\lambda x$$求解走: $Ax=\\lambda x\\rightarrow Ax=\\lambda E x\\rightarrow (\\lambda E-A)x=0\\rightarrow|\\lambda E-A|=0$解出特征值带入得到特征向量 特征分解:对于mxm的满秩对称矩阵A$$A=Q\\Sigma Q^{-1}=Q\\Sigma Q^T$$其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。 特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。 奇异值与奇异值分解 运用到的理论: 对于n阶方阵，$Ax=\\lambda x$; 如果$\\vec{a}$与$\\vec{b}$正交,那么有$\\vec{a} \\cdot \\vec{b} = 0$ 一个内积空间的正交基（orthogonal basis）是元素两两正交的基,基中的元素称为基向量。如果一个正交基的基向量的模长都是单位长度1，则称这正交基为标准正交基或”规范正交基”（Orthonormal basis）； A与A的转置矩阵是有相同的特征值,但是他们各自的特征向量没有关系； SVD推导之矩阵分解: 对于矩阵$A$,有$A^TA = \\lambda_{i} v_{i}$(因为$A^TA$肯定是方阵);$\\lambda_i$是特征值,$v_i$是特征向量;假设$(v_{i}, v_{j})$是一组正交基，那么有$v_{i}^{T} \\cdot v_{j} = 0$，那么:$$\\begin{align} (Av_{i}, Av_{j}) &amp;= (Av_{i})^{T} \\cdot Av_{j} \\ &amp;= v_{i}^{T} A^T Av_{j} \\ &amp;= v_{i}^{T} \\lambda_{j} v_{j} \\ &amp;= \\lambda_{j} \\color{red}{v_{i}^{T} v_{j} } \\ &amp;= 0 \\end{align} \\tag{1}$$可以得到$Av_{i}, Av_{j}$;根据公式$(1)$可以推导得到$(Av_{i}, Av_{i}) = \\lambda_{i} v_{i}^{T} v_{i}=\\lambda_{i}$;又因为行列式的性质$|AB|=|A||B|\\rightarrow|(Av_{i})^{T} \\cdot Av_{i}|=|Av_{i}^{T} ||Av_{i}|=|Av_{i}|^2$,所以有:$$\\begin{align} &amp; |Av_{i}|^2 = \\lambda_{i} \\ &amp; |Av_{i}| = \\sqrt{\\lambda_{i} } \\end{align} \\tag{2}$$根据公式(2),有$\\frac{Av_{i} }{|Av_{i}|} = \\frac{1}{\\sqrt{\\lambda_{i} } } Av_{i}$，令$\\frac{1}{\\sqrt{\\lambda_{i} } } Av_{i}= u_{i}$,可以得到:$$Av_{i}= \\sqrt{\\lambda_{i} }u_{i}=\\delta_{i}u_{i} \\tag{3}$$其中$\\delta_{i} = \\sqrt{\\lambda_{i} }$（这个称作奇异值）,进一步推导成矩阵形式:$$\\begin{align} AV &amp;= A(v_{1}, v_{2}, \\dots, v_{n} ) \\ &amp;= (Av_{1}, Av_{2}, \\dots, Av_{n} ) \\ &amp;= (\\delta_{1}u_{1}, \\delta_{2}u_{2}, \\dots, \\delta_{n}u_{n} ) \\ &amp;= U\\Sigma \\end{align} \\tag{4}$$从而得到:$$A = U\\Sigma V^T \\tag{5}$$ SVD推导之矩阵计算: 已知$A$怎么算$U$和$V$呢？ 首先计算$A$的转置$A^T$,而$A^T$相当于:$$\\begin{align} A^T = V\\Sigma^TU^T \\end{align} \\tag{6}$$然后计算$A^TA$:$$\\begin{align} A^TA &amp;= V\\Sigma^TU^T U\\Sigma V^T \\ &amp;= V\\Sigma^2V^T \\end{align} \\tag{7}$$通过公式(7),会发现这不就是特征值分解嘛！！！可以得到$A^TA v_{i} = \\lambda_{i}v_{i}$,只需要求出$A^TA$的特征向量就可以得到$V$了 同理计算$AA^T:$$$\\begin{align} A A^T &amp;= U\\Sigma V^T V\\Sigma^TU^T \\ &amp;= U\\Sigma^2U^T \\end{align} \\tag{8}$$ 通过公式(8),可以得到$AA^T u_{i} = \\lambda_{i}u_{i}$,只需要求出$AA^T$的特征向量就可以得到$U$了 $\\Sigma$是上面公式(7)或者公式(8)中求到的非零特征值从大到小排列后开根号的值 SVD计算例子: 假设有一个矩阵$A$:$$A=\\begin{bmatrix} 1&amp;1\\1&amp;1\\0&amp;0\\end{bmatrix}$$要计算:$$A_{3\\times 2}=U_{3\\times 3}\\Sigma_{3\\times2}V^T_{2\\times 2}$$中的$U,V,\\Sigma$ 计算$U$ $AA^T=\\begin{bmatrix} 2&amp;2&amp;0\\2&amp;2&amp;0\\0&amp;0&amp;0\\end{bmatrix}$,进行特征分解，得到特征值[4,0,0]以及对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T,[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T,[0,0,1]^T$,可以得到：$$U=\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}}&amp;0 \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}&amp;0 \\ 0&amp;0&amp;1 \\end{bmatrix}$$ 计算$V$ $A^TA=\\begin{bmatrix} 2&amp;2 \\ 2&amp;2 \\end{bmatrix}$,进行特征分解,得到特征值[4,0]以及对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T,[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T$,可以得到:$$ V=\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}} \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}\\end{bmatrix}$$ 计算$\\Sigma$ 因为特征值是[4,0]，因此:$$ \\Sigma=\\begin{bmatrix} 2&amp;0 \\ 0&amp;0 \\ 0&amp;0 \\end{bmatrix}$$ 所以$A$的SVD分解是:$$ A=U \\Sigma V^T= \\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}}&amp;0 \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}&amp;0 \\ 0&amp;0&amp;1 \\end{bmatrix} \\begin{bmatrix} 2&amp;0 \\ 0&amp;0 \\ 0&amp;0 \\end{bmatrix} {\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}} \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}\\end{bmatrix}}^T=\\begin{bmatrix} 1&amp;1\\1&amp;1\\0&amp;0\\end{bmatrix}$$ 代码求解方法: 123import numpy as npA=np.array([1,1],[1,1],[0,0])print(np.linalg.svd(A)) 以下主要是优化的部分 拉格朗日乘子法 To be done 参考博客 向量范数与矩阵范数 雅可比矩阵和海森矩阵 链式法则 Hermite矩阵性质 矩阵特征值求解 矩阵的基本知识 矩阵的奇异值推导","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"p4学习-5:完善MRI","date":"2021-03-06T08:44:38.000Z","path":"2021/03/06/p4学习-5/","text":"p4学习-5:完善MRI实验目标这次实验的目的是在基本的L3转发上面拓展一个带内遥测(INT)的阉割版本，这里称作多跳路由检查(Multi-Hop Route Inspection)(MRI)。 根据维基百科，多跳路由(Multi-hop routing)是无线电网络中的一种通信，其中网络覆盖区域大域单个节点的无线电范围，因此要到达某一个目的地的时候一个节点可以使用其他节点做中继。 MRI允许使用者追踪每一个包经过的路线以及序列的长度，为了支持这个功能需要写一个P4程序，这个程序能够在每一个包的header stack上面附加一个ID以及队列的长度。在收包的目的地，交换机ID的顺序相当于这个包走的路径，每一个ID后面都跟着这个交换机的队列长度。 控制平面已经事先设置好了 代码实现mri里面包括了两个自定义的头:mri_t包含了count，用来指示交换机ID的数量;switch_t包含了数据包经过的每个交换机跳的交换机ID和队列深度字段； 主要挑战是处理用于解析两个headers的递归逻辑；这里使用parser_metada字段的remaining来追踪有多少switch_t头需要来解析;在parse_mri状态,这个字段设置为hdr.mri.count。在parse_swtrace状态将转换到其自身，直到剩余为0。 MRI自定义报头会携带在IP Options 头里面,其中IP Options头里面的option用于指示选项的类型。 我们将使用特殊的类型31来表示MRI标头的存在。 除了解析器逻辑外，您还将在sgress中添加一个表，在swtrace中存储交换机ID和队列深度，并执行增加count字段的操作，并附加一个switch_t标头。 一个完整的mri.p4包含如下组件: 以太网（ethernet_t），IPv4（ipv4_t），IP选项（ipv4_option_t），MRI（mri_t）和交换机（switch_t）的header头部类型定义。 以太网，IPv4，IP选项，MRI和交换机的解析器Parsers，将填充ethernet_t，ipv4_t，ipv4_option_t，mri_t和switch_t。 使用mark_to_drop()丢弃数据包的动作action。 一个action动作（称为ipv4_forward），它将： 设置下一跳的出口端口。 用下一跳的地址更新以太网目标地址。 用交换机的地址更新以太网源地址。 减少TTL 一个ingress control: 定义一个表，该表将读取IPv4目标地址，并调用drop或ipv4_forward。 一个应用表的apply模块 在egress部分，将添加交换机ID和队列深度的action动作（add_swtrace）。 一个egress control,它应用表（swtrace）来存储交换机ID和队列深度并调用add_swtrace 用于选择将字段插入传出数据包的顺序的deparser。 实例化 headers部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#x2F;* -*- P4_16 -*- *&#x2F;#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;const bit&lt;8&gt; UDP_PROTOCOL &#x3D; 0x11;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;const bit&lt;5&gt; IPV4_OPTION_MRI &#x3D; 31;#define MAX_HOPS 9&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;typedef bit&lt;32&gt; switchID_t;typedef bit&lt;32&gt; qdepth_t;header ethernet_t &#123; macAddr_t dstAddr; macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;header ipv4_t &#123; bit&lt;4&gt; version; bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;header ipv4_option_t &#123; bit&lt;1&gt; copyFlag; bit&lt;2&gt; optClass; bit&lt;5&gt; option; bit&lt;8&gt; optionLength;&#125;&#x2F;&#x2F;mri头header mri_t &#123; bit&lt;16&gt; count;&#125;header switch_t &#123; switchID_t swid; qdepth_t qdepth;&#125;struct ingress_metadata_t &#123; bit&lt;16&gt; count;&#125;struct parser_metadata_t &#123; bit&lt;16&gt; remaining;&#125;struct metadata &#123; ingress_metadata_t ingress_metadata; parser_metadata_t parser_metadata;&#125;struct headers &#123; ethernet_t ethernet; ipv4_t ipv4; ipv4_option_t ipv4_option; mri_t mri; switch_t[MAX_HOPS] swtraces;&#125;error &#123; IPHeaderTooShort &#125; 实验过程1 先跑不完整的初始版本代码先跑一下初始代码看看啥样，以便和之后的做对比 在shell上面跑: make 这步会: 编译mri.p4 启动一个 Mininet 实例，其中三个交换机(s1,s2,s3)设置在三角形结构里面。有5个主机.具体见拓扑图部分 主机被指定成了10.0.1.1, 10.0.2.2，其他的也都是(10.0.&lt;Switchid&gt;.&lt;hostID&gt;)这种格式 控制平面部分的规则是基于sx-runtime.json 准备做的事情是在h1和h2之间发送低速率的流, 在h11和h22之间发送搞俗的测试流。s1和s2之间会形成一个拥塞因为在topology.json里面把带宽削减到了512kbps。因此如果我们在h2收包胡发现连接里面有很长的队列等待长度。 拓扑如下: 在make打开的Mininet命令行界面开四个窗口: 1mininet&gt; xterm h1 h11 h2 h22 在h2的xterm里面打开收包的服务: 1.&#x2F;receive.py 在h22的xterm里面打开iperf UDP 服务: 1iperf -s -u 在h1的xterm里面使用send.py给h2每秒发一个包，发30秒: 1./send.py 10.0.2.2 \"P4 is cool\" 30 在h2的xterm里面会收到”P4 is cool “信息 在h11的xterm里面，启动iperf客户端发送15秒: 1iperf -c 10.0.2.22 -t 15 -u 在h2端,MRI header没有hop信息(count=0) 退出来 这里h2虽然接到了信息，但是没有关于这条消息经过的路径的信息。完善的内容就是在mri.p4里面完善MRI逻辑来记录路径信息。 到目前的实验结果如下: 会发现h2收到的MRI信息里面的count=0; h22中因为线路的带宽有限，几次实验发现15秒发不完: h1和h11里面是发包的提示信息: h1如下: h11如下: 2 控制平面相关 控制平面相关:P4程序定义了一个数据包处理管道，但是控制数据包的规则是由控制平面插入到管道中的。 当规则与数据包匹配时，将使用控制平面提供的参数作为规则的一部分来调用其动作。在本练习中，控制平面逻辑已经实现。 作为启动Mininet实例的一部分，make脚本将在每个交换机的表中安装数据包处理规则。 这些定义在sX-runtime.json文件中，其中X对应于交换机号。 12345678910111213141516171819202122232425262728//s1-runtime.json部分代码&#123; \"target\": \"bmv2\", \"p4info\": \"build/mri.p4.p4info.txt\", \"bmv2_json\": \"build/mri.json\", \"table_entries\": [ &#123; \"table\": \"MyEgress.swtrace\", \"default_action\": true, \"action_name\": \"MyEgress.add_swtrace\", \"action_params\": &#123; \"swid\": 1 &#125; &#125;, &#123; \"table\": \"MyIngress.ipv4_lpm\", \"match\": &#123; \"hdr.ipv4.dstAddr\": [\"10.0.1.1\", 32] &#125;, \"action_name\": \"MyIngress.ipv4_forward\", \"action_params\": &#123; \"dstAddr\": \"08:00:00:00:01:01\", \"port\": 2 &#125; &#125;, //..............还有一部分已经省略 ]&#125; 不难发现这里的表项和拓扑图以及P4代码里面的table息息相关，写法也和之前的P4runtime里面的相似 3 完善MRI见前面的代码实现部分 4 运行解决方案参考博客","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode300-m","date":"2021-03-04T15:31:23.000Z","path":"2021/03/04/leetcode300-m/","text":"300. 最长递增子序列难度中等1422收藏分享切换为英文接收动态反馈 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 12输入：nums &#x3D; [0,1,0,3,2,3]输出：4 示例 3： 12输入：nums &#x3D; [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 进阶： 你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 解答 : $O(n^2)$的方法： 使用dp[i]表示[0,i]之间的最大子序列长度，根据最大子序列的定义来思考状态转移方程: dp[i]=max(dp[i],dp[j]+1 if j&lt;i and nums[j]&lt;nums[i]) 也就是一个循环遍历i，然后里面的循环遍历j，找到一个nums[i]小的然后更新; 1234567891011121314class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: _length=len(nums) if _length &lt; 2: return _length dp=[1]*(_length+1) res=dp[0] for i in range(0,_length): for j in range(0,i): if nums[j]&lt;nums[i]: dp[i]=max(dp[i],dp[j]+1) res=max(res,dp[i]) return res $O(NlogN)$的方法: 贪心加二分，不是很好想; 这里找的状态时tail[i],表示长度为i+1的所有上升子序列的结尾最小值;这里的tail[i]时严格递增的，可以用反证法证明; 这题就变成了维护tail这个数组，这个数组的长度就是我们要求的结果的长度;如何维护分为以下两步: 扩充数组元素: 如果遍历nums的时候这个 nums[i]&gt;*(tail.end()),那么就把nums[i]添加到tail数组后面，此时相当于tail数组变长了一位; 更新数组里面的元素： 如果遍历nums的时候这个nums[i]&lt;*(tail.end()),那么就要看tail数组里面第一个大于nums[i]的数，然后把它换成nums[i]; 例子解释: [9,2,3,6,7,4],初始化的时候表示长度的end=1,tail[end]=-1001,下面的[]表示tail数组 [9] 遍历到9,9&gt;tail[end],tail[end]=9 [2] 遍历到2,2&lt;tail[end],找到第一个大于2的,只有9,替换 [2,3] 遍历到3,3&gt;tail[end],添加进去 [2,3,6] 同理 [2,3,6,7] 同理 [2,3,4,7] 遍历到4,4&lt;tail[end],找到第一个大于4的,把它变小成4 直观的来看,tail 数组越紧致,它越容易边长 123456789101112131415161718192021class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: _length=len(nums) tail=[-1001]*(_length+1) end=1 tail[end-1]=nums[0] for i in range(1,_length): if nums[i]&gt;tail[end-1]: end=end+1 tail[end-1]=nums[i] elif nums[i]&lt;tail[end-1]: left=0 right=end-1 while left&lt;right: mid=(left+right)&gt;&gt;1 if tail[mid]&lt;nums[i]: left=mid+1 # 中位数不是要找的数 else: right=mid tail[left]=nums[i] return end","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"C++标准库与泛型编程学习笔记","date":"2021-03-04T13:25:17.000Z","path":"2021/03/04/STL/","text":"C++标准库与泛型编程学习笔记 感谢侯捷老师 基础知识 六大部件 容器(containers):数据存放在里面 分配器(Allocators):支持容器的内存管理 算法(Algorithms):一个个模板函数 迭代器(Iterators):泛化的指针 适配器(Adapters):有容器/迭代器/仿函数适配器，可以帮他们进行转换 仿函数(Functors):相似于函数 12345678910#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#include&lt;iostream&gt;........int main()&#123; int ia[6]=&#123;27,210,....&#125;; vector&lt;int,allocator&lt;int&gt;&gt;vi(ia,ia+6);//分配器不写会默认帮你搞好;vi是iterator; cout&lt;&lt;count_if(vi.begin(),vi.end(),notl(bind2nd(less&lt;int&gt;(),40)));//count_if 是算法,not1是function adapter(negator)，表示否定，大于等于40;bind2nd是function adapter(binder),绑定第二参数,这里的作用是有没有小于40;less是function object 仿函数;not1(....)这行称作predicate&#125; 复杂度 略 “前闭后开”区间：标准库用 c.begin()指的是头,c.end()指向尾巴的后面一个,因此是[);所以*(c.end())是不行的; 12345678910111213141516171819202122232425Container&lt;T&gt; c;....Container&lt;T&gt;::iterator ite=c.begin();for(;ite!=c.end();++ite)&#123; .....&#125;//range-based for statement C++11for(decl:coll)&#123; statement;&#125;//例子:std::vector&lt;double&gt;vec;...for(auto elem:vec)&#123; std::cout&lt;&lt;elem;&#125;for(auto&amp; elem:vec)&#123; elem*=3;//使用引用才能变;&#125;//auto的使用;list&lt;string&gt;c;list&lt;string&gt;::iterator ite;ite=::find(c.begin(),c.end(),target);//等价于auto ite=::find(c.begin(),c.end(),target); 容器测试 分类: Sequence Containers(序列式): Array:固定元素大小的数组 Vector:末端可以扩张的数组 Deque(/dek/):前后可以扩张的数组,双向队列 List:双链 Forward-List:单链,内存小于前者 Associative Containers(关联式): 适合查找 Set/Multiset:集合,底部用红黑树做;Multiset可以重复 Map/Multimap:有序的键/值对,后者的key可以重复,底部用红黑树做; Unordered Containers(不定序的元素): Unordered set/Multiset:集合,底部基于哈希-拉链法 Unordered Map/Multimap:有序的键/值对,底部基于哈希-拉链法 容器速率直观比较: (单位是毫秒) Array:47,187(项目:50万随机数for循环赋值时间和排序+二分查找时间) Vector:3063,2765(项目:100万随机数for循环push_back和排序+二分查找时间）a.size()=1000000,a.capacity()=1048576,因为vector增加的时候会预留空间,长着长着开一个两倍的空间复制进去;这个例子里面用find找元素比排序+二分快,0毫秒 List:3265,2312,16(项目:100万随机数for循环push_back和排序+二分查找时间和find的时间),list自带sort forward_list:3204,15,2656(项目:100万随机数,find的时间,sort的时间) ，它也自带sort slist:非标准库里面,#include&lt;ext\\slist&gt;里面有;和forward_list使用差不多; deque:2704,15,3110(项目:100万随机数push_back,find函数,使用全局sort)deque的连续是一种假象;它是分段连续,分成一个个buffer,由指针指着;如果buffer用完了就再申请一块buffer; stack: deque其实涵盖了stack和queue;它们两个的底层都是deque;812(项目:30万随机数push) queue:890(项目:30万随机数push) 因为stack,queue是由deque实现的,所以也被称为容器适配器 multiset:6609,203,0(项目:100万随机数insert放进去和全局find和自己的find)关联式容器找东西非常快 multimap:4812,0(项目:&lt;index,100万随机数&gt; insert放进去和自己的find) unordered_multiset:4406,109,0(项目:100万随机数insert进去和全局find和自带find) ;bucket_count()可以看出篮子的个数,篮子一定比元素多;load_factor()可以看出负载因子; unordered_multimap:4313,0(项目:100万随机数insert进去和自带的find) set:3922,0,0(项目:100万随机数insert进去和全局find和自带find) map:4890,0(项目:100万放进去和自带的find)；multiset不能用c[i]=string(buf)只能用insert函数插入,但是map可以； unordered_map,unordered_set:略 一些老版本的容器比如slist,hash_set,hash_map.hash_multiset,hash_multimap要另外include; 分配器测试:下面都是GNU-C里面的: 分类器使用示例: 1template&lt;typename_Tp,typename_Alloc=std::allocator&lt;_Tp&gt;&gt;class vector:protected_Vector_base&lt;_Tp,_Alloc&gt; 不同分配器的使用示例: 123456789101112131415//使用std::allocator意外的allocator需要自行#include&lt;ext\\....&gt;#include&lt;ext\\array_allocator.h&gt;#include&lt;ext\\mt_allocator.h&gt;#include&lt;ext\\debug_allocator.h&gt;#include&lt;ext\\pool_allocator.h&gt;#include&lt;ext\\bitmap_allocator.h&gt;#include&lt;ext\\new_allocator.h&gt;....list&lt;string,allocator&lt;string&gt;&gt; c1;list&lt;string,__gnu_cxx::malloc_allocator&lt;string&gt;&gt; c2;list&lt;string,__gnu_cxx::new_allocator&lt;string&gt;&gt; c3;list&lt;string,__gnu_cxx::__pool_allocator&lt;string&gt;&gt; c4;list&lt;string,__gnu_cxx::__mt_allocator&lt;string&gt;&gt; c5;list&lt;string,__gnu_cxx::bitmap_allocator&lt;string&gt;&gt; c6; 分配器可以分配内存，但是不如malloc/free;new/delete舒服，释放内存很麻烦;比如: 1234int*p;allocator&lt;int&gt;alloc1;p&#x3D;alloc1.allocate(1);alloc1.deallocate(p,1);","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"}]},{"title":"p4学习-4:P4runtime实验","date":"2021-03-02T14:06:07.000Z","path":"2021/03/02/p4学习-4/","text":"p4学习-4:P4runtime实验实验目标使用P4Runtime而不是来交换机的CLI发送flow entries;P4程序是在basic tunnel里面的程序的基础上写的，改名叫了 advanced_tunnel.p4，并且增加了两个counters(ingressTunnelCounter, egressTunnelCounter)和两个actions(myTunnel_ingress, myTunnel_egress) 使用启动程序mycontroller.py以及一些 p4runtime_lib 库里面的函数来创建主机1和主机2之间隧道通信所需的表项。 代码部分主要是mycontroller.py里面的writeTunnelRules函数的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/env python2import argparseimport grpcimport osimport sysfrom time import sleep# Import P4Runtime lib from parent utils dir# Probably there's a better way of doing this.sys.path.append( os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../utils/'))import p4runtime_lib.bmv2from p4runtime_lib.switch import ShutdownAllSwitchConnectionsimport p4runtime_lib.helperSWITCH_TO_HOST_PORT = 1SWITCH_TO_SWITCH_PORT = 2def writeTunnelRules(p4info_helper, ingress_sw, egress_sw, tunnel_id, dst_eth_addr, dst_ip_addr): \"\"\" Installs three rules: 1) An tunnel ingress rule on the ingress switch in the ipv4_lpm table that encapsulates traffic into a tunnel with the specified ID ipv4_lpm表的入接口开关上的隧道入接口规则，该规则用指定的ID将流量封装到一个隧道中 2) A transit rule on the ingress switch that forwards traffic based on the specified ID 入口交换机上的一种传输规则，根据指定的ID转发流量 3) An tunnel egress rule on the egress switch that decapsulates traffic with the specified ID and sends it to the host 出口交换机上的一条隧道出口规则，将指定ID的流量解封装后发送给主机 :param p4info_helper: the P4Info helper :param ingress_sw: the ingress switch connection :param egress_sw: the egress switch connection :param tunnel_id: the specified tunnel ID :param dst_eth_addr: the destination IP to match in the ingress rule :param dst_ip_addr: the destination Ethernet address to write in the egress rule \"\"\" # 1) Tunnel Ingress Rule table_entry = p4info_helper.buildTableEntry( table_name=\"MyIngress.ipv4_lpm\", match_fields=&#123; \"hdr.ipv4.dstAddr\": (dst_ip_addr, 32) &#125;, action_name=\"MyIngress.myTunnel_ingress\", action_params=&#123; \"dst_id\": tunnel_id, &#125;) ingress_sw.WriteTableEntry(table_entry) print \"Installed ingress tunnel rule on %s\" % ingress_sw.name # 2) Tunnel Transit Rule # The rule will need to be added to the myTunnel_exact table and match on the tunnel ID (hdr.myTunnel.dst_id). Traffic will need to be forwarded using the myTunnel_forward action on the port connected to the next switch.这条规则是添加到myTunnel_exact table上面的，match的部分是tunnel ID (hdr.myTunnel.dst_id)。流量将会使用myTunnel_forward action转发到连接下一个交换机的端口，这里要观察下面的拓扑图会发现连接交换机(h1,h2)的都是二号端口，文件里面用SWITCH_TO_SWITCH_PORT表示了2号端口 # # For our simple topology, switch 1 and switch 2 are connected using a link attached to port 2 on both switches. We have defined a variable at the top of the file, SWITCH_TO_SWITCH_PORT, that you can use as the output port for this action. # # We will only need a transit rule on the ingress switch because we are using a simple topology. In general, you'll need on transit rule for each switch in the path (except the last switch, which has the egress rule), and you will need to select the port dynamically for each switch based on your topology. # TODO build the transit rule # TODO install the transit rule on the ingress switch #print \"TODO Install transit tunnel rule\" table_entry=p4info_helper.buildTableEntry( table_name=\"MyIngress.myTunnel_exact\", match_fields=&#123; \"hdr.myTunnel.dst_id\":tunnel_id &#125;, action_name=\"MyIngress.myTunnel_forward\", action_params=&#123; \"port\":SWITCH_TO_SWITCH_PORT &#125;) ingress_sw.WriteTableEntry(table_entry) print \"Installed transit tunnel rule on %s\" % ingress_sw.name # 3) Tunnel Egress Rule # For our simple topology, the host will always be located on the SWITCH_TO_HOST_PORT (port 1). # In general, you will need to keep track of which port the host is connected to. table_entry = p4info_helper.buildTableEntry( table_name=\"MyIngress.myTunnel_exact\", match_fields=&#123; \"hdr.myTunnel.dst_id\": tunnel_id &#125;, action_name=\"MyIngress.myTunnel_egress\", action_params=&#123; \"dstAddr\": dst_eth_addr, \"port\": SWITCH_TO_HOST_PORT &#125;) egress_sw.WriteTableEntry(table_entry) print \"Installed egress tunnel rule on %s\" % egress_sw.name #### 下面的函数省略不表 实际写的时候主要依靠下面的Tunnel Egress Rule规则仿写,主要p4文件里面: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************/control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) ingressTunnelCounter; counter(MAX_TUNNEL_ID, CounterType.packets_and_bytes) egressTunnelCounter; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec = port; hdr.ethernet.srcAddr = hdr.ethernet.dstAddr; hdr.ethernet.dstAddr = dstAddr; hdr.ipv4.ttl = hdr.ipv4.ttl - 1; &#125; action myTunnel_ingress(bit&lt;16&gt; dst_id) &#123; hdr.myTunnel.setValid(); hdr.myTunnel.dst_id = dst_id; hdr.myTunnel.proto_id = hdr.ethernet.etherType; hdr.ethernet.etherType = TYPE_MYTUNNEL; ingressTunnelCounter.count((bit&lt;32&gt;) hdr.myTunnel.dst_id); &#125; action myTunnel_forward(egressSpec_t port) &#123; standard_metadata.egress_spec = port; &#125; action myTunnel_egress(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec = port; hdr.ethernet.dstAddr = dstAddr; hdr.ethernet.etherType = hdr.myTunnel.proto_id; hdr.myTunnel.setInvalid(); egressTunnelCounter.count((bit&lt;32&gt;) hdr.myTunnel.dst_id); &#125; table ipv4_lpm &#123; key = &#123; hdr.ipv4.dstAddr: lpm; &#125; actions = &#123; ipv4_forward; myTunnel_ingress; drop; NoAction; &#125; size = 1024; default_action = NoAction(); &#125; table myTunnel_exact &#123; key = &#123; hdr.myTunnel.dst_id: exact; &#125; actions = &#123; myTunnel_forward; myTunnel_egress; drop; &#125; size = 1024; default_action = drop(); &#125; apply &#123; if (hdr.ipv4.isValid() &amp;&amp; !hdr.myTunnel.isValid()) &#123; // Process only non-tunneled IPv4 packets. ipv4_lpm.apply(); &#125; if (hdr.myTunnel.isValid()) &#123; // Process all tunneled packets. myTunnel_exact.apply(); &#125; &#125;&#125; match_field里面相当于action里面的key部分,具体的值由控制平面也就是函数里面的tunnel_id确定;action_name里面相当于调用了action myTunnel_forward,这个action的参数只有port,又因为题目里面的提示要求port是SWITCH_TO_SWITCH_PORT因此填进去就行了; 实验过程1 跑未完成的代码 mycontroller.py里面包含了一些隧道通信需要的规则，在没有完成的情况下先跑p4看看啥样: 1make 这步编译了 advanced_tunnel.p4, 启动一个Mininet实例，其中三个交换机(s1, s2, s3)配置在一个三角形中，每个交换机连接到一个主机(h1, h2, h3)，并且把10.0.1.1, 10.0.2.2, 10.0.3.3这些IP配置到对应的主机上 现在会看到mininet命令窗口，ping h1 和 h2: 1mininet&gt; h1 ping h2 因为交换机上面没有规则，现在还没法接受回应，然后如果ctrl+C就如下图各种丢包； 现在把这个ping留着继续跑然后开另一个shell 在另一个shell里面跑: 12cd ~/tutorials/exercises/p4runtime./mycontroller.py 这会安装advanced_tunnel.p4程序到switch上面并且把tunnel ingress规则推进去；这个程序每两秒打印ingress和egress的counters 因为目前没有完成还有一些TODO的部分，所以下面可以看到这些包经过s1的ingress并且让计数器增加； Ctrl-c退出 目前的交换机是根据目的IP地址将流量映射到隧道(ID)上面，要做的工作是写规则，从而让交换机能够基于隧道(tunnel) ID来转发流量 和前面的对比：之前的都是依靠一些json文件静态的设置表项，这里是动态的；要注意到p4 程序仅仅定义了一个包处理的管道，但是是不包含具体的规则的； P4程序定义了包处理管道（规则由控制平面插入），同时定义了交互机的pipeline和控制平面的接口（这部分在advanced_tunnel.p4info）里面；在mycontroller. py里面构建的表项(table entries)会根据名称引用特定的表、键和actions；使用p4info会将名字转换程P4runtime所需要的ID。在P4程序中添加或者重命名的表、键、actions都要反映在 py程序的表项(table entries)里面 2 完善隧道转发 p4runtime_lib库里面的总结,这部分代码在tutorials/utils/p4runtime_lib里面: p4runtime_lib.helper 包含了P4InfoHelper 类能够解析P4Info文件，包括了name,id,alias,match_field(本身/id/name/pb/value)，action_param(本身/id/name/pb) 提供了实体的名字到ID数字转换的方法(buildTableEnrty函数) 构建P4Runtime表项的P4依赖于程序的部分。 p4runtime_lib.switch.py 包括了SwitchConnection类，会获取gRPC的client stub以及给交换机建立连接 提供了helper方法，能够构建P4Runtime协议的buffer信息以及制作P4Runtime gRPC service calls p4runtime_lib.bmv2.py 包含了 Bmv2SwitchConnection 类，它拓展了SwitchConnections并且提供了BMv2-specific 设备载荷来装载P4程序 PS:实际上是重载了SwitchConnection 然后多了一个buildDeviceConfig函数能够根据bmv2_json_file来返回设备的配置 p4runtime_lib.convert.py 由helper.py调用 主要提供了一些把数字/字符串编码协议buffer信息需要的格式的方法以及相应的解码方法 mycontroller.py是一个结能的控制平面做了以下的事情 为P4Runtime服务构建了一个到交换机的 gRPC连接 把P4程序push给各个交换机 在h1,h2之间的两个隧道编写了ingress/egress规则 每两秒读隧道的ingress/egress计数器 代码部分主要要做的事情是在 writeTunnelRules函数里面写隧道转发规则，它对应于隧道ID并且能够把包转发到下一跳 拓扑图如下: 3 实验结果先make clean再make，然后h1 ping h2，然后开一个新端口./mycontroller.py，这个时候可以看见ingress,egress的计数都上涨了: py_info 另外ping也能够成功的收到了: mini_info 额外参考——rpc,grpc学习左转参考博客 参考博客 rpc介绍 P4 runtime 和 p4 info","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode303-s","date":"2021-03-01T12:18:36.000Z","path":"2021/03/01/leetcode303-s/","text":"303. 区域和检索 - 数组不可变难度简单283收藏分享切换为英文接收动态反馈 给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j两点。 实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])） 示例： 1234567891011输入：[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 提示： 0 &lt;= nums.length &lt;= 104 -105 &lt;= nums[i] &lt;= 105 0 &lt;= i &lt;= j &lt; nums.length 最多调用 104 次 sumRange 方法 解答： 使用前缀和方法，前缀和表示的是[0,i)之间的和，比如对于数组 [1,2,3,4,5],presum[0]=0,presum[1]=0+1=1…… 12for i in range(0,len(nums)+1): presum[i+1]=presum[i]+nums[i] 因此本题解法如下: 123456789101112131415class NumArray: def __init__(self, nums: List[int]): _length=len(nums) self.presum=[0]*(_length+1) for i in range(0,_length): self.presum[i+1]=self.presum[i]+nums[i] def sumRange(self, i: int, j: int) -&gt; int: return self.presum[j+1]-self.presum[i]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j)","tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://tyler-ytr.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"leetcode1176-h","date":"2021-02-26T09:05:15.000Z","path":"2021/02/26/leetcode1176-h/","text":"1178. 猜字谜难度困难149 外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）都不能作为谜底。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例： 1234567891011输入：words &#x3D; [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles &#x3D; [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#39;g&#39;。 提示： 1 &lt;= words.length &lt;= 10^5 4 &lt;= words[i].length &lt;= 50 1 &lt;= puzzles.length &lt;= 10^4 puzzles[i].length == 7 words[i][j], puzzles[i][j] 都是小写英文字母。 每个 puzzles[i] 所包含的字符都不重复。 解答： 这题有两个要思考的点，第一个是怎么压缩状态，非常自然的想到二进制，英文字母一共26位，用int完全可以表示，通过这一点可以想到一个朴素的方法（TLE）: 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;int&gt; findNumOfValidWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles) &#123; //int 二进制有32位 英文字母一共26位 出现一次该位为1 //a最小,z最大 //如果字谜A包含了wordB,首先A&amp;B==1，判断A中的第一个字母有没有包含在B里面 假设该字母是00010,取反是11101，(11101|B)&amp;(00010)表示有 vector&lt;int&gt;result(puzzles.size(),0); vector&lt;int&gt;wordmap(words.size(),0); vector&lt;int&gt;puzzlemap(puzzles.size(),0); int temp; for(int i=0;i&lt;words.size();++i)&#123; for (int j=0;j&lt;words[i].size();j++)&#123; temp=1&lt;&lt;(int)(words[i][j]-'a'); wordmap[i]|=temp; &#125; &#125; for(int i=0;i&lt;puzzles.size();++i)&#123; for (int j=0;j&lt;puzzles[i].size();j++)&#123; temp=1&lt;&lt;(int)(puzzles[i][j]-'a'); puzzlemap[i]|=temp; &#125; &#125; for(int i=0;i&lt;puzzles.size();++i)&#123; for(int j=0;j&lt;words.size();++j)&#123; int temp=1&lt;&lt;(int)(puzzles[i][0]-'a'); if((~temp|wordmap[j])&amp;temp)&#123; int a=puzzlemap[i]; int b=wordmap[j]; if((a&amp;b)==b)&#123; result[i]+=1; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 这个方法就是先将words,puzzles都压缩成二进制串然后一对一比较，后面比较是一个O($N^2$),并且没有利用puzzles[i].length == 7这个条件，因此会TLE；（这是TLE的分析） 根据puzzles[i].length == 7，然后可以联想到优化的方法，因为长度是固定的，所以它的子集数目也是比较小的，因此可以将words做一个unorderer_map，然后对于pussles压缩之后的每一个子集进行查询即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;int&gt; findNumOfValidWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles) &#123; //位运算 //int 二进制有32位 英文字母一共26位 出现一次该位为1 //a最小,z最大 //如何枚举一个二进制数的子集： //也就是10101的子集是10101,10100,10001,10000,00101,00100,00001,00000; /* int sub = k; do &#123; sub = (sub - 1) &amp; k; &#125; while(sub != k); */ unordered_map&lt;int, int&gt; count; for (string &amp;word: words) &#123;//注意 int mask = 0; for (char ch : word) mask |= (1 &lt;&lt; (ch - 'a')); count[mask]+=1;//如果出现了那么对应的count那么这个count应该为1 // cout&lt;&lt;count[mask]; &#125; int len=puzzles.size(); vector&lt;int&gt; result(len, 0); for(int i=0;i&lt;len;++i)&#123; string&amp;puzzle=puzzles[i]; int k=0; for(char ch:puzzle)&#123; k|=(1&lt;&lt;(ch-'a')); &#125; int sub = k; do &#123; sub = (sub - 1) &amp; k; if ((1 &lt;&lt; (puzzle[0] - 'a')) &amp; sub) result[i] += count[sub]; &#125; while(sub != k); &#125; return result; &#125;&#125;;","tags":[{"name":"位运算","slug":"位运算","permalink":"http://tyler-ytr.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"如何阅读一篇论文阅读笔记","date":"2021-02-25T08:59:25.000Z","path":"2021/02/25/how-to-read-a-paper-notes/","text":"How to read a paper 阅读笔记 原文链接:https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf 由刘恩萌启发 3段方法 1st pass 仔细阅读标题，abstract和intruduction，结论；浏览section &amp; subsection的标题、数学内容；reference；其他部分一概忽略 能够回答下面的五个C: Category:(类型：测量/分析/描述……) Context:(有关论文？理论基础？…… ) Correctness:（假设看上去正确吗？……） Contributions Clarity:（写的咋样……） 通过这些内容决定是否进一步阅读 2nd pass 比第一遍更认真的看，可以记一些笔记在空白处，划重点；看完之后应该能够把握论文内容 认真看图表，看看有没有错 标注没读过的相关文献以便进一步了解背景 如果看完还是懵逼，以下三选一： 扔一边不看了 过一会/看完背景材料再看 坚持不懈并且进入步骤3 3rd pass virtually re-implement: 标注作者的假设，然后在这些假设基础(虚拟)上重新实现这个工作，通过将重新实现和作者文章的比较，很容易发现它的创新点以及隐藏的错误/假设 重点是关注细节，积累对未来工作的想法 在这一阶段结束时，能够根据记忆重建整篇文章的结构，并且能够识别出它的优缺点。","tags":[]},{"title":"p4学习-3:P4 basic tunnel实验","date":"2021-02-24T08:52:17.000Z","path":"2021/02/24/p4学习-3/","text":"P4学习-3：P4 basic tunnel实验实验目标 在本练习中，我们将向IP添加对基本隧道协议的支持 你在上一个作业中完成的路由器。基本交换机根据目的IP地址进行转发。您的工作是定义一个新的头类型来封装IP包并修改交换代码，这样它就可以使用一个新的隧道头来决定目的端口。 新的头类型将包含协议ID，它指示被封装的包的类型，以及用于路由的目的地ID。 P4程序定义了一个包处理管道，但是每个表中的规则是由控制平面插入的。当一个规则匹配一个包时，它的操作将被控制平面作为规则的一部分提供的参数调用。 对于本练习，我们已经添加了必要的静态控制平面条目。作为启动Mininet实例的一部分，make run命令将在每个交换机的表中安装包处理规则。这些是在sX-runtime中定义的json files，其中X对应开关号。 因为控制平面试图访问myTunnel_exact表，而这个表还不存在，所以make run命令不能与启动器代码一起工作。 PS：这里使用P4Runtime来安装规则，文件内容在sX-runtime.json里面 拓扑如下: basic_tunnel.p4文件包含了一个基本的IP路由器的实现，完整的实现版本将能够转发基于自定义封装头的内容，以及如果封装头在数据包中不存在，那么将执行正常的IP转发。工作有以下几个部分: NOTE:添加了一个新的头类型称作myTunnel_t ,包含了proto_id and dst_id NOTE:myTunnel_t 已经加入了myTunnel_t header TODO:更新解析器，根据以太网头中的etherType字段提取myTunnel头或ipv4头。myTunnel报头对应的etherType是’ 0x1212 ‘。如果proto_id == TYPE_IPV4 &#39;即0x0800)，解析器还应该在myTunnel 头之后提取ipv4头。 TODO: 定义了一个新的action称作 myTunnel_forward ，它设置出口端口(即standard_metadata总线的egress_spec字段)到控制平面提供的端口号。 TODO:定义一个名为myTunnel_exact的新表，它对myTunnel报头的dst_id字段执行精确匹配。如果表中有匹配项，该表应该调用myTunnel_forward操作，否则它应该调用drop操作。 TODO:如果myTunnel报头有效，更新MyIngress控制块中的apply语句，以应用新定义的myTunnel_exact表。否则，如果ipv4报头有效，则调用ipv4_lpm表。 更新deparser以发出’ ethernet ‘，然后是’ myTunnel ‘，然后是’ ipv4 ‘头。请记住，deparser只会在消息头有效时发出消息头。头的隐式有效性位由解析器在提取时设置。这里不需要检查头的有效性。 为新定义的表添加静态规则，以便交换机能够正确转发’ dst_id ‘的每个可能值。请参阅下面的图，了解拓扑的端口配置以及我们将如何为主机分配id。在此步骤中，您需要将转发规则添加到“sX-runtime”中。json文件。 代码部分headers部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;* -*- P4_16 -*- *&#x2F;#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;&#x2F;&#x2F; NOTE: new type added hereconst bit&lt;16&gt; TYPE_MYTUNNEL &#x3D; 0x1212;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;header ethernet_t &#123; macAddr_t dstAddr; macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;&#x2F;&#x2F; NOTE: added new header typeheader myTunnel_t &#123;&#x2F;&#x2F;新的header type bit&lt;16&gt; proto_id; &#x2F;&#x2F;包含了proto_id以及dst_id bit&lt;16&gt; dst_id;&#125;header ipv4_t &#123; bit&lt;4&gt; version; bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;struct metadata &#123; &#x2F;* empty *&#x2F;&#125;&#x2F;&#x2F; NOTE: Added new header type to headers structstruct headers &#123; ethernet_t ethernet; myTunnel_t myTunnel; &#x2F;&#x2F;新添加的字段 ipv4_t ipv4;&#125; Parser部分：1234567891011121314151617181920212223242526272829&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as wellparser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet; &#125; state parse_ethernet &#123; packet.extract(hdr.ethernet); transition select(hdr.ethernet.etherType) &#123; TYPE_IPV4 : parse_ipv4; default : accept; &#125; &#125; state parse_ipv4 &#123; packet.extract(hdr.ipv4); transition accept; &#125;&#125; 解答: 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;&#x2F;&#x2F; TODO: Update the parser to parse the myTunnel header as wellparser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet; &#125; state parse_ethernet &#123; packet.extract(hdr.ethernet); transition select(hdr.ethernet.etherType) &#123; TYPE_IPV4 : parse_ipv4; TYPE_MYTUNNEL : parse_mytunnel; default : accept; &#125; &#125; state parse_ipv4 &#123; packet.extract(hdr.ipv4); transition accept; &#125; state parse_mytunnel&#123; packet.extract(hdr.myTunnel); transition select(hdr.myTunnel.proto_id)&#123; &#x2F;&#x2F;满足需求：如果&#96;proto_id &#96; &#x3D;&#x3D; &#96; TYPE_IPV4 &#39;&#96;即0x0800)，解析器还应该在&#96;myTunnel 头&#96;之后提取&#96;ipv4 &#96;头。 TYPE_IPV4 : parse_ipv4; default : accept; &#125; transition accept; &#125;&#125; Ingress部分（以及checksum部分）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec &#x3D; port; hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; hdr.ethernet.dstAddr &#x3D; dstAddr; hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port) &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact &#x2F;&#x2F; TODO: also remember to add table entries! apply &#123; &#x2F;&#x2F; TODO: Update control flow if (hdr.ipv4.isValid()) &#123; ipv4_lpm.apply(); &#125; &#125;&#125; 解答： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata); &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec &#x3D; port; hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; hdr.ethernet.dstAddr &#x3D; dstAddr; hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm;&#x2F;&#x2F;最长前缀匹配 &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; &#x2F;&#x2F; TODO: declare a new action: myTunnel_forward(egressSpec_t port) action myTunnel_ford(egressSpec_t port)&#123; standard_metadata.egress_spec &#x3D; port;&#x2F;&#x2F;设置端口号 &#125; &#x2F;&#x2F; TODO: declare a new table: myTunnel_exact table myTunnel_exact&#123; key&#x3D;&#123; hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配 &#125; actions&#x3D;&#123; myTunnel_ford; drop;&#x2F;&#x2F;如果表中有匹配项，该表应该调用&#96; myTunnel_forward &#96;操作，否则它应该调用&#96; drop &#96;操作。 &#125; size &#x3D; 1024; default_action &#x3D; drop(); &#125; &#x2F;&#x2F; TODO: also remember to add table entries! apply &#123; &#x2F;&#x2F; TODO: Update control flow if (hdr.ipv4.isValid()) &#123; ipv4_lpm.apply(); &#125; if(hdr.myTunnel.isValid())&#123;&#x2F;&#x2F;模仿ipv4写的 myTunnel_exact.apply(); &#125; &#125;&#125; PS: match_kind： 这是match_action table里面的一种类型，比如 123key&#x3D;&#123; hdr.myTunnel.dst_id: exact;&#x2F;&#x2F;精准匹配&#125; 里面的exact就是一种match_kind，p4c/p4include/core.p4有三种: 12345678match_kind &#123; &#x2F;&#x2F;&#x2F; Match bits exactly.精准匹配 exact, &#x2F;&#x2F;&#x2F; Ternary match, using a mask. 把值和一个 mask 比较，比如 0x01020304 符合 mask 0x0F0F0F0F ternary, &#x2F;&#x2F;&#x2F; Longest-prefix match.最长前缀匹配 lpm&#125; p4c/p4include/v1model.p4里面有一下几种: 12345678match_kind &#123; &#x2F;&#x2F;检查是否值在一个范围里，比如取 0x01020304 - 0x010203FF 之间的值 range, &#x2F;&#x2F; Either an exact match, or a wildcard (matching any value).精准匹配或者通配 optional, &#x2F;&#x2F; Used for implementing dynamic_action_selection 用于实现dynamic_action_selection selector&#125; 因为在include上述两个文件的情况下一共有六种 Egress部分（以及checksum部分）：123456789101112131415161718192021222324252627282930313233&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; apply &#123; &#125;&#125;&#x2F;************************************************************************************** C H E C K S U M C O M P U T A T I O N ***************************************************************************************&#x2F;control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; update_checksum( hdr.ipv4.isValid(), &#123; hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr &#125;, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16); &#125;&#125; Deparser部分: 1234567891011&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet); &#x2F;&#x2F; TODO: emit myTunnel header as well packet.emit(hdr.ipv4); &#125;&#125; 解答: 12345678910111213&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet); &#x2F;&#x2F; TODO: emit myTunnel header as well packet.emit(hdr.myTunnel); packet.emit(hdr.ipv4); &#125;&#125; 实例化部分： 123456789101112&#x2F;************************************************************************************************ S W I T C H ********************************************************************************************************&#x2F;V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(),MyComputeChecksum(),MyDeparser()) main; 实验结果 make run 这会进行以下几步: 编译basic_tunnel.p4 启动一个Mininet实例，其中三个交换机(s1、s2、s3)配置在一个三角形中，每个交换机连接到一个主机(h1、h2和h3)。 这些主机的ip地址设置为10.0.1.1, 10.0.2.2, and 10.0.3.3. 然后进入mininet界面 使用mininet的xterm功能： 1mininet&gt; xterm h1 h2 在h2的界面输入 : 1.&#x2F;receive.py 在h1的界面输入: 1.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot; 这是不经过my_tunnel的测试； 如果您检查接收到的数据包，您应该会看到它由一个以太网报头、一个IP报头、一个TCP报头和消息组成。如果您更改了目的IP地址(例如试图发送到’ 10.0.3.3 ‘)，则该消息不应该被’ h2 ‘接收，而将被’ h3 ‘接收。 结果如下图: 发给10.0.3.3之后: h1有相似的显示，h2没有变化 下面测试my_tunnel 在h1的界面输入: 1.&#x2F;send.py 10.0.2.2 &quot;P4 is cool&quot; --dst_id 2 结果如下图: 数据包在h2处接收。它由一个以太网报头、一个隧道报头、一个IP报头、一个TCP报头和消息组成。隧道报头就是那个###[MyTunnel]在IP报头上面; 在h1的界面输入: 1.&#x2F;send.py 10.0.3.3 &quot;P4 is cool&quot; --dst_id 2 结果如下: 即使IP地址是h3的地址，数据包也应该在h2处接收。这是因为当MyTunnel头在包中时，交换机不再使用IP头进行路由。 一开始我也不理解上面这句话，后来我看了s1-runtime文件，这个文件规定了交换机的静态规则，将这个文件和basic里面的同名文件比较会发现里面多了: 这部分内容结合刚刚./receive代码里面的–dst 2后缀可以得知刚刚那个包在进入交换机s1之后会因为p4的解包触发走myTunnel_forward的规则然后发给S1的2端口，结合拓扑图可以看出确实是发给h2的 解析其他内容my_tunnel.py12345678910111213141516171819from scapy.all import *import sys, osTYPE_MYTUNNEL = 0x1212TYPE_IPV4 = 0x0800class MyTunnel(Packet): name = \"MyTunnel\" fields_desc = [ ShortField(\"pid\", 0), ShortField(\"dst_id\", 0) ] def mysummary(self): return self.sprintf(\"pid=%pid%, dst_id=%dst_id%\")bind_layers(Ether, MyTunnel, type=TYPE_MYTUNNEL)bind_layers(MyTunnel, IP, pid=TYPE_IPV4) 因为原来的scapy只支持ipv4，不支持我们的myTunnel协议，因此需要重新定义，上面的文件就重新定义了MyTunnel； 每一个协议层都是Packet类的子类。协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。一个简单的协议层是被一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为fields_desc的属性中。每一个字段都是一个field类的实例： 上面MyTunnel的协议层有两个字段分别是pid和dst_id，默认值都是0； UDP的协议层定义如下: 123456class UDP(Packet): name &#x3D; &quot;UDP&quot; fields_desc &#x3D; [ ShortEnumField(&quot;sport&quot;, 53, UDP_SERVICES), ShortEnumField(&quot;dport&quot;, 53, UDP_SERVICES), ShortField(&quot;len&quot;, None), XShortField(&quot;chksum&quot;, None), ] 最后两句是绑定协议层; Scapy在解析协议层时一个很酷的特性是他试图猜测下一层协议是什么。连接两个协议层官方的方法是bind_layers(): send.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env pythonimport argparseimport sysimport socketimport randomimport structimport argparsefrom scapy.all import sendp, send, get_if_list, get_if_hwaddr, hexdumpfrom scapy.all import Packetfrom scapy.all import Ether, IP, UDP, TCPfrom myTunnel_header import MyTunneldef get_if(): ifs=get_if_list() # # type: () -&gt; List[str] \"\"\"Return a list of interface names\"\"\",返回接口(网卡)名字 iface=None # \"h1-eth0\" for i in get_if_list(): if \"eth0\" in i: iface=i break; if not iface: print \"Cannot find eth0 interface\" exit(1) return ifacedef main(): parser = argparse.ArgumentParser()#argsparse是python的命令行解析的标准模块，相当于就是解析./send.py后面的参数 parser.add_argument('ip_addr', type=str, help=\"The destination IP address to use\")#type是要传入的参数的数据类型 help是该参数的提示信息,使用python send.py -h可以看到 parser.add_argument('message', type=str, help=\"The message to include in packet\") parser.add_argument('--dst_id', type=int, default=None, help='The myTunnel dst_id to use, if unspecified then myTunnel header will not be included in packet') args = parser.parse_args()##获得传入的参数 addr = socket.gethostbyname(args.ip_addr)## 获取ip_addr的主机名 dst_id = args.dst_id#获得dst_id iface = get_if()#获取网卡的名字 if (dst_id is not None):#包装 print \"sending on interface &#123;&#125; to dst_id &#123;&#125;\".format(iface, str(dst_id)) pkt = Ether(src=get_if_hwaddr(iface), dst='ff:ff:ff:ff:ff:ff') pkt = pkt / MyTunnel(dst_id=dst_id) / IP(dst=addr) / args.message else: print \"sending on interface &#123;&#125; to IP addr &#123;&#125;\".format(iface, str(addr)) pkt = Ether(src=get_if_hwaddr(iface), dst='ff:ff:ff:ff:ff:ff') pkt = pkt / IP(dst=addr) / TCP(dport=1234, sport=random.randint(49152,65535)) / args.message pkt.show2()# hexdump(pkt)# print \"len(pkt) = \", len(pkt) sendp(pkt, iface=iface, verbose=False)if __name__ == '__main__': main() 大概流程就是，先分析参数，然后包装成Ether的格式然后用scapy发包; receive.py12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env pythonimport sysimport structimport osfrom scapy.all import sniff, sendp, hexdump, get_if_list, get_if_hwaddrfrom scapy.all import Packet, IPOptionfrom scapy.all import ShortField, IntField, LongField, BitField, FieldListField, FieldLenFieldfrom scapy.all import IP, TCP, UDP, Rawfrom scapy.layers.inet import _IPOption_HDRfrom myTunnel_header import MyTunneldef get_if(): # 获得网卡接口 ifs=get_if_list() iface=None for i in get_if_list(): if \"eth0\" in i: iface=i break; if not iface: print \"Cannot find eth0 interface\" exit(1) return ifacedef handle_pkt(pkt): if MyTunnel in pkt or (TCP in pkt and pkt[TCP].dport == 1234): print \"got a packet\" pkt.show2()# hexdump(pkt)# print \"len(pkt) = \", len(pkt) sys.stdout.flush()def main(): ifaces = filter(lambda i: 'eth' in i, os.listdir('/sys/class/net/')) iface = ifaces[0] print \"sniffing on %s\" % iface sys.stdout.flush() sniff(iface = iface, prn = lambda x: handle_pkt(x))if __name__ == '__main__': main() 首先获得网卡，发出“sniffing on….”信息，并且立刻打出来，然后把收到的包里面的东西立刻打印出来 原文部分IntroductionIn this exercise, we will add support for a basic tunneling protocol to the IProuter that you completed in the previous assignment. The basic switchforwards based on the destination IP address. Your jobs is to define a newheader type to encapsulate the IP packet and modify the switch code, so that itinstead decides the destination port using a new tunnel header. The new header type will contain a protocol ID, which indicates the type ofpacket being encapsulated, along with a destination ID to be used for routing. Spoiler alert: There is a reference solution in the solutionsub-directory. Feel free to compare your implementation to the reference. The starter code for this assignment is in a file called basic_tunnel.p4 andis simply the solution to the IP router from the previous exercise. A note about the control planeA P4 program defines a packet-processing pipeline, but the rules within eachtable are inserted by the control plane. When a rule matches a packet, itsaction is invoked with parameters supplied by the control plane as part of therule. For this exercise, we have already added the necessary static control planeentries. As part of bringing up the Mininet instance, the make run commandwill install packet-processing rules in the tables of each switch. These aredefined in the sX-runtime.json files, where X corresponds to the switchnumber. Since the control plane tries to access the myTunnel_exact table, and thattable does not yet exist, the make run command will not work with the startercode. Important: We use P4Runtime to install the control plane rules. The contentof files sX-runtime.json refer to specific names of tables, keys, andactions, as defined in the P4Info file produced by the compiler (look for thefile build/basic.p4info after executing make run). Any changes in the P4program that add or rename tables, keys, or actions will need to be reflectedin these sX-runtime.json files. 参考博客： P4学习笔记专栏 core.p4库 scapy中文文档 scapy添加新的协议 scapy源码 argparse使用","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode24-m","date":"2021-02-24T08:37:35.000Z","path":"2021/02/24/leetcode24-m/","text":"24. 两两交换链表中的节点难度中等827 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： img 12输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head &#x3D; []输出：[] 示例 3： 12输入：head &#x3D; [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。） 迭代解法：开了一个虚拟节点，然后pid的next是将要交换的第一个节点,pid.next.next是第二个 12345678910111213141516171819# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: temphead=ListNode(0) temphead.next=head pid=temphead while pid.next and pid.next.next: node1=pid.next node2=pid.next.next pid.next=node2 node1.next=node2.next node2.next=node1 pid=node2.next return temphead.next 递归解法：见里面的注释 首先思考递归终止条件，然后思考里面的递归过程 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode:# def __init__(self, val&#x3D;0, next&#x3D;None):# self.val &#x3D; val# self.next &#x3D; nextclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: # 终止条件：head是空或者head.next是空 比如[],[1] if not head or not head.next: return head #1,2,3,4 temp&#x3D;head.next #因为马上要修改 #1-&gt;2-&gt;3-&gt;4 #修改好了4-&gt;3 #所以1-&gt;4-&gt;3 head.next&#x3D;self.swapPairs(temp.next) #temp相当于2,2-&gt;1 temp.next&#x3D;head return temp","tags":[{"name":"递归","slug":"递归","permalink":"http://tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"链表","slug":"链表","permalink":"http://tyler-ytr.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"leetcode23-h","date":"2021-02-23T12:08:25.000Z","path":"2021/02/23/leetcode23-h/","text":"23. 合并K个升序链表难度困难1151 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 12345678910输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 示例 2： 12输入：lists &#x3D; []输出：[] 示例 3： 12输入：lists &#x3D; [[]]输出：[] 提示： k == lists.length 0 &lt;= k &lt;= 10^4 0 &lt;= lists[i].length &lt;= 500 -10^4 &lt;= lists[i][j] &lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 解答： 优先队列 heapq是二叉堆，通常用普通列表实现。 heapq模块是在Python中不错的优先级队列实现。由于heapq在技术上只提供最小堆实现，因此必须添加额外步骤来确保排序稳定性，以此来获得“实际”的优先级队列中所含有的预期特性。 12345678910111213141516import heapqq &#x3D; []heapq.heappush(q, (2, &#39;code&#39;))heapq.heappush(q, (1, &#39;eat&#39;))heapq.heappush(q, (3, &#39;sleep&#39;))while q: next_item &#x3D; heapq.heappop(q) print(next_item)# 结果：# (1, &#39;eat&#39;)# (2, &#39;code&#39;)# (3, &#39;sleep&#39;) queue.PriorityQueue这个优先级队列的实现在内部使用了heapq，时间和空间复杂度与heapq相同。 区别在于PriorityQueue是同步的，提供了锁语义来支持多个并发的生产者和消费者。 在不同情况下，锁语义可能会带来帮助，也可能会导致不必要的开销。不管哪种情况，你都可能更喜欢PriorityQueue提供的基于类的接口，而不是使用heapq提供的基于函数的接口。 12345678910111213141516from queue import PriorityQueueq &#x3D; PriorityQueue()q.put((2, &#39;code&#39;))q.put((1, &#39;eat&#39;))q.put((3, &#39;sleep&#39;))while not q.empty(): next_item &#x3D; q.get() print(next_item)# 结果：# (1, &#39;eat&#39;)# (2, &#39;code&#39;)# (3, &#39;sleep&#39;) 其中PriorityQueue可以自定义比较函数: 12345678910111213141516171819202122232425262728from queue import PriorityQueueclass Job(object): def __init__(self, priority, description): self.priority &#x3D; priority self.description &#x3D; description print(&#39;New job:&#39;, description) return def __lt__(self, other): return self.priority &lt; other.priority &#39;&#39;&#39; 或者使用__cmp__函数 def __cmp__(self, other): if self.priority &lt; other.priority: return -1 elif self.priority &#x3D;&#x3D; other.priority: return 0 else: return 1 &#39;&#39;&#39;q2 &#x3D; PriorityQueue() q2.put(Job(5, &#39;Mid-level job&#39;))q2.put(Job(10, &#39;Low-level job&#39;))q2.put(Job(1, &#39;Important job&#39;)) #数字越小，优先级越高 while not q2.empty(): next_job &#x3D; q2.get() #可根据优先级取序列 print(&#39;Processing job&#39;, next_job.description) 题解: 使用heapq解决该问题，每一个链表的第一个节点进入堆进行比较，然后最小的那个取出来扔进新链表，然后最小的那个向后移动一位（80ms） 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: import heapq minheap=[] for index,node in enumerate(lists): if node!=None: heapq.heappush(minheap,(node.val,index)) #第几个链表的节点的值 head=ListNode(-1) tail=head while minheap: nodeval,index=heapq.heappop(minheap) tail.next=lists[index] tail=tail.next lists[index]=lists[index].next if lists[index]!=None: heapq.heappush(minheap,(lists[index].val,index)) return head.next 使用PriorityQueue解决问题，速度慢于heapq(144ms)： 12345678910111213141516171819202122# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: from queue import PriorityQueue minheap=PriorityQueue() for index,node in enumerate(lists): if node!=None: minheap.put((node.val,index)) #第几个链表的节点的值 head=ListNode(-1) tail=head while not minheap.empty(): nodeval,index=minheap.get() tail.next=lists[index] tail=tail.next lists[index]=lists[index].next if lists[index]!=None: minheap.put((lists[index].val,index)) return head.next 分治 首先实现合并两个链表，然后分治： 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: # 合并两个链表的代码 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1,l2=l2,l1 l1.next=self.mergeTwoLists(l1.next,l2) return l1 or l2 #调用上面的代码合并两个节点 def mergetwonode(self,node1:ListNode,node2:ListNode)-&gt;ListNode: return self.mergeTwoLists(node1,node2) #分治 def merge(self,left:int,right:int,lists:List[ListNode])-&gt;ListNode: if left==right: return lists[left] if left&gt;right: return None mid=left+((right-left)//2) return self.mergetwonode(self.merge(left,mid,lists),self.merge(mid+1,right,lists)) def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: if not lists: return None return self.merge(0,len(lists)-1,lists)","tags":[{"name":"递归","slug":"递归","permalink":"http://tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"优先队列","slug":"优先队列","permalink":"http://tyler-ytr.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}]},{"title":"leetcode1052-m","date":"2021-02-23T09:54:13.000Z","path":"2021/02/23/leetcode1052-m/","text":"1052. 爱生气的书店老板难度中等106 今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。 在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。 请你返回这一天营业下来，最多有多少客户能够感到满意的数量。 示例： 12345输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3输出：16解释：书店老板在最后 3 分钟保持冷静。感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16. 提示： 1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000 0 &lt;= customers[i] &lt;= 1000 0 &lt;= grumpy[i] &lt;= 1 解答: 分为两部分，第一部分是不用秘密方法得到的满意度，第二部分是使用秘密方法得到的满意度 123456789101112131415class Solution: def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -&gt; int: base=0 increase=0 maxincrease=0 length=len(customers) for i in range(0,length): base=base+customers[i]*(1-grumpy[i]) for i in range(0,X): increase=increase+customers[i]*grumpy[i] maxincrease=increase for i in range(X,length): increase=increase+customers[i]*grumpy[i]-customers[i-X]*grumpy[i-X] maxincrease=max(increase,maxincrease) return maxincrease+base","tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://tyler-ytr.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"贪心","slug":"贪心","permalink":"http://tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"机器学习导论笔记","date":"2021-02-23T09:26:04.000Z","path":"2021/02/23/机器学习/","text":"机器学习笔记绪论 学习过程 训练数据，经过 学习算法训练，得到 模型(决策树，射精网络，支持向量机，Boosting，贝叶斯网……)，可以判断 新数据样本，得到结论 机器学习的局限性，失效条件: 特征信息不充分 样本信息不充分 机器学习的理论基础(计算学习理论),概率近似正确(PAC): $P(|f(x)-y|\\le \\epsilon)\\ge 1-\\delta$ f(x)是预测值,y是真实值,目的是尽可能贴近真实值也就是$|f(x)-y|\\le \\epsilon$,然后这件事情有一个概率的保证，一定大于$1-\\delta$的概率确保这件事情的完成。一句话总结就是很高的概率得到很好的结果的模型。 如果你能确定百分百正确，就不用整机器学习了 数学参考范数 在实数域中，数的大小和两个数之间的距离是通过绝对值来度量的。将数推广到向量就引入了范数。范数（Norm）是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。 在算例子的时候我觉得其实是不同维度到0点的距离 向量的范数 范数标准定义: 正定性:$||x||\\ge 0$,且$||x||= 0$当且仅当$x=0$; 齐次性:对任意实数 $\\alpha$ ，都有$||\\alpha x||=|\\alpha|\\ ||x||$ 三角不等式: 对任意$x,y\\in R^n$,都有$||x+y|| \\le ||x|| + ||y||$ 则称$||x||$为$R^n$上的向量范数 范数表达式:$$\\begin{align}\\left| \\left| x \\right| \\right|{p}\\; :=\\; \\left( \\sum{i=1}^{n}{\\left| x_{i} \\right|^{p} } \\right)^{\\frac{1}{p} }\\tag{1}\\end{align}$$ L1范数:$$||x||_1 = |x_1| + |x_2| + \\dots + |x_n| = \\sum_i^n |x_i|$$向量元素绝对值之和 L2范数:$$||x||_2 = (|x_1|^2 + |x_2|^2+\\dots+ |x_n|^2)^{\\frac{1}{2} } =\\sqrt{ \\sum_i^n x_i^2}$$Euclid范数(欧几里得范数，常用计算向量长度) Lp范数:$$||x||_p = (|x_1|^p + |x_2|^p+\\dots+ |x_n|^p)^{\\frac{1}{p} } =\\sqrt[p]{ \\sum_i^n x_i^p}$$ Lp的形状随p的变化的图 L$\\infty $范数:$$||x||{\\infty} = \\max\\limits{1\\le i\\le n} |x_i|$$ 所有向量元素绝对值中的最大值 L$-\\infty$范数: $$ ||x||{\\infty} = \\min\\limits{1\\le i\\le n} |x_i| $$ 所有向量元素绝对值中的最小值 L0范数: $$ ||x||_0 = \\sum_i^n I(x_i \\ne 0) $$ 也就是非零元素的数量 例子:$x=(1,4,3,0)^T$的常用范数: $||x||_0=3$ $||x||_1=|1|+|4|+|3|+|0|=8$ $||x||_2=\\sqrt{|1|^2+|4|^2+|3|^2+|0|^2}=\\sqrt{26}$ $||x||_{\\infty}=|4|=4$ 矩阵的范数 推广到矩阵，矩阵相容范数的定义: 正定性:$||A||\\ge 0$,且$||A||= 0$当且仅当$A=0$; 齐次性:对任意实数 $\\alpha$ ，都有$||\\alpha A||=|\\alpha|\\ ||A||$ 三角不等式: 对任意$A,B\\in R^{n\\times n}$,都有$||A+B|| \\le ||A|| + ||B||$ 相容性:对任意$A,B\\in R^{n\\times n}$,都有$||AB|| \\le ||A||\\ ||B||$ 则称$||A||$为$R^{n\\times n}$上的一个矩阵范数 列范数:$$||A||1 = \\max\\limits{1\\le j\\le n} \\sum_i^n |a_{ij}|$$$A$的每一列的绝对值的最大值，称作$A$的列范数 行范数:$$||A||{\\infty} = \\max\\limits{1\\le i\\le n} \\sum_j^n |a_{ij}|$$$A$的每一行的绝对值的最大值，称作$A$的行范数 L2范数:$$||A||2 = \\sqrt{\\lambda{max} (A^T A)}$$其中$\\lambda_{max}$表示$A^TA$的特征值的绝对值的最大值 F-范数(Frobenius):$$||A||_F = (\\sum_i^n \\sum_j^n a_{ij}^2)^{\\frac{1}{2} }=(tr(A^TA))^{1/2}$$它相当于矩阵$A$各项元素的绝对值平方的总和,也就是矩阵张成向量之后的L2范数 求导 一阶导数：雅可比矩阵 假设函数$F:{R_n} \\to {R_m}$是一个从欧式n维空间转换到欧式m维空间的函数.这个函数由m个实函数组成:$y1(x1,…,xn), …, ym(x1,…,xn)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵, 这就是所谓的雅可比矩阵：$$\\begin{bmatrix} \\frac{\\partial y_1}{\\partial x_1} &amp; \\cdots &amp; \\frac{\\partial y_1}{\\partial x_n} \\ \\vdots &amp; \\ddots &amp; \\vdots \\ \\frac{\\partial y_m}{\\partial x_1} &amp; \\cdots &amp; \\frac{\\partial y_m}{\\partial x_n} \\end{bmatrix}$$ 此矩阵表示为: ${J_F}({x_1}, \\ldots ,{x_n})$,或者$\\frac{ {\\partial {({y_1}, … ,{y_m})} } } { {\\partial {({x_1}, … ,{x_n})} } }$. hexo 两个{之间要加空格不然会报错: expected variable end 如果$p$是$R_n$中的一点，$F$在$p$点可微分，那么这一点的导数由$J_F(p)$给出.在此情况下, 由$F(p)$描述的线性算子即接近点$p$的$F$的最优线性逼近, $x$逼近于$p$: $$ F({\\bf{x} }) \\approx F({\\bf{p} }) + {J_F}({\\bf{p} }) \\cdot ({\\bf{x} } – {\\bf{p} }) $$ 二阶导数：海森矩阵 海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下：$$f({x_1},{x_2} \\ldots ,{x_n})$$如果$f$所有的二阶导都存在，那么有：$$H{(f)_{ij} }(x) = {D_i}{D_j}f(x)$$也就是:$$\\begin{bmatrix}\\frac{\\partial^2 f}{\\partial x_1^2} &amp; \\frac{\\partial^2 f}{\\partial x_1\\,\\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_1\\,\\partial x_n} \\ \\\\frac{\\partial^2 f}{\\partial x_2\\,\\partial x_1} &amp; \\frac{\\partial^2 f}{\\partial x_2^2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_2\\,\\partial x_n} \\ \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ \\\\frac{\\partial^2 f}{\\partial x_n\\,\\partial x_1} &amp; \\frac{\\partial^2 f}{\\partial x_n\\,\\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_n^2}\\end{bmatrix}$$ 链式法则的式子里面有转置的原因可以从维度的角度来思考; 奇异值 共轭:$z=a+bi$,z的共轭$\\bar{z}=a-bi$;实数的共轭是他自身; 矩阵概念: 对称矩阵: $A^T=A$ Hermite矩阵，将实数范围讨论的对称矩阵延伸到复数范围: 其中，用$\\bar{A}$表示以$A$的元素的共轭复数为元素构成的矩阵,那么$A^H=(\\bar{A}^T)$，这个称作$A$的复共轭转置矩阵; 特征值都是实数。 任意两个不同特征值所对应的特征向量正交。 正交矩阵: $A^TA=E$ 酉矩阵: $A^HA=E$ 这玩意其实就是正交矩阵在复数范围的推广 奇异矩阵: $|A|=0$称作奇异矩阵，否则称作非奇异矩阵;$A$是可逆矩阵的充要条件是$|A|\\neq0$,因此可逆矩阵就是非奇异矩阵 正规矩阵: $A^HA=AA^H$,如果都是实数矩阵，那么$A^T=A^H,A^TA=AA^T$ 幂等矩阵: $A^2=A$ 正定矩阵:它是对称矩阵/Hermite矩阵的进一步延伸 设$A$为n阶Hermite矩阵，如果对任意n维复向量$x$都有$x^HAx\\ge 0$,则称A是半正定矩阵;如果对任意n维复向量$x$都有$x^HAx&gt; 0$,则称A是正定矩阵。 Hermite矩阵$A$为正定（半正定）矩阵 $\\leftrightarrow$$A$的所有特征值是正数（非负数）。 Hermite矩阵$A$为正定矩阵 $\\leftrightarrow$存在n阶非奇异矩阵$P$，使得$A=P^HP$ Hermite矩阵$A$为半正定矩阵$\\leftrightarrow $存在n阶矩阵$P$，使得$A=P^HP$ 特征值与特征分解: 特征值特征向量定义：$\\lambda$是特征值,$x$是特征向量,A是方阵$$Ax=\\lambda x$$求解走: $Ax=\\lambda x\\rightarrow Ax=\\lambda E x\\rightarrow (\\lambda E-A)x=0\\rightarrow|\\lambda E-A|=0$解出特征值带入得到特征向量 特征分解:对于mxm的满秩对称矩阵A$$A=Q\\Sigma Q^{-1}=Q\\Sigma Q^T$$其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。 特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。 奇异值与奇异值分解 运用到的理论: 对于n阶方阵，$Ax=\\lambda x$; 如果$\\vec{a}$与$\\vec{b}$正交,那么有$\\vec{a} \\cdot \\vec{b} = 0$ 一个内积空间的正交基（orthogonal basis）是元素两两正交的基,基中的元素称为基向量。如果一个正交基的基向量的模长都是单位长度1，则称这正交基为标准正交基或”规范正交基”（Orthonormal basis）； A与A的转置矩阵是有相同的特征值,但是他们各自的特征向量没有关系； SVD推导之矩阵分解: 对于矩阵$A$,有$A^TA = \\lambda_{i} v_{i}$(因为$A^TA$肯定是方阵);$\\lambda_i$是特征值,$v_i$是特征向量;假设$(v_{i}, v_{j})$是一组正交基，那么有$v_{i}^{T} \\cdot v_{j} = 0$，那么:$$\\begin{align} (Av_{i}, Av_{j}) &amp;= (Av_{i})^{T} \\cdot Av_{j} \\ &amp;= v_{i}^{T} A^T Av_{j} \\ &amp;= v_{i}^{T} \\lambda_{j} v_{j} \\ &amp;= \\lambda_{j} \\color{red}{v_{i}^{T} v_{j} } \\ &amp;= 0 \\end{align} \\tag{1}$$可以得到$Av_{i}, Av_{j}$;根据公式$(1)$可以推导得到$(Av_{i}, Av_{i}) = \\lambda_{i} v_{i}^{T} v_{i}=\\lambda_{i}$;又因为行列式的性质$|AB|=|A||B|\\rightarrow|(Av_{i})^{T} \\cdot Av_{i}|=|Av_{i}^{T} ||Av_{i}|=|Av_{i}|^2$,所以有:$$\\begin{align} &amp; |Av_{i}|^2 = \\lambda_{i} \\ &amp; |Av_{i}| = \\sqrt{\\lambda_{i} } \\end{align} \\tag{2}$$根据公式(2),有$\\frac{Av_{i} }{|Av_{i}|} = \\frac{1}{\\sqrt{\\lambda_{i} } } Av_{i}$，令$\\frac{1}{\\sqrt{\\lambda_{i} } } Av_{i}= u_{i}$,可以得到:$$Av_{i}= \\sqrt{\\lambda_{i} }u_{i}=\\delta_{i}u_{i} \\tag{3}$$其中$\\delta_{i} = \\sqrt{\\lambda_{i} }$（这个称作奇异值）,进一步推导成矩阵形式:$$\\begin{align} AV &amp;= A(v_{1}, v_{2}, \\dots, v_{n} ) \\ &amp;= (Av_{1}, Av_{2}, \\dots, Av_{n} ) \\ &amp;= (\\delta_{1}u_{1}, \\delta_{2}u_{2}, \\dots, \\delta_{n}u_{n} ) \\ &amp;= U\\Sigma \\end{align} \\tag{4}$$从而得到:$$A = U\\Sigma V^T \\tag{5}$$ SVD推导之矩阵计算: 已知$A$怎么算$U$和$V$呢？ 首先计算$A$的转置$A^T$,而$A^T$相当于:$$\\begin{align} A^T = V\\Sigma^TU^T \\end{align} \\tag{6}$$然后计算$A^TA$:$$\\begin{align} A^TA &amp;= V\\Sigma^TU^T U\\Sigma V^T \\ &amp;= V\\Sigma^2V^T \\end{align} \\tag{7}$$通过公式(7),会发现这不就是特征值分解嘛！！！可以得到$A^TA v_{i} = \\lambda_{i}v_{i}$,只需要求出$A^TA$的特征向量就可以得到$V$了 同理计算$AA^T:$$$\\begin{align} A A^T &amp;= U\\Sigma V^T V\\Sigma^TU^T \\ &amp;= U\\Sigma^2U^T \\end{align} \\tag{8}$$ 通过公式(8),可以得到$AA^T u_{i} = \\lambda_{i}u_{i}$,只需要求出$AA^T$的特征向量就可以得到$U$了 $\\Sigma$是上面公式(7)或者公式(8)中求到的非零特征值从大到小排列后开根号的值 SVD计算例子: 假设有一个矩阵$A$:$$A=\\begin{bmatrix} 1&amp;1\\1&amp;1\\0&amp;0\\end{bmatrix}$$要计算:$$A_{3\\times 2}=U_{3\\times 3}\\Sigma_{3\\times2}V^T_{2\\times 2}$$中的$U,V,\\Sigma$ 计算$U$ $AA^T=\\begin{bmatrix} 2&amp;2&amp;0\\2&amp;2&amp;0\\0&amp;0&amp;0\\end{bmatrix}$,进行特征分解，得到特征值[4,0,0]以及对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T,[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T,[0,0,1]^T$,可以得到：$$U=\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}}&amp;0 \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}&amp;0 \\ 0&amp;0&amp;1 \\end{bmatrix}$$ 计算$V$ $A^TA=\\begin{bmatrix} 2&amp;2 \\ 2&amp;2 \\end{bmatrix}$,进行特征分解,得到特征值[4,0]以及对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T,[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T$,可以得到:$$ V=\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}} \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}\\end{bmatrix}$$ 计算$\\Sigma$ 因为特征值是[4,0]，因此:$$ \\Sigma=\\begin{bmatrix} 2&amp;0 \\ 0&amp;0 \\ 0&amp;0 \\end{bmatrix}$$ 所以$A$的SVD分解是:$$ A=U \\Sigma V^T= \\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}}&amp;0 \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}&amp;0 \\ 0&amp;0&amp;1 \\end{bmatrix} \\begin{bmatrix} 2&amp;0 \\ 0&amp;0 \\ 0&amp;0 \\end{bmatrix} {\\begin{bmatrix} \\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}} \\ \\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}\\end{bmatrix}}^T=\\begin{bmatrix} 1&amp;1\\1&amp;1\\0&amp;0\\end{bmatrix}$$ 代码求解方法: 123import numpy as npA=np.array([1,1],[1,1],[0,0])print(np.linalg.svd(A)) 以下主要是优化的部分 拉格朗日乘子法 To be done Chapter 2空间 假设空间 假设满足XX条件的是好瓜 版本空间 有限训练集，已知XX是好瓜 归纳偏好 假设空间和训练集一致的假设 学习过程中对某种类型假设的偏好称为归纳偏好 No Free Lunch 奥卡姆剃刀：两个模型效果同样好，选择较为简单的 模型评估与选择 经验误差与过拟合 错误率率&amp;误差 错误率：错份样本的占$E=a/m$ 误差：样本真实输出与预测输出之间的差异 训练（经验）误差：训练集上 测试误差：测试集 泛化误差：初训练集外所有样本 过拟合 学习器把训练样本学习的“太好”，将训练样本本身的特点当作所有样本的一般性质，导致泛化性能下降 优化目标加正则项 Early stop 欠拟合 对训练样本的一般性质尚未学好 决策树：扩展分支 神经网络：增加训练层数 评估方法 留出法 直接将数据集划分为两个互斥集合 训练/测试集划分要尽可能保持数据分布的一致性 一般若干次随机划分，重复实验取平均值 训练/测试样本比例通常为2:1～4:1 交叉验证法 将数据集分层采样划分为$k$个大小相似的互斥子集 自助法 以自助采样法为基础，对数据集$D$有放回采样$m$次得到训练集$D^{\\prime}$，$D\\backslash D^{\\prime}$用作测试集 性能度量 性能度量是衡量模型泛化能力的评价标准，反映任务的需求 回归任务最常用的是“均方误差”： $E(f:D)=\\frac{1}{m}\\sum_{i=1}^{m}(f(x_i)-y_i)^{2}$ 查准率 $P=\\frac{TP}{TP+FP}$ 查全率 $R=\\frac{TP}{TP+FN}$ $P-R$曲线 $F1$ measure：$\\frac{2\\times TP}{N+TP-TN}$ $AUC=\\frac{1}{2}\\sum_{i=1}^{m-1}(x_{i+1}-x_{i})\\cdot(y_{i}+y_{i+1})$，预测了排序质量 代价敏感错误率 性能评估 关于性能比较 测试性能并不等于泛化性能 测试性能随着测试集的变化而变化 很多机器学习算法本身有一定的随机性 直接选取相应评估方式在相应条件下评估并不可靠 二项检验 泛化错误率为$\\epsilon$，测试错误率为$\\hat{\\epsilon}$，嘉定测试样本从样本总体分布中独立采样而来，我们可以使用“二项检验”，对于$\\epsilon&lt;epsilon_{0}$进行假设检验。 假设$\\epsilon\\leq\\epsilon_{0}$，若测试错误率小于 $t$检验 交叉验证$t$检验 偏差和方差 对于测试样本$x$，令$y_{D}$为$x$在数据集中的标记，$y$为$x$的真实标记，$f(x;D)$为训练集$D$上学的模型$f$在$x$上的预测输出。 以回归任务为例： 期望预期为：$\\bar{f}(x)=\\mathbb{E}_{D}[f(x;D)]$； 使用样本数目相同的不同训练集产生的方差为$var(x)=\\mathbb{E}_{D}[(f(x:D)-\\bar{f}(x))^{2}]$； 噪声为$\\varepsilon^{2}=\\mathbb{E}{D}[(y{D}-y)^{2}]$ $E(f;D)=bias^{2}(x)+var(x)+\\varepsilon^2$ Chapter 3基本形式 线性模型一般形式$f(x)=w_1x_1+w_2x_2+\\cdots+w_dx_d+b$ 向量形式$f(x)=w^{T}x+b$ 区分猫狗的例子 按照像素行堆叠或列堆叠，成为一个向量 乘以单位，对于二分类问题，单位就是一个向量 Perceptron感知机 对于线性分类器，误分类则$-y_{1}(w\\cdot x_i)+b&gt;0$ 定义损失函数$L(w,b)=-\\sum_{x_{i}\\in M}y_{i}(w\\cdot x_{i}+b)$ 梯度$\\bigtriangledown_{w}L(w,b)=-\\sum_{x_{i}\\in M}y_{i}x_{i}$ $\\bigtriangledown_{b}L(w,b)=-\\sum_{x_{i}\\in M}y_{i}$ 梯度下降法 一阶方法 考虑无约束优化$min_{x}f(x)$，$f(x+\\Delta x)\\approx f(x)+\\Delta x^{T}\\bigtriangledown f(x)$ $\\Delta x^{T}\\bigtriangledown f(x)&lt;0$ $\\Delta x=-\\gamma \\bigtriangledown f(x)$ $\\gamma$使用二分查找法进行查找 优点 形式简单，易于建模 可解释性 非线性模型的基础 引入层级结构或高维映射 缺陷 解决不了$x^{2}$问题 线性回归 目的：学得一个线性模型以尽可能准确地预测实值输出标记 离散属性处理 有“序”关系 连续化为连续值 无“序”关系 单一属性的线性回归目标 $f(x)=wx_{i}+b$使得$f(x_{i})\\simeq y_{i}$ 参数/模型估计：最小二乘法（Least square method） $(w^{},b^{})=arg\\ min_{(w,b)}\\sum_{i=1}^{m}(f(x_{i})-y_i)^2$ 最小化均方误差$E_{(w,b)}$ 多元线性回归 $f(\\hat{x_{i}})=\\hat{x_{i}}^{T}(X^{T}X)^{-1}$ $X^{T}X$不满秩，进行正则化 广义线性模型 一般形式：$y=g^{-1}(w^{T}x+b)$ $g$为联系函数(link function) 二分类问题 预测值与输出标记$z=w^{T}x+b$ 寻找函数将分类标记与线性回归模型输出联系起来 最理想的模型——单位阶跃函数 替代函数——对数几率函数（logistic function） $y=\\frac{1}{1+e^{-z}}$ 运行对数几率函数$y=\\frac{1}{1+e^{-z}}=\\frac{1}{1+e^{-(w^{T}x+b)}}$ 对数几率 样本作为正例的相对可能性的对数$\\ln\\frac{y}{1-y}=\\ln\\frac{p(y=1|x)}{p(y=0|x)}=w^{T}x+b$ 极大似然法 给定数据集${(x_{i}, y_{i})}^{m}_{i=1}$ 最大化样本属于其真实标记的概率 线性判别分析（Linear Discriminant Analysis） 最大化目标$J=\\frac{|w^{T}\\mu_{0}-w^{T}\\mu_{1}|^{2}{2}}{w^{T}\\sum{0}w+w^{T}\\sum_{1}w}=\\frac{w^{T}(\\mu_{0}-\\mu_{1})(\\mu_{0}-\\mu_{1})^{T}w}{w^{T}(\\sum_{0}+\\sum_{1})w}$ 类间散度矩阵，类内散度矩阵 广义瑞丽商$J=\\frac{w^{T}S_{b}w}{w^{T}S_{w}w}$ 拉格朗日乘子法 $\\bigtriangledown f(x^{})+\\lambda \\Delta g(x^{})=0$ $L(x,\\lambda)=f(x)+\\lambda g(x)$. 多分类问题 多分类学习方法 二分类学习方法推广到多类 利用二分类学习器解决多分类问题 对问题进行拆分，为拆出的每个二分类任务训练一个分类器 对于每个分类器的预测结果进行集成以获得最终的多分类结果 拆分策略 一对一（OVO） $N$个类别两两配对，$N(N-1)/2$个二类任务 各个二类任务学习分类器，$N(N-1)/2$个二类分类器 一对其余（OVR） 多对多（MVM） 若干类作为正类，若干类作为反类 输出纠错码（Error Correcting Output Code, ECOC） 类别不平衡问题$(class\\ imbalance)$ 不同类别训练样例数相差很大情况（正类为小类） 类别平衡正例预测$\\frac{y}{1-y}&gt;1\\Rightarrow \\frac{y}{1-y}&gt;\\frac{m^{+}}{m^{-}}$正负类比例 再缩放 欠采样$(undersampling)$ 去除一些反例使正反例数目接近 过采样$(oversampling)$ 增加一些正例使正反例数目接近 阈值移动$(threshold-moving)$ Chapter4 决策树4.1 基本流程决策树基于树结构来进行预测 如果用决策树来进行分来,起码该模型一定意义上是可以理解的 树结构的return(1)当前节点包含的样本全部属于同一类别(没必要分类)(2)当前的属性集为空,或所有样本所有属性上取值相同(没法分类)(3)当前节点包含的样本集合为空($ \\emptyset $)4.2划分选择 希望决策树的分支节点包含的样本尽可能属于同一类别,即节点的”纯度”(purity)越来越高 经典的属性划分方法:1)信息增益,2)增益率,3)基尼指数 划分选择-信息增益 “信息熵”是度量样本集合纯度最常用的一种指标 信息熵 $$Ent(D)=-\\sum_{k=1}^{|y|}p_klog_2p_k$$ 推导:$$\\int P(x)f(x)dx\\rightarrow E_{x - p}(f(x))\\rightarrow E_{x-p} (log_2 \\frac{1}{p_k})$$ (log2可以表示用二进制表示,$\\frac{1}{p_k}$可以显示信息(概率越低越刺激)) 计算信息熵的约定:若p=0,则Ent=0 Ent(D)的值越小,纯度越大 信息增益 $$Gain(D,a)=Ent(D)-\\sum_{v=1}^{V}\\frac{|D^{v}|}{|D|}Ent(D^{v})$$ 算出信息增益之后,可以确定树的每一层应该对应哪些划分属性 存在的问题 信息增益对可取值数目较多的属性有所偏好 划分选择-增益率 增益率：$$Gain_ ratio (D,a)=\\frac{Gain(D,a)}{IV(a)}$$其中 $$IV(a)=-\\sum _{v=1}^{V}\\frac{D^v}{D}log_2 \\frac{D^v}{D}$$ 存在的问题 增益率准则对可取值数目较少的属性有所偏好 划分选择-基尼指数 $$ Gini(D)=\\sum_{k=1}^{|y|}\\sum _{k’\\neq k}p_kp_{k’}=1-\\sum_{k=1}^{|y|}p_k^{2}$$ Gini越小纯度越高 4.3剪枝处理 为了对抗过拟合 基本策略 预剪枝 后剪枝 判断决策树泛化性能是否提升的办法 留出法#####预剪枝 优点 降低过拟合风险 显著减少训练时间和测试时间开销 缺点 欠拟合风险#####后剪枝 优点 比预剪枝保留了更多的分支,欠拟合风险小,泛化性能往往由于预剪枝决策树 缺点 时间开销4.4连续与缺失值连续与缺失值-连续值处理 连续属性离散化(二分法) 缺失值处理 面临两个问题 如何划分,如何测试 4.5多变量决策树Chapter 55.1 神经网络模型与发展史 第一阶段 M-P模型 Hebb学习规则:类似于巴普洛夫,if input and output 同时激活或者失活, 那么这两个神经元的链接应该被加强,else 应该减弱 感知机网络 自适应神经元,最小均方学习算法 GG 1: 单层的神经网络不能解决非线性问题,多层神经网络算力不足的时候就输了 第二阶段 Hopfield 网络 反向传播算法 SVM与统计学习理论 第三阶段 DBN深度信念网络 神经元模型 M-P神经元模型 输入:来自其他n个神经元传递过来的输入信号 处理:输入信号通过带权重的连接进行传递,神经元接收到的总输入值将与神经元的阈值进行比较 输出:通过激活函数的处理以得到输出:$y=f(\\sum _{i=1}^{n}w_ix_i-\\theta)$ 扯一点signmoid(x)=$\\frac{1}{1+e^{-x}}$$y’=\\frac{1}{1+e^{-x}}’=\\frac{1}{1+e^{-x}}\\times \\frac{e^{-x}}{1+e^{-x}}=y(1-y)$ 5.2 感知机与多层网络 感知机 由两层神经元组成,输入层接受外界输入信号传递个输出层,输出层是M-神经元 与或非 多层感知机 多层前馈神经网络 定义:每层神经元与下一层神经元全互联 前馈:输入层接受外界输入,隐含层与输出层神经元对信号进行加工,最终结果由输出层神经元输出 5.3 误差逆传播算法 误差逆传播算法(BP) 前向计算: $b_h=f(\\beta _h -y_h ),\\beta h=\\sum{i=1}^{d}v_{ih}x_i$ $\\hat{y}_i^{k}=f(a_j-\\theta _j),\\alpha_h=\\sum_{i=1}^{d} w_{hj}b_{h}$ $E_k=\\frac{1}{2}\\sum_{j=1}^{l}(\\hat{y}{j}^{k}-\\hat{y}{j}^{k})^{2}$ 参数数目 权重:$v_{ih},w_{hj}$, 阈值:$\\theta {j}$,$y{h}$ (i=1,…,d,h=1,…,q,j=1,…,l)因此网络中需要(d+l+1)q+l个参数需要优化 参数优化 BP是迭代学习算法,在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计,任意的参数v的更新估计式为$$v\\leftarrow v+\\Delta v$$ 梯度咋整? 梯度消失咋整? 因为本质上还是函数的复合,因此不能用线性函数做传递函数 一些BP算法 标准BP算法:每来一个样本,就扔到bp网络中,然后前馈得到误差,得到误差之后就逆传递回来更新网络…… 累计BP算法:用平均误差更新权值,一定意义上可以减少震荡 实际应用: Mini BP 一块一块更新 多层前馈网络: 局限: 可能遭遇过拟合 到底搞几层？ 解决过拟合策略： 正则化 早停 5.4 全局最小与局部极小 策略 使用”模拟退火” 随机梯度下降 遗传算法 5.5 其他常见神经网络 RBF网络:单隐层,激活函数与输入向量有关:$$\\phi(x)=\\sum^{q}_{i=1}w_i\\rho(x,c_i)$$$\\rho(x,c_i)$是径向基函数：$$\\rho(x,c_i)=e^{-\\beta_i ||x-c_i||^{2}}$$ ART网络：自适应谐振理论竞争性学习网络,输出神经元互相竞争,遵循胜者通吃原则比较层,识别层(???) SOM网络：获取数据内在的结构 级联相关,或则隐层节点的构造 Elman网络：递归神经网络 Chapter 6: 支持向量机传奇——一刀999神经网络(1989-1994)(BP算法)———–&gt;支持向量机 (1995-2005)(核方法,统计学习)(Vapnik)———&gt; 神经网络(2006-今)(深度学习) 支持向量机 灵活（核方法） 能力很强 数学理论坚实 全局最优解 不需要人工调参 神经网络 更灵活 能力很强 理论不清,来自认知 局部最优解 非常依赖人工调参 支持向量机(SVM) 计算开销大 领域知识嵌入困难(对现象的认识) 服务于科学界 神经网络(NN) 可大可小 领域知识无处不在 服务于工业界 6.1 间隔与支持向量 最大间隔: 寻找参数$w$,b,使得$\\nu=\\frac{2}{||w||}$ 最大 $$arg~max_{w,b}~\\frac{2}{||w||}$$ s.t. $y_i(w^{T}x_i+b)\\geq 1,i=1,2,…,m$ $$arg~min~\\frac{1}{2}||w||^{2}$$ s.t. $y_i(w^{T}x_i+b) \\geq 1,i=1,2,…,m$ 6.2 对偶问题 拉格朗日乘子法 三步 解的稀疏性 最终模型:$f(x)=w^Tx+b=\\sum_{i=1}^{m}a_iy_ix_{i}^{T}x+b$ KKT条件: $${\\begin{cases}a_i\\geq 0\\y_if(x_i)\\geq 1\\a_i(y_if(x_i)-1)=0\\end{cases}}$$ SMO-求解方法,选两个固定搞，因为两个有闭式解； 6.3 核函数 从低维映射到高维可以用线性的方式进行分类，只要维数足够高，高维的空间总可以线性的来分类； 将x映射到$\\phi(x)$转换前面的最终模型为:$f(x)=w^Tx+b=\\sum_{i=1}^{m}a_iy_i\\phi(x)_{i}^{T}\\phi(x)+b$ 定义核函数:$k(x_i,x_j)=\\phi(x_i)^{T}\\phi(x_j)$ 定义核矩阵:$$K= {\\left[ \\begin{matrix} k(x_1,x_1) &amp; k(x_1,x_2) &amp; … &amp; k(x_1,x_n)\\ k(x_2,x_1) &amp; k(x_2,x_2) &amp; … &amp; k(x_2,y_n) \\ …&amp;… &amp; … &amp; .. \\ k(x_n,x_1) &amp; k(x_n,x_2) &amp; … &amp; k(x_n,y_n) \\end{matrix} \\right]} $$ 6.4 软间隔与正则化 黑人问号，谜の调参(C) 6.5 支持向量回归 因为听不懂所以自闭了 感觉大概推了一个神奇的二次回归吧 6.6 核方法 表示定理：对于任意单调增函数$\\Omega$和任意非负损失函数l,优化问题…… Chapter 7 :贝叶斯7.1 贝叶斯决策论概率框架下实施决策的基本理论： 条件风险 $R(c_i|x)=\\sum_{j=1}^{N}\\lambda _{ij}P(c_j|x)$ 贝叶斯判定准则 $h^{*}(x)=argmin_{c\\in \\gamma} ~R(c|x)$ $h^*(x)$:贝叶斯最优分类器, 反应了机器学习所能产生的模型精度的理论上限 P(c|x)在现实中通常难以直接获得 两种基本策略： 判别式模型：直接对P(c|x)建模 决策树 BP神经网络 SVM 生成式模型：先对联合概率分布P(x,c)建模,再由此获得P(c|x) $P(c|x)=\\frac{P(x.c)}{P(x)}$ 贝叶斯定理 后验概率与联合概率分布的关系： $P(c|x)=\\frac{P=(x,c)}{P(x)}$ $P(c|x)=\\frac{P(c)P(x|c)}{P(x)}=\\frac{P(c)P(x|c)}{\\int P(c)P(x|c)~dc}$ P(c):先验概率(人群中得病概率为1/1000000) P(x):证据 P(c|x):后验概率(医院看到了症状之后判断的概率) P(x|c): likehood 似然(重点在另外的变量$\\theta$上) ,likehood function目的是求$\\theta$ Prob(重点在变量上面) 7.2极大似然估计fenleiqifenleiqi（不太懂 https://blog.csdn.net/chenjianbo88/article/details/52398181 7.3 朴素贝叶斯分类器(naive Bayes classifier)假定属性独立地对分类结果发生影响 $$P(c|x)=\\frac{P(c)P(x|c)}{P(x)}=\\frac{P(c)}{P(x)}\\Pi^{d}_{i=1}P(x_i|c)$$ P(c)=$\\frac{D_c}{D}$ $P(x_i|c)=\\frac{D_{c,x_i}}{D_c}$ 拉普拉斯修正(为了解决某一个属性值在训练集中没有与某个类同时出现过就凉了 所以要假设出现了一次) $\\hat{P(c)}=\\frac{|D_c|+1}{|D|+N}$ $\\hat{P(x_i|c)}=\\frac{|D+{c_i,x_i}|+1}{|D_c|+N_i}$ hint: 连续的分布用概率密度来代替,(一般用高斯分布) 7.4 半朴素贝叶斯分类器One - Dependent Esitimator SPODE 超父带你飞 TAN 计算条件互信息 $I(x_i,x_j|y)=\\sum _{x_i,x_j;c\\in \\gamma}P(x_i,x_j|c)log\\frac{P(x_i,x_j|c)}{P(x_i|c)P(x_j|c)}$ 建完全图,权重设为上面的I 构建最大带权生成树,挑选根变量,将变置为有向 加入类别节点y,增加从y到每一个属性的有向边 AODE 7.5 贝叶斯网（概率论知识反应不能,To be continued V型例子:各位的智商x1 考试难度x2 最后的考试成绩x4,考完结果出来x1,x2就不独立了 道德图(从marriage的梗里面获得) Chap 8 集成学习​ ​ PS：使用https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/ 里面的方法解决了博客的数学公式显示问题","tags":[{"name":"ML","slug":"ML","permalink":"http://tyler-ytr.github.io/tags/ML/"}]},{"title":"数学期望","date":"2021-02-23T09:24:41.000Z","path":"2021/02/23/数学期望/","text":"离散型:$\\sum _{k=1}^{\\infty}x_kp_k$,需要它绝对收敛; 连续型:$\\int_{-\\infty}^{\\infty}xp(x)dx$,同样需要它绝对收敛,如果$\\int_{-\\infty}^{\\infty}|x|p(x)dx$发散,则X的数学期望不存在 Gamma函数:$$\\Gamma(x)=\\int_{0}^{+\\infty}t^{x-1}e^{-t}$$ $\\Gamma(1)=1$ $\\Gamma(x+1)=x\\Gamma(x)$ $\\Gamma(n)=(n-1)!$ 高斯积分: $\\int_{-\\infty}^{+\\infty}e^{-x^2}dx=\\sqrt{\\pi}$ $C_{n}^{k}=\\frac{n!}{k!(n-k)!}$ $\\int \\frac{1}{1+x^2}=arctanx$ 数学期望 概率与数学期望及方差: 0-1分布:$X~B(1,p)$,$0&lt;p&lt;1$: E(x)=0(1-p)+1p=p D(X)=pq 二项分布:$X~B(n,p)$,$0&lt;p&lt;1$ $P{X=k}=C_{n}^kp^k(1-p)^{n-k},(k=0,1,…,n)$ $E(X)=np$ $E(X)$的证明注意$\\sum^{n-1}{s=0}C^{s}{n-1}p^s(1-p)^{n-1-s}=1$ $D(x)=npq$ 几何分布: P(X=k)=$p(1-p)^{k-1}$ E(x)= 泊松分布:X~$P(\\lambda),\\lambda&gt;0$ $P{X=k}=\\frac{\\lambda^{k}}{k!}e^{-\\lambda}$ E(X)=$\\lambda$ $E(x)$的证明注意$\\sum_{m=0}^{\\infty}\\frac{\\lambda^m}{m!}e^{-\\lambda}=1$(这是因为泊松分布概率的加和为1) D(X)=$\\lambda$ 均匀分布:X~$U(a,b)$ $\\begin{aligned}p(x)&amp;=\\frac{1}{b-a},a&lt;x&lt;b;\\&amp;=0,~~~~others;\\end{aligned}$ E(x)=$\\frac{a+b}{2}$ 指数分布:X~E($\\lambda$)$\\lambda&gt;0$, p(x)=$\\lambda e^{-\\lambda x}$,x&gt;0; E(x)=$\\frac{1}{\\lambda}$ 正态分布:X~N($\\mu,\\sigma^2$) p(x)=$\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},-\\infty&lt;x&lt;\\infty$ E(x)=$\\mu$ $\\mu$:平均值;$\\sigma^2$:X取值的离散程度 代换: 一维 E(Y)=E[g(X)]=$\\sum_{k=1}^{\\infty}g(x_k)p_k$(离散) E(Y)=E[g(X)]=$\\int_{-\\infty}^{+\\infty}g(x)p(x)dx$ 二维 E(Z)=E[g(X,Y)]=$\\sum_{j=1}^{\\infty}\\sum_{i=1}^{\\infty}g(x_i,y_i)p_{ij}$(离散型) E(Z)=E[g(X,Y)]=$\\int_{j=1}^{\\infty}\\int_{i=1}^{\\infty}g(x,y)p_{x,y}dxdy$(连续型) 边缘密度:E(g(X,Y)),g(X,Y)=x,E(x)=$\\int_{j=1}^{\\infty}\\int_{i=1}^{\\infty}xp_{x,y}dxdy$ 性质: E(X+Y)=E(X)+E(Y) if X,Y互相独立:E(XY)=E(X)E(Y) 设C是常数:E(C)=C 设k是常数:E(kx)=kE(x) 方差 D(X)=E{[X-E(X)]$^2$} D(X)=$\\sum_{k=1}^{+\\infty}[x_k-E(X)]^2p_k$ D(X)=$\\int_{-infty}^{+\\infty}[x_k-E(X)]^2p_k$ D(x)=E($X^2$)-$[E(x)]^2$ 性质: D(C)=0; C是常数 D(CX)=$C^2$D(X) D(X+C)=D(X) D(X),D(Y)存在: if 不独立:D($X\\pm Y$)=$D(X)\\pm +D(y)\\pm 2E{(X-E(X))(Y-E(Y))}$ else:D($X\\pm Y$)=$D(X)\\pm +D(y)$ 切比雪夫不等式: $P{|X-E(X)|\\geq \\varepsilon }\\leq \\frac{D(X)}{\\varepsilon ^2 }$ $P{|X-E(X)|&lt;&gt; \\varepsilon }\\geq 1- \\frac{D(X)}{\\varepsilon ^2 }$ D(X)=0 $\\Leftrightarrow $ P{X=C}=1","tags":[{"name":"概率论","slug":"概率论","permalink":"http://tyler-ytr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"p4学习-2:P4 basic实验","date":"2021-02-21T09:12:26.000Z","path":"2021/02/21/p4学习-2/","text":"P4学习-2：P4 basic实验实验目标 写一个P4程序完成基本的IPV4转发，也就是交换机需要:1.更新源和目的MAC地址 2. 在IP报头中减少 time-to-live(TTL) 3.将数据包转发到适当的端口 交换机有一个简单的table,控制平面将根据基本的规则更新它。每个规则将一个IP地址映射到下一跳的MAC地址和输出端口。我们已经定义了控制平面规则，所以你只需要实现你的P4程序的数据平面逻辑。 拓扑如下: 实验basic.p4给了一个p4程序，关键部分被TODO代替，这个程序主要由以下部分组成: Ethernet (ethernet_t) and IPv4 (ipv4_t)两个header type的类型定义 TODO：用于以太网和IPv4的Parser,它通过解析数据包填充了上述两个header; 一个丢包的动作，用了mark_to_drop() TODO：一个动作（ipv4_forward）： 设置下一跳的出口端口。 更新以太网目的地址为下一跳地址。 将以太网源地址更新为交换机地址。 TTL衰减。 TODO: 一个control: 定义一个表，该表将读取IPv4目的地址，并调用drop 或者ipv4_forward 应用这个表的一个 apply block 选择字段插入出数据包的顺序的Deparser。 实例化部分 通常，包还需要校验和验证和重新计算控件的实例。这些对于本教程来说不是必需的，它们将被空控件的实例化所取代。 代码部分本部分根据上面对程序的描述一一进行分析： headers部分:12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;* -*- P4_16 -*- *&#x2F; # 声明语言是p4-16#include &lt;core.p4&gt;#include &lt;v1model.p4&gt;const bit&lt;16&gt; TYPE_IPV4 &#x3D; 0x800;&#x2F;************************************************************************************************ H E A D E R S ************************************************************************************************************&#x2F;typedef bit&lt;9&gt; egressSpec_t;typedef bit&lt;48&gt; macAddr_t;typedef bit&lt;32&gt; ip4Addr_t;header ethernet_t &#123; # header数据结构相当于c语言里面的 packed struct,它有一个隐藏的参数validity，如果解析正确那么是true，可以通过isValid()获得，比如hdr.ipv4.isValid(); macAddr_t dstAddr;# macAddr_t是typedef bit&lt;48&gt; 的自定义类型 macAddr_t srcAddr; bit&lt;16&gt; etherType;&#125;header ipv4_t &#123; bit&lt;4&gt; version;#4bit的数据 bit&lt;4&gt; ihl; bit&lt;8&gt; diffserv; bit&lt;16&gt; totalLen; bit&lt;16&gt; identification; bit&lt;3&gt; flags; bit&lt;13&gt; fragOffset; bit&lt;8&gt; ttl; bit&lt;8&gt; protocol; bit&lt;16&gt; hdrChecksum; ip4Addr_t srcAddr; ip4Addr_t dstAddr;&#125;struct metadata &#123; #struct数据结构相当于python里面的 dictionary &#x2F;* empty *&#x2F; #这个实验用不到&#125;struct headers &#123; ethernet_t ethernet; ipv4_t ipv4;&#125; 其中V1model的结构如下图所示: 总的来说这是一个模板，大致由下图组成: 主要由HEADERS,PARSER,CHECKSUMVERFICATION,INGRESSPROCESSING,EGRESSPROCESSING,CHECKSUM UPDATE,DEPARSER,SWITCH组成;大概实例化的解释如下: 12345678V1Switch(MyParser(), &#x2F;&#x2F; 解析数据包，提取包头 MyVerifyChecksum(), &#x2F;&#x2F; 校验和验证MyIngress(), &#x2F;&#x2F; 输入处理MyEgress(), &#x2F;&#x2F; 输出处理MyComputeChecksum(), &#x2F;&#x2F; 计算新的校验和MyDeparser() &#x2F;&#x2F; 逆解析器) main; Parser部分1234567891011121314&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; state start &#123; &#x2F;* TODO: add parser logic *&#x2F; transition accept;#表示接受，也就是程序终止 &#125;&#125; 解答:123456789101112131415161718192021222324&#x2F;************************************************************************************************ P A R S E R ************************************************************************************************************&#x2F;parser MyParser(packet_in packet, out headers hdr, #out相当于输出的数据,然后它的type是headers inout metadata meta, #inout同时作为输入和输出值，类似 c++ 里面的引用 inout standard_metadata_t standard_metadata) &#123; state start &#123; transition parse_ethernet;#转移到解析以太包头阶段 &#125; state parse_ethernet&#123; packet.extract(hdr.ethernet); #把packet提取到hdr的ethernet里面，这里的过程可以理解为根据ethernet的长度截取一段数据 transition select(hdr.ethernet.etherType)&#123;#根据etherType的值选择进入的状态 TYPE_IPV4: parse_ipv4;#是IPV4包，进入解析ipv4的状态 default: accept; &#125; &#125; state parse_ipv4&#123; packet.extract(hdr.ipv4); #接着解析ipv4部分，这里可以理解为指针又往前移动了 transition accept; &#125;&#125; Ingress部分123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;************************************************************************************* C H E C K S U M V E R I F I C A T I O N **************************************************************************************&#x2F;control MyVerifyChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; &#125;&#125;&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分 &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; &#x2F;* TODO: fill out code in action body *&#x2F; &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; NoAction(); &#125; apply &#123; &#x2F;* TODO: fix ingress control logic * - ipv4_lpm should be applied only when IPv4 header is valid *&#x2F; ipv4_lpm.apply(); &#125;&#125; 解答: 1234567891011121314151617181920212223242526272829303132333435363738&#x2F;*************************************************************************************** I N G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; action drop() &#123; mark_to_drop(standard_metadata);#内置函数，将当前数据包标记为即将丢弃的数据包,standard_metadata的解释见PS部分 &#125; action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) &#123; standard_metadata.egress_spec&#x3D;port; #egress_spec可以在输入代码中指定一个值来控制数据包将去哪个输出端口 hdr.ethernet.srcAddr &#x3D; hdr.ethernet.dstAddr; #原数据包的源地址改为目的地址 hdr.ethernet.dstAddr &#x3D; dstAddr; #目的地址改为控制面传入的新的地址 hdr.ipv4.ttl &#x3D; hdr.ipv4.ttl - 1; #ttl要减去1 &#125; table ipv4_lpm &#123; key &#x3D; &#123; hdr.ipv4.dstAddr: lpm; &#125; actions &#x3D; &#123; ipv4_forward; drop; NoAction; &#125; size &#x3D; 1024; default_action &#x3D; NoAction(); &#125; apply &#123; if (hdr.ipv4.isValid()) &#123;# 隐藏的参数，判断解析是否成功 ipv4_lpm.apply(); &#125; &#125;&#125; PS:standard_metadata是v1model.p4里面定义的数据结构，在simple_switch的README里面进行了详细的解释,simple_switch是p4语言的一种架构，它大概的定义如下,其中v1m表示v1model,p4-16的一种模型，sm14是p4-14里面定义的模型 123456789ingress_port (sm14, v1m) - For new packets, the number of the ingress port on which the packet arrived to the device. Read only.packet_length (sm14, v1m) - For new packets from a port, or recirculated packets, the length of the packet in bytes. For cloned or resubmitted packets, you may need to include this in a list of fields to preserve, otherwise its value will become 0.egress_spec (sm14, v1m) - Can be assigned a value in ingress code to control which output port a packet will go to. The P4_14 primitive drop, and the v1model primitive action mark_to_drop, have the side effect of assigning an implementation specific value DROP_PORT to this field (511 decimal for simple_switch by default, but can be changed through the --drop-port target-specific command-line option), such that if egress_spec has that value at the end of ingress processing, the packet will be dropped and not stored in the packet buffer, nor sent to egress processing. See the &quot;after-ingress pseudocode&quot; for relative priority of this vs. other possible packet operations at end of ingress. If your P4 program assigns a value of DROP_PORT to egress_spec, it will still behave according to the &quot;after-ingress pseudocode&quot;, even if you never call mark_to_drop (P4_16) or drop (P4_14).egress_port (sm14, v1m) - Only intended to be accessed during egress processing, read only. The output port this packet is destined to.egress_instance (sm14) - Renamed egress_rid in simple_switch. See egress_rid below.instance_type (sm14, v1m) - Contains a value that can be read by your P4 code. In ingress code, the value can be used to distinguish whether the packet is newly arrived from a port (NORMAL), it was the result of a resubmit primitive action (RESUBMIT), or it was the result of a recirculate primitive action (RECIRC). In egress processing, can be used to determine whether the packet was produced as the result of an ingress-to-egress clone primitive action (INGRESS_CLONE), egress-to-egress clone primitive action (EGRESS_CLONE), multicast replication specified during ingress processing (REPLICATION), or none of those, so a normal unicast packet from ingress (NORMAL). Until such time as similar constants are pre-defined for you, you may copy this list of constants into your code.parser_status (sm14) or parser_error (v1m) - parser_status is the name in the P4_14 language specification. It has been renamed to parser_error in v1model. The value 0 (sm14) or error.NoError (P4_16 + v1model) means no error. Otherwise, the value indicates what error occurred during parsing.parser_error_location (sm14) - Not present in v1model.p4, and not implemented in simple_switch.checksum_error (v1m) - Read only. 1 if a call to the verify_checksum primitive action finds a checksum error, otherwise 0. Calls to verify_checksum should be in the VerifyChecksum control in v1model, which is executed after the parser and before ingress. Egress部分123456789&#x2F;***************************************************************************************** E G R E S S P R O C E S S I N G ********************************************************************************************&#x2F;control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) &#123; apply &#123; &#125;&#125; Checksum 部分1234567891011121314151617181920212223&#x2F;************************************************************************************** C H E C K S U M C O M P U T A T I O N ***************************************************************************************&#x2F;control MyComputeChecksum(inout headers hdr, inout metadata meta) &#123; apply &#123; update_checksum( hdr.ipv4.isValid(), &#123; hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr &#125;, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16); &#125;&#125;# 内置函数 Deparser部分123456789&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; &#x2F;* TODO: add deparser logic *&#x2F; &#125;&#125; 解答: 12345678910&#x2F;************************************************************************************************ D E P A R S E R ********************************************************************************************************&#x2F;control MyDeparser(packet_out packet, in headers hdr) &#123; apply &#123; packet.emit(hdr.ethernet);#按照顺序封装,emit的含义是发射 packet.emit(hdr.ipv4); &#125;&#125; 实例化部分12345678910111213&#x2F;************************************************************************************************ S W I T C H ********************************************************************************************************&#x2F;V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(),MyComputeChecksum(),MyDeparser()) main; 实验结果:pingall测试: image-20210223225105957","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"p4学习-1:介绍与参考资料","date":"2021-02-18T03:08:37.000Z","path":"2021/02/18/p4学习-1/","text":"P4学习-1：介绍与参考资料实验前 P4的PISA(Protocol-Independent Switch Architecture)结构： Programmable Parser—&gt;Programmable Match-Action Pipeline—&gt; Programmable Deparser； Parser作用:程序员声明应该被识别的头和它们在包中的顺序 Match-Action作用:程序员定义表和精确的处理算法 Deparser作用:程序员声明输出的包怎样输出到总线上 整个结构都是流水线架构，一个来自外部的网络数据包经过层层流程首先被Parser解析出headers,然后进入Match-Action Table进行匹配和操作，这些headsers可以被添加/修改/删除；然后进入Deparser组装好流入外部网络，因为是流水线，所以Match-Action部分是不可以回头的 ； 实验部分——文件结构:(主要参考博客) tutorials的文件结构: 1234tutorials&#x2F;├── exercises # 存放各种练习├── utils # 工具脚本目录└── vm # 用于vagrant构建虚拟机的目录，可以无视 例子的文件结构: 123456789101112131415# 我们切换进入 exercises&#x2F;basic_tunnel 这个例子basic├── basic_tunnel.p4 # 要编写的p4代码├── build # 生成文件的目录├── logs # 日志文件， 在调试的时候真的非常重要！├── Makefile ### 通过Makefile 来调用utils下的脚本!├── pcaps # 生成的pcap包，可以使用wireshark等工具来分析├── README.md # 详细的指导├── receive.py ## 利用scapy写的抓取和分析数据包的工具├── s1-runtime.json #├── s2-runtime.json # 在运行同时加载入交换机的控制面代码，这里有争议，稍后再谈├── s3-runtime.json #├── send.py ## 利用scapy写的构建和发送数据包的工具├── solution # 这里有这个例子的示例代码（答案）└── topology.json # 描述拓扑的json文件 这部分摘自参考资料的博客，实际情况有所不同 Makefile会调用前面提到的utils下面的Makefile脚本，运行P4代码; 使用make run 启动; 调用make run，我们可以运行当前目录下（以basic目录为例）的代码，它将执行以下几个步骤: 编译basic.p4 代码，生成basic.json 解析topology.json， 并且构建相应的mininet仿真拓扑，按照该拓扑启动一台或者多台BMv2交换机，以及一些host 启动BMv2的同时会将p4代码编译产生的json文件导入 启动BMv2后会解析 sN-runtime.json 文件(s1,s2,s3……)，将其载入 交换机sN流表之中 进入mininet命令行，同时开始记录log以及搜集pcap文件 P4的参考手册:https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html 参考资料 https://www.sdnlab.com/22512.html P4官方tutorial(https://github.com/p4lang/tutorials) P4学习笔记专栏","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"leetcode21-s","date":"2021-02-14T09:46:54.000Z","path":"2021/02/14/leetcode21-s/","text":"21. 合并两个有序链表难度简单1530 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： img 12输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4] 示例 2： 12输入：l1 &#x3D; [], l2 &#x3D; []输出：[] 示例 3： 12输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0] 123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1,l2=l2,l1 l1.next=self.mergeTwoLists(l1.next,l2) return l1 or l2","tags":[{"name":"递归","slug":"递归","permalink":"http://tyler-ytr.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"p4安装","date":"2021-02-07T08:25:10.000Z","path":"2021/02/07/p4安装/","text":"P4环境配置 因为之后使用的时候PI那块还是有问题，建议谨做参考，安装还是最好用一用官方的tuorials里面的虚拟机脚本 0.准备 基础环境ubuntu 18.04 LTS 使用trojan终端代理，不然一些下载太慢了 ubuntu换源到阿里云 在~目录新建P4目录并且加入环境变量 1234mkdir P4cd P4echo&quot;P4_HOME&#x3D;$(pwd)&quot;&gt;&gt; ~&#x2F;.bashrcsource ~&#x2F;.bashrc 安装依赖包 12sudo apt-get install -y cmake g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev libboost-graph-dev llvm pkg-config python python-scapy python-ipaddr python-ply tcpdump doxygen graphviz texlivesudo apt-get install g++ git automake libtool libgc-dev bison flex libfl-dev libgmp-dev libboost-dev libboost-iostreams-dev pkg-config python python-scapy python-ipaddr tcpdump cmake## 两个参考里面的可能有重复 下面都是在P4文件夹进行的工作 所有的make都巨慢，合理安排好时间 1. 安装依赖库protocol 参考了这个依赖库github的C++环境的README; 安装依赖并且git clone 12345sudo apt-get install autoconf automake libtool curl make g++ unzipgit clone https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf.gitcd protobufgit submodule update --init --recursive.&#x2F;autogen.sh 其中 git submodule update –init –recursive 必做，这会下载好相应的googletest文件，忽略这一步会在make check报错 然后build以及安装，下面步骤耗时较长: 12345.&#x2F;configuremakemake checksudo make installsudo ldconfig # refresh shared library cache.更新共享库 2. 安装PI以及它的依赖 参考PI的 github网站https://github.com/p4lang/PI 安装 首先安装gRPC V1.17.2 123456789git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;grpc.gitcd grpc&#x2F;git checkout tags&#x2F;v1.17.2git submodule update --init --recursive # 这步耗时较长，一定要代理make #也可以make -j4 表示用四个核make,j后面这个数量可以自己设定sudo make installsudo ldconfig# Install gRPC Python Package 这步安装挺慢的sudo pip install grpcio 然后安装PI –with-proto,（To include p4runtime.proto in the build, please run configure with --with-proto.） 123456.&#x2F;autogen.sh.&#x2F;configure --with-protomake make checksudo make installsudo ldconfig 3. 安装bmv2 建议先阅读原来的github库(https://github.com/p4lang/behavioral-model) 安装操作 1234cd ~&#x2F;P4git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;behavioral-model.gitcd behavioral-modelsudo .&#x2F;install_deps.sh #脚本安装依赖库 终端代理的好处在于这些脚本如果不是终端代理下载会异常慢以至于不得不手动转换到gitee安装 安装依赖库因为要编译其他第三方库也异常的慢 123456 .&#x2F;autogen.sh .&#x2F;configure --enable-debugger --with-pi make sudo make install sudo sudo ldconfigcd .. 4. 安装p4c 下载库 123456789cd ~&#x2F;P4git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;p4c.gitcd p4cmkdir buildcd buildcmake ..make -j4 #4线程编译sudo make installcd ..&#x2F;.. 这步如果make -j4后面make check 会花很多时间然后有可能报错 5. 下载p4 tutorials1git clone https:&#x2F;&#x2F;github.com&#x2F;p4lang&#x2F;tutorials 目前的目录: 12345678P4|——behavioral-model # BMv2 软件交换机|——grpc # 作为BMv2的依赖|——mininet # 网络仿真|——p4c #p4c编译器|——PI # PI P4 runtime库|——protobuf # 依赖|——tutorials #教程 6. 解决实验出现的bug在做实验的时候出现了陆陆续续的bug，还需要: No module named psutil 1234wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;p&#x2F;psutil&#x2F;psutil-2.1.3.tar.gz tar -zxvf psutil-2.1.3.tar.gz cd psutil-2.1.3 python setup.py install No module named google.protobuf.internal 1pip install protobuf 根据https://github.com/p4lang/behavioral-model/tree/main/targets/simple_switch_grpc 安装simple_switch_grpc 安装之后还是P4 switch s1 did not start correctly，根据issuehttps://github.com/p4lang/tutorials/issues/107 ，还需要： 1sudo ldconfig 至此可以编译basic实验 安装之后进行P4runtime的时候出现报错 ：No module named rpc 尚未解决 因此建议还是使用官方的vagrant PS: 最后发现其实最标准的安装操作是根据tutorials（https://github.com/p4lang/tutorials）里面的vm里面的两个脚本安装（为啥要手动还不是因为网速太慢 参考博客 https://p4.org/p4/getting-started-with-p4.html https://www.jianshu.com/p/2878192ba3f7 https://www.sdnlab.com/22512.html","tags":[{"name":"p4","slug":"p4","permalink":"http://tyler-ytr.github.io/tags/p4/"}]},{"title":"深度探索C++对象模型2","date":"2020-10-09T03:13:38.000Z","path":"2020/10/09/深度探索C-对象模型2/","text":"深度探索c++对象模型2这一章主要是编译器对于“对象构造过程”的干涉以及对于“程序形式”和“程序效率”的冲击 Default Constructor的构造操作 带有默认构造函数的Member Class Object 总结而言就是，如果对象a中依次有对象b，c，d，如果程序员仅仅初始化了c（10），那么编译器会调用b，d的默认构造函数，顺序是b，c（10），d；另外，对于对象g，假设里面只有int c;string d;编译器的隐式默认构造函数是不会帮忙解决这两者的初始化问题的，也就是这个构造函数是trivial的 带有默认构造函数的Base Class 一个类的构造函数，需要调用一些基类的构造函数（必要之默认构造函数），你自定义的构造函数，编译器会帮你补上调用那些构造函数的部分；先调用基类的默认构造函数然后调用成员类的默认构造函数 带有一个Virtual Function 的 Class 以下两种情况，需要编译器合成出default constructor class声明（或者继承）一个virtual constructor class派生自一个继承串链，其中有一个或者更多的virtual base classes以上两种情况如果缺乏用户声明的constructor，那么编译器会详细记录合成一个default constructor 的必要信息。主要有以下两种扩张行动： 一个虚函数表会被编译器产生出来，存放着类的虚函数地址 一个vptr会被编译器合成出来，包含着虚函数表的地址 带有一个Virtual Base Class 的 Class C继承A、B，A虚继承X，B虚继承X；根据不同编译器，在构造这些对象的时候会有类似指针的东西指向虚继承的类里面的成员，这些都是编译器在类对象构造期间完成的；对于这样的类所定义的每一个构造函数，编译器会安插那些“允许每一个virtual base class的执行期存取操作”的代码。如果class没有声明任何的constructors,编译器必须为它合成一个default constructor。； 总结： 上面四种情况，会造成：编译器必须为没有声明构造函数的类合成一个默认构造函数“，这些合成物被称为隐式非平凡默认构造函数(implicit nontrivial default constructors)。除此之外都是隐式平凡构造函数，实际上不会被合成出来。 在合成出来的这些构造函数里面，只有base class subobjects和member class objects会被初始化，其他的都不会。 Copy Constructor 的构造操作 下面三种情况，会以一个object的内容作为另一个class object的初值 显式地以一个对象的内容作为另一个类对象的初值 12X x;X xx&#x3D;x; 当对象被当做参数交给某一个函数的时候 当函数传回一个类对象的时候 如果类的设计者显式定义了一个拷贝构造函数，就会调用它 默认的拷贝构造函数 当类没有提供一个显示的拷贝构造函数时候使用，用递归的方式实行member initialization，比每一个内建的活着派生的data member的值从一个object拷贝到另一个上面。 下面讨论的是隐式的拷贝构造函数编译器是否会合成一个default copy constructor的问题。根据C++标准，决定一个copy constructor 是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。（只有nontrivial的实例才会被合成于程序里面。） bitwise copy semantics（位逐次拷贝） 什么时候一个class不展现出所谓的位逐次拷贝呢？ 一个class中有一个成员变量的class里面声明了一个copy constructor 这个class继承自一个基类，然后这个基类里面有一个copy constructor 当class声明了一个或者多个virtual functions（考虑vptr的拷贝问题） 当class派生自一个继承串链，其中有一个或者多个virtual base classes（发生在一个class object 以其derived classes的某一个对象作为初值的时候，编译器需要安插一些代码来设定virtual base class pointer/offset 的初值） 程序转化语义学（Program Transformation Semantics） 主要从初始化，参数初始化，返回值初始化三个角度探讨了拷贝构造函数的应用及应用的伪码； 显示初始化： 1234void foo_bar()&#123; X x1(x0); X x2&#x3D;x0; X x3&#x3D;X(x0); 转换成的可能的伪码： Alt 其中： 1x1.X::X(x0); //表现为对一下copy constructor 的调用： 1X::x(const X&amp; xx); 参数初始化：对于一下子调用方式： 1234void foo(X x0);X xx;&#x2F;&#x2F;...foo(xx) 可能的伪码： 123X __temp0;__temp0.X::X(xx);foo(__temp0); 返回值的初始化：对于以下函数： 12345X bar()&#123; x xx; &#x2F;&#x2F;.... return xx;&#125; 转化为如下伪码： NRV优化： NRV(name returned value)优化大致如下，我觉得是通过把返回的临时变量变成一个引用形参来实现的； NRV优化需要一个copy constructor,（最好是内联的提高效率) 最后探讨了copy constructor 要还是不要的问题，我觉得它的含义是，从速度角度来看，如果存在NRV优化的可能性，以及传值的要求，那么实现拷贝构造函数可以帮助实现这一点； 同时实现拷贝构造函数准备使用memcpy，memset的时候要注意是否有虚函数或者含有虚基类，防止错误的改变内部的vtpr; 比如下图： Alt Alt 成员初始化表 必须使用成员初始化表的四种情况： 当初始化一个reference member 当初始化一个const member; 当调用一个base class 的constructor，而它拥有一组参数的时候; 当调用一个member class的constructor，而它拥有一组参数的时候； 使用的注意点： 顺序问题，成员初始化表的初始化顺序是声明的顺序，因此如下代码会有bug: 12345678class X&#123; int i; int j; public: X(int val):j(val),i(j)&#123; ; &#125;&#125; 因为实际执行的时候是先i(j)然后j(val)的； 另外成员初始化表在显式代码的前面，因此 12345678class X&#123; int i; int j; public: X(int val):j(val)&#123; i&#x3D;j; &#125;&#125; 是合法的； 本书不太建议在成员初始化表里面调用一个member function进行初始化，主要因为不清楚具体的依赖关系的问题；当然如下图的伪代码，这是合法的： Alt -","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"http://tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"leetcode_478_m","date":"2020-09-25T09:13:45.000Z","path":"2020/09/25/leetcode478-m/","text":"478. 在圆内随机生成点难度中等37 给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。 说明: 输入值和输出值都将是浮点数。 圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。 圆周上的点也认为是在圆中。 randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。 示例 1： 1234输入: [&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;][[1,0,0],[],[],[]]输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]] 示例 2： 1234输入: [&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;][[10,5,-7.5],[],[],[]]输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]] 输入语法说明： 输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。 C++11新特性,随机数库,不香嘛？ https://blog.csdn.net/qq_23225317/article/details/79787543 基本语法: 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;std::random_device rd;std::default_random_engine e(rd());//e.seed(time(0));//随机整数std::uniform_int_distribution&lt;unsigned&gt; u(0, 9);//随机实数std::uniform_real_distribution&lt;double&gt; u2(0, 1);for(size_t i = 0; i &lt; 10; i++) std::cout&lt;&lt;u2(e)&lt;&lt;'\\t';//正态分布std::cout&lt;&lt;\"test normal distribution:\\n\";e.seed(time(0));std::normal_distribution&lt;&gt; n(4, 1.5);std::vector&lt;unsigned&gt; vals(9);for(size_t i = 0; i &lt; 250; i++)&#123; unsigned v = lround(n(e)); if(v &lt; vals.size()) vals[v]++;&#125;for(size_t i = 0; i &lt; vals.size(); i++)&#123; std::cout&lt;&lt;i&lt;&lt;\": \"&lt;&lt;std::string(vals[i], '*')&lt;&lt;std::endl;&#125;std::cout&lt;&lt;\"test normal distribution done.\\n\"&lt;&lt;std::endl;//伯努利分布std::cout&lt;&lt;\"test bernoulli distribution:\\n\";e.seed(time(0));std::bernoulli_distribution b(0.7);std::vector&lt;unsigned&gt; bers(2);for(size_t i = 0; i &lt; 200; i++)&#123; if(b(e)) bers[1]++; else bers[0]++;&#125;std::cout&lt;&lt;\"True: \"&lt;&lt;bers[1]&lt;&lt;std::endl;std::cout&lt;&lt;\"False: \"&lt;&lt;bers[0]&lt;&lt;std::endl;std::cout&lt;&lt;\"test bernoulli distribution done.\\n\"; 某一个题解: 相信大部分人都没有看懂，我就来通俗地解释一下吧。 确定圆内一点，需要有相对于圆心的距离r，以及相对于圆心的角度angle。 一开始的想法，我们在[0, radius]中等概率取r，在[0, 2π)中等概率取angle即可实现圆内的随机分布。 事实上，这是不对的。 在[0, 2π)中等概率取angle，相对于把一个圆分成了无数个扇形，点落在每个扇形上的概率均相等。 假设某个扇形的圆心角是theta，那么该扇形的面积是0.5 theta radius ^ 2，分布在该扇形区域上的概率是theta / 2π，只要每个扇形的圆心角相等，扇形面积就是相等的，点在扇形中也是等概率的。 在[0, radius]中等概率取r，相当于把一个圆分成了无数个环形，点落在每个环形上的概率均相等。 假设某个环形的内径是r1，外径是r2，那么该环形的面积是π * (r2 ^ 2 - r1 ^ 2)。可见每个环形的面积是不一样的，显然每个环形上的点密度是不一样的。这样做会造成靠近圆心的点分布比较密集，远离圆心的点分布比较稀疏。 那么，如何取r使得点落在圆内任意区域的概率均相等呢？这样做显然会使得落在每个环形上的概率均不同，且环形面积较大的概率高，环形面积较小的概率小。 根据环形面积的计算公式：π * (r2 ^ 2 - r1 ^ 2)，落在该环形面积上的概率应为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)。 在[0, radius]中如何分布概率密度函数f(x)，可以使得f(x)其在[r1, r2]上的积分值为(r2 ^ 2 - r1 ^ 2) / (radius ^ 2)呢？ 取f(x) = 2x / (radius ^ 2)可以满足上述条件，即半径r在[0, radius]上的概率密度函数应为f(x) = 2x / (radius ^ 2)，故只需要在[0, radius ^ 2]范围内等概率取r ^ 2，再开根号即得r值。（求一下导数即可，x ^ 2的导数是2x） 时间复杂度是和空间复杂度均是O(1)。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;private: double radius; double x_center,y_center; double _2pi;public://极坐标:x=rcos(\\theta),y=rsin(\\theta) Solution(double radius, double x_center, double y_center) &#123; this-&gt;radius=radius; this-&gt;x_center=x_center; this-&gt;y_center=y_center; this-&gt;_2pi=acos(-1)*2; &#125; vector&lt;double&gt; randPoint() &#123; vector&lt;double&gt;result; if(radius&gt;0)&#123; random_device rd; default_random_engine e(rd()); uniform_real_distribution&lt;double&gt;u1(0,radius*radius); uniform_real_distribution&lt;double&gt;u2(0,_2pi);//acos(-1)*2=2\\pi double r=sqrt(u1(e)); double theta=u2(e); double x=x_center+r*cos(theta); double y=y_center+r*sin(theta); result.push_back(x); result.push_back(y); &#125; return result; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(radius, x_center, y_center); * vector&lt;double&gt; param_1 = obj-&gt;randPoint(); */","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"name":"随机采样","slug":"随机采样","permalink":"http://tyler-ytr.github.io/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"}]},{"title":"leetcode_18_m 四数之和","date":"2020-09-25T08:19:56.000Z","path":"2020/09/25/leetcode18-m/","text":"18. 四数之和难度中等572 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，**b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 通过次数109,251 提交次数284,303 双指针法;主要要注意的是几个边界以及怎么去重的方法; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; //双指针法; //比O(n^4)的暴力减少了一些重复的内容; //算法是:固定a,b=a+1,然后c,d双指针遍历;然后b++……;然后b结束外层循环a++; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt;result; int size=nums.size(); if(size&lt;4)return result; int a,b,c,d; for(int a=0;a&lt;=size-4;++a)&#123; if(a&gt;0&amp;&amp;nums[a]==nums[a-1])continue; for(int b=a+1;b&lt;=size-3;++b)&#123; if(b&gt;a+1&amp;&amp;nums[b]==nums[b-1])continue; c=b+1; d=size-1; while(c&lt;d)&#123; if(nums[a]+nums[b]+nums[c]+nums[d]&lt;target)&#123; c++; &#125;else if(nums[a]+nums[b]+nums[c]+nums[d]&gt;target)&#123; d--; &#125;else&#123; result.push_back(&#123;nums[a],nums[b],nums[c],nums[d]&#125;); while(c&lt;d&amp;&amp;nums[c]==nums[c+1])&#123; c++; &#125; while(c&lt;d&amp;&amp;nums[d]==nums[d-1])&#123; d--; &#125; c++; d--; &#125; &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic_knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"HDU_4734 F(x)","date":"2020-09-20T12:19:26.000Z","path":"2020/09/20/HDU-4734/","text":"F(x)For a decimal number x with n digits (AnAn-1An-2 … A2A1), we define its weight as F(x) = An 2n-1 + An-1 2n-2 + … + A2 2 + A1 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). Input The first line has a number T (T &lt;= 10000) , indicating the number of test cases.For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109) Output For every case,you should output “Case #t: “ at first, without quotes. The t is the case number starting from 1. Then output the answer. Sample Input 123430 1001 105 100 Sample Output 123Case #1: 1Case #2: 2Case #3: 13 最开始的思路肯定是搜索 首先是对数位的搜索 然后开始思考另外有什么状态是需要往下面传的，那么就只有前面数的和了，因此是二维的，第一维度是数位，第二个维度是sum; 然后思考记忆化,最直观的就是第二维度就是sum,但是这样子的话每一次都需要根据all进行修改;比较特别的是dp里面的sum记录的是all-sum的值,这样做可以有效的利用memset优化; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstring&gt;int dp[12][5005];//dp[pos][sum]:对于位置pos的数位,这里的sum存储的是all-当前pos前缀和的差;int cur[12];int all;using namespace std;int f(int a)&#123;//计算F(a)的值 if(a==0)return 0; int pos=0; int able[11]; while(a)&#123; able[pos++]=a%10; a/=10; &#125; int result=0;// int now=1; for(int i=pos-1;i&gt;=0;--i)&#123; result+=(able[i]&lt;&lt;i); //now*=2; &#125; //cout&lt;&lt;\"result:\"&lt;&lt;result&lt;&lt;endl; return result;&#125;// pos:当前的数位,sum 当前的和/* if(pos&lt;0)return 1;合法; */int dfs(int pos,int sum,bool limit)&#123;//这里的sum表示的是到目前数位的前缀和 if(pos&lt;0)return sum&lt;=all; if(sum&gt;all)return 0; if(!limit&amp;&amp;dp[pos][all-sum]!=-1)return dp[pos][all-sum]; int up=limit?cur[pos]:9; int ans=0; for(int i=0;i&lt;=up;++i)&#123; ans+=dfs(pos-1,sum+i*(1&lt;&lt;pos),limit&amp;&amp;cur[pos]==i); &#125; if(!limit)dp[pos][all-sum]=ans;// cout&lt;&lt;pos&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;limit&lt;&lt;\" \"&lt;&lt;ans&lt;&lt;endl; return ans; &#125;int solve(int a,int b)&#123;// memset(cur,0,sizeof(cur)); all=f(a); int pos=0; if(b==0)return 0; while(b)&#123; cur[pos++]=b%10; b/=10; &#125; // for(int i=pos-1;i&gt;=0;--i)&#123; // cout&lt;&lt;cur[i]&lt;&lt;endl; // &#125; int result=dfs(pos-1,0,true); return result;&#125;int main()&#123; int t; //cin&gt;&gt;t; scanf(\"%d\",&amp;t); memset(dp,-1,sizeof(dp)); for(int i=0;i&lt;t;++i)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); //cin&gt;&gt;a&gt;&gt;b; int result=solve(a,b); // printf(\"Case #%d: %d\",i+1,result); printf(\"Case #%d: %d\\n\",i+1,result); // cout&lt;&lt;\"Case #\"&lt;&lt;i+1&lt;&lt;\": \"&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位dp","slug":"数位dp","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"}]},{"title":"HDU_2089 不要62","date":"2020-09-19T12:40:05.000Z","path":"2020/09/19/HDU-2089/","text":"不要62杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input 输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input 121 1000 0 Sample Output 180 经典的数位dp题目,数位dp我参考了数位dp总结 之 从入门到模板进行学习;总的来说的思想是对每一个数位进行枚举,然后辅之以记忆化搜索,以下是我根据板子做出来的结果; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int dp[10][2];int a[10];//pos:数位,pre:前一位什么数,state:前一位是不是6,如果是6那么就是1,否则是0;limit:防止超过最大数;为true的时候表示上一个到顶了;int dfs(int pos,int pre,int state,bool limit)&#123; if(pos&lt;0)&#123; return 1;//枚举合法 &#125; if(!limit&amp;&amp;dp[pos][state]!=-1)return dp[pos][state];//记忆化; int up=limit?a[pos]:9;//如果limit成功,那么前面的没有到顶,因此可以到9,否则只能到这个数位的值,比如231,前面枚举到3的时候,最后一位只有1可以; int ans=0;//计数; for(int i=0;i&lt;=up;++i)&#123; if(i==4)continue; if(pre==6&amp;&amp;i==2)continue; ans+=dfs(pos-1,i,i==6,i==up&amp;&amp;limit); &#125; if(!limit)dp[pos][state]=ans; return ans; &#125;int solve(int n)&#123;//分解数位 memset(a,0,sizeof(a)); int pos=0; while(n)&#123; a[pos]=n%10; n/=10; pos++; &#125; int result=dfs(pos-1,0,0,true); return result;&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp)); while(cin&gt;&gt;l&gt;&gt;r &amp;&amp;(l!=0||r!=0))&#123; int result=solve(r)-solve(l-1); cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位dp","slug":"数位dp","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"}]},{"title":"深度探索C++对象模型1","date":"2020-09-10T02:08:08.000Z","path":"2020/09/10/深度探索C-对象模型1/","text":"深度探索c++对象模型1 C++的主要额外负担： virtual function 机制 virtual base class 用以实现“多次出现在继承体系中的base class，又一个单一而被共享的实例” 多重继承下的额外负担 1.1 C++对象模式 C++对象模型 非静态成员变量存放在每一个class object里面，静态成员变量存放在个别的class object 之外；静态函数，非静态函数成员放在个别的class object之外，虚函数特殊对待： 每一个class 产生出一堆指向virtual function 的指针，放在表格中，这个表格称之为虚函数表（virtual table） 每一个class object被安插一个指针，指向相关的virtual table。通常这个指针称为$vtpr$.$vtpr$的设定由每一个class的constructor，destructor和copy assignment运算符自动完成。每一个class所关联的$tyle_info$ object(用来支持runtime type identification)也经由虚函数表纸出来，通常放在表格的第一个slot里面。例子如下 Alt C++继承 使用所谓的base table 模型。每一个class object内涵一个bptr,被初始化，指向它的base class table，然后这个表就如同虚函数表一样指向继承的类的对象，如下图 Alt 什么时候一个人应该使用struct 取代class？当它让一个人感觉比较好的时候（狗头）聚合（composition）而非继承才是把C++和C结合起来的好方法。struct在C++中的一个合理用途，是当你要传递一个“复杂的class object的全部或者部分”到某一个C函数去的时候，struct声明可以将数据封装起来，并且保证拥有与C兼容的空间布局，然而这种保证只在聚合（composition）的情况下存在。如果是继承的话，可能会因为内存布局原因无法实现想要的结果。 C++以下列方法支持多态： 经过一组隐式的转化操作，比如把一个派生类的指针转化为一个指向它的public base type的指针：shape *ps=new circle (); 经由virtual function机制：ps-&gt;rotate（） 经由$dynamic_cast$和typeid运算符：$if(circle pc=dynami_cast &lt; circle&gt;(ps))$ 需要多少内存才能够表现一个class object： 非静态成员变量的总和大小 加上任何由于alignment（对齐）的需求而填补（padding）上去的空间 加上为了支持virtual而内部产生的任何额外负担 关于指针：不同类型的指针从内存需求的观点来看没有什么不同，“指向不同类型之各指针‘间的差异，既不在其指针表示法的不同，也不再其内容的不同，而是在其所寻址出来的object类型不同。也就是说，“指针类型”会教导编译器如何解释某一个特定地址的内存内容及其大小。 最后一部分内容讨论了多态发生的条件，我认为总结下来就是引用和指针可能触发多态，通过虚函数来实现。然后将子对象赋值给父类对象一般会导致切割，来放置数据溢出。 具体问题： 一个Bear指针和一个ZooAnimal指针有什么不同： 123Bear b;ZooAnimal *pz&#x3D;&amp;b;Bear *pb&#x3D;&amp;; 它们每一个都指向Bear object 的第一个type，它们的区别是：pb所涵盖的地址包含整个 Bear object但是pz所涵盖的地址之包含Bear object中的ZooAnimal subobject.内存布局如下图： Alt","tags":[{"name":"C++","slug":"C","permalink":"http://tyler-ytr.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"http://tyler-ytr.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"leetcode22_m","date":"2020-09-07T01:28:58.000Z","path":"2020/09/07/leetcode22-m/","text":"22. 括号生成难度中等1252收藏分享切换为英文关注反馈 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 12345678输入：n &#x3D; 3输出：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 通过次数166,462 提交次数218,996 一道经典的回溯算法的题目,lcnit表示左边括号的数目,rcnt表示右括号的数目;结束的条件是temp.size()==2*n,也就是满足长度; 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt;result; int maxn=0; void back_track(string temp,int lcnt,int rcnt)&#123; if(temp.size()==maxn*2)&#123; result.push_back(temp); return; &#125; if(lcnt&lt;maxn)&#123; temp.push_back('('); back_track(temp,lcnt+1,rcnt); temp.pop_back(); &#125; if(rcnt&lt;lcnt)&#123; temp.push_back(')'); back_track(temp,lcnt,rcnt+1); temp.pop_back(); &#125; return; &#125; vector&lt;string&gt; generateParenthesis(int n) &#123; string temp=\"\"; maxn=n; back_track(temp,0,0); return result; &#125;&#125;;","tags":[{"name":"栈","slug":"栈","permalink":"http://tyler-ytr.github.io/tags/%E6%A0%88/"},{"name":"数据结构","slug":"数据结构","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode134_m","date":"2020-09-07T01:26:14.000Z","path":"2020/09/07/leetcode134-m/","text":"134. 加油站难度中等243 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 1234567891011121314输入: gas &#x3D; [1,2,3,4,5]cost &#x3D; [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 12345678910111213输入: gas &#x3D; [2,3,4]cost &#x3D; [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 参考了一个数形结合的题解 注意最小值的初始化问题 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int success=0; int n=gas.size(); int tempsum=0; for(int i=0;i&lt;n;i++)&#123; tempsum=tempsum+gas[i]-cost[i]; &#125; if(tempsum&lt;0)&#123; success=0; return -1; &#125; //现在起码可以环绕一圈，开始找起始点 //我觉得如果可以跑的话就是一个逃税过程，如何逃掉更多的税呢？因为起始点起始相当于少交一次前面的税 int gassum=0; int costsum=0; int min_ans=0; int min_result=INT_MAX; int temp=0; for(int i=0;i&lt;n;i++)&#123; gassum+=gas[i]; costsum+=cost[i]; temp=gassum-costsum; if(temp&lt;min_result)&#123; min_result=temp; min_ans=i; &#125; &#125; return (min_ans+1)%n; &#125;&#125;;","tags":[{"name":"贪心","slug":"贪心","permalink":"http://tyler-ytr.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"poj2386","date":"2020-09-07T01:24:14.000Z","path":"2020/09/07/poj2386/","text":"Lake Counting Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 59523 Accepted: 28958 Description Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John’s field, determine how many ponds he has. Input * Line 1: Two space-separated integers: N and M * Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output * Line 1: The number of ponds in Farmer John’s field. Sample Input 123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output 13 Hint OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left,and one along the right side. Source USACO 2004 November 题目大意: 计算出相连的’W’有多少块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;//#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;char mapa[maxn][maxn];int N,M;void dfs(int x,int y)&#123; mapa[x][y]='.'; int tempx; int tempy; for(int i=-1;i&lt;=1;i++)&#123; for(int j=-1;j&lt;=1;j++)&#123; tempx=x+i; tempy=y+j; if(tempx&gt;=0&amp;&amp;tempx&lt;N&amp;&amp;tempy&gt;=0&amp;&amp;tempy&lt;M&amp;&amp;mapa[tempx][tempy]=='W')&#123; dfs(tempx,tempy); &#125; &#125; &#125; return ;&#125;int main() &#123; // std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; cin&gt;&gt;N&gt;&gt;M; // vector&lt;vector&lt;char&gt; &gt; map(N,(vector&lt;char&gt; (M))); for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; char temp; cin &gt;&gt; temp; mapa[i][j]=temp; &#125; &#125;//cout&lt;&lt;\"here\"&lt;&lt;endl; int cnt=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(mapa[i][j]=='W')&#123; dfs(i,j);// cout&lt;&lt;cnt&lt;&lt;endl;// for(int i=0;i&lt;N;i++)&#123;// for(int j=0;j&lt;M;j++)&#123;//// cout&lt;&lt;mapa[i][j]&lt;&lt;\" \";// &#125;// cout&lt;&lt;endl;// &#125; cnt+=1; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"poj1321 棋盘问题","date":"2020-09-07T01:22:23.000Z","path":"2020/09/07/poj1321/","text":"棋盘问题 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 96005 Accepted: 43758 Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input 1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output 1221 Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;vector&lt;string&gt;map;//vector&lt;bool&gt;line;int cnt;int ans;void clear()&#123; map.clear(); cnt=0; ans=0;&#125;int N;int K;void backtrace(int j,vector&lt;bool&gt;&amp;line) &#123; if (cnt == K) &#123;//注意出递归的条件是cnt==K也就是找到这么多个 ans++; return; &#125; if(j&gt;=N)&#123;//这里是为了防止遍历的行数超过边界 return; &#125; for (int i = 0; i &lt; N; i++)&#123; if(!line[i]&amp;&amp;map[j][i]=='#')&#123; line[i]=true; cnt+=1; backtrace(j+1,line); cnt-=1; line[i]=false; &#125; &#125; backtrace(j+1,line);//遍历下一行&#125;int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; //vector&lt;string&gt;map; int n; int t; clear(); vector&lt;bool&gt;line(9, false); while(cin&gt;&gt;n&amp;&amp;cin&gt;&gt;t)&#123; if(n==-1&amp;&amp;t==-1)&#123; break; &#125;else&#123; N=n; K=t; for(int i=0;i&lt;n;i++)&#123; string a; cin&gt;&gt;a; map.push_back(a); &#125; for(int i=0;i&lt;9;i++)&#123; line[i]=false; &#125; backtrace(0,line); // N=n;// for(int i=0;i&lt;n;i++)&#123;// for(int j=0;j&lt;n;j++)// cout&lt;&lt;map[i][j]&lt;&lt;\" \";// &#125; cout&lt;&lt;ans&lt;&lt;endl; //cout结果; clear(); &#125; &#125; return 0;&#125; PS:leetcode刷题表示所有的OJ题","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode491_m","date":"2020-09-07T01:18:16.000Z","path":"2020/09/07/leetcode491-m/","text":"491. 递增子序列难度中等88 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。 示例: 12输入: [4, 6, 7, 7]输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 说明: 给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。 通过次数7,099 提交次数14,688 使用回溯算法进行dfs;主要要和那道全排列进行比较和区分; 使用set可以减少重复(我感觉剪枝更快但是不好写) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: set&lt;vector&lt;int&gt;&gt;result; void dfs(vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;temp,int pos)&#123; if(temp.size()==0)&#123; temp.push_back(nums[pos]); &#125; for(int i=1;i&lt;nums.size();++i)&#123; if(i+pos&gt;nums.size()-1||nums[i+pos]&lt;temp.back())&#123; continue; &#125;else&#123; temp.push_back(nums[pos+i]); result.insert(temp); dfs(nums,temp,pos+i); temp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; //感觉是回溯算法做的; vector&lt;int&gt;temp; for(int i=0;i&lt;nums.size();++i)&#123; temp.clear(); dfs(nums,temp,i); &#125; vector&lt;vector&lt;int&gt;&gt;ans; set&lt;vector&lt;int&gt;&gt;::iterator it; for(it=result.begin();it!=result.end();++it)&#123; ans.push_back(*it); &#125; return ans; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode386_m","date":"2020-09-07T01:14:51.000Z","path":"2020/09/07/leetcode386-m/","text":"386. 字典序排数难度中等74 给定一个整数 n, 返回从 1 到 n 的字典顺序。 例如， 给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。 请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt;result; void dfs(int cur,int n)&#123; if(cur&gt;n)&#123; return; &#125; else&#123; result.push_back(cur); for(int i=0;i&lt;10;++i)&#123; if(cur*10+i&gt;n)&#123; return; &#125;else&#123; dfs(cur*10+i,n); &#125; &#125; &#125; &#125; vector&lt;int&gt; lexicalOrder(int n) &#123; for(int i=1;i&lt;=9;++i) dfs(i,n); return result; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode133_m","date":"2020-09-07T01:12:57.000Z","path":"2020/09/07/leetcode133-m/","text":"133. 克隆图难度中等155 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。 示例 1： img 12345678输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2： img 123输入：adjList &#x3D; [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3： 123输入：adjList &#x3D; []输出：[]解释：这个图是空的，它不含任何节点。 示例 4： img 12输入：adjList &#x3D; [[2],[1]]输出：[[2],[1]] 提示： 节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 图是连通图，你可以从给定节点访问到所有节点。 使用dfs+字典/哈希表 即可;重点需要学会的是C++map/unorder_map的使用count查询的操作,count返回0表示没有,1表示有; 递归+数组版本: 12345678910111213141516171819class Solution &#123;public: Node*used[101]; Node* cloneGraph(Node* node) &#123; //需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素; //也可以不用Map 用一个Node*数组来表示; if(!node)return node; if(used[node-&gt;val])return used[node-&gt;val]; Node*p=new Node(node-&gt;val);//创建拷贝结点; used[node-&gt;val]=p; vector&lt;Node*&gt;tp=node-&gt;neighbors; for(int i=0;i&lt;tp.size();++i)&#123; p-&gt;neighbors.push_back(cloneGraph(tp[i])); &#125; return p; &#125;&#125;; 递归+unorder_map版本; 123456789101112131415161718class Solution &#123;public: unordered_map&lt;Node*, Node*&gt;used; Node* cloneGraph(Node* node) &#123; //需要使用stl语法map或者unorder_map 来记录,注意使用count来查询有没有这个元素; //也可以不用Map 用一个Node*数组来表示; if(!node)return node; if(used.count(node))return used[node]; Node*p=new Node(node-&gt;val);//创建拷贝结点; used[node]=p; vector&lt;Node*&gt;tp=node-&gt;neighbors; for(int i=0;i&lt;tp.size();++i)&#123; p-&gt;neighbors.push_back(cloneGraph(tp[i])); &#125; return p; &#125;&#125;; map版本用map替换unorder_map即可; 其中速度:map慢于unorder_map慢于数组; 原因:(摘自一个题解): map： 优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间 适用处：对于那些有顺序要求的问题，用map会更高效一些 unordered_map： 优点： 因为内部实现了哈希表，因此其查找速度非常的快缺点： 哈希表的建立比较耗费时间适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map 深度优先遍历的递归写法1.发现新节点1.如果没有操作该节点，就操作该节点，并将该节点的visit置11.1接着对该节点的neibor挨个遍历dfs函数2.如果有操作就返回该节点或者pass 非递归版本: 12345678910111213141516171819202122232425262728293031class Solution &#123;public: &#x2F;&#x2F;unordered_map&lt;Node*, Node*&gt;used; Node* cloneGraph(Node* node) &#123; if(!node)return node; stack&lt;Node*&gt;S; S.push(node);&#x2F;&#x2F;等同于 stack &lt;Node*&gt;S(&#123;node&#125;); unordered_map&lt;Node*, Node*&gt;used; used[node] &#x3D; new Node(node-&gt;val); Node* tmp; while(!S.empty())&#123; tmp &#x3D; S.top(); S.pop(); Node* r &#x3D; used[tmp]; vector&lt;Node*&gt;n&#x3D;tmp-&gt;neighbors; for(int i&#x3D;0;i&lt;n.size();++i)&#123; &#x2F;&#x2F;如果这个节点之前已经遍历到，就把他的复制加到链表中 &#x2F;&#x2F;没有遍历过就复刻该节点，加入map，加入neighbor Node*cur&#x3D;n[i]; if(!used.count(cur))&#123; Node*t&#x3D;new Node(cur-&gt;val); used[cur]&#x3D;t; S.push(cur); &#125; r-&gt;neighbors.push_back(used[cur]); &#125; &#125; return used[node]; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode131_m","date":"2020-09-07T01:10:18.000Z","path":"2020/09/07/leetcode131-m/","text":"98. 验证二叉搜索树难度中等471 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 &#x2F; \\ 1 3输出: true 示例 2: 123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 dfs 递归版本 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int flag; bool dfs(TreeNode* root,long long int lower,long long int higher)&#123; if(root==NULL)&#123; return true; &#125; long long int temp=root-&gt;val; if(temp&lt;=lower||temp&gt;=higher)&#123; return false; &#125; return dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); &#125; bool isValidBST(TreeNode* root) &#123; flag=1; return dfs(root,LONG_MIN,LONG_MAX); &#125; &#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode98_m","date":"2020-09-07T01:05:19.000Z","path":"2020/09/07/leetcode98-m/","text":"98. 验证二叉搜索树难度中等471 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 &#x2F; \\ 1 3输出: true 示例 2: 123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 dfs 递归版本 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int flag; bool dfs(TreeNode* root,long long int lower,long long int higher)&#123; if(root==NULL)&#123; return true; &#125; long long int temp=root-&gt;val; if(temp&lt;=lower||temp&gt;=higher)&#123; return false; &#125; return dfs(root-&gt;left,lower,temp)&amp;&amp;dfs(root-&gt;right,temp,higher); &#125; bool isValidBST(TreeNode* root) &#123; flag=1; return dfs(root,LONG_MIN,LONG_MAX); &#125; &#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode51_h","date":"2020-09-07T01:00:57.000Z","path":"2020/09/07/leetcode51-h/","text":"51. N皇后难度困难377 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 img 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例: 12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, &#x2F;&#x2F; 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: //行列; 本质上还是回溯法 //逐个行来扫描,这一行确定了之后就删除一些状态 //三个需要验证的合法性: //列,两个对角线: //line,incline1,incline2 //按行遍历,如果这列ok 就line[i]=1 //0x0x //x1xx (1,1)(0,0)(2,2)(3,3) 发现abs(j-i)是相同的;因此j-i+N 相同(这样确保大于0)) //0x0x (1,1)(0,2)(3,0) 发现对角线上面i+j是相同的 //xxx0 //所以每次更新的时候都是line[i]=true,incline[i+j]=true,incline[j-i+N]=true; int N; vector&lt;vector&lt;string&gt;&gt;result;//用来保存; void place(int j,vector&lt;vector&lt;bool&gt;&gt;&amp;track,vector&lt;bool&gt;&amp;line,vector&lt;bool&gt;&amp;incline1,vector&lt;bool&gt;&amp;incline2)&#123; if(j==N)&#123; //递归结束 string a=\"\"; vector&lt;string&gt; b; for(int p=0;p&lt;N;p++)&#123; for(int k=0;k&lt;N;k++)&#123; if(track[p][k])&#123; a.push_back('Q'); &#125;else&#123; a.push_back('.'); &#125; &#125; b.push_back(a); a.clear(); &#125; result.push_back(b); return; &#125;else&#123; for(int i=0;i&lt;N;i++)&#123; if(!line[i]&amp;&amp;!incline1[i+j]&amp;&amp;!incline2[j-i+N])&#123; line[i]=true; incline1[i+j]=true; incline2[j-i+N]=true; track[j][i]=true; place(j+1,track,line,incline1,incline2); line[i]=false; incline1[i+j]=false; incline2[j-i+N]=false; track[j][i]=false; &#125; &#125; ; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;bool&gt;incline1(2*n,false); vector&lt;bool&gt;incline2(2*n,false); vector&lt;bool&gt;line(n,false); vector&lt;vector&lt;bool&gt;&gt; track(n,line); N=n; place(0,track,line,incline1,incline2); return result; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"回溯法","slug":"回溯法","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"leetcode46_m","date":"2020-09-07T00:59:34.000Z","path":"2020/09/07/leetcode46-m/","text":"46 PermutationsMedium 333697Add to ListShare Given a collection of distinct integers, return all possible permutations. Example: 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt;res; vector&lt;bool&gt; vis;//表示这个解遇到过了; void backtrace(const vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;track,int index)&#123; //index记录vis的编号; if(index==nums.size())&#123; res.push_back(track); return; &#125; for(int i=0;i&lt;nums.size();i++)&#123; if(vis[i])&#123; ; &#125;else&#123; //没有访问过; vis[i]=true; track.push_back(nums[i]); backtrace(nums,track,index+1); track.pop_back(); vis[i]=false; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; res.clear(); if(nums.size()==0)&#123; return res; &#125; vis = vector&lt;bool&gt;(nums.size(), false); vector&lt;int&gt; track; backtrace(nums,track,0); return res; &#125;&#125;;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"回溯法","slug":"回溯法","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"leetcode124_h","date":"2020-09-07T00:58:16.000Z","path":"2020/09/07/leetcode124-h/","text":"124. 二叉树中的最大路径和难度困难510 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 1234567输入: [1,2,3] 1 &#x2F; \\ 2 3输出: 6 示例 2: 123456789输入: [-10,9,20,null,null,15,7] -10 &#x2F; \\ 9 20 &#x2F; \\ 15 7输出: 42 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ //用一个maxm来缓存对于某一个根节点的状态; //dfs过程中返回给上层应该是最大的一边;class Solution &#123;public: int maxm=INT_MIN; int dfs(TreeNode*root)&#123; if(root==nullptr)&#123; return 0; &#125; int left=max(0,dfs(root-&gt;left)); int right=max(0,dfs(root-&gt;right)); maxm=max(maxm,root-&gt;val+left+right); return max(left+root-&gt;val,right+root-&gt;val); &#125; int maxPathSum(TreeNode* root) &#123; // dfs(root); return maxm; &#125;&#125;; dfs解决该题,使用maxm缓存最大的结点处于的状态;dfs到某一个结点的时候,该节点返回给上一层:该节点值,该结点值+左值,该节点的值+右值的最大值; 对于空节点,返回0,表示对原来的结点没有贡献; 对于负值,和0比较取max的步骤表示如果有一边是负的那么就不做贡献,和空节点没有区别;","tags":[{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode690_s","date":"2020-09-07T00:56:33.000Z","path":"2020/09/07/leetcode690-s/","text":"690. 员工的重要性难度简单88 给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。 比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。 现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。 示例 1: 1234输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1输出: 11解释:员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 &#x3D; 11。 注意: 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。 通过次数13,683 提交次数23,456 重要的是先进行的hash操作,运用了unorder_map结构体,极大的简化了dfs的操作; 12345678910111213141516171819202122232425262728293031// Definition for Employee.class Employee &#123;public: int id; int importance; vector&lt;int&gt; subordinates;&#125;;class Solution &#123;public: unordered_map&lt;int,Employee*&gt;mp; int result=0; void dfs(int id)&#123; result+=mp[id]-&gt;importance; for(int i=0;i&lt;mp[id]-&gt;subordinates.size();++i)&#123; dfs(mp[id]-&gt;subordinates[i]); &#125; &#125; int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; //哈希: for(Employee* tmp:employees)&#123; mp[tmp-&gt;id]=tmp; &#125; //进行dfs; dfs(id); return result; &#125;&#125;; BFS版本: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*// Definition for Employee.class Employee &#123;public: int id; int importance; vector&lt;int&gt; subordinates;&#125;;*/// unordered_map&lt;int, Employee*&gt; mp;// int ans = 0;// public:// int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;// for (auto&amp; e : employees) // mp[e-&gt;id] = e;// dfs(id);// return ans;// &#125;// void dfs(int id) &#123;// ans += mp[id]-&gt;importance;// for (int i = 0; i &lt; mp[id]-&gt;subordinates.size(); ++i) // dfs(mp[id]-&gt;subordinates[i]);// &#125;class Solution &#123;public: unordered_map&lt;int,Employee*&gt;mp; int result=0; int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; //哈希: for(Employee* tmp:employees)&#123; mp[tmp-&gt;id]=tmp; &#125; //进行bfs queue&lt;int&gt; q; q.push(id); while(!q.empty())&#123; int temp=q.front(); q.pop(); result+=mp[temp]-&gt;importance; for(int i=0;i&lt;mp[temp]-&gt;subordinates.size();++i)&#123; q.push(mp[temp]-&gt;subordinates[i]); &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"}]},{"title":"leetcode199_m","date":"2020-09-07T00:53:29.000Z","path":"2020/09/07/leetcode199-m/","text":"199. 二叉树的右视图难度中等186 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例: 123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- &#x2F; \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 通过次数29,576 提交次数46,105 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; //bfs // 1 //2 3 // 5 4 //广度优先搜索，当q里面只有最右边一个元素的时候把这个元素加入到输出的队列里面; // if(root==nullptr)&#123;return NULL&#125;; vector&lt;int&gt;result; if(root==nullptr)&#123;return result;&#125;; queue&lt;TreeNode*&gt;q;//先进先出 q.push(root); while(!q.empty())&#123; // TreeNode*temp=q.front(); //关键点: 用len记录q的size;通过这个来获得最右侧的点; int len=q.size(); for(int i=0;i&lt;len;i++)&#123; TreeNode*temp=q.front(); if(i==len-1)&#123; result.push_back(temp-&gt;val); &#125; q.pop(); if(temp-&gt;left!=nullptr)&#123; q.push(temp-&gt;left); &#125; if(temp-&gt;right!=nullptr)&#123; q.push(temp-&gt;right); &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode101_s","date":"2020-09-07T00:51:12.000Z","path":"2020/09/07/leetcode101-s/","text":"101. 对称二叉树难度简单 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 &#x2F; \\2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 BFS的板子题 12345678910111213141516171819202122class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int size = q.size(); vector&lt;int&gt; v(size); for(int i = 0; i&lt;size; ++i)&#123; root = q.front(); q.pop(); v[i] = root ? root-&gt;val : INT_MIN; if(root) &#123; q.push(root-&gt;left); q.push(root-&gt;right); &#125; &#125; // 判断是否回文 for(int i = 0; i&lt; size/2; ++i)&#123; if(v[i] != v[size-1-i]) return false; &#125; &#125; return true; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode200_m","date":"2020-09-07T00:49:14.000Z","path":"2020/09/07/leetcode200-m/","text":"200. 岛屿数量难度中等515 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1: 123456输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。 解法1:BFS 遍历每一个点,遇到1就bfs并且把bfs到的1变成0;记录bfs的次数即可： 测试数据竟然有空集，这样会导致int maxn=map[0].size();//列数; 出现runtime error神必报错我tm…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; //感觉可以bfs //遍历map的每一个点,如果map[i][j]是1,进行bfs,遇到1的变成0; vector&lt;vector&lt;char&gt;&gt;map(grid); int cnt=0; //m*n; int maxm=map.size();//行数 if(maxm==0)&#123;return 0;&#125;//对付空集的神必特判 int maxn=map[0].size();//列数; for(int i=0;i&lt;maxm;i++)&#123; for(int j=0;j&lt;maxn;j++)&#123; if(map[i][j]=='1')&#123; cnt+=1; queue&lt;pair&lt;int,int&gt;&gt;q; pair&lt;int,int&gt;temp; temp.first=i; temp.second=j; q.push(temp); map[i][j]='0'; while(!q.empty())&#123; pair&lt;int,int&gt;cur=q.front(); q.pop(); int tempi=cur.first; int tempj=cur.second; if(tempi-1&gt;=0&amp;&amp;map[tempi-1][tempj]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi-1; temp2.second=tempj; q.push(temp2); map[tempi-1][tempj]='0'; &#125; if(tempi+1&lt;maxm&amp;&amp;map[tempi+1][tempj]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi+1; temp2.second=tempj; q.push(temp2); map[tempi+1][tempj]='0'; &#125; if(tempj-1&gt;=0&amp;&amp;map[tempi][tempj-1]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi; temp2.second=tempj-1; q.push(temp2); map[tempi][tempj-1]='0'; &#125; if(tempj+1&lt;maxn&amp;&amp;map[tempi][tempj+1]=='1')&#123; pair&lt;int,int&gt;temp2; temp2.first=tempi; temp2.second=tempj+1; q.push(temp2); map[tempi][tempj+1]='0'; &#125; ; &#125; ; &#125; &#125; &#125; return cnt; &#125;&#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"leetcode705_s","date":"2020-09-06T08:26:54.000Z","path":"2020/09/06/leetcode705-s/","text":"705. 设计哈希集合难度简单40 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: 123456789MyHashSet hashSet &#x3D; new MyHashSet();hashSet.add(1); hashSet.add(2); hashSet.contains(1); &#x2F;&#x2F; 返回 truehashSet.contains(3); &#x2F;&#x2F; 返回 false (未找到)hashSet.add(2); hashSet.contains(2); &#x2F;&#x2F; 返回 truehashSet.remove(2); hashSet.contains(2); &#x2F;&#x2F; 返回 false (已经被删除) 注意： 所有的值都在 [0, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 通过次数11,949 提交次数21,319 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class MyHashSet &#123;private: struct Node&#123; int val; Node* next; Node(int val):val(val),next(nullptr)&#123;&#125; &#125;;public: vector&lt;Node*&gt; arr; const int len=101; /** Initialize your data structure here. */ MyHashSet() &#123; arr=vector&lt;Node*&gt;(len,new Node(-1)); &#125; void add(int key) &#123; int addr=key%len; Node*temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)return; if(!(temp-&gt;next))&#123; Node*node=new Node(key); temp-&gt;next=node; return; &#125; temp = temp -&gt; next; &#125; &#125;else&#123; temp-&gt;val=key; return; &#125; &#125; void remove(int key) &#123;// int haval = key % len;// Node* temp = arr[haval];// if(temp -&gt; val != -1)&#123;// while(temp)&#123;// if(temp -&gt; val == key)&#123;// temp -&gt; val = -1;// return;// &#125;// temp = temp -&gt; next;// &#125;// &#125; int addr=key%len; Node*temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)&#123; temp-&gt;val=-1; return; &#125; temp=temp-&gt;next; &#125; &#125; &#125; /** Returns true if this set contains the specified element */ bool contains(int key) &#123; int addr=key%len; Node* temp=arr[addr]; if(temp-&gt;val!=-1)&#123; while(temp)&#123; if(temp-&gt;val==key)&#123; return true; &#125; temp=temp-&gt;next; &#125; return false; &#125;else&#123; return false; &#125; &#125;&#125;;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","permalink":"http://tyler-ytr.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"leetcode67_s","date":"2020-09-06T08:25:13.000Z","path":"2020/09/06/leetcode67-s/","text":"67. 二进制求和难度简单398 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;输出: &quot;10101&quot; 提示： 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 模拟题,用j来从后往前遍历; 一开始搞错的原因是因为忘记在result.push_back之后加上temp=0了,佛佛佛 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string addBinary(string a, string b) &#123; vector&lt;int&gt;result; int n=a.size(); int m=b.size(); int maxn=max(n,m); int out=0;//处理进位 int temp=0; for(int j=0;j&lt;maxn;++j)&#123; if(n-j&gt;0)&#123; temp+=(int)(a[n-j-1]-'0'); &#125; if(m-j&gt;0)&#123; temp+=(int)(b[m-j-1]-'0'); &#125; temp+=out; out=0; if(temp&gt;=2)&#123; temp-=2; out=1; &#125; result.push_back(temp); temp=0; &#125; if(out==1)&#123; result.push_back(1); &#125; string res; for(int i=result.size()-1;i&gt;=0;--i)&#123; if(result[i]==1)&#123; res=res+'1'; &#125;else&#123;res=res+'0';&#125; &#125; return res; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"leetcode14_s","date":"2020-09-06T07:58:44.000Z","path":"2020/09/06/leetcode14-s/","text":"14. 最长公共前缀难度简单1079 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 模拟题实锤,纵向比较,重点是要掌握string的substr方法; 12345678910111213141516171819202122232425262728class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int cnt=0; //纵向扫描; if(strs.size()==0)&#123; return \"\"; &#125; int length=strs[0].size(); if(length==0)&#123; return \"\"; &#125; for(int i=0;i&lt;length;++i)&#123; char c=strs[0][i]; for(int j=1;j&lt;strs.size();++j)&#123; if(strs[j][i]!=c||i==strs[j].size())&#123; return strs[0].substr(0,cnt); &#125; &#125; cnt+=1; &#125; if(cnt==0)&#123; return \"\"; &#125; return strs[0]; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"leetcode892_s","date":"2020-09-06T07:56:59.000Z","path":"2020/09/06/leetcode892-s/","text":"892. 三维形体的表面积难度简单90 在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： 12输入：[[2]]输出：10 示例 2： 12输入：[[1,2],[3,4]]输出：34 示例 3： 12输入：[[1,0],[0,2]]输出：16 示例 4： 12输入：[[1,1,1],[1,0,1],[1,1,1]]输出：32 示例 5： 12输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46 提示： 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 一道模拟题，题目意思很难懂 第一个示例的意思是 0,0这个位置有一个高度为2的立方体； 第二个示例的意思是 0,0 高度为1;0,1 高度为2………… 主要解法是找到一个求解表面积的公式 12345678910111213141516171819202122232425class Solution &#123;public: int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int N=grid.size(); int result=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;N;j++)&#123; if(grid[i][j]&gt;0)&#123; result+=2+4*grid[i][j]; &#125; if(i&gt;0)&#123; if(grid[i-1][j]&gt;0)&#123; result-=min(grid[i-1][j],grid[i][j])*2; &#125; &#125; if(j&gt;0)&#123;if(grid[i][j-1]&gt;0)&#123; result-=min(grid[i][j-1],grid[i][j])*2; &#125; &#125; &#125; &#125; return result; &#125;&#125;;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://tyler-ytr.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"DNS刷新","date":"2020-09-04T06:56:33.000Z","path":"2020/09/04/DNS刷新/","text":"DNS刷新垃圾windows连接校园网的时候一直出现dns probe finished no Internet报错，和信息中心的工程师打完电话之后发现是自己电脑DNS的问题，因此bing搜索，发现了如下的方法进行DNS的刷新: 1234netsh int ip reset netsh winsock resetipconfig&#x2F;flushdns 重启 然后报错从dns probe finished no Internet变成了 image-20200904150200196 佛了 面对不知道咋整的东西，那就选择重装系列： 右击 image-20200904184552395 然后点击网络重置 好像就行了？！","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"关于windows密钥登录服务器","date":"2020-09-04T06:56:33.000Z","path":"2020/09/04/cmd_vs_rsa/","text":"关于windows密钥登录服务器前言:windows的权限管理太屑了 参考https://blog.csdn.net/joshua2011/article/details/90208741","tags":[{"name":"windows配置","slug":"windows配置","permalink":"http://tyler-ytr.github.io/tags/windows%E9%85%8D%E7%BD%AE/"}]},{"title":"wishlist_together","date":"2020-09-04T02:18:35.000Z","path":"2020/09/04/wishlist-together/","text":"2020 wishlist 一起去鬼屋 一起去迪士尼","tags":[{"name":"wishlist","slug":"wishlist","permalink":"http://tyler-ytr.github.io/tags/wishlist/"}]},{"title":"leetcode4_h","date":"2020-08-31T14:55:42.000Z","path":"2020/08/31/leetcode4-h/","text":"4. 寻找两个正序数组的中位数难度困难2695 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 &#x3D; [1, 3]nums2 &#x3D; [2]则中位数是 2.0 示例 2: 1234nums1 &#x3D; [1, 2]nums2 &#x3D; [3, 4]则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5 123456789101112131415161718192021222324252627282930class Solution: #二分法,对于arr1,arr2,k:令x=k//2,如果arr1[x]&lt;arr2[x]说明arr1的前x元素不可能出现第k大个元素,去掉;相应k应该减小; #注意处理边界 def findkthelement(self,arr1:List[int],arr2:List[int],k)-&gt;float: len1=len(arr1) len2=len(arr2) if len1&gt;len2: return self.findkthelement(arr2,arr1,k) ##确保arr1是短的一边; if not arr1: #arr1为空,递归结束 return arr2[k-1] if k==1: #返回最小的元素 return min(arr1[0],arr2[0]) x=k//2 i=int(min(x,len1)-1) #arr1的边界;因为是数组所以要减一,代表有i+1个元素 j=int(min(x,len2)-1) if arr1[i]&lt;arr2[j]: return self.findkthelement(arr1[i+1:],arr2,k-i-1) else: return self.findkthelement(arr1,arr2[j+1:],k-j-1) def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: len1=len(nums1) len2=len(nums2) #考虑中位数的奇偶问题 mid1=(len1+len2+1)//2 mid2=(len1+len2+2)//2 return(self.findkthelement(nums1,nums2,mid1)+self.findkthelement(nums1,nums2,mid2))/2","tags":[{"name":"二分","slug":"二分","permalink":"http://tyler-ytr.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"leetcode990_m","date":"2020-08-31T14:28:06.000Z","path":"2020/08/31/leetcode990-m/","text":"990. 等式方程的可满足性难度中等73 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&quot;a==b&quot; 或 &quot;a!=b&quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 123输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]输出：false解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 123输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]输入：true解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。 示例 3： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]输出：true 示例 4： 12输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]输出：false 示例 5： 12输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]输出：true 提示： 1 &lt;= equations.length &lt;= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 &#39;=&#39;，要么是 &#39;!&#39; equations[i][2] 是 &#39;=&#39; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int p[26]; int find_set(int x)&#123; if(x!=p[x])&#123; p[x]=find_set(p[x]); &#125; return p[x]; &#125; bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; //图的连通性问题---并查集 for(int i =0;i&lt;26;i++)&#123; p[i]=i; &#125; for(int i=0;i&lt;equations.size();i++)&#123; //==就合并; if(equations[i][1]=='=')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1!=fx2)&#123; p[fx1]=p[fx2]; &#125; &#125; &#125; for(int i=0;i&lt;equations.size();i++)&#123; if(equations[i][1]=='!')&#123; int x1=equations[i][0]-'a'; int x2=equations[i][3]-'a'; int fx1=find_set(x1); int fx2=find_set(x2); if(fx1==fx2)return false; &#125; &#125; return true; &#125;&#125;; 官方版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class UnionFind &#123;private: vector&lt;int&gt; parent;public: UnionFind() &#123; parent.resize(26); iota(parent.begin(), parent.end(), 0); &#125; int find(int index) &#123; if (index &#x3D;&#x3D; parent[index]) &#123; return index; &#125; parent[index] &#x3D; find(parent[index]); return parent[index]; &#125; void unite(int index1, int index2) &#123; parent[find(index1)] &#x3D; find(index2); &#125;&#125;;class Solution &#123;public: bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; UnionFind uf; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;&#x3D;&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; uf.unite(index1, index2); &#125; &#125; for (const string&amp; str: equations) &#123; if (str[1] &#x3D;&#x3D; &#39;!&#39;) &#123; int index1 &#x3D; str[0] - &#39;a&#39;; int index2 &#x3D; str[3] - &#39;a&#39;; if (uf.find(index1) &#x3D;&#x3D; uf.find(index2)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;satisfiability-of-equality-equations&#x2F;solution&#x2F;deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","tags":[{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"}]},{"title":"leetcode547_m","date":"2020-08-31T14:23:59.000Z","path":"2020/08/31/leetcode547-m/","text":"547. 朋友圈难度中等255 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2: 123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意： N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 通过次数47,496 提交次数83,180 并查集版本 改了好久,主要是要改unite函数的$if(roota==rootb)return$ ;这一句;之前用的是$f[a]==f[b]$做的判断,实际上不行;因为这里的f[a]==f[b]发生在路径压缩之前; 还有就是find函数的条件是$x==f[x]$ 别搞错了; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: struct dis_set&#123; int n; //int f[205]; vector&lt;int&gt;f; dis_set(int x)&#123; // this-&gt;n=205; //f.resize(this-&gt;n); //iota(f.begin(),f.end(),0); n=x; f.resize(x+1); for(int i=0;i&lt;this-&gt;n;i++)&#123; f[i]=i; &#125; &#125; int find(int x)&#123; if(x==f[x])&#123; return x; &#125; f[x]=find(f[x]); return f[x]; &#125; void unite(int a,int b)&#123; int roota=find(a); int rootb=find(b); if(roota==rootb)return ; this-&gt;n--; f[roota]=rootb; &#125; int count()&#123; return n; &#125; &#125;; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? if(M.size()==0) return 0; int n=M[0].size(); struct dis_set cur(n); for(int i=0;i&lt;M.size();++i)&#123; for(int j=0;j&lt;M[0].size();++j)&#123; if(M[i][j]==1)&#123; cur.unite(i,j); &#125; &#125; &#125; return cur.count(); &#125; &#125;; dfs版本: 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt;vis; void dfs(int id,vector&lt;vector&lt;int&gt;&gt;&amp;M)&#123; if(vis[id]==1)return; vis[id]=1; for(int i=0;i&lt;M[id].size();++i)&#123; if(M[id][i]==1)&#123; dfs(i,M); &#125; &#125; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; vis.resize(n); // iota(vis.begin(),vis.end(),0); mgj iota的含义是填充0,1,2,3,4...不是所有的填充同一个数; for(int i=0;i&lt;n;i++)&#123; vis[i]=0; &#125; for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]==0)&#123; dfs(i,M); cnt++; &#125; &#125; return cnt; &#125; &#125;; bfs 版本的解法: 注意vis[j]=1那句,很重要; image-20200617203349985 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; //我感觉可以并查集,然后对每一个同学查询? //实际上还可以用dfs做,用vis记录已经访问过的结点; //还可以用bfs做;同样用vis记录没有访问过的结点; if(M.size()==0) return 0; int n=M[0].size(); int cnt=0; queue&lt;int&gt;Q; vector&lt;int&gt;vis(n,0); for(int i=0;i&lt;M.size();++i)&#123; if(vis[i]!=1)&#123; Q.push(i); while(!Q.empty())&#123; int top=Q.front(); Q.pop(); vis[top]=1; for(int j=0;j&lt;M[top].size();++j)&#123; if(M[top][j]==1&amp;&amp;vis[j]==0)&#123; Q.push(j); vis[j]=1;//这句很重要,如果没有这句会慢很多; &#125; &#125; &#125; cnt++; &#125; &#125; return cnt; &#125; &#125;;","tags":[{"name":"BFS","slug":"BFS","permalink":"http://tyler-ytr.github.io/tags/BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://tyler-ytr.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"http://tyler-ytr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"http://tyler-ytr.github.io/tags/DFS/"},{"name":"union-find","slug":"union-find","permalink":"http://tyler-ytr.github.io/tags/union-find/"}]},{"title":"leetcode94_m","date":"2020-08-31T14:11:42.000Z","path":"2020/08/31/leetcode94-m/","text":"94. 二叉树的中序遍历难度中等614 给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 &#x2F; 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 通过次数210,162 提交次数290,172 递归版本: 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void sol(TreeNode *root,vector&lt;int&gt;&amp;nums)&#123; if(root==NULL)&#123; return; &#125; sol(root-&gt;left,nums); nums.push_back(root-&gt;val); sol(root-&gt;right,nums); return ; ; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt;nums; sol(root,nums); return nums; &#125;&#125;; 迭代版本: 1234567891011121314151617181920212223242526272829vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; //迭代版本如下: stack&lt;TreeNode*&gt;S; vector&lt;int&gt;result; TreeNode*cur=root; while(cur!=NULL||!S.empty())&#123; while(cur!=NULL)&#123; S.push(cur); cur=cur-&gt;left; &#125; cur=S.top(); result.push_back(cur-&gt;val); S.pop(); cur=cur-&gt;right; /* # 这里设置 curr = curr.right， 如果 curr.right 不为空，那么说明 curr.right 是一棵树的根节点，走 while curr is not None 的逻辑。 # 如果 curr.right 为空，那么这个右节点是空啊，没有意义，直接在 stack 中 pop 出一个节点。 # 实际上，这里将一颗二叉树，看做了只有 根节点 和 左节点的树。 */ &#125; return result;&#125; image-20200809090152414 以此图为例,算法首先从1开始,不停压栈,直到4,栈里面是 1 2 4,4在栈顶;然后cur=4,栈里面弹出4;然后cur=4-&gt;right,是空的,因此会跳过 while(cur!=NULL)这个循环,然后cur=2,栈里面弹出2,然后cur=2-&gt;right=5,因为5不是空的,开始压栈,直到7,此时栈里面是1,5,7……","tags":[{"name":"树","slug":"树","permalink":"http://tyler-ytr.github.io/tags/%E6%A0%91/"}]},{"title":"面试题51_h","date":"2020-08-31T14:10:23.000Z","path":"2020/08/31/面试题51-h/","text":"面试题51. 数组中的逆序对难度困难90 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 12输入: [7,5,6,4]输出: 5 限制： 10 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000 当然二重for循环暴力可以解决，但是会超时； 实际上是一道二分思想的归并排序题目 image-20200424130136282 对于两个已经排序好的数组进行归并的时候，当且仅当右边的有序数组归并进去的时候，要把左边没有被归并的数组数目加到逆序个数里面; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: vector&lt;int &gt;temp; int mergesort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)&#123; return 0; &#125;; int tempresult=0; //int mid=(l+r)/2; int mid=l+((r-l)&gt;&gt;1);//防止l,r过大的时候溢出 //int mid=(l+r)&gt;&gt;1; 最快 tempresult=mergesort(nums,l,mid)+mergesort(nums,mid+1,r); int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;=nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; tempresult+=mid-i+1;//这个地方做的事情就是,当归并右边的元素进去的时候，逆序对加上左边没有归并元素数量的操作 &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; return tempresult; &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; //居然是归并排序 if(nums.size()&lt;2)&#123; return 0; &#125; else&#123; int result=0; temp.resize((int)nums.size()+1, 0); result=mergesort(nums,0,(int)nums.size()-1); return result; &#125; &#125;&#125;;","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode912_m","date":"2020-08-31T13:27:52.000Z","path":"2020/08/31/leetcode912-m/","text":"912. 排序数组难度中等98 给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 12输入：nums &#x3D; [5,2,3,1]输出：[1,2,3,5] 示例 2： 12输入：nums &#x3D; [5,1,1,2,0,0]输出：[0,0,1,1,2,5] 排序算法复习题 归并排序 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; temp; void mergeSort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&gt;=r)return;//左指针偶遇右指针 int mid=(l+r)&gt;&gt;1; mergeSort(nums,l,mid); mergeSort(nums,mid+1,r); // 现在l-mid mid+1-r是有序的 //考虑合并的情况 int i=l; int j=mid+1; int cnt=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(nums[i]&lt;nums[j])&#123; temp[cnt++]=nums[i++]; &#125;else&#123; temp[cnt++]=nums[j++]; &#125; &#125; while(i&lt;=mid)&#123; temp[cnt++]=nums[i++]; &#125; while(j&lt;=r)&#123; temp[cnt++]=nums[j++]; &#125; for (int i = 0; i &lt; r - l + 1; ++i) nums[i + l] = temp[i]; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; temp.resize((int)nums.size(), 0); mergeSort(nums, 0, (int)nums.size() - 1); return nums; &#125;&#125;; 插入排序 12 快速排序 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: //快速排序,本质上是分治的一种思想; 需要注意的是通过随机化来避免对这个算法特定的攻击从而达到平均复杂度O(nlgn)这个trick int partition(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int pivot=nums[r]; int i=l-1; for(int j=l;j&lt;=r-1;++j)&#123; if(nums[j]&lt;=pivot)&#123; i=i+1;//扩展比pivot小的边界; swap(nums[i],nums[j]); &#125; &#125; swap(nums[i+1],nums[r]); return i+1; &#125; int randomized_partiton(vector&lt;int&gt;&amp;nums,int l,int r)&#123; int i = rand() % (r - l + 1) + l; cout&lt;&lt;i&lt;&lt;endl; swap(nums[r],nums[i]);//选择pivot然后存放到最右端; return partition(nums,l,r); &#125; void quicksort(vector&lt;int&gt;&amp;nums,int l,int r)&#123; if(l&lt;r)&#123; int pos=randomized_partiton(nums,l,r); quicksort(nums,l,pos-1); quicksort(nums,pos+1,r); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; srand((unsigned)time(NULL)); quicksort(nums,0,(int)nums.size()-1); return nums; &#125;&#125;; 堆排序（不稳定排序） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: void maxheapify(vector&lt;int&gt;&amp;nums,int i,int len)&#123;//左子树和右子树ok,A[i]可能不ok,维护最大堆性质;这里与算导的主要区别是算导的数组是1-n;这里是0-len(n-1) for(;(i&lt;&lt;1)+1&lt;=len;)&#123; int lson=(i&lt;&lt;1)+1; int rson=(i&lt;&lt;1)+2; int largest; if(lson&lt;=len&amp;&amp;nums[lson]&gt;nums[i])&#123; largest=lson; &#125;else&#123; largest=i; &#125; if(rson&lt;=len&amp;&amp;nums[rson]&gt;nums[largest])&#123; largest=rson; &#125; if(i!=largest)&#123; int temp=nums[i]; nums[i]=nums[largest]; nums[largest]=temp; i=largest; &#125;else&#123;break;&#125; &#125; &#125; void buildmaxheap(vector&lt;int&gt;&amp;nums,int len)&#123; for(int i=len/2;i&gt;=0;--i)&#123; maxheapify(nums,i,len); &#125; &#125; void heapsort(vector&lt;int&gt;&amp;nums)&#123; int len=(int)nums.size()-1; buildmaxheap(nums,len); for(int i=len;i&gt;=1;--i)&#123; int temp=nums[0]; nums[0]=nums[i]; nums[i]=temp; len-=1; maxheapify(nums,0,len); &#125; &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; heapsort(nums); return nums; &#125;&#125;; //另外关于排序算法 线性时间但是有限制的有: 计数排序:统计每一个数组各个数的个数然后排序,要求被排序的数组都是0-k的整数;$\\Theta(n+k)$ 基数排序:对于所有的数,首先通过加0统一所有的数位,然后对每一个数位进行计数排序(此时k=10,这个时候是O(n)),从低到高,虽然这是线性的但是可能系数K很大！ radix sort 桶排序:","tags":[{"name":"排序","slug":"排序","permalink":"http://tyler-ytr.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode50_m","date":"2020-08-31T13:26:51.000Z","path":"2020/08/31/leetcode50-m/","text":"50. Pow(x, n)难度中等365 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 通过次数85,540 提交次数241,065 123456789101112131415161718192021222324class Solution &#123;public:double fastPower(double base, long long power) &#123; double result = 1.0; while (power &gt; 0) &#123; if (power &amp; 1) &#123;//此处等价于if(power%2==1) result = result * base; &#125; power &gt;&gt;= 1;//此处等价于power=power/2 base = (base * base) ; &#125; return result;&#125; double myPow(double x, int n) &#123; long long temp=n; if(n&gt;0) return fastPower(x,temp); else&#123; return 1/fastPower(x,-temp); &#125; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode914_s","date":"2020-08-31T13:25:40.000Z","path":"2020/08/31/leetcode914-s/","text":"914. 卡牌分组难度简单100 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X &gt;= 2 时返回 true。 示例 1： 123输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2： 123输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。 示例 3： 123输入：[1]输出：false解释：没有满足要求的分组。 示例 4： 123输入：[1,1]输出：true解释：可行的分组是 [1,1] 示例 5： 123输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: const int maxn=10002; int cnt[10002];int GCD1(int num1,int num2)&#123;if(num1%num2==0)&#123;return num2;&#125;else&#123;int next1=num2; int next2=num1%num2;return GCD1(next1,next2);&#125;&#125; bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123; memset(cnt,0,sizeof(cnt)); for(int i=0;i&lt;deck.size();i++)&#123; cnt[deck[i]]+=1; &#125; int g=-1; for(int i=0;i&lt;maxn;i++)&#123; if(cnt[i]!=0)&#123; if(g==-1)&#123; g=cnt[i]; &#125;else&#123; g=GCD1(g,cnt[i]); &#125; &#125; &#125; if(g&gt;=2)return true; else return false; &#125;&#125;;","tags":[{"name":"数学题","slug":"数学题","permalink":"http://tyler-ytr.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"leetcode312_h","date":"2020-08-31T13:23:43.000Z","path":"2020/08/31/leetcode312-h/","text":"312. 戳气球难度困难318 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 1234输入: [3,1,5,8]输出: 167 解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167 这题需要考虑的有两点: 第一点是状态的寻找和转移 第二点是如何进行递推; image-20200620172037074 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; //dp[i][j]表示:开区间(i,j)中戳破所有气球的获得硬币的最大数量; //dp[i][j]=max(dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]),k \\in [i+1,j-1] 这里k表示最后一次戳哪一个气球; //注意到dp[k][j] dp[i][k]决定了dp[i][j],不难发现dp[k][j]在dp[i][j]左边(k&gt;i),dp[i][k]在dp[i][j]下面(k&lt;j)所以要从i大往i小,j小往j大遍历; //另外还需要在左端和右端都添加虚假的气球; int n=nums.size(); vector&lt;int&gt;points(n+2,0); points[0]=1; points[n+1]=1; for(int i=0;i&lt;n;++i)&#123; points[i+1]=nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt; (n + 2, 0)); for(int i=n;i&gt;=0;--i)&#123; for(int j=i+1;j&lt;n+2;++j)&#123; int maxn=0; for(int k=i+1;k&lt;j;++k)&#123; maxn=max(maxn,dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]); &#125; dp[i][j]=maxn; &#125; &#125; return dp[0][n+1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"HDU2513 切蛋糕","date":"2020-08-31T13:21:36.000Z","path":"2020/08/31/HDU2513/","text":"多校联合训练的常见问题回答（FAQ） Cake slicing\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 583 Accepted Submission(s): 305 ** Problem DescriptionA rectangular cake with a grid of mn unit squares on its top needs to be sliced into pieces. Several cherries are scattered on the top of the cake with at most one cherry on a unit square. The slicing should follow the rules below: 1. each piece is rectangular or square; 2. each cutting edge is straight and along a grid line; 3. each piece has only one cherry on it; 4. each cut must split the cake you currently cut two separate parts For example, assume that the cake has a grid of 34 unit squares on its top, and there are three cherries on the top, as shown in the figure below. One allowable slicing is as follows. For this way of slicing , the total length of the cutting edges is 2+4=6. Another way of slicing is In this case, the total length of the cutting edges is 3+2=5. Give the shape of the cake and the scatter of the cherries , you are supposed to find out the least total length of the cutting edges. InputThe input file contains multiple test cases. For each test case: The first line contains three integers , n, m and k (1≤n, m≤20), where n*m is the size of the unit square with a cherry on it . The two integers show respectively the row number and the column number of the unit square in the grid . All integers in each line should be separated by blanks. OutputOutput an integer indicating the least total length of the cutting edges. Sample Input3 4 3 1 2 2 3 3 2 Sample OutputCase 1: 5 SourceECJTU 2008 Autumn Contest 【题意】 有一个n*m大小的蛋糕，上面有k个樱桃，现在我们需要把这个蛋糕切成k份，使每份蛋糕上有一个樱桃，问最小切割长度和。(切割一刀必须切到底) 我参考了网上的博客,思路如下: 这是一道区间Dp的题目;$dp[i][j][k][l]$表示以(i,j)为左上角,(k,l)为右下角的点,实际操作中因为初始化等问题,对于 image-20200620162927557 因为判定樱桃数量的函数使用的是&lt;=,所以实际上是判断的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int MAXN=0x3f3f3f3f;int m[25][25];int dp[25][25][25][25];int y,x,sum;//y*x矩阵；sum个樱桃;int Dp(int i,int j,int k,int l)&#123;//以i,j为左上角,k,l为右下角 if(dp[i][j][k][l]!=-1)&#123; return dp[i][j][k][l]; &#125;//如果之前计算过了,直接返回; //统计区域里面的樱桃数量; int cherry=0; for(int a=i;a&lt;=k;++a)&#123; for(int b=j;b&lt;=l;++b)&#123; if(m[a][b]==1)&#123; cherry+=1; &#125; &#125; &#125; //如果樱桃数量==1,那么不需要切割,返回0; if(cherry==1)&#123; dp[i][j][k][l]=0; return 0; &#125; //如果是0,那么这是一个不应该取得解,返回INF; if(cherry==0)&#123; dp[i][j][k][l]=MAXN; return MAXN; &#125; //否则需要切割;横着切或者纵着切; int minn=MAXN; //横着切: for(int a=i;a&lt;k;++a)&#123; minn=min(minn,Dp(i,j,a,l)+Dp(a+1,j,k,l)+l-j+1); &#125; //纵着切割: for(int b=j;b&lt;l;++b)&#123; minn=min(minn,Dp(i,j,k,b)+Dp(i,b+1,k,l)+k-i+1); &#125; dp[i][j][k][l]=minn; return dp[i][j][k][l];&#125;void init()&#123; memset(dp,-1,sizeof(dp)); memset(m,0,sizeof(m));&#125;int main() &#123; int cnt=1; while(~scanf(\"%d%d%d\",&amp;y,&amp;x,&amp;sum))&#123; init(); for(int i=0;i&lt;sum;++i)&#123; int p,q; scanf(\"%d%d\",&amp;p,&amp;q); m[p][q]=1; &#125; Dp(1,1,y,x); printf(\"Case %d: %d\\n\",cnt,dp[1][1][y][x]); cnt+=1; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"http://tyler-ytr.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"面试题08_m","date":"2020-08-31T13:20:30.000Z","path":"2020/08/31/面试题08-m/","text":"面试题 08.11. 硬币难度中等82 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007) 示例1: 12345 输入: n &#x3D; 5 输出：2 解释: 有两种方式可以凑成总金额:5&#x3D;55&#x3D;1+1+1+1+1 示例2: 1234567 输入: n &#x3D; 10 输出：4 解释: 有四种方式可以凑成总金额:10&#x3D;1010&#x3D;5+510&#x3D;5+1+1+1+1+110&#x3D;1+1+1+1+1+1+1+1+1+1 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; //没有优化的版本: vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;temp(n+2,0); vector&lt;vector&lt;int&gt;&gt;dp(val.size(),temp); dp[0][0]=1; for(int i=0;i&lt;4;i++)&#123; dp[i][0]=1;//不管用几种硬币组成0元只有一种方法 &#125; for(int i=0;i&lt;n+1;i++)&#123; dp[0][i]=1;//只用一种硬币(1)当然只有一种方法 &#125; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;n+1;j++)&#123; if(j&gt;=val[i]) dp[i][j]=dp[i-1][j]% 1000000007+dp[i][j-val[i]]% 1000000007; else&#123; dp[i][j]=dp[i-1][j]% 1000000007; &#125; &#125; &#125; return dp[3][n]% 1000000007; &#125;&#125;; //上面的是没有简化过的版本,因为不难发现j是递增的,因此存储空间可以复用,因此可以把二维降到一维 1234567891011121314151617181920212223242526272829class Solution &#123;public: int waysToChange(int n) &#123; //dp int result=0; //完全背包问题: 25 10 5 1 4个物品 //dp[0][0]=1 //dp[i][j]=dp[i-1][j]+dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]...+dp[i-1][j-val[i]*k],(k+1)*val[i]&gt;=j&gt;=k*val[i] //dp[i][j-val[i]]=dp[i-1][j-val[i]]+dp[i-1][j-val[i]*2]....+dp[i-1][j-val[i]*k] //上下相减: //dp[i][j]-dp[i][j-val[i]]=dp[i-1][j] //因此: //dp[i][j]=dp[i-1][j]+dp[i][j-val[i]]; // //降维到一维的版本: //dp[j]=dp[j]+dp[j-val[i]]; vector&lt;int&gt;val=&#123;1,5,10,25&#125;; vector&lt;int&gt;dp(n+2,1); dp[0]=1; for(int i=1;i&lt;val.size();i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(j&gt;=val[i]) dp[j]=dp[j]%1000000007+dp[j-val[i]]%1000000007; &#125; &#125; return dp[n]%1000000007; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode1014_m","date":"2020-08-31T13:19:15.000Z","path":"2020/08/31/leetcode1014-m/","text":"1014. 最佳观光组合难度中等124 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 123输入：[8,1,5,2,6]输出：11解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11 提示： 2 &lt;= A.length &lt;= 50000 1 &lt;= A[i] &lt;= 1000 通过次数17,154 提交次数32,791 主要注意优化的这种思路,真的挺妙的; 123456789101112131415161718192021class Solution &#123;public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; //A[i]+i+A[j]-j //原始解法: //对于每一个j 枚举1-[j-1]得到每一个j的最优解然后取最大值;O(N^2) //优化: //tmp=max(A[i]+i)([0,j-1]),对于每一个j,maxn=max(tmp+A[j]-j,maxn); O(n) int tmp=A[0]+0; int maxn=INT_MIN; for(int i=1;i&lt;A.size();++i)&#123; maxn=max(tmp+A[i]-i,maxn); tmp=max(tmp,A[i]+i); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode837_m","date":"2020-08-31T13:18:28.000Z","path":"2020/08/31/leetcode837-m/","text":"837. 新21点难度中等190 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？ 示例 1**：** 123输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10输出：1.00000说明：爱丽丝得到一张卡，然后停止。 示例 2**：** 1234输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10输出：0.60000说明：爱丽丝得到一张卡，然后停止。在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。 示例 3**：** 12输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10输出：0.73278 提示： 0 &lt;= K &lt;= N &lt;= 10000 1 &lt;= W &lt;= 10000 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。 此问题的判断限制时间已经减少。 这题是一道首先要确定好DP方向,然后还要对DP进行进一步优化的题目;说实话一开始没有想到状态挺惭愧的;具体的推导见注释; 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: double new21Game(int N, int K, int W) &#123; //dp[x]: 得到x分之后继续游戏,成功的概率; //dp[x]=(dp[x+1]+dp[x+2].....+dp[x+W])/W //初始化: 已知:dp[k]......dp[k+w-1]/dp[n-1]都是1 //结果:dp[0] //优化:发现 dp[x]和dp[x-1]之间的关系: //Wdp[x-1]=dp[x]+...+dp[x+w-1] //Wdp[x]=dp[x+1].....dp[x+w] //W (dp[x]-dp[x-1])=-dp[x]+dp[x+w] //(W+1)dp[x]-dp[x+w]=Wdp[x-1] //dp[x-1]=((W+1)dp[x]-dp[x+w])/W x&lt;k if(K==0)&#123; return 1.0; &#125; int maxn=max(N,K+W+1)+1; vector&lt;double&gt;dp(maxn,0); for(int i=K;i&lt;=N&amp;&amp;i&lt;K+W;i++)&#123; dp[i]=1.0; &#125; for(int i=1;i&lt;=W;i++)&#123; dp[K-1]+=dp[i+K-1]; &#125; dp[K-1]/=W; //dp[K - 1] = 1.0 * min(N - K + 1, W) / W; //dp[K-1]=((W+1)*dp[K]-dp[K+W])/W; for(int i=K-2;i&gt;=0;i--)&#123; dp[i]=((W+1)*dp[i+1]-dp[i+W+1])/W; &#125; return dp[0]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode416_m","date":"2020-08-31T13:17:48.000Z","path":"2020/08/31/leetcode416-m/","text":"416. 分割等和子集难度中等218 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 01背包问题 具体解体思路见注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; //背包问题 //背包的容量是总和的一半 //dp[i][j] 表示取了前i个数剩余容积为j时候的最大值 //dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+num[i]) int sum=0; int n=nums.size(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; if(sum%2!=0)&#123; return false; &#125; int V=sum/2; vector&lt;vector &lt;int&gt; &gt; dp(n,vector&lt;int&gt;(V+1,0)); //初始化: dp[0][0]=0; //只取0号数字的时候的初始化： for(int i=nums[0];i&lt;=V;i++)&#123;//注意越界问题 dp[0][i]=nums[0];//因为只能取一次nums[0]; &#125; //dp状态转移 for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;=V;j++)&#123; if(j-nums[i]&gt;=0) dp[i][j]=max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else&#123; dp[i][j]=dp[i-1][j]; &#125; &#125; &#125; if(dp[n-1][V]!=V)&#123; return false; &#125; return true; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode221_m","date":"2020-08-31T13:16:52.000Z","path":"2020/08/31/leetcode221-m/","text":"221. 最大正方形难度中等428 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 神必的dp 主要是状态的寻找,这题的状态是:$dp[i][j]$表示i,j点为右下角的矩形的最大宽度; 状态转移方程比较难像: $dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])$ 解释如下: image-20200531160513652 为了代码的美观减少一次特判,应该要在左边和上边多加一列: 0 0 0 ….. 0 matrix 0 … python代码如下： 1234567891011121314151617181920212223class Solution: #重点是神必的状态转移方程 def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) ==0: return 0 height=len(matrix) width=len(matrix[0]) dp=[[0 for i in range(width+1)] for j in range(height+1)] #dp初始化,并且在外面多套了一层; #dp[i,j]表示以i,j为右下角的矩形的最大宽度; # 0 0 0 0 .... # 0 matrix # 0 # 0 # ... #转移方程:dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1 maxedge=0 for i in range(height): for j in range(width): if matrix[i][j]=='1': dp[i+1][j+1]=min(dp[i][j],dp[i+1][j],dp[i][j+1])+1 maxedge=max(maxedge,dp[i+1][j+1]) return maxedge*maxedge","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode213_m","date":"2020-08-31T13:16:12.000Z","path":"2020/08/31/leetcode213-m/","text":"213. 打家劫舍 II难度中等284 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;和打家劫舍(198)异曲同工;之前是线性现在是环,那么可以先算1~n-1 然后再算2~n,然后取max返回; if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; if(nums.size()&#x3D;&#x3D;1)&#123; return nums[0]; &#125; vector&lt;int&gt;dp1(nums.size(),0); vector&lt;int&gt;dp2(nums.size(),0); dp1[0]&#x3D;nums[0]; dp1[1]&#x3D;max(nums[0],nums[1]); if(nums.size()&#x3D;&#x3D;2)&#123; return dp1[1]; &#125; if(nums.size()&#x3D;&#x3D;3)&#123; return dp1[1]; &#125; for(int i&#x3D;2;i&lt;nums.size()-1;++i)&#123; dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i]); &#125; int result1&#x3D;dp1[nums.size()-2]; dp2[1]&#x3D;nums[1]; dp2[2]&#x3D;max(nums[1],nums[2]); for(int i&#x3D;3;i&lt;nums.size();i++)&#123; dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]); &#125; int result2&#x3D;dp2[nums.size()-1]; return max(result1,result2); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode198_m","date":"2020-08-31T13:15:12.000Z","path":"2020/08/31/leetcode198-m/","text":"198. 打家劫舍难度简单875 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 原始版本: 12345678910111213141516171819202122232425262728class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; //dp[i]:第0间-第i间房子偷窃的最高金额; //dp[i]=max&#123;dp[i-1],dp[i-2]+a[i]&#125;//这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; //初始化: //dp[0]=nums[0] //dp[1]=max(nums[0],nums[1]) if(nums.size()==0)&#123; return 0; &#125; int len=nums.size(); vector&lt;int&gt;dp(len,0); dp[0]=nums[0]; if(nums.size()==1)&#123; return dp[0]; &#125; dp[1]=max(nums[1],nums[0]); for(int i=2;i&lt;len;++i)&#123; dp[i]=max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; //滚动数组优化; &#125;&#125;; 滚动数组优化版本; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;dp[i]:第0间-第i间房子偷窃的最高金额; &#x2F;&#x2F;dp[i]&#x3D;max&#123;dp[i-1],dp[i-2]+a[i]&#125;&#x2F;&#x2F;这里i-2很妙,因为如果偷第i个房子,那么第i-1个肯定不偷,因此是无关的; &#x2F;&#x2F;初始化: &#x2F;&#x2F;dp[0]&#x3D;nums[0] &#x2F;&#x2F;dp[1]&#x3D;max(nums[0],nums[1]) if(nums.size()&#x3D;&#x3D;0)&#123; return 0; &#125; int len&#x3D;nums.size(); int first&#x3D;nums[0]; if(nums.size()&#x3D;&#x3D;1)&#123; return first; &#x2F;&#x2F;return dp[0]; &#125; int sec&#x3D;max(nums[1],nums[0]); int result&#x3D;sec; for(int i&#x3D;2;i&lt;len;i++)&#123; result&#x3D;max(sec,first+nums[i]); first&#x3D;sec; sec&#x3D;result; &#125; return result; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode96_m","date":"2020-08-31T13:10:02.000Z","path":"2020/08/31/leetcode96-m/","text":"96. 不同的二叉搜索树难度中等537 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; //dp[i]:i个结点的时候二叉搜索树的个数 //空树只有一种情况:dp[0]=1 //dp[1]=1 //dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2].......(以第一结点做根节点+以第二个结点做根节点.....) // vector&lt;int&gt;dp(n+1,0); dp[0]=1; dp[1]=1; if(n&lt;2)&#123; return dp[n]; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; dp[i]+=dp[j]*dp[i-j-1]; &#125; &#125; return dp[n]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode64_m","date":"2020-08-31T13:09:13.000Z","path":"2020/08/31/leetcode64-m/","text":"64. 最小路径和难度中等486 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 1234567891011121314151617181920212223242526class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //dp[i][j]:到i,j 的最小路径和; //dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; vector&lt;vector&lt;int&gt;&gt;dp(grid); int m=dp.size(); if(m==0)&#123;return 0;&#125;; int n=dp[0].size(); for(int i=1;i&lt;m;++i)&#123; dp[i][0]=dp[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;++i)&#123; dp[0][i]=dp[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode62_m","date":"2020-08-31T13:04:05.000Z","path":"2020/08/31/leetcode62-m/","text":"62. 不同路径难度中等560 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ img 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 1234567输入: m &#x3D; 3, n &#x3D; 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m &#x3D; 7, n &#x3D; 3输出: 28 1234567891011121314151617181920212223242526272829class Solution &#123;public: int uniquePaths(int m, int n) &#123; &#x2F;&#x2F;dp[i][j]:到达i,j这个点有多少种方案 &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#x2F;&#x2F;dp[0][0]&#x3D;1; &#x2F;&#x2F;dp[0][1]&#x3D;1&#39; &#x2F;&#x2F;dp[1][0]&#x3D;1; if(m&lt;&#x3D;0||n&lt;&#x3D;0)&#123;return 0;&#125; vector&lt;int&gt;tmp(m,0); vector&lt;vector&lt;int&gt;&gt;dp(n,tmp); for(int i&#x3D;0;i&lt;m;i++)&#123; dp[0][i]&#x3D;1; &#125; for(int i&#x3D;0;i&lt;n;i++)&#123; dp[i][0]&#x3D;1; &#125; for(int i&#x3D;1;i&lt;n;i++)&#123; for(int j&#x3D;1;j&lt;m;j++)&#123; dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[n-1][m-1]; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode53_s","date":"2020-08-31T13:03:25.000Z","path":"2020/08/31/leetcode53-s/","text":"53. 最大子序和难度简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 水题: dp[i]表示第i个之前的连续子数组的最大和 dp[i]=max(dp[i],dp[i-1]+dp[i]) 12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxnum; vector&lt;int&gt; dp(nums); maxnum=nums[0]; for(int i=1;i&lt;nums.size();i++)&#123; if(dp[i-1]&gt;0)&#123; dp[i]=dp[i-1]+dp[i]; &#125; maxnum=max(maxnum,dp[i]); &#125; return maxnum; &#125; &#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode32_h","date":"2020-08-31T13:01:40.000Z","path":"2020/08/31/leetcode32-h/","text":"32. 最长有效括号难度困难784 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 通过次数74,856 提交次数233,569 题解见注释:主要是要两两字符判断; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int longestValidParentheses(string s) &#123; //动态规划:dp[i]:对于(0-i)个字符组成的字串的最长有效括号字串长度; //对于...............(): //dp[i]=dp[i-2]+2; //对于...............)): //dp[i-1]表示(0-i-1)个字符组成的字串的最长有效括号字串长度:....(.....) //判断s[i-dp[i-1]-1],如果是(: //dp=dp[i-1]+2+dp[i-dp[i-1]-2] (最后一个因为.....((.....))匹配那么这个模式之前的一个也可以加入合法套餐了; int n=s.length();; vector&lt;int&gt;dp(n+1,0); if(n==0 || n==1)&#123; return 0; &#125; int maxn=0; for(int i=1;i&lt;n;++i)&#123; if(s[i]==')')&#123; if(s[i-1]=='(')&#123; if(i&gt;=2)&#123; dp[i]=dp[i-2]+2; &#125;else&#123; dp[i]=2; &#125; &#125;else&#123; if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]=='(')&#123; if(i-dp[i-1]-2&gt;=0) dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]; else&#123; dp[i]=dp[i-1]+2; &#125; &#125; &#125; &#125; maxn=max(maxn,dp[i]); &#125; return maxn; &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode5_m","date":"2020-08-31T13:00:48.000Z","path":"2020/08/31/leetcode5-m/","text":"5. 最长回文子串难度中等 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 这题目可以使用动态规划 我觉得很棒的一个题解 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int len=s.length(); if(len&lt;=1) return s; vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len)); for(int i=0;i&lt;len;i++)&#123; dp[i][i]=1; &#125; int start=0; int maxl=1; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(s[i]==s[j])&#123; if(i-j&lt;=2)&#123; dp[j][i]=1; &#125;else&#123; dp[j][i]=dp[j+1][i-1]; &#125; &#125; if(dp[j][i]==1)&#123; int temp=i-j+1; if(temp&gt;maxl)&#123; maxl=temp; start=j; &#125; &#125; &#125; &#125; return s.substr(start,maxl); &#125;&#125;;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"HDU_1284","date":"2020-08-31T12:58:32.000Z","path":"2020/08/31/HDU-1284/","text":"钱币兑换问题\\Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 15976 Accepted Submission(s): 9546** Problem Description 在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。 Input 每行只有一个正整数N，N小于32768。 Output 对应每个输入，输出兑换方法数。 Sample Input 12293412553 Sample Output 1271883113137761 Author SmallBeer(CML) Source 杭电ACM集训队训练赛（VII） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;//相当于3件物品，容量为N的背包，第i件物品的重量是i//初始化: dp[0][0]=1//dp[i][j]表示用前i件物品组成j的方案数量//dp[i][j]=sum&#123;dp[i-1][j],dp[i][j-val[i]]&#125;//滚动数组优化：//dp[j]=sum&#123;dp[j],dp[j-val[i]]&#125;using namespace std;int temp;const int maxn=33000;//32468long long int dp[maxn];int main() &#123; //std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; memset(dp,0,sizeof(dp)); dp[0]=1; for(int i=1;i&lt;=3;i++)&#123; for(int j=i;j&lt;maxn;j++)&#123; dp[j]+=dp[j-i]; // printf(\"%lld\\n\",dp[j]); // dp[j]+=max(dp[j],dp[j-i]); &#125; &#125;// printf(\"here\");//// scanf(\"%d\",&amp;temp);// printf(\"%lld\",dp[temp]); while(scanf(\"%d\",&amp;temp)==1)&#123; printf(\"%I64d\\n\",dp[temp]); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://tyler-ytr.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode19_m","date":"2020-08-31T03:12:38.000Z","path":"2020/08/31/leetcode19-m/","text":"19. 删除链表的倒数第N个节点难度中等947收藏分享切换为英文关注反馈 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗 快慢指针的想法来实现: 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* l; ListNode*r; l=head; r=head; ListNode* temp; int cnt=0; for(cnt=0;cnt&lt;n;cnt++)&#123; r=r-&gt;next; &#125; if(r==nullptr)&#123; return head-&gt;next; &#125; //cout&lt;&lt;r-&gt;val&lt;&lt;endl; while(r-&gt;next!=nullptr)&#123; r=r-&gt;next; l=l-&gt;next; &#125; // cout&lt;&lt;l-&gt;val&lt;&lt;endl; l-&gt;next=l-&gt;next-&gt;next; return head; &#125;&#125;;","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode16_m","date":"2020-08-31T03:11:14.000Z","path":"2020/08/31/leetcode16-m/","text":"16. 最接近的三数之和难度中等530 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 123输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。 提示： 3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4 通过次数141,122 提交次数308,415 和leetcode15相似,主要思路还是排序+双指针 我使用了minA维护了当前的最小值,然后使用res记录和; 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: #排序: -4 -1 1 2 #minA 对于遍历到的每一个i,维护minA; #每一次循环,如果大于target,R=R-1;否则L=L+1;如果相等,返回; n=len(nums) if n&lt;3 or not nums: return NULL minA=sys.maxsize # INT最大值 res=minA nums.sort() for i in range(0,n-2): L=i+1 R=n-1 while L&lt;R: cur=nums[i]+nums[L]+nums[R] if cur==target: minA=0 return cur elif cur&lt;target: tempres=target-cur if abs(tempres)&lt;minA: minA=abs(tempres) res=cur L=L+1 else: tempres=cur-target if abs(tempres)&lt;minA: minA=abs(tempres) res=cur R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"leetcode15_m","date":"2020-08-31T03:06:50.000Z","path":"2020/08/31/leetcode15-m/","text":"15. 三数之和难度中等2455 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 通过次数293,697 提交次数1,016,765 还是看了题解,排序太香了！ 主要操作是排序使用双指针进行检查;同时记得去重; 12345678910111213141516171819202122232425262728293031323334class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if n&lt;3 or not nums: return res nums.sort() #从i遍历到n-2,使用双指针维护和探查; #记得去重,也就是对于相同的找最后的; for i in range(0,n): if nums[i]&gt;0: return res if i&gt;0 and nums[i]==nums[i-1]: continue #去重 L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while L&lt; R and nums[R]==nums[R-1]: R=R-1 L=L+1 R=R-1 elif nums[i]+nums[L]+nums[R]&lt;0: L=L+1 else: R=R-1 return res","tags":[{"name":"双指针","slug":"双指针","permalink":"http://tyler-ytr.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://tyler-ytr.github.io/tags/basic-knowledge/"}]},{"title":"Winter plan","date":"2020-01-22T09:17:23.000Z","path":"2020/01/22/winter-learning-plan/","text":"需要完成的目标: 线性代数复习 学习cs224n 刷leetcode 算法竞赛入门经典 目前进度: 线性代数: 1.22 cs224n 1.22 leetcode 1.22 算法竞赛入门经典","tags":[{"name":"flag","slug":"flag","permalink":"http://tyler-ytr.github.io/tags/flag/"}]},{"title":"ubuntu教程","date":"2020-01-22T08:28:15.000Z","path":"2020/01/22/ubuntu-back/","text":"反思 之前崩的原因是搜狗输入法安装的时候没有提前安装fcix框架,导致乱码然后系统就傻掉了; 重装很多次的原因是因为没有在重装之前完全的格式化分区,我建议每一次玩具坏了都要用windows格式化一次呜呜呜 复活操作基本配置 管理员权限,换源,安装vim sudo passwd(修改sudo密码) sudo apt-get update sudo apt-get install vim 更换国内源,这里我选择的是清华源用下面的命令打开文件,并且注释里面的所有内容, sudo vim /etc/apt/sources.list 然后粘贴下面的内容到打开的文件里面# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse如果你学过vim,就知道:w :q的含义,如果没有可以在终端使用vimtutor学习一下; 安装搜狗输入法(之前几次都因为它炸了我不信了……)，我参考了这一篇博客 然后搭建基本的C语言环境,主要参考啦蒋老师的PA讲义su apt-get install build-essential apt-get install man # on-line reference manual apt-get install gcc-doc # manual for GCC apt-get install gdb # GNU debugger apt-get install git # reversion control system apt-get install libreadline-dev # a library to use compile the project later apt-get install libsdl2-dev # a library to use compile the project later apt-get install qemu-system-x86 # QEMU 安装chrome:请使用bing搜索;用gmail同步很香; 科学的看世界 我选择的是shadowsocks-libev(因为我qt5以及普通的pip安装的shadowsocks就没有成功过) mkdir shadowsocks cd shadowsocks touch shadowsocks.json vim shadowsocks.json 将下面的内容根据自己的配置放进去: { \"server\":\"my_server_ip\", \"server_port\":53450, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"密码\", \"timeout\":300, \"method\":\"aes-256-gcm\", \"fast_open\": false } 然后: ss-local -c ~/shadowsocks/shadowsocks/json &amp;自己测试一下有没有问题; 感谢阿姨的提醒,我决定用别名+脚本来启动shadowsocks(因为每次开机输入上面的东西实在没有效率)： 先写一个自启动脚本： touch ~/.ssstart.sh vim ~/.ssstart.sh 内容是: #!/bin/bash ss-local -c ~/shadowsocks/shadowsocks.json 然后在终端里面起别名:vim ~/.bashrc在末尾添加:alias ss=’. ~/.ssstart.sh’:wq 保存,退出在终端里面:source ~/.bashrc(如果是zsh:source ~/.zshrc)尝试一下在终端输入ss,它lei了; 因为后面的netdata需要终端翻墙,我也就尝试了一下,如果没有需求可以跳过这一步: 主要参考的是谷歌出来的网站 首先用pip -V康康有没有pip,没有的话使用sudo apt-get install python-pip安装 下面尝试全局代理(我也不确定能不能成功)： sudo pip install genpac 选择安装配置文件的目录,我选择的是:/home/larryytr/shadowsocks 然后执行以下命令:sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 下面是一句搬运,我没有遇到过:注意：如果报错“fetch gfwlist fail.online: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt local:None”，可以使用后面的语句：sudo genpac –proxy=”SOCKS5 127.0.0.1:1080” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 执行完之后,目录下面会有一个autoproxy.pac文件。 然后在右上角,打开系统设置——网络——网络代理：“方法”选择“自动”，“配置URL”填写： file:///home/larryytr/shadowsocks/autoproxy.pac (请根据自己的实际情况修改) 然后使得终端也能使用代理。我们需要privoxy代理工具: 安装很自然:sudo apt-get install privoxy 然后编辑配置文件sudo vim /etc/privoxy/config 在文档中搜索(vim 使用/搜索)“listen-address”（即监听地址），找到如下一行：listen-address localhost:8118 确保它没有被注释（如果这一行有#号，就手动删除）。再查找“forward-socks5t”，找到如下一行：forward-socks5t / 127.0.0.1:1080 . 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy： 1sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config 最后，再配置/etc/profile： # 先进入编辑模式 sudo vim /etc/profile # 在末尾添加以下三行： export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118export ftp_proxy=http://127.0.0.1:8118 # 退出之后记得执行 source /etc/profile 验证是否成功:curl www.google.com或wget www.google.com判断是否可以访问 HINT(请务必注意):使用proxy的时候没有办法提交os作业,要make submit之前,先进入配置文件(/etc/privoxy/config)把刚刚做的事情给注释掉,然后用上面的命令重启privoxy,最后就可以提交了！！！ 优化美化 官网安装网易云 官网安装vscode 配置zsh,tmux,vim: zsh安装与美化 学习了:https://www.sysgeek.cn/install-zsh-shell-ubuntu-18-04/https://segmentfault.com/a/1190000013612471这两篇教程; 感谢何伟的配置文件; 相应的setting请参考我的github相关内容. 安装zsh:sudo apt-get update sudo apt-get install zsh chsh -s /bin/zsh (设置zsh为默认) 重启你的ubuntu 安装oh-my-zsh插件: wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 不改theme一无所有 准备使用powerline主题 首先安装powerline字体： git clone https://github.com/powerline/fonts.git --depth=1 # install cd fonts ./install.sh # clean-up a bit cd .. rm -rf fonts 安装完字体之后要记得使用：终端-编辑-首选项-文本-文本外观-自定义字体打勾-选一个带有powerline的。(星际玩家找了好久) 安装powerline: sudo apt install powerline 我的配置见相关内容的setting .zshrc 颜色选择困难请: for code ({000..255}) print -P – “$code: %F{$code}This is how your text would look like%f” 改完请source ~/.zshrc tmux tmux是一个很优秀的分屏软件,介绍可以看jyy的PA讲义以及自己搜索教程; 我使用了何伟的配置,具体见相关内容的setting 我又加了一个插件使得tmux在重启之后状态可以恢复: 主要参考这个知乎教程 git clone https://github.com/tmux-plugins/tmux-resurrect ~/tmux_tmp 在~/.tmux.conf.local里面加上:run-shell ~/tmux_tmp/resurrect.tmux 最后载入这个配置：tmux source-file ~/.tmux.conf vim的美化 使用啦懒人vim: spf13-vim美化 请看相关内容的setting，找到并且下载spf13-vim.sh,然后bash spf13-vim.sh 我的配置同样在相关内容的setting里面; 这个时候的vim没有办法和系统剪切版交互,我根据https://www.cnblogs.com/memory4young/p/could-not-use-system-clipboard-in-vim.html 下载了其他一些插件:sudo apt-get install vim-scripts vim-gtk vim-gnome这样 vim –version|grep “cliboard” 会看到 +clipboard;然后就可以用+y,+p实现系统剪切版和vim剪切版的交互啦！ 其他内容: OSlab还需要: sudo apt-get install curl sudo apt-get install gcc-multilib git 配置请搜索廖雪峰 ctags 可以参考Mengzelev的博客 感谢xnr给我推荐的network来查看linux的运行情况 这是netdata的官方网站:https://github.com/netdata/netdata#user-base 但是由于GFW,安装会出现报错,事实上需要终端翻墙才行 可以通过这篇教程 sudo apt-get install net-tools ifconfig查看inet 之后的内容来得知自己的server_ip 成功之后,进入 http://127.0.0.1:19999/ (:19999前面的是自己的server_ip地址,请按需要更改),得到炫酷的体验 相应配置可以参考这篇博客或者自己搜索 OSlab的kvm bug处理方法：https://bugzilla.redhat.com/show_bug.cgi?id=1479558chmod 666 /dev/kvm to get it working right now. Then to fix future reboots, create a file /lib/udev/rules.d/99-kvm.rules with this content: KERNEL==\"kvm\", GROUP=\"kvm\", MODE=\"0666\" texlive 安装sudo apt install texlive-full 相关的vscode配置可以抄我的[setting](https://github.com/larryytr/Note_for_blog/tree/master/setting) vscode的保存即编译请Ctrl+Shift+p,搜索setting,搜索Build,Latex-workshop › Synctex › After Build: Enabled打勾； ubuntu的截图:我参考了这篇博客 打开右上角的设置–&gt;设备–&gt;键盘–&gt;快捷键,点击+ 显然的配置好按键,然后在命令里面写gnome-screenshot -a hint:上面的命令终端输入也有效截屏的图在文件夹的图片(picture)里面; ubuntu jupyter lab配置在服务器上面配置了jupyter lab; 主要借鉴了:https://cloud.tencent.com/developer/article/1769288?from=information.detail.jupyter%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8 安装anaconda 使用python生成密钥; 12345678In [1]: from notebook.auth import passwd In [2]: passwd() Enter password: Verify password: Out[2]: &#39;sha1:salt:hashed-password&#39;#这里输出的东西就是密钥，复制好之后填In [3]: exit() 生成配置文件: 1jupyter notebook --generate-config 修改它: 1vi ~/.jupyter/jupyter_notebook_config.py 在末尾加上: 1234567c.NotebookApp.allow_remote_access &#x3D; True # 允许外部访问c.NotebookApp.ip&#x3D;&#39;*&#39; # 设置所有ip皆可访问c.NotebookApp.password &#x3D; u&#39;sha1:salt:hashed-password&#39; # 使用刚才生成的密钥c.NotebookApp.open_browser &#x3D; False # 禁止自动打开浏览器c.NotebookApp.port &#x3D; 2021 # 任意指定一个不冲突的端口，c.NotebookApp.notebook_dir &#x3D; &#39;&#x2F;home&#x2F;ubuntu&#x2F;JupyterProject&#x2F;&#39; #默认文件路径,这里用户名要改成自己的c.NotebookApp.allow_root &#x3D; True # 允许root身份运行jupyter notebook 记得在安全组里面打开这个 在服务器端输入jupyter notebook, 然后本地浏览器输入 服务器地址:2021就行啦(比如 122.52.187.69:2021)(这个服务器是随意打的) To be continued 有空再研究怎么换主题;","tags":[{"name":"教程","slug":"教程","permalink":"http://tyler-ytr.github.io/tags/%E6%95%99%E7%A8%8B/"}]}]