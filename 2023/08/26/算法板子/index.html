<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>算法模板整理 | Tyler-yin&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,教程">
    <meta name="description" content="算法模板与题目整理链表链表反转https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;reverse-linked-list&#x2F; 123456789101112ListNode* reverseList(ListNode* head) &amp;#123;    ListNode* cur &#x3D; head;    ListNode* prev &#x3D; nullptr;    while(cur !&#x3D; nullp">
<meta property="og:type" content="article">
<meta property="og:title" content="算法模板整理">
<meta property="og:url" content="http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/index.html">
<meta property="og:site_name" content="Tyler-yin&#39;s blog">
<meta property="og:description" content="算法模板与题目整理链表链表反转https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;reverse-linked-list&#x2F; 123456789101112ListNode* reverseList(ListNode* head) &amp;#123;    ListNode* cur &#x3D; head;    ListNode* prev &#x3D; nullptr;    while(cur !&#x3D; nullp">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-08-26T08:02:31.000Z">
<meta property="article:modified_time" content="2023-08-26T08:03:42.674Z">
<meta property="article:author" content="Tyler-yin">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="教程">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="Tyler-yin&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/Tyler.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Tyler-yin</h5>
          <a href="mailto:ytrpossible@gmail.com" title="ytrpossible@gmail.com" class="mail">ytrpossible@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Index
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Tyler-ytr/" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-address-book"></i>
                Friends
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-link"></i>
                link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">算法模板整理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">算法模板整理</h1>
        <h5 class="subtitle">
            
                <time datetime="2023-08-26T08:02:31.000Z" itemprop="datePublished" class="page-time">
  2023-08-26
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#算法模板与题目整理"><span class="post-toc-number">1.</span> <span class="post-toc-text">算法模板与题目整理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#链表"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#链表反转"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">链表反转</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#检查回文链表"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">检查回文链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间翻转链表"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">区间翻转链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两两交换链表中的节点"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">两两交换链表中的节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#K个一组翻转链表"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">K个一组翻转链表</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间查询计算——树状数组"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">区间查询计算——树状数组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间查询计算——线段树"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">区间查询计算——线段树</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#搜索"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">搜索</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#排序"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#归并排序"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">归并排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#统计逆序对"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">统计逆序对</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#快速排序"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#求第K大"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">求第K大</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图论"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">图论</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#并查集"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">并查集</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#树"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#拓扑排序"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">拓扑排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Kruskal"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">Kruskal</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Prim"><span class="post-toc-number">1.5.5.</span> <span class="post-toc-text">Prim</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#树的直径"><span class="post-toc-number">1.5.6.</span> <span class="post-toc-text">树的直径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最短路"><span class="post-toc-number">1.5.7.</span> <span class="post-toc-text">最短路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图遍历-环检测-拓扑排序"><span class="post-toc-number">1.5.8.</span> <span class="post-toc-text">图遍历&#x2F;环检测&#x2F;拓扑排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Dijkstra"><span class="post-toc-number">1.5.9.</span> <span class="post-toc-text">Dijkstra</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#强连通分量"><span class="post-toc-number">1.5.10.</span> <span class="post-toc-text">强连通分量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二分图匹配（匈牙利算法）"><span class="post-toc-number">1.5.11.</span> <span class="post-toc-text">二分图匹配（匈牙利算法）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最大流"><span class="post-toc-number">1.5.12.</span> <span class="post-toc-text">最大流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最小费用最大流"><span class="post-toc-number">1.5.13.</span> <span class="post-toc-text">最小费用最大流</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#动态规划"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">动态规划</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最长上升子序列"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">最长上升子序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不同的子序列"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">不同的子序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最长回文子序列"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">最长回文子序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数位dp"><span class="post-toc-number">1.6.4.</span> <span class="post-toc-text">数位dp</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#树状dp"><span class="post-toc-number">1.6.5.</span> <span class="post-toc-text">树状dp</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符串"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典树"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">字典树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Rabin-Karp-Hash"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">Rabin-Karp (Hash)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Knuth-Morris-Pratt"><span class="post-toc-number">1.7.3.</span> <span class="post-toc-text">Knuth-Morris-Pratt</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数学"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">数学</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#GCD-最大公约数"><span class="post-toc-number">1.8.1.</span> <span class="post-toc-text">GCD 最大公约数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#优质算法博客"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">优质算法博客</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-算法板子"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">算法模板整理</h1>
        <div class="post-meta">
            <time class="post-time" title="2023-08-26 16:02:31" datetime="2023-08-26T08:02:31.000Z"  itemprop="datePublished">2023-08-26</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="算法模板与题目整理"><a href="#算法模板与题目整理" class="headerlink" title="算法模板与题目整理"></a>算法模板与题目整理</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查回文链表"><a href="#检查回文链表" class="headerlink" title="检查回文链表"></a>检查回文链表</h3><p>先使用快慢指针找到回文串的右部分，然后翻转右部分，再将两个链表进行比对。 <a href="https://leetcode.cn/problems/palindrome-linked-list" target="_blank" rel="noopener">https://leetcode.cn/problems/palindrome-linked-list</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* rp = reverseList(slow-&gt;next);</span><br><span class="line">    ListNode* lp = head;</span><br><span class="line">    <span class="keyword">while</span>(lp != <span class="literal">nullptr</span> &amp;&amp; rp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lp-&gt;val != rp-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lp = lp-&gt;next;</span><br><span class="line">        rp = rp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间翻转链表"><a href="#区间翻转链表" class="headerlink" title="区间翻转链表"></a>区间翻转链表</h3><p>假设需要翻转[l, r]，那么我们记录start=l, end=r+1, startPrev=start-1。翻转之后，startPrev-&gt;next = reversedHead, start-&gt;next = end。由于翻转之后head可能会被改变，因此需要在head前添加一个dummy节点用于找到新链表的头。 <a href="https://leetcode.cn/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head, ListNode* end)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != end) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* startPrev = dummy;</span><br><span class="line">    ListNode* start = dummy;</span><br><span class="line">    ListNode* end = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left; i++) &#123;</span><br><span class="line">        startPrev = start;</span><br><span class="line">        start = start-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right; i++) &#123;</span><br><span class="line">        end = end-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    end = end-&gt;next;</span><br><span class="line"></span><br><span class="line">    startPrev-&gt;next = reverseList(start, end);</span><br><span class="line">    start-&gt;next = end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p>思路和链表的区间翻转是一样的，区间的大小为2，需要特殊考虑奇数点的情况。 <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* startPrev = dummy;</span><br><span class="line">    ListNode* start = head;</span><br><span class="line">    ListNode* end = head;</span><br><span class="line">    <span class="keyword">while</span>(end != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 奇数个点</span></span><br><span class="line">        <span class="keyword">if</span>(end-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        end = end-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        startPrev-&gt;next = reverseList(start, end);</span><br><span class="line">        start-&gt;next = end;</span><br><span class="line">        startPrev = start;</span><br><span class="line">        start = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h3><p>两两交换链表节点的一般情况，区间大小为k，需要考虑不足k个点的情况。 <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode.cn/problems/reverse-nodes-in-k-group</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* startPrev = dummy;</span><br><span class="line">    ListNode* start = head;</span><br><span class="line">    ListNode* end = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(end != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否能移动k步</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(end-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无法移动k步</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以走k步</span></span><br><span class="line">        end = end-&gt;next;</span><br><span class="line"></span><br><span class="line">        startPrev-&gt;next = reverseList(start, end);</span><br><span class="line">        start-&gt;next = end;</span><br><span class="line">        startPrev = start;</span><br><span class="line">        start = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="区间查询计算——树状数组"><a href="#区间查询计算——树状数组" class="headerlink" title="区间查询计算——树状数组"></a>区间查询计算——树状数组</h3><p><strong>307. 区域和检索 - 数组可修改</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要注意的是，因为利用了位运算的奇技淫巧，所以树状数组需要从1开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//树状数组,https://oi-wiki.org/ds/fenwick/</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;bit;<span class="comment">//bit[1....n] bit[1]表示a[0];bit[2]表示a[0]+a[1]; 管辖的区间是[x-lowbit(x),x-1]; 假设管辖的数组从0开始计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// lowbit(0b01011000) == 0b00001000</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bit[0]..bit[x] 中间覆盖的点的和 相当于nums[0]+...+nums[x]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">                sum += bit[x];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += bit[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//单点加法，对于x加上y，更新所有的树状数组</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; bit.size())&#123;</span><br><span class="line">            bit[x] += y; </span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bit[left] 到 bit[right] 中间覆盖的点的和 nums[left]+...+nums[right]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> pre_sum(right) - pre_sum(left<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pre_sum(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        bit.resize(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            bit[i]+=nums[i];</span><br><span class="line">            <span class="keyword">int</span> t=i+lowbit(i);<span class="comment">//树状数组性质:c[x]真包含于c[x+lowbit(x)]</span></span><br><span class="line">            <span class="keyword">if</span>(t&lt;n)bit[t]+=bit[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> old = sumRange(index, index);</span><br><span class="line">        add(index, val-old);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_sum(left, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="区间查询计算——线段树"><a href="#区间查询计算——线段树" class="headerlink" title="区间查询计算——线段树"></a>区间查询计算——线段树</h3><p><strong>307. 区域和检索 - 数组可修改</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SegmentTreeNode(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> sum,SegmentTreeNode*left=<span class="literal">nullptr</span>,SegmentTreeNode*right=<span class="literal">nullptr</span>):start(start),end(end),sum(sum),left(left),right(right)&#123;&#125;;</span><br><span class="line">        SegmentTreeNode(<span class="keyword">const</span> SegmentTreeNode&amp;) = <span class="keyword">delete</span>;<span class="comment">//禁用拷贝构造函数</span></span><br><span class="line">        SegmentTreeNode&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SegmentTreeNode&amp;) = <span class="keyword">delete</span>;<span class="comment">//禁用赋值   </span></span><br><span class="line">        ~SegmentTreeNode()&#123;</span><br><span class="line">            <span class="keyword">delete</span> left;</span><br><span class="line">            <span class="keyword">delete</span> right;</span><br><span class="line">            left=right=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">    SegmentTreeNode*left;</span><br><span class="line">    SegmentTreeNode*right;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        _nums.assign(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(!_nums.empty())&#123;</span><br><span class="line">            _root=(buildTree(<span class="number">0</span>,_nums.size()<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        updateTree(_root,index,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumRange(_root,left,right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//线段树操作</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        build(start,end,vals) O(n)</span></span><br><span class="line"><span class="comment">        update(index,value) O(logn)</span></span><br><span class="line"><span class="comment">        rangequery(start,end) O(logn+k) k表示会被的段的数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;_nums;</span><br><span class="line">    SegmentTreeNode*_root;</span><br><span class="line"></span><br><span class="line">    <span class="function">SegmentTreeNode*<span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SegmentTreeNode(start,end,_nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> left=buildTree(start,mid);</span><br><span class="line">        <span class="keyword">auto</span> right=buildTree(mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">auto</span> node=<span class="keyword">new</span> SegmentTreeNode(start, end, left-&gt;sum + right-&gt;sum, left, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(SegmentTreeNode*root,<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;start==i&amp;&amp;root-&gt;end==i)&#123;</span><br><span class="line">            root-&gt;sum=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=root-&gt;start+(root-&gt;end-root-&gt;start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=mid)&#123;</span><br><span class="line">            updateTree(root-&gt;left,i,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            updateTree(root-&gt;right,i,val);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;sum=root-&gt;left-&gt;sum+root-&gt;right-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(SegmentTreeNode*root,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==root-&gt;start&amp;&amp;j==root-&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=root-&gt;start+(root-&gt;end-root-&gt;start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> sumRange(root-&gt;left,i,j);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i &gt;mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> sumRange(root-&gt;right,i,j);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sumRange(root-&gt;left,i,mid)+sumRange(root-&gt;right,mid+<span class="number">1</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="统计逆序对"><a href="#统计逆序对" class="headerlink" title="统计逆序对"></a>统计逆序对</h3><p>例题，剑指Offer51 <a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">int</span> reverseCount;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> al, <span class="keyword">int</span> ar, <span class="keyword">int</span> bl, <span class="keyword">int</span> br)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = al, j = bl;</span><br><span class="line">    <span class="keyword">int</span> k = al;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= ar &amp;&amp; j &lt;= br) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reverseCount += ar - i + <span class="number">1</span>;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= ar) &#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= br) &#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k = al; k &lt;= br; k++) &#123;</span><br><span class="line">        nums[k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, l, mid);</span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">    merge(nums, l, mid, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    temp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> reverseCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="求第K大"><a href="#求第K大" class="headerlink" title="求第K大"></a>求第K大</h3><p>例题，LeetCode216 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计nums[l, r]中的第k大</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &gt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(nums[j], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[i+<span class="number">1</span>], nums[r]);</span><br><span class="line">    <span class="comment">// 分清楚i+1和k的关系</span></span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> - l + <span class="number">1</span> == k) <span class="keyword">return</span> nums[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> - l + <span class="number">1</span> &gt; k) <span class="keyword">return</span> findK(nums, l, i, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findK(nums, i+<span class="number">2</span>, r, k - (i+<span class="number">1</span> - l + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>样例:leetcode 990 <strong>等式方程的可满足性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//count表示连通分量的个数，这里find使用了路径压缩，注意if语句而不是while;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//并查集</span></span><br><span class="line">    <span class="comment">//如果是等号，那么union；</span></span><br><span class="line">    <span class="comment">//如果是不等号，那么connect返回的值应该是false；</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;parent;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x]!=x)&#123;</span><br><span class="line">            parent[x]=find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _union(<span class="keyword">int</span> p,<span class="keyword">int</span> q)&#123;</span><br><span class="line">        <span class="keyword">int</span> root_p=find(p);</span><br><span class="line">        <span class="keyword">int</span> root_q=find(q);</span><br><span class="line">        <span class="keyword">if</span>(root_p!=root_q)&#123;</span><br><span class="line">            parent[root_p]=root_q;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            parent.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        count=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> now:equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now[<span class="number">1</span>]==<span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> a=now[<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> b=now[<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                _union(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> now:equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now[<span class="number">1</span>]==<span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> a=now[<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> b=now[<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(connect(a,b))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h3 id="图遍历-环检测-拓扑排序"><a href="#图遍历-环检测-拓扑排序" class="headerlink" title="图遍历/环检测/拓扑排序"></a>图遍历/环检测/拓扑排序</h3><p>例题，<a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener">207.课程表</a>；另外拓扑排序相当于后序遍历加入的值(边表示依赖)(或者翻转后序遍历的值，边表示被依赖）<a href="https://leetcode.cn/problems/course-schedule-ii/" target="_blank" rel="noopener">210.课程表 II</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS版本</span></span><br><span class="line"><span class="comment">// 需要注意visited和onPath的顺序，如果onPath在循环内部，那么会错过根节点</span></span><br><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line"><span class="keyword">bool</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 发现环！！！</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将节点 s 标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 开始遍历节点 s</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点 s 遍历完成</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>例题，LeetCode743 <a href="https://leetcode.cn/problems/network-delay-time/" target="_blank" rel="noopener">https://leetcode.cn/problems/network-delay-time/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n+<span class="number">1</span>, <span class="number">0x3fffffff</span>)</span></span>;</span><br><span class="line">dist[st] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 其实遍历n-1就可以</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// 寻找dist[u]最小且未被访问过的点</span></span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[j] &amp;&amp; (u == <span class="number">-1</span> || dist[j] &lt; dist[u])) &#123;</span><br><span class="line">            u = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据dist[u]更新其邻点的dist</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [v, w] : g[u]) &#123;</span><br><span class="line">        dist[v] = min(dist[v], dist[u] + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p>例题，POJ2186（貌似不支持C++11及其以上的语法） <a href="http://poj.org/problem?id=2186" target="_blank" rel="noopener">http://poj.org/problem?id=2186</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++timeStamp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    s.push(u);</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v] == <span class="number">-1</span>) &#123; <span class="comment">// 没有访问过的节点</span></span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]); <span class="comment">// 如果v能够到达dfn更小的点，那么u也可以</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(inStack[v]) &#123; <span class="comment">// v一定比u先被访问</span></span><br><span class="line">            low[u] = min(low[u], dfn[v]); <span class="comment">// 更新v能够到达的dfn更小的点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩点</span></span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u]) &#123;</span><br><span class="line">        ++sccCount;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            x = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            inStack[x] = <span class="literal">false</span>;</span><br><span class="line">            node2scc[x] = sccCount;</span><br><span class="line">            ++sccSize[sccCount];</span><br><span class="line">        &#125; <span class="keyword">while</span>(x != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分图匹配（匈牙利算法）"><a href="#二分图匹配（匈牙利算法）" class="headerlink" title="二分图匹配（匈牙利算法）"></a>二分图匹配（匈牙利算法）</h3><p><a href="http://poj.org/problem?id=1274" target="_blank" rel="noopener">1274 – The Perfect Stall (poj.org)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; g;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; x;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; y;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span> &gt; vis;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hungary</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// u为X部的顶点</span></span><br><span class="line">	<span class="comment">// v为Y部的顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = g[u][i];</span><br><span class="line">		<span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[v] = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 如果Y部的顶点v还未被匹配，那么可以去匹配它</span></span><br><span class="line">		<span class="comment">// 假设v匹配了X部的顶点p，且从p能找到另一个匹配q，那么x-y-p-q是一条增广路径</span></span><br><span class="line">		<span class="keyword">if</span> (y[v] == <span class="number">-1</span> || hungary(y[v])) &#123;</span><br><span class="line">			x[u] = v;</span><br><span class="line">			y[v] = u;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">		g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">		vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span> &gt;(m, <span class="literal">false</span>);</span><br><span class="line">		x = <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;(n, <span class="number">-1</span>);</span><br><span class="line">		y = <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;(m, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">while</span> (x--) &#123;</span><br><span class="line">				<span class="keyword">int</span> a;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">				g[i].push_back(a - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">			<span class="comment">// 如果X部还存在点未被匹配，那么尝试去匹配它</span></span><br><span class="line">			<span class="keyword">if</span> (x[u] == <span class="number">-1</span>) &#123;</span><br><span class="line">				vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span> &gt;(m + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">				<span class="keyword">if</span> (hungary(u)) &#123;</span><br><span class="line">					res++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>题目<a href="https://www.luogu.com.cn/problem/P3376" target="_blank" rel="noopener">P3376 【模板】网络最大流 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>Edmod-Karp算法</p>
<p>其思想是使用bfs不断地找增广路，复杂度很高</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EdmodKarp</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt;&amp; cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">int</span> maxFlow = <span class="number">0x7fffffff</span>;</span><br><span class="line">	<span class="keyword">int</span> n = cap.size();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> bfs = [&amp;]() &#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		pre = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		vis[source] = <span class="literal">true</span>;</span><br><span class="line">		q.push(source);</span><br><span class="line">		<span class="keyword">int</span> flow = maxFlow;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (u == dest) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cap[u][v] &gt; <span class="number">0</span> &amp;&amp; !vis[v]) &#123;</span><br><span class="line">					vis[v] = <span class="literal">true</span>;</span><br><span class="line">					pre[v] = u;</span><br><span class="line">					<span class="keyword">if</span> (flow &gt; cap[u][v]) flow = cap[u][v];</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pre[dest] == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> flow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sumFlow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		delta = bfs();</span><br><span class="line">		<span class="comment">// delta不为0说明还能找到一条从source到dest的增广路径</span></span><br><span class="line">		<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> cur = dest;</span><br><span class="line">		<span class="keyword">while</span> (pre[cur] != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> last = pre[cur];</span><br><span class="line">			cap[last][cur] -= delta;</span><br><span class="line">			cap[cur][last] += delta;</span><br><span class="line">			cur = last;</span><br><span class="line">		&#125;</span><br><span class="line">		sumFlow += delta;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sumFlow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ford-Fulkerson算法</p>
<p>将上述EK算法的bfs寻路改为dfs，即得到Ford-Fulkerson算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">FordFulkerson</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt;&amp; cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> ll maxFlow = <span class="number">0x7fffffff</span>;</span><br><span class="line">	<span class="keyword">int</span> n = cap.size();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">int</span> cur, <span class="keyword">int</span> des, ll curFlow) &#123;</span><br><span class="line">		function&lt;ll(<span class="keyword">int</span>, <span class="keyword">int</span>, ll)&gt; _dfs;</span><br><span class="line"></span><br><span class="line">		_dfs = [&amp;](<span class="keyword">int</span> cur, <span class="keyword">int</span> des, ll curFlow) -&gt; ll &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur == des) &#123;</span><br><span class="line">				<span class="keyword">return</span> curFlow;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[cur] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cap[cur][v] &gt; <span class="number">0</span> &amp;&amp; !vis[v]) &#123;</span><br><span class="line">					ll flow = _dfs(v, des, min(curFlow, cap[cur][v]));</span><br><span class="line">					<span class="keyword">if</span> (flow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						cap[cur][v] -= flow;</span><br><span class="line">						cap[v][cur] += flow;</span><br><span class="line">						<span class="keyword">return</span> flow;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> _dfs(cur, des, curFlow);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	ll sumFlow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>);</span><br><span class="line">		ll delta = dfs(source, dest, maxFlow);</span><br><span class="line">		<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sumFlow += delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sumFlow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dinic算法</p>
<p>首先使用bfs计算当前残差网络中每个节点的层次，然后使用dfs寻找增广路，要求在搜索过程中，深度为d的顶点只能走到深度为d+1的顶点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt;&amp; cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> ll maxFlow = <span class="number">0x7fffffff</span>;</span><br><span class="line">	<span class="keyword">int</span> n = cap.size();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">depth</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">int</span> cur, <span class="keyword">int</span> des, ll curFlow) &#123;</span><br><span class="line">		function&lt;ll(<span class="keyword">int</span>, <span class="keyword">int</span>, ll)&gt; _dfs;</span><br><span class="line"></span><br><span class="line">		_dfs = [&amp;](<span class="keyword">int</span> cur, <span class="keyword">int</span> des, ll curFlow) -&gt; ll &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur == des) &#123;</span><br><span class="line">				<span class="keyword">return</span> curFlow;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cap[cur][v] &gt; <span class="number">0</span> &amp;&amp; depth[v] == depth[cur] + <span class="number">1</span>) &#123;</span><br><span class="line">					ll flow = _dfs(v, des, min(curFlow, cap[cur][v]));</span><br><span class="line">					<span class="keyword">if</span> (flow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						cap[cur][v] -= flow;</span><br><span class="line">						cap[v][cur] += flow;</span><br><span class="line">						<span class="keyword">return</span> flow;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> _dfs(cur, des, curFlow);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> bfs = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		depth = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		depth[source] = <span class="number">1</span>;</span><br><span class="line">		q.push(source);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cap[u][v] &gt; <span class="number">0</span> &amp;&amp; depth[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> depth[dest] != <span class="number">-1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	ll sumFlow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			ll delta = dfs(source, dest, maxFlow);</span><br><span class="line">			<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			sumFlow += delta;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sumFlow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><p>题目<a href="https://www.luogu.com.cn/problem/P3381" target="_blank" rel="noopener">P3381 【模板】最小费用最大流 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>在EK算法的基础上，求解增广路的同时求最短路（source到dest增广路径上的cost之和最小）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> cap;</span><br><span class="line">	<span class="keyword">int</span> cost;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	Edge() = <span class="keyword">default</span>;</span><br><span class="line">	Edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _cap, <span class="keyword">int</span> _cost, <span class="keyword">int</span> _n) : u(_u), v(_v), cap(_cap), cost(_cost), next(_n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">	Graph() = <span class="keyword">delete</span>;</span><br><span class="line">	Graph(<span class="keyword">int</span> n) : head(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>)) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">		edges.emplace_back(u, v, cap, cost, head[u]);</span><br><span class="line">		head[u] = edges.size() - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest, <span class="keyword">int</span> n, Graph&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costSum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">int</span> inf = <span class="number">0x3fffffff</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">inque</span><span class="params">(n ,<span class="literal">false</span>)</span></span>;</span><br><span class="line">	pre = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line">	path = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line">	costSum = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, inf);</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flow</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 源点的流量初始为无穷大，cost为0</span></span><br><span class="line">	q.push(source);</span><br><span class="line">	inque[source] = <span class="literal">true</span>;</span><br><span class="line">	flow[source] = inf;</span><br><span class="line">	costSum[source] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// 这里是spfa求最短路，不完全是一遍bfs</span></span><br><span class="line">		inque[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> eid = g.head[u]; eid != <span class="number">-1</span>; eid = g.edges[eid].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = g.edges[eid].v;</span><br><span class="line">			<span class="keyword">int</span> cost = g.edges[eid].cost;</span><br><span class="line">			<span class="keyword">int</span> cap = g.edges[eid].cap;</span><br><span class="line">			<span class="comment">// 松弛边</span></span><br><span class="line">			<span class="keyword">if</span> (g.edges[eid].cap &gt; <span class="number">0</span> &amp;&amp; costSum[v] &gt; costSum[u] + cost) &#123;</span><br><span class="line">				<span class="comment">// 更新到v点的最小cost之和</span></span><br><span class="line">				costSum[v] = costSum[u] + cost;</span><br><span class="line">				<span class="comment">// 更新到v点的最大流量</span></span><br><span class="line">				flow[v] = min(flow[u], cap);</span><br><span class="line">				<span class="comment">// 记录到v点的上一个点和边号</span></span><br><span class="line">				pre[v] = u;</span><br><span class="line">				path[v] = eid;</span><br><span class="line">				<span class="comment">// spfa算法中v重新入队</span></span><br><span class="line">				<span class="keyword">if</span> (!inque[v]) &#123;</span><br><span class="line">					inque[v] = <span class="literal">true</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> flow[dest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mcmf</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest, <span class="keyword">int</span> n, Graph&amp; g)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">path</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">costSum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> minCost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> maxFlow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">// 运行一次最短路，求出增广路径上的流量</span></span><br><span class="line">		<span class="keyword">int</span> flow = spfa(source, dest, n, g, pre, path, costSum);</span><br><span class="line">		<span class="keyword">if</span> (flow == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 更新最大流量和最小费用</span></span><br><span class="line">		maxFlow += flow;</span><br><span class="line">		minCost += flow * costSum[dest];</span><br><span class="line">		<span class="comment">// 更新残差网络</span></span><br><span class="line">		<span class="keyword">int</span> cur = dest;</span><br><span class="line">		<span class="keyword">while</span> (cur != source) &#123;</span><br><span class="line">			g.edges[path[cur]].cap -= flow;</span><br><span class="line">			g.edges[path[cur] ^ <span class="number">1</span>].cap += flow;</span><br><span class="line">			cur = pre[cur];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; maxFlow &lt;&lt; <span class="string">" "</span> &lt;&lt; minCost &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, s, t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c, d;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">		<span class="comment">// 正向边，capacity为c，cost为d</span></span><br><span class="line">		g.AddEdge(a<span class="number">-1</span>, b<span class="number">-1</span>, c, d);</span><br><span class="line">		<span class="comment">// 反向边，capacity为0，cost为-d</span></span><br><span class="line">		g.AddEdge(b<span class="number">-1</span>, a<span class="number">-1</span>, <span class="number">0</span>, -d);</span><br><span class="line">	&#125;</span><br><span class="line">	mcmf(s<span class="number">-1</span>, t<span class="number">-1</span>, n, g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p>dp(i)表示长度为i+1的上升子序列的最后一位的最小值 <a href="https://leetcode.cn/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode.cn/problems/longest-increasing-subsequence</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[len] &lt; nums[i]) &#123;</span><br><span class="line">            dp[++len] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(dp.begin(), dp.begin() + len + <span class="number">1</span>, nums[i]);</span><br><span class="line">            *it = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><p>给定字符串s和t，计算s子序列中t出现的次数。首先在s和t前面加上一个标记字符，然后dp(i, j)表示s[1…i]的子序列中t[1…j]出现的次数。 <a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode.cn/problems/distinct-subsequences/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    s = <span class="string">"#"</span> + s;</span><br><span class="line">    t = <span class="string">"#"</span> + t;</span><br><span class="line">    <span class="keyword">int</span> lens = s.size();</span><br><span class="line">    <span class="keyword">int</span> lent = t.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(lens, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(lent, <span class="number">0</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lens; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lens; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; lent; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == t[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[lens - <span class="number">1</span>][lent - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p>dp(i, j)表示s[i…j]中的最长回文子序列的长度，分情况讨论s[i]是否等于s[j]即可。 <a href="https://leetcode.cn/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>)  &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i+<span class="number">1</span>])</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><h3 id="树状dp"><a href="#树状dp" class="headerlink" title="树状dp"></a>树状dp</h3><p>例题,leetcode 834 树中距离之和,换根DP，原理是当根发生变化的时候只有部分状态需要修改</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//result数组保存第i个节点到所有其他节点的距离之和</span></span><br><span class="line"><span class="comment">//dp[i] 表示以0为根节点的情况下，以i节点为根的子树中，i节点到它的子孙的距离之和</span></span><br><span class="line"><span class="comment">//size[i] 表示i节点为根的子树的点的数量</span></span><br><span class="line"><span class="comment">//初始情况下dp[i]=0 size[i]=1</span></span><br><span class="line"><span class="comment">//样例中dp[0]=dp[1]+size[1]+dp[2]+size[2]=0+1+3+4=8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;size;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;graph,<span class="keyword">int</span> now,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">        size[now]=<span class="number">1</span>;</span><br><span class="line">        dp[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> node:graph[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=father)&#123;</span><br><span class="line">                dfs(graph,node,now);</span><br><span class="line">                dp[now]=dp[now]+dp[node]+size[node];</span><br><span class="line">                size[now]=size[node]+size[now];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;graph,<span class="keyword">int</span> now,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">        result[now]=dp[now];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> node:graph[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=father)&#123;</span><br><span class="line">                <span class="comment">//换根 主要原理是很多点的状态不需要修改</span></span><br><span class="line">                <span class="comment">//首先保留原来的状态</span></span><br><span class="line">                <span class="keyword">int</span> dp_now=dp[now],size_now=size[now],dp_node=dp[node],size_node=size[node];</span><br><span class="line">                <span class="comment">//状态转移 假设以node为根，进行求解;</span></span><br><span class="line">                dp[now]=dp[now]-(dp[node]+size[node]);</span><br><span class="line">                size[now]=size[now]-size[node];</span><br><span class="line">                dp[node]=dp[node]+dp[now]+size[now];</span><br><span class="line">                size[node]=size[node]+size[now];</span><br><span class="line">                solve(graph,node,now);</span><br><span class="line">                <span class="comment">//还原现场</span></span><br><span class="line">                dp[now]=dp_now;</span><br><span class="line">                dp[node]=dp_node;</span><br><span class="line">                size[now]=size_now;</span><br><span class="line">                size[node]=size_node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumOfDistancesInTree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;graph(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        dp.resize(n,<span class="number">0</span>);</span><br><span class="line">        size.resize(n,<span class="number">0</span>);</span><br><span class="line">        result.resize(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;_pair:edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=_pair[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=_pair[<span class="number">1</span>];</span><br><span class="line">            graph[u].emplace_back(v);</span><br><span class="line">            graph[v].emplace_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(graph,<span class="number">0</span>,<span class="number">-1</span>);<span class="comment">//从0这个根节点开始做预处理;</span></span><br><span class="line">        solve(graph,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h3 id="Rabin-Karp-Hash"><a href="#Rabin-Karp-Hash" class="headerlink" title="Rabin-Karp (Hash)"></a>Rabin-Karp (Hash)</h3><h3 id="Knuth-Morris-Pratt"><a href="#Knuth-Morris-Pratt" class="headerlink" title="Knuth-Morris-Pratt"></a>Knuth-Morris-Pratt</h3><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="GCD-最大公约数"><a href="#GCD-最大公约数" class="headerlink" title="GCD 最大公约数"></a>GCD 最大公约数</h3><p><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/solution/python3-zui-da-gong-yue-shu-914-qia-pai-fen-zu-by-/" target="_blank" rel="noopener">914. 卡牌分组</a>，<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/bfszui-da-gong-yue-shu-by-fe-lucifer/" target="_blank" rel="noopener">365. 水壶问题</a>， <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/1071-zi-fu-chuan-de-zui-da-gong-yin-zi-zui-da-gong/" target="_blank" rel="noopener">1071. 字符串的最大公因子</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _gcd(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="comment">//gcd(a,b)=gcd(b,a%b);</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _gcd(b,a%b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="优质算法博客"><a href="#优质算法博客" class="headerlink" title="优质算法博客"></a>优质算法博客</h2><ol>
<li><strong><a href="http://39.107.250.150/" target="_blank" rel="noopener">木易東</a></strong></li>
<li><a href="https://labuladong.gitee.io/algo/" target="_blank" rel="noopener">labuladong</a></li>
<li><a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI wiki</a></li>
<li><strong><a href="https://lucifer.ren/blog/2020/12/26/heap/" target="_blank" rel="noopener">几乎刷完了力扣所有的堆题，我发现了这些东西。。。</a></strong></li>
</ol>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2023-08-26T08:03:42.674Z" itemprop="dateUpdated">2023-08-26 16:03:42</time>
</span><br>


        
        Link：<a href="/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/" target="_blank" rel="external">http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/</a>
        
    </div>
    
    <footer>
        <a href="http://Tyler-ytr.github.io">
            <img src="/img/Tyler.png" alt="Tyler-yin">
            Tyler-yin
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/&title=《算法模板整理》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/&title=《算法模板整理》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《算法模板整理》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2023/08/20/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">C++多线程</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "NoLhoWnmbSW89zV4zc04RPwx-gzGzoHsz",
            appKey: "SSdRGaHcdjoKc7cJJpOlJIqJ",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Tyler-yin &copy; 2015 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/&title=《算法模板整理》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/&title=《算法模板整理》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《算法模板整理》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsklEQVR42u3awY7iQAwE0Pn/n2alPa00O1BldzMcXk4IQtIvh45V9tdXfDz+Hu2Zj3+O7+d8P346p11DfeDh4eGNlv78lsmlny/0OT65b/tfPDw8vNu8ZIvPGcl1flpocsfkXnh4eHifwNvA2rI7x+Ph4eF9Mi/Z3JNF58FEvgY8PDy89/OS27QbeouZlfXHshY8PDy8mDdra/3u54v9PTw8PLxFV71t8M/+m39T3wsPDw/vAq8NDvajA210m/z6YuV4eHh413jtZp1v4hvSLGj4z4sBDw8P7xCvHVFtB6Q2RXYeEEfFNB4eHt5lXh6q5ktsBw7aKKSOcfHw8PBGvH1pO3tAs7jhwOgAHh4e3pqXbKntq+JUPJG8xl78ioeHh3eN1y79+YLafyXI4fABHh4e3gVevsSkpE4i1+EWf3TEAQ8PD2/PywOCe1c4G47g4eHh3eYV81mLb/Lz89fJMKvGw8PDO8TLF50/obbRlbe7kjAFDw8P7wavHWnKBwVmRXa+9GgcAQ8PD+8Crx0RaCPddqxqVrIXJTUeHh7emrdfbluI58i2YRaV1Hh4eHhrXnLRPIptW2VJGT0bccDDw8O7zcsDiE3LfxPLrl4MeHh4eBd4m/hgNvB0qowuAlw8PDy8o7x8KbMFta2y2cjCxZkyPDw8vNEu2kYPsyZW++uBFwMeHh7euqROiuk8pGhHBGZb/ItHiYeHh/d2Xk7dRAn7ZhgeHh7ee3iP8sgD3FkIe6ptVtwGDw8Pr+Sd6hO1AW4bCrfxBB4eHt5t3maDnrWpzp4fxbh4eHh4F3jJpWcFcR5hbN5geHh4eJ/Myx9BvqB20y8eGR4eHt6v8tqA9fmLZBNqFKU5Hh4e3jVe2/Rqh6U2bbMDCTQeHh7ehe55W/62sDxuSK7TBhx4eHh4h3h/AKdPpks74pelAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '＞﹏＜';
            clearTimeout(titleTime);
        } else {
            document.title = '~\(≧▽≦)/~';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


</body>
</html>
