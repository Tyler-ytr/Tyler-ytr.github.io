<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Linux内核设计与实现阅读笔记1 | Tyler-yin&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,linux">
    <meta name="description" content="Linux内核设计与实现(第三版) 学习笔记第2章 从内核出发2.1 内核源码可以从内核网站中下载Linux的内核源码。可以使用uname -r查看内核release版本号。 也可以使用如下命令查看最新的版本源代码 123git clone git:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux-2.6.git#更新到最新版本git">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核设计与实现阅读笔记1">
<meta property="og:url" content="http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/index.html">
<meta property="og:site_name" content="Tyler-yin&#39;s blog">
<meta property="og:description" content="Linux内核设计与实现(第三版) 学习笔记第2章 从内核出发2.1 内核源码可以从内核网站中下载Linux的内核源码。可以使用uname -r查看内核release版本号。 也可以使用如下命令查看最新的版本源代码 123git clone git:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux-2.6.git#更新到最新版本git">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/picture/image-20240606200432946.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/picture/image-20240606201800745.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/picture/image-20240608194647424.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/picture/2019-10-02-21-57-04.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/picture/2019-10-02-21-58-01.png">
<meta property="article:published_time" content="2024-06-05T02:14:32.000Z">
<meta property="article:modified_time" content="2024-06-17T14:52:11.909Z">
<meta property="article:author" content="Tyler-yin">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/picture/image-20240606200432946.png">
    
        <link rel="alternate" type="application/atom+xml" title="Tyler-yin&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/Tyler.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Tyler-yin</h5>
          <a href="mailto:ytrpossible@gmail.com" title="ytrpossible@gmail.com" class="mail">ytrpossible@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Index
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Tyler-ytr/" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-address-book"></i>
                Friends
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-link"></i>
                link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Linux内核设计与实现阅读笔记1</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Linux内核设计与实现阅读笔记1</h1>
        <h5 class="subtitle">
            
                <time datetime="2024-06-05T02:14:32.000Z" itemprop="datePublished" class="page-time">
  2024-06-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux内核设计与实现-第三版-学习笔记"><span class="post-toc-number">1.</span> <span class="post-toc-text">Linux内核设计与实现(第三版) 学习笔记</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第2章-从内核出发"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">第2章 从内核出发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-内核源码"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">2.1 内核源码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-内核源码结构"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">2.2 内核源码结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-编译内核"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">2.3 编译内核</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-内核开发的特点"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">2.4 内核开发的特点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第3章-进程管理"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">第3章 进程管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-进程"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">3.1 进程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-进程描述符"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">3.2 进程描述符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-1-分配进程描述符"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">3.2.1 分配进程描述符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-2-进程描述符的存放"><span class="post-toc-number">1.2.2.2.</span> <span class="post-toc-text">3.2.2 进程描述符的存放</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-3-进程状态"><span class="post-toc-number">1.2.2.3.</span> <span class="post-toc-text">3.2.3 进程状态</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-4-设置进程状态"><span class="post-toc-number">1.2.2.4.</span> <span class="post-toc-text">3.2.4 设置进程状态</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-5-进程上下文"><span class="post-toc-number">1.2.2.5.</span> <span class="post-toc-text">3.2.5 进程上下文</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-6-进程家族树"><span class="post-toc-number">1.2.2.6.</span> <span class="post-toc-text">3.2.6 进程家族树</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-进程创建"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">3.3 进程创建</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-1-写拷贝"><span class="post-toc-number">1.2.3.1.</span> <span class="post-toc-text">3.3.1 写拷贝</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-2-fork"><span class="post-toc-number">1.2.3.2.</span> <span class="post-toc-text">3.3.2 fork()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-3-vfork"><span class="post-toc-number">1.2.3.3.</span> <span class="post-toc-text">3.3.3 vfork()</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-线程在Linux中的实现"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">3.4 线程在Linux中的实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-1-创建线程"><span class="post-toc-number">1.2.4.1.</span> <span class="post-toc-text">3.4.1 创建线程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-2-内核线程"><span class="post-toc-number">1.2.4.2.</span> <span class="post-toc-text">3.4.2 内核线程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-进程终结"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">3.5 进程终结</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-1-删除进程描述符"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">3.5.1 删除进程描述符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-2-孤儿进程造成的进退维谷"><span class="post-toc-number">1.2.6.1.</span> <span class="post-toc-text">3.5.2 孤儿进程造成的进退维谷</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第四章-进程调度"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">第四章 进程调度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-多任务"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">4.1 多任务</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-Linux-的进程调度"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">4.2 Linux 的进程调度</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-策略"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">4.3  策略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-1-I-O消耗型和处理器消耗型的选择"><span class="post-toc-number">1.3.3.1.</span> <span class="post-toc-text">4.3.1  I&#x2F;O消耗型和处理器消耗型的选择</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-2-进程优先级"><span class="post-toc-number">1.3.3.2.</span> <span class="post-toc-text">4.3.2 进程优先级</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-3-时间片"><span class="post-toc-number">1.3.3.3.</span> <span class="post-toc-text">4.3.3 时间片</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-4-Linux调度算法"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">4.4 Linux调度算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-4-1-调度器类"><span class="post-toc-number">1.3.4.1.</span> <span class="post-toc-text">4.4.1 调度器类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-4-3-公平调度"><span class="post-toc-number">1.3.4.2.</span> <span class="post-toc-text">4.4.3 公平调度</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考链接"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">参考链接</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Linux内核设计与实现阅读笔记1"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Linux内核设计与实现阅读笔记1</h1>
        <div class="post-meta">
            <time class="post-time" title="2024-06-05 10:14:32" datetime="2024-06-05T02:14:32.000Z"  itemprop="datePublished">2024-06-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="Linux内核设计与实现-第三版-学习笔记"><a href="#Linux内核设计与实现-第三版-学习笔记" class="headerlink" title="Linux内核设计与实现(第三版) 学习笔记"></a>Linux内核设计与实现(第三版) 学习笔记</h1><h2 id="第2章-从内核出发"><a href="#第2章-从内核出发" class="headerlink" title="第2章 从内核出发"></a>第2章 从内核出发</h2><h3 id="2-1-内核源码"><a href="#2-1-内核源码" class="headerlink" title="2.1 内核源码"></a>2.1 内核源码</h3><p>可以从<a href="https://www.kernel.org/" target="_blank" rel="noopener">内核网站</a>中下载Linux的内核源码。可以使用<code>uname -r</code>查看内核release版本号。</p>
<p>也可以使用如下命令查看最新的版本源代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git</span><br><span class="line"><span class="comment">#更新到最新版本</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>也可以直接使用如下命令直接clone最新版本。然后使用<code>git checkout</code>来切换分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</span><br></pre></td></tr></table></figure>
<p>Linux中一般使用补丁的形式对发布的代码进行修改，增量补丁可以作为版本转移的桥梁。使用如下代码在内部源码树开始进行增量补丁的添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; .../patch-x.y.z</span><br></pre></td></tr></table></figure>
<h3 id="2-2-内核源码结构"><a href="#2-2-内核源码结构" class="headerlink" title="2.2 内核源码结构"></a>2.2 内核源码结构</h3><p>内核源码由很多目录组成，而大多数目录又包含更多的子目录。源码树的根目录及其子目录如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">目录</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">arch</td>
<td style="text-align:left">特定体系结构的源码如：ARM，AMD64</td>
</tr>
<tr>
<td style="text-align:left">block</td>
<td style="text-align:left">块设备I/O层</td>
</tr>
<tr>
<td style="text-align:left">crypto</td>
<td style="text-align:left">加密API</td>
</tr>
<tr>
<td style="text-align:left">Documentation</td>
<td style="text-align:left">内核源码文档</td>
</tr>
<tr>
<td style="text-align:left">drivers</td>
<td style="text-align:left">设备驱动程序</td>
</tr>
<tr>
<td style="text-align:left">firmware</td>
<td style="text-align:left">使用某些驱动程序而需要的设备的固件</td>
</tr>
<tr>
<td style="text-align:left">fs</td>
<td style="text-align:left">VFS和各种文件系统</td>
</tr>
<tr>
<td style="text-align:left">include</td>
<td style="text-align:left">内核头文件</td>
</tr>
<tr>
<td style="text-align:left">init</td>
<td style="text-align:left">内核引导和初始化</td>
</tr>
<tr>
<td style="text-align:left">ipc</td>
<td style="text-align:left">进程间通信代码</td>
</tr>
<tr>
<td style="text-align:left">kernel</td>
<td style="text-align:left">调度程序等核心子系统</td>
</tr>
<tr>
<td style="text-align:left">lib</td>
<td style="text-align:left">通用内核函数</td>
</tr>
<tr>
<td style="text-align:left">mm</td>
<td style="text-align:left">内存管理子系统和VM</td>
</tr>
<tr>
<td style="text-align:left">net</td>
<td style="text-align:left">网络子系统</td>
</tr>
<tr>
<td style="text-align:left">samples</td>
<td style="text-align:left">示例，示范代码</td>
</tr>
<tr>
<td style="text-align:left">scripts</td>
<td style="text-align:left">编译内核所用的脚本</td>
</tr>
<tr>
<td style="text-align:left">security</td>
<td style="text-align:left">Linux安全模块</td>
</tr>
<tr>
<td style="text-align:left">sound</td>
<td style="text-align:left">语音子系统</td>
</tr>
<tr>
<td style="text-align:left">usr</td>
<td style="text-align:left">早期用户空间代码(所谓的initramfs)</td>
</tr>
<tr>
<td style="text-align:left">tools</td>
<td style="text-align:left">在Linux开发中有用的工具</td>
</tr>
<tr>
<td style="text-align:left">virt</td>
<td style="text-align:left">虚拟化基础结构</td>
</tr>
</tbody>
</table>
<h3 id="2-3-编译内核"><a href="#2-3-编译内核" class="headerlink" title="2.3 编译内核"></a>2.3 编译内核</h3><p>略</p>
<h3 id="2-4-内核开发的特点"><a href="#2-4-内核开发的特点" class="headerlink" title="2.4 内核开发的特点"></a>2.4 内核开发的特点</h3><ol>
<li>内核编程时既不能访问c库也不能访问标准的c头文件<ol>
<li>完整的C库太大过于低效；</li>
<li>基本头文件在顶级目录下的include目录中；体系结构相关的头文件在arch//include/asm目录下使用<code>#include &lt;asm/ioctl.h&gt;</code>进行头文件的包含。</li>
</ol>
</li>
<li>GNU C<ol>
<li>内核开发包括了C99标准以及GNU C扩展特性</li>
<li>内联函数；使用inline内联函数</li>
<li>内联汇编；使用<code>asm volatile(&quot;rdtsc&quot;:&quot;=a&quot; (low),&quot;=d&quot; (high))</code>嵌入汇编代码</li>
<li>分支声明；使用<code>likely</code>和<code>unlikely</code>对于if-else条件分支选择进行优化</li>
</ol>
</li>
<li>没有内存保护机制<ol>
<li>用户程序的非法内存访问由内核兜底并结束进程；内核自己非法内存访问就直接寄了</li>
<li>内核的内存不分页</li>
</ol>
</li>
<li>不要轻易在内核使用浮点数<ol>
<li>用户程序的浮点操作会通过内核转换为整数操作</li>
<li>内核本身不能完美地支持浮点操作</li>
</ol>
</li>
<li>内核给每个进程只有一个很小的定长堆栈<ol>
<li>内核栈的准确大小随着体系结构而改变，内核栈的大小是两页，32位是8KB，64位是16KB。</li>
</ol>
</li>
<li>需要关注并发和同步<ol>
<li>Linux是抢占多任务操作系统，内核包含了调度程序，内核必须和这些任务同步</li>
<li>Linux支持对称多处理器系统(SMP)，需要考虑多处理器并发访问同一个资源的情况</li>
<li>中断随时都可能发生</li>
<li>Linux内核可抢占，没有保护，可能导致几段代码同时访问相同的资源，通常使用自旋锁和信号量来解决</li>
</ol>
</li>
<li>要仔细考虑可移植的特性<ol>
<li>注意保持字节序、64位对齐、不假定字长和页面长度等一系列准则等</li>
</ol>
</li>
</ol>
<h2 id="第3章-进程管理"><a href="#第3章-进程管理" class="headerlink" title="第3章 进程管理"></a>第3章 进程管理</h2><h3 id="3-1-进程"><a href="#3-1-进程" class="headerlink" title="3.1 进程"></a>3.1 进程</h3><ol>
<li><strong>每一个线程都拥有一个独立的程序计数器、进程栈、一组进程寄存器</strong>。<em>内核调度的对象是线程，而不是进程</em> (<a href="https://www.jianshu.com/p/8ff15d3a1dfd" target="_blank" rel="noopener">从进程和线程了解浏览器的工作原理</a>)；在Linux中对线程和进程的区分度不是很大。</li>
<li>线程之间共享虚拟内存，但是每个线程都拥有自己独立的虚拟处理器。</li>
<li>程序本身不是进程。可以存在多个进程执行同一个程序；多个进程也可以共享诸多资源，比如打开文件或者地址空间</li>
<li>进程一般通过fork()复制现有进程创建新进程；调用结束后，父进程恢复执行，子进程开始执行。fork()系统调用从内核返回两次，一次回到父进程，一次回到子进程。</li>
<li>新的进程可以通过调用exec()创建新的地址空间；程序通过exec()系统调用推出。父进程可以通过wait4()查询子进程是否被终结。</li>
</ol>
<h3 id="3-2-进程描述符"><a href="#3-2-进程描述符" class="headerlink" title="3.2 进程描述符"></a>3.2 进程描述符</h3><p><em>参考链接：</em> <a href="https://blog.csdn.net/gatieme/article/details/51383272" target="_blank" rel="noopener">Linux进程描述符task_struct结构体详解</a>;<a href="https://segmentfault.com/a/1190000009724931" target="_blank" rel="noopener">文件描述符（File Descriptor）简介</a></p>
<p>内核通过任务队列的(双向循环链表)来存放和管理进程列表。其中存放的数据类型是<code>task_struct</code>，即进程描述符，定义在<code>&lt;linux/sched.h&gt;</code>文件中，包含有：打开的文件、进程的地址空间、挂起的信号、进程的状态等信息。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="picture/image-20240606200432946.png" alt="进程描述符" title="">
                </div>
                <div class="image-caption">进程描述符</div>
            </figure>
<h4 id="3-2-1-分配进程描述符"><a href="#3-2-1-分配进程描述符" class="headerlink" title="3.2.1 分配进程描述符"></a>3.2.1 分配进程描述符</h4><p>Linux 通过slab分配器分配task_struct结构。slab生成一个task_struct,只需要在栈底(向下增长的栈)或栈顶(向上增加的栈)创建一个新的结构<code>thread_info</code>(定义在<code>&lt;asm/thread_info.h&gt;</code>)中内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>  *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32               flags;</span><br><span class="line">    __u32               status;</span><br><span class="line">    __u32               cpu;</span><br><span class="line">    <span class="keyword">int</span> fd              preempt_count;</span><br><span class="line">    <span class="keyword">mm_segment_t</span>        addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>    <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">void</span>                    *sysenter_return;</span><br><span class="line">    <span class="keyword">int</span>                     uaccess_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="picture/image-20240606201800745.png" alt="进程描述符和内核栈" title="">
                </div>
                <div class="image-caption">进程描述符和内核栈</div>
            </figure>
<p>每个任务的thread_info结构在它的内核栈的尾端分配，结构中task域中存放的是指该任务实际task_struct的指针</p>
<h4 id="3-2-2-进程描述符的存放"><a href="#3-2-2-进程描述符的存放" class="headerlink" title="3.2.2 进程描述符的存放"></a>3.2.2 进程描述符的存放</h4><ol>
<li><p>内核通过唯一的进程标识值(PID)来标识每一个进程。PID类型是<code>pid_t</code>，实际上是int,最大值位32768；不考虑兼容性的情况下可以通过修改<code>/proc/sys/kernel/pid_max</code>提高上限。</p>
</li>
<li><p>内核中的访问任务，通常需要获取其指向task_struct的指针。一般是通过current宏来查找当前正在运行进程的task_struct。不同的硬件体系结构实现的方式不同。一般都是汇编配合专用寄存器来实现的。</p>
</li>
</ol>
<h4 id="3-2-3-进程状态"><a href="#3-2-3-进程状态" class="headerlink" title="3.2.3 进程状态"></a>3.2.3 进程状态</h4><ol>
<li>进程描述符中的state域描述了当前集成的状态。必然是下面的5种情况之一<ol>
<li><code>TASK_RUNNING</code>(运行):进程可执行或者正在执行</li>
<li><code>TASK_INTERRUPTIBLE</code>(可中断):进程正在睡眠状态(也就是说它被阻塞)，等待某些条件的达成。就可以从状态回到运行态</li>
<li><code>TASK_UNINTERRUPTIBLE</code>(不可中断):就算接收到信号也不会被唤醒或准备</li>
<li><code>__TASK_TRACED</code>:被其它进程跟踪的进行，例如通过ptrace对调试程序进行跟踪</li>
<li><code>__TASK_STOPPED</code>(停止)：进程停止执行；进程没有投入运行也不能投入运行。</li>
</ol>
</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="picture/image-20240608194647424.png" alt="进程状态" title="">
                </div>
                <div class="image-caption">进程状态</div>
            </figure>
<h4 id="3-2-4-设置进程状态"><a href="#3-2-4-设置进程状态" class="headerlink" title="3.2.4 设置进程状态"></a>3.2.4 设置进程状态</h4><p>内核可以使用<code>set_task_state(task,state)</code>或<code>set_current_state(state)</code>函数来更改和设置进程的状态</p>
<h4 id="3-2-5-进程上下文"><a href="#3-2-5-进程上下文" class="headerlink" title="3.2.5 进程上下文"></a>3.2.5 进程上下文</h4><ol>
<li><p>可执行程序代码是进程的重要组成部分，这些代码从一个可执行文件载入到进程的地址空间执行。</p>
</li>
<li><p>需要注意的是，执行系统调用时，内核“代表进程执行”并处于进程上下文中，此时current宏是有效的；相对的中断上下文中，系统不代表进程执行，而是执行中断处理程序，所以此时不存在进程上下文。</p>
</li>
</ol>
<h4 id="3-2-6-进程家族树"><a href="#3-2-6-进程家族树" class="headerlink" title="3.2.6 进程家族树"></a>3.2.6 进程家族树</h4><ol>
<li><p>Linux和unix中所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。init进程读取系统的初始化脚本(initscript)并执行其它程序，最终完成系统启动的整个过程。</p>
</li>
<li><p>系统中每一个进程必有一个父进程。每个task_struct都包含一个指针指向其父进程task_struct的parent指针。也有一个children的子进程链表。可以通过如下代码依次访问父进程和子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取父进程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span>=<span class="title">current</span>-&gt;<span class="title">parent</span>;</span></span><br><span class="line"><span class="comment">//依次访问子进程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">list_for_each(<span class="built_in">list</span>,&amp;current-&gt;children)&#123;</span><br><span class="line">    task=list_entry(<span class="built_in">list</span>,struct task_struct,siblings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init进程的进程描述符是作为init_task静态分配的。下面的代码可以很好的演示所有进程之间的关系:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="comment">//一直指向直到查找到init进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(task==current;task!=&amp;init_task;task=task-&gt;parent)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表的下一个进程</span></span><br><span class="line"></span><br><span class="line">list_entry(task-&gt;task.next,struct task_struct task);</span><br><span class="line"><span class="comment">//获取前一个进程</span></span><br><span class="line"></span><br><span class="line">list_entry(task-&gt;task.prev,struct task_struct task);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-3-进程创建"><a href="#3-3-进程创建" class="headerlink" title="3.3 进程创建"></a>3.3 进程创建</h3><p>Linux使用fork()以及exec()的组合来创建进程。</p>
<h4 id="3-3-1-写拷贝"><a href="#3-3-1-写拷贝" class="headerlink" title="3.3.1 写拷贝"></a>3.3.1 写拷贝</h4><p>linux中的fork()使用写时拷贝(copy-on-write)页实现。fork()时内核并不复制整个进程地址空间，而是让父进程和子进程共享一个拷贝。只有在需要写入的时候，数据才会被复制。之前都是以只读方式共享。因此fork()的实际开销在于复制父进程的页表以及给子进程创建唯一的进程描述符。</p>
<h4 id="3-3-2-fork"><a href="#3-3-2-fork" class="headerlink" title="3.3.2 fork()"></a>3.3.2 fork()</h4><p>fork()函数调用clone()系统调用，再由clone()去调用do_fork(),do_fork()调用copy_process()函数，然后让进程开始运行。copy_process()完成的工作内容如下：</p>
<ol>
<li>调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的</li>
<li>检查确认子进程后，确认当前用户所拥有的进程数目没有超出它分配的资源</li>
<li>子进程开始设置与父进程的差异值。进程描述符中许多成员都要被清0或者重新初始化</li>
<li>子进程状态被设置为TASK_UNINTERRUPTIBLE，防止被投入运行</li>
<li>copy_process()调用copy_flags()以更新task_struct的flags成员。</li>
<li>调用alloc_pid()为新进程分配一个有效的pid</li>
<li>根据clone()函数接收到的参数，为copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等</li>
<li>最后，copy_process()做扫尾工作，并返回一个指向子进程的指针。</li>
</ol>
<p>最终层层调用回归，kernel会优先选择执行子进程，因为一般子进程都会马上调用exec()函数。避免额写拷贝开销。如果父进程先执行，则可能会开开始向地址空间中写入。</p>
<h4 id="3-3-3-vfork"><a href="#3-3-3-vfork" class="headerlink" title="3.3.3 vfork()"></a>3.3.3 vfork()</h4><p>vfork()不拷贝父进程的页表项，其它基本相同；子进程作为父进程的一个单独的线程在它的地址空间中运行。不过现在基本没什么作用了。</p>
<h3 id="3-4-线程在Linux中的实现"><a href="#3-4-线程在Linux中的实现" class="headerlink" title="3.4 线程在Linux中的实现"></a>3.4 线程在Linux中的实现</h3><p>Linux中将所有的线程都当做进程来实现，内核并没有准备特别的线程调度算法或特定数据结构。线程仅仅被视为一个与其它进程共享某些资源的进程。每个线程都拥有唯一一个task_struct。(Windows或者Solaris都在内核中提供了专门的线程支持机制–轻量级进程)</p>
<h4 id="3-4-1-创建线程"><a href="#3-4-1-创建线程" class="headerlink" title="3.4.1 创建线程"></a>3.4.1 创建线程</h4><p>创建线程与进程相似，不过是在调用clone时需要传递参数来指明需要共享的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//clone 参数</span></span><br><span class="line">clone(CLONE_VM|CLONE_FS|CLONE_FILES|CONLE_SIGHAND,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通fork实现</span></span><br><span class="line"></span><br><span class="line">clone(SIGCHLD,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//vfork()实现</span></span><br><span class="line"></span><br><span class="line">clone(CLONE_VFORK|CLONE_VM|SIGCHLD,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>clone的标志位可选内容如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="picture/2019-10-02-21-57-04.png" alt="clone参数1" title="">
                </div>
                <div class="image-caption">clone参数1</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="picture/2019-10-02-21-58-01.png" alt="clone参数2" title="">
                </div>
                <div class="image-caption">clone参数2</div>
            </figure>
<h4 id="3-4-2-内核线程"><a href="#3-4-2-内核线程" class="headerlink" title="3.4.2 内核线程"></a>3.4.2 内核线程</h4><p>内核中也是存在线程，称为内核线程。内核线程<strong>没有独立的地址空间</strong>(实际上指向地址空间的mm指针被设置为NULL)。他们只在内核空间运行，从来不切换到用户空间去。使用<code>ps -ef</code>可以查看到内核线程。</p>
<p>从现有内核中创建一个新的内核线程的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">kthread_create</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data),<span class="keyword">void</span> *data,<span class="keyword">const</span> <span class="keyword">char</span> namefmt[],...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">kthread_run</span><span class="params">(<span class="keyword">int</span>(*threadfn)(<span class="keyword">void</span> *data),<span class="keyword">void</span> data,<span class="keyword">const</span> <span class="keyword">char</span> namefmt[],...)</span></span></span><br></pre></td></tr></table></figure>
<p>新创建的进程不会主动运行。需要使用kthread_run()函数来让进程运行起来。kthread_run()是以宏实现的具体实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kthread_run(threadfn,data,namefmt,...) \ </span></span><br><span class="line">(&#123; \ </span><br><span class="line">	struct task_struct *k; \ </span><br><span class="line">	k=kthread_create(threadfn,data,namefmt,##__VA_ARGS__); \ </span><br><span class="line">	<span class="keyword">if</span>(!IS_ERR(k)) \ </span><br><span class="line">	wake_up_process(k); \ </span><br><span class="line">	k; \ </span><br><span class="line">&#125;) \</span><br></pre></td></tr></table></figure>
<p>内核线程启动之后一直运行知道调用do_exit()退出，或者内核的其他部分调用 kthread_stop()退出。</p>
<h3 id="3-5-进程终结"><a href="#3-5-进程终结" class="headerlink" title="3.5 进程终结"></a>3.5 进程终结</h3><p>一般进程的析构是自身引起的，发生在exit()被调用时。C语言编译器会在main函数的return 之后调用exit()函数。exit()函数的主要任务由do_exit()来完成。主要完成下面的几个工作：</p>
<ol>
<li>将task_struct中的标志成员设置为PF_EXITING;</li>
<li>调用del_timer_sync()删除任一内核定时器。取消CPU排队。</li>
<li>如果BSD()的<a href="https://blog.csdn.net/zhizhengguan/article/details/117392646" target="_blank" rel="noopener">进程记账</a>功能是开启的，会调用acct_update_integrals()来输出记账信息。</li>
<li>调用exit_mm()来释放进程占用的mm_struct。内存没有被共享就彻底释放他们。</li>
<li>调用sem_exit()函数。取消正在等待的IPC信号队列</li>
<li>调用exit_files()和exit_fs()，分别递减文件描述符、文件系统数据的引用计数。计数为0释放资源</li>
<li>将存放在task_struct中的exit_code成员中的退出代码设置为exit()提供的退出代码。供父进程随时检索</li>
<li>调用exit_notify()向父进程发送信号，并给子进程重新寻找养父(线程组中的其它线程或者init进程)，把进程状态(task_struct结构中的exit_state)设置为EXIT_ZOMBIE。</li>
<li>调用schedule()切换到新的进程。处于EXIT_ZOMBIE状态的进程不会再被调度。</li>
</ol>
<p>上述操作之后，进程不可运行并处于EXIT_ZOMBIE状态，它存在的唯一目的就是向它的父进程提供信息。父进程检索到信息之后(或通知内核子进程信息是无关信息后)。进程持有的剩余内存(task_struct)被释放。所有资源回归给系统。</p>
<h3 id="3-5-1-删除进程描述符"><a href="#3-5-1-删除进程描述符" class="headerlink" title="3.5.1 删除进程描述符"></a>3.5.1 删除进程描述符</h3><p>当父进程收到消息，并且确认进程无用时，就可以进程进程描述符的删除。删除工作主要由<code>release_task()</code>函数完成主要工作内容如下：</p>
<ol>
<li>调用<code>__exit_signal()</code>函数，它调用<code>__unhash_process()</code>,后者继续调用<code>detach_pid()</code>。从<code>pidhash</code>上删除该进程，即将该进程从任务列表中删除。</li>
<li><code>__exit_signal()</code>函数释放当前僵死进程所用的所有剩余资源，并进行最终统计和记录。</li>
<li>如果这个进程是线程最后一个进程，并且领头进程已经死掉，那么<code>release_task()</code>将通知僵死的领头进程的父进程。</li>
<li><code>release_task()</code>调用<code>put_task_ struct()</code>释放进程内核栈和<code>thread_info</code>结构所占的页,并释放<code>task_struct</code>所占的slab高速缓存。</li>
</ol>
<h4 id="3-5-2-孤儿进程造成的进退维谷"><a href="#3-5-2-孤儿进程造成的进退维谷" class="headerlink" title="3.5.2 孤儿进程造成的进退维谷"></a>3.5.2 孤儿进程造成的进退维谷</h4><p>父进程在子进程之前退出，会给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做他们的父进程（通过这样的方法可以防止这些“孤儿”进程在退出的时候永远处于僵死状态浪费内存）。函数调用顺序如下:do_exit()-&gt;exit_notify()-&gt;forget_original_parent()-&gt;find_new_reaper();<code>find_new_reaper()</code>函数执行过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">find_new_reaper</span><span class="params">(struct task_struct *father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>=<span class="title">task_active_pid_ns</span>(<span class="title">father</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span></span><br><span class="line">    thread=father;</span><br><span class="line">    <span class="comment">//遍历每一个线程，寻找最佳的线程</span></span><br><span class="line"></span><br><span class="line">    while_each_thread(father,thread)&#123;</span><br><span class="line">        <span class="comment">//检查任务是否存在，否则跳过下面的执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(thread-&gt;flags&amp;PF_EXITING)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//将它的孩子指针指向father;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(unlikely(pid_ns-&gt;child_reaper==father))</span><br><span class="line">            pid_ns-&gt;child_reaper=thread;</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pid_ns没有指向father</span></span><br><span class="line">    <span class="keyword">if</span>(unlikely(pid_ns-&gt;child_reaper==father))&#123;</span><br><span class="line">        <span class="comment">//进行任务列表加锁</span></span><br><span class="line">        </span><br><span class="line">        write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">        <span class="comment">//检查是否是初始化进程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(unlikely(pid_ns==&amp;init_pid_ns))&#123;</span><br><span class="line">            panic(<span class="string">"Attempted to kill init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        zap_pid_ns_processes(pid_ns);</span><br><span class="line">        write_lock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">        pid_ns-&gt;child_reaper=init_pid_ns.child_reaper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid_ns-&gt;child_reaper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是通过对各个进程的遍历，查找可以作为父进程的指针 在找到养父进程之后，就可以遍历所有子进程并为他们设置新的父进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reaper=find_new_reaper(father);</span><br><span class="line"></span><br><span class="line">list_for_each_entry_safe(p,n,&amp;father-&gt;children,siblings)&#123;</span><br><span class="line">    p-&gt;real_parent=reaper;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;parent==father)&#123;</span><br><span class="line">        BUG_ON(p-&gt;ptrace);</span><br><span class="line">        p-&gt;parent=p-&gt;real_parent;</span><br><span class="line">    &#125;</span><br><span class="line">    reparent_thread(p,father);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来使用ptrace_exit_finish()同样进行新的寻父过程，不过这次是给ptraced的子进程寻找父亲</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit_ptrace</span><span class="params">(struct task_struct *tracer)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>,*<span class="title">n</span>;</span></span><br><span class="line">    LIST_HEAD(ptrace_dead);</span><br><span class="line">    <span class="comment">//添加任务线程锁</span></span><br><span class="line"></span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    list_for_each_entry_safe(p,n,&amp;tracer-&gt;ptraced,ptrace_entry)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__ptrace_detach(tracer,p))&#123;</span><br><span class="line">            list_add(&amp;p-&gt;ptrace_entry,&amp;ptrace_dead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    BUG_ON(!list_empty(&amp;tracer-&gt;ptraced));</span><br><span class="line">    list_for_each_entry_safe(p,n,&amp;tracer-&gt;ptraced,ptrace_entry)&#123;</span><br><span class="line">        list_del_init(&amp;p-&gt;ptrace_entry);</span><br><span class="line">        release_task(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四章-进程调度"><a href="#第四章-进程调度" class="headerlink" title="第四章 进程调度"></a>第四章 进程调度</h2><p>调度程序负责决定将哪一个进程投入运行，何时运行以及运行多长实时间，它的基本原则是：最大限度的利用处理器时间。</p>
<h3 id="4-1-多任务"><a href="#4-1-多任务" class="headerlink" title="4.1 多任务"></a>4.1 多任务</h3><p>多任务分类：抢占式和非抢占式。Linux中提供了抢占(强行挂起的动作)式的多任务模式。</p>
<h3 id="4-2-Linux-的进程调度"><a href="#4-2-Linux-的进程调度" class="headerlink" title="4.2 Linux 的进程调度"></a>4.2 Linux 的进程调度</h3><p><em>参考链接：</em></p>
<ul>
<li><a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">小林coding调度算法</a></li>
</ul>
<p>Linux中从2.5开始使用了O(1)内核调度算法。但是该算法对响应时间敏感的程序有一些先天不足，对于服务器友好，但是对于桌面操作系统不行。因此引用了“翻转楼梯最后期限调度算法”(RSDL)。被称为“完全公平调度算法”或者简称(CFS)。</p>
<h3 id="4-3-策略"><a href="#4-3-策略" class="headerlink" title="4.3  策略"></a>4.3  策略</h3><p>策略决定调度程序在何时让什么进程运行。</p>
<h4 id="4-3-1-I-O消耗型和处理器消耗型的选择"><a href="#4-3-1-I-O消耗型和处理器消耗型的选择" class="headerlink" title="4.3.1  I/O消耗型和处理器消耗型的选择"></a>4.3.1  I/O消耗型和处理器消耗型的选择</h4><p>进程分为I/O消耗型和处理器消耗型，例如GUI是属于I/O密集型，矩阵运算是处理器消耗密集型。</p>
<p>调度策略需要在两个矛盾的目标中间寻求平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）</p>
<h4 id="4-3-2-进程优先级"><a href="#4-3-2-进程优先级" class="headerlink" title="4.3.2 进程优先级"></a>4.3.2 进程优先级</h4><p>Linux 中采用了两种不同的优先级范围：</p>
<ul>
<li>nice值，范围是-20到+19，默认值为0；nice值越大意味着优先级越低（说明该进程对其他进程更友好）。低nice值会获得更多的处理器时间。Linux系统中，nice值代表时间片的比例，可以通过<code>ps-el</code>查看系统中的进程列表，Mac OS中，nice值代表分配给进程的时间片的绝对值</li>
<li>实时优先级:是可配置的。默认情况下的变化范围是0到99，越高意味着进程优先级越高。可以通过如下命令查看实时优先级：<code>ps -ao state,uid,pid,ppid,rtprio,time,comm</code>;其中(RTPRIO)表示实时优先级。</li>
</ul>
<h4 id="4-3-3-时间片"><a href="#4-3-3-时间片" class="headerlink" title="4.3.3 时间片"></a>4.3.3 时间片</h4><p>Linux默认的时间片是10ms。</p>
<h3 id="4-4-Linux调度算法"><a href="#4-4-Linux调度算法" class="headerlink" title="4.4 Linux调度算法"></a>4.4 Linux调度算法</h3><h4 id="4-4-1-调度器类"><a href="#4-4-1-调度器类" class="headerlink" title="4.4.1 调度器类"></a>4.4.1 调度器类</h4><p>Linux调度器是以模块方式提供的，这样做的目的是允许不同类型的进程可以有针对性地选择调度算法。这种模块化结构被称为<strong>调度器类(scheduler classes)</strong>。它允许多种不同的可添加的调度算法并存，调度器代码定义在<code>kernel/sched.c</code>文件中。完全公平调度(CFS)是针对一个普通进程的调度，在Linux中称SCHED_NORMAL(在POSIX中称为SCHED_OTHER)，CFS定义在文件<code>kernel/sched_fair.c</code>中。</p>
<h4 id="4-4-3-公平调度"><a href="#4-4-3-公平调度" class="headerlink" title="4.4.3 公平调度"></a>4.4.3 公平调度</h4><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><p><a href="https://github.com/muditbac/Reading/blob/master/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(%E7%AC%AC%E4%B8%89%E7%89%88%E4%B8%AD%E6%96%87%E9%AB%98%E6%B8%85%E5%B8%A6%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">电子书地址</a>.pdf)</p>
</li>
<li><p><a href="https://wangpengcheng.github.io/2019/09/18/linux_kernel_development_01/" target="_blank" rel="noopener">博客笔记</a></p>
</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2024-06-17T14:52:11.909Z" itemprop="dateUpdated">2024-06-17 22:52:11</time>
</span><br>


        
        Link：<a href="/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/" target="_blank" rel="external">http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/</a>
        
    </div>
    
    <footer>
        <a href="http://Tyler-ytr.github.io">
            <img src="/img/Tyler.png" alt="Tyler-yin">
            Tyler-yin
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/&title=《Linux内核设计与实现阅读笔记1》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/&title=《Linux内核设计与实现阅读笔记1》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Linux内核设计与实现阅读笔记1》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2024/04/24/Tofino%E6%8E%A7%E5%88%B6%E9%9D%A2/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Tofino控制面</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "NoLhoWnmbSW89zV4zc04RPwx-gzGzoHsz",
            appKey: "SSdRGaHcdjoKc7cJJpOlJIqJ",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Tyler-yin &copy; 2015 - 2024</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/&title=《Linux内核设计与实现阅读笔记1》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/&title=《Linux内核设计与实现阅读笔记1》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Linux内核设计与实现阅读笔记1》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2024/06/05/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAElElEQVR42u3aW27jOhAEUO9/0xng/ia2q7qVuabm6MvwgyKPDJD9eDzi6+u/6/vr79/5fn3/9PXIyW+fvZPP5PEbFyZMmDBh+kimr5dXMvQzgtcLePad12Ttp/l8Xo+JCRMmTJhOZ5oN13Js7vgaNPm0PdxgwoQJE6Z/jSkPHROmGcTsYJEEzJgwYcKECdM+ITtLtrZh8D7hiwkTJkyY7sfU3my2xbbjz0LxPCn8K7lwTJgwYcL0YUybxp3TX/+l/iZMmDBhwvQ/MX2VV5vSzceZBdJtKXS4akyYMGHCdCxTXj7cJHD3Sd5NY1Aecr+ZFSZMmDBhuh3TpjkmH7ndsJP7XpWAjg4EmDBhwoTpg5ny7TmZUNs82qZlkwNEGypHfxFMmDBhwnQsUx7QthPN06nJ5r0nSx7SG0RMmDBhwnQgU37LdjGbqecjXwXxZkWYMGHChOlwplnzTVvIzCuDM+K23ac+MWHChAkTplsw7Vt5ZmXLPNydoc8C6Te5cEyYMGHC9PFMM4KEb7aFt3efIeYp6cfmn4IJEyZMmD6SaX8syA8B++9v0sd5iw8mTJgwYTqdaZOQzSfUhqbJYvaBd/uHwIQJEyZMZzG1om0YnJc/23c23HXIjQkTJkyYjmXKl5qHjnl4eVULzibpnMwQEyZMmDCdy5Snd9tEbX7UaNO47RzaGf7wGhMmTJgw3YipvcGsAXQfDOdnnPYR/nBHTJgwYcJ0LFOy/belyk1eNA9lW+J2XW+KmpgwYcKE6RZMbbZ4uNGO7pUvcjMmJkyYMGE6nakNYq8KbotteBQMJ4+qOC5gwoQJE6bDmdrmm3yctuFmNk6ejB6GzZgwYcKE6VimPKmahJez40K+F7cBc7uuQgMTJkyYMB3FlCdD20B33wa0CdrbA0FUzsSECRMmTDdi2gSN+cJmYW0yt314XOhiwoQJE6YPZmq3zPwQkC9+04Kz3/KHoTImTJgwYTqWqU3m5lvyLFTOW4tmoXV+JMKECRMmTCcybYqOm+15U6qcFS/zwP5NkhcTJkyYMB3IlA80KysmR4R9MbJNDedhNiZMmDBhOpdplkidJWSvDUd/LxSva7+YMGHChOmDmXKIazf4vAGoPbJskr+YMGHChOmuTEkY2QaWbRo3T862s81Zn76PCRMmTJgOZ8oPBNcmc/MmoXxrz9eVNyphwoQJE6YTmb7WVx4ebxa/L2Hm5dIf4DBhwoQJ0+FMmzC1vmUQuF7bEtQ+wh/GwYQJEyZMt2Bqm2ZmqdI8XfsbYfmqLRUTJkyYMB3IlAPlBcJ8O88Tr3ngPXsY9UPChAkTJkyHMF2V0t2UJ9steTar5F5PoTFhwoQJ07FMm6aW/Dub7ycFzhn0BQEwJkyYMGE6hKko7I225/aI0P5q1o6TNxJhwoQJE6Z7MCUbZ9uyk+A+RtfrETatRW/yBJgwYcKE6dZM+Xa+L3luDhzRsq8qAWPChAkTplsztWSbIuiswWgzN0yYMGHCdCem2eKvCkHzo0BbqmwD+6e/xYQJEyZMxzJtGndy1ja1OgtrZweIVUiMCRMmTJg+l+kPs3FaCnpuplUAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '＞﹏＜';
            clearTimeout(titleTime);
        } else {
            document.title = '~\(≧▽≦)/~';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


</body>
</html>
