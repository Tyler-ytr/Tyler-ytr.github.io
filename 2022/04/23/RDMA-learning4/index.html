<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>RDMA-learning4 | Tyler-yin&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="RDMA">
    <meta name="description" content="RDMA技术整理4 RDMA编程入门连通测试物理拓扑：服务器6和8之间有一根直连网线；两台服务器各有一张cx5网卡，支持RoCe  使用ibdev2netdev查看设备：   使用show_gids看看网卡支持的RoCe版本  这里的IPv4地址是通过nmtui进行配置的  服务器8根据如上的信息使用ib_send_bw -d mlx5_1 -x 2，作为信号的接收端；另一台服务器6使用sudo">
<meta property="og:type" content="article">
<meta property="og:title" content="RDMA-learning4">
<meta property="og:url" content="http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/index.html">
<meta property="og:site_name" content="Tyler-yin&#39;s blog">
<meta property="og:description" content="RDMA技术整理4 RDMA编程入门连通测试物理拓扑：服务器6和8之间有一根直连网线；两台服务器各有一张cx5网卡，支持RoCe  使用ibdev2netdev查看设备：   使用show_gids看看网卡支持的RoCe版本  这里的IPv4地址是通过nmtui进行配置的  服务器8根据如上的信息使用ib_send_bw -d mlx5_1 -x 2，作为信号的接收端；另一台服务器6使用sudo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/picture/image-20220426191053641.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/picture/image-20220426191319616.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/picture/image-20220426191807687.png">
<meta property="og:image" content="http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/picture/image-20220426191822803.png">
<meta property="article:published_time" content="2022-04-23T12:47:37.000Z">
<meta property="article:modified_time" content="2022-05-08T08:58:36.360Z">
<meta property="article:author" content="Tyler-yin">
<meta property="article:tag" content="RDMA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/picture/image-20220426191053641.png">
    
        <link rel="alternate" type="application/atom+xml" title="Tyler-yin&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/Tyler.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Tyler-yin</h5>
          <a href="mailto:ytrpossible@gmail.com" title="ytrpossible@gmail.com" class="mail">ytrpossible@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Index
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Tyler-ytr/" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-address-book"></i>
                Friends
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-link"></i>
                link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">RDMA-learning4</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">RDMA-learning4</h1>
        <h5 class="subtitle">
            
                <time datetime="2022-04-23T12:47:37.000Z" itemprop="datePublished" class="page-time">
  2022-04-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RDMA技术整理4-RDMA编程入门"><span class="post-toc-number">1.</span> <span class="post-toc-text">RDMA技术整理4 RDMA编程入门</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#连通测试"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">连通测试</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RDMA-常用命令"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">RDMA 常用命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RDMA-编程入门"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">RDMA 编程入门</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RDMA-编程入门1"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">RDMA 编程入门1</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Passive-Server-side"><span class="post-toc-number">1.3.1.0.1.</span> <span class="post-toc-text">Passive&#x2F;Server side</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考资料"><span class="post-toc-number">1.3.1.1.</span> <span class="post-toc-text">参考资料</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-RDMA-learning4"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">RDMA-learning4</h1>
        <div class="post-meta">
            <time class="post-time" title="2022-04-23 20:47:37" datetime="2022-04-23T12:47:37.000Z"  itemprop="datePublished">2022-04-23</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="RDMA技术整理4-RDMA编程入门"><a href="#RDMA技术整理4-RDMA编程入门" class="headerlink" title="RDMA技术整理4 RDMA编程入门"></a>RDMA技术整理4 RDMA编程入门</h1><h2 id="连通测试"><a href="#连通测试" class="headerlink" title="连通测试"></a>连通测试</h2><p>物理拓扑：服务器6和8之间有一根直连网线；两台服务器各有一张cx5网卡，支持RoCe</p>
<ol>
<li><p>使用<code>ibdev2netdev</code>查看设备：</p>
<p><img src="picture/image-20220426191053641.png" alt="image-20220426191053641"></p>
</li>
<li><p>使用<code>show_gids</code>看看网卡支持的RoCe版本</p>
<p><img src="picture/image-20220426191319616.png" alt="image-20220426191319616"></p>
<p>这里的IPv4地址是通过<code>nmtui</code>进行配置的</p>
</li>
<li><p>服务器8根据如上的信息使用<code>ib_send_bw -d mlx5_1 -x 2</code>，作为信号的接收端；另一台服务器6使用<code>sudo ib_send_bw -d mlx5_3 192.168.42.8 --report_gbits -F -x 2</code>进行信息的发送；（5_3是服务器6里面有ipv4地址并且up的设备）</p>
</li>
<li><p>测试结果:</p>
<p>接收端：</p>
<p><img src="picture/image-20220426191807687.png" alt="image-20220426191807687"></p>
<p>发送端：</p>
<p><img src="picture/image-20220426191822803.png" alt="image-20220426191822803"></p>
</li>
</ol>
<h2 id="RDMA-常用命令"><a href="#RDMA-常用命令" class="headerlink" title="RDMA 常用命令"></a>RDMA 常用命令</h2><p>参考自<a href="https://blog.csdn.net/bandaoyu/article/details/115798693" target="_blank" rel="noopener">https://blog.csdn.net/bandaoyu/article/details/115798693</a></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>操作</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ibv_devinfo</code></td>
<td>显示device信息（简略）</td>
<td></td>
</tr>
<tr>
<td><code>ibv_devinfo mlx5_0</code></td>
<td>显示设备mlx5_0的详细信息</td>
<td></td>
</tr>
<tr>
<td><code>ibv_devinfo -v</code></td>
<td>显示网卡信息（详细）</td>
<td></td>
</tr>
<tr>
<td><code>ibv_devices</code></td>
<td>列出device</td>
<td></td>
</tr>
<tr>
<td><code>ibvdev2netdev</code></td>
<td>显示device和网口的对应关系</td>
<td>mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令</td>
</tr>
<tr>
<td><code>show_gids</code></td>
<td>显示gid列表</td>
<td>mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令</td>
</tr>
<tr>
<td><code>show_drop</code></td>
<td>查看端口包丢弃情况</td>
<td>mellonx的命令，intel的需要阅读用户说明自己根据他们的脚本编写类似的命令</td>
</tr>
<tr>
<td><code>ibstatus</code></td>
<td>查看核更改网卡工作模式：Ethernet 或infiniband模式</td>
<td></td>
</tr>
<tr>
<td><code>ibv_asyncwatch</code></td>
<td>监视 InfiniBand 异步事件</td>
<td></td>
</tr>
<tr>
<td><code>iblinkinfo.pl 或 iblinkinfo</code></td>
<td>显示光纤网络中所有链路的链路信息</td>
<td></td>
</tr>
<tr>
<td><code>sminfo</code></td>
<td>用法sminfo –help;查询 IB SMInfo 属性</td>
<td></td>
</tr>
<tr>
<td><code>ibstat 或 ibsysstat</code></td>
<td>查询 InfiniBand 设备状态或 IB 地址上的系统状态</td>
<td></td>
</tr>
<tr>
<td><code>hca_self_test.ofed</code></td>
<td>RDMA网卡自测</td>
<td>mellonx</td>
</tr>
<tr>
<td><code>/etc/infiniband/info</code></td>
<td>Mellanox OFED 安装的信息</td>
<td>mellonx</td>
</tr>
<tr>
<td><code>cat /etc/infiniband/openib.conf</code></td>
<td>看自动加载的模块列表</td>
<td>mellonx</td>
</tr>
<tr>
<td>`lspci</td>
<td>grep Mellanox`</td>
<td></td>
<td>检查Mellanox网卡是否安装和版本</td>
</tr>
</tbody>
</table>
<h2 id="RDMA-编程入门"><a href="#RDMA-编程入门" class="headerlink" title="RDMA 编程入门"></a>RDMA 编程入门</h2><h3 id="RDMA-编程入门1"><a href="#RDMA-编程入门1" class="headerlink" title="RDMA 编程入门1"></a>RDMA 编程入门1</h3><p>这部分来自<a href="https://github.com/tarickb/the-geek-in-the-corner" target="_blank" rel="noopener">the-geek-in-the-corner</a>的<a href="https://github.com/tarickb/the-geek-in-the-corner/tree/master/01_basic-client-server" target="_blank" rel="noopener">01_basic-client-server</a>；</p>
<p>在上述配置中的运行方法和连通实验类似：</p>
<ol>
<li><p>在两个服务器使用make；</p>
</li>
<li><p>服务器8作为server使用<code>./server</code>，程序告知端口号是36436；</p>
</li>
<li><p>服务器6作为client使用<code>./client 192.168.42.8 36436</code>；这里的IP地址和上面连通测试使用的IP地址一样</p>
</li>
<li><p>运行结果：</p>
<p>server8，服务端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp@R750-427Server8:~/worker/the-geek-in-the-corner/01_basic-client-server$ ./server</span><br><span class="line">listening on port 36436.</span><br><span class="line">received connection request.</span><br><span class="line">received message: message from active/client side with pid 21871</span><br><span class="line">connected. posting send...</span><br><span class="line">send completed successfully.</span><br><span class="line">peer disconnected.</span><br></pre></td></tr></table></figure>
<p>server6，客户端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp@R750-427Server6:~/worker/the-geek-in-the-corner/01_basic-client-server$ ./client 192.168.42.8 36436</span><br><span class="line">address resolved.</span><br><span class="line">route resolved.</span><br><span class="line">connected. posting send...</span><br><span class="line">send completed successfully.</span><br><span class="line">received message: message from passive/server side with pid 14356</span><br><span class="line">disconnected.</span><br></pre></td></tr></table></figure>
<p>这部分代码的目标是连接两个应用程序，让他们能够交换数据。这部分的关键是QP pair和CP，连接的每一端都有发送-接受队列和一个完成队列。构建队列并且对他们相互连接的步骤如下：</p>
<ul>
<li>创建保护域（关联队列对、完成队列、内存注册等）、完成队列和发送-接收队列对。</li>
<li>确定队列对的地址。 </li>
<li>将地址传送到另一个节点（通过某些带外机制）。</li>
<li>将队列对转换为“随时可以接收”（RTR） 状态，然后转换为“准备发送”（RTS） 状态。</li>
<li>根据需要发布发送、接收等操作</li>
</ul>
<p>主动端（请求端）和被动端（响应端）的具体步骤如下：</p>
<p><strong>被动端：</strong></p>
<ol>
<li>创建一个事件通道，以便我们可以接收 rdmacm 事件，例如连接请求和连接建立的通知。</li>
<li>绑定到地址。</li>
<li>创建侦听器并返回端口/地址。</li>
<li>等待连接请求。</li>
<li>创建保护域、完成队列和发送-接收队列对。</li>
<li>接受连接请求。</li>
<li>等待建立连接。</li>
<li>根据需要发布操作。</li>
</ol>
<p><strong>主动端：</strong></p>
<ol>
<li>创建一个事件通道，以便我们可以接收 rdmacm 事件，例如地址解析、路由解析和连接建立的通知。</li>
<li>创建连接标识符。</li>
<li>解析对等方的地址，这会将连接标识符绑定到本地 RDMA 设备。</li>
<li>创建保护域、完成队列和发送-接收队列对。</li>
<li>解析到对等方的路由。</li>
<li>连接。等待建立连接。</li>
<li>根据需要发布操作。</li>
</ol>
</li>
</ol>
<p>双方将共享相当数量的代码 - 被动端的步骤 1、5、7 和 8 大致相当于主动端的步骤 1、4、7 和 8。一旦建立了连接，与套接字一样，双方都是对等的。利用连接需要我们在队列对上发布操作。接收操作（不出所料）发布在接收队列上。在发送队列上，我们发布发送请求、RDMA 读/写请求和原子操作请求。</p>
<hr>
<h5 id="Passive-Server-side"><a href="#Passive-Server-side" class="headerlink" title="Passive/Server side"></a>Passive/Server side</h5><p>上面交代了被动端设置的部分，现在是详细的代码部分。因为几乎所有的内容都是异步处理的；因此这项工作首先需要构建一个事件处理循环和一组时间处理器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rdma/rdma_cma.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_NZ(x) do &#123; <span class="meta-keyword">if</span> ( (x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned non-zero)."</span> ); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_Z(x)  do &#123; <span class="meta-keyword">if</span> (!(x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned zero/null)."</span>); &#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, reason);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来设置一个事件通道，创建一个ramdacm ID(相当于套接字)，绑定之后再循环中等待事件，这部分是修改<code>main()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> *<span class="title">event</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_id</span> *<span class="title">listener</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_event_channel</span> *<span class="title">ec</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line"> </span><br><span class="line">  TEST_Z(ec = rdma_create_event_channel());</span><br><span class="line">  TEST_NZ(rdma_create_id(ec, &amp;listener, <span class="literal">NULL</span>, RDMA_PS_TCP));</span><br><span class="line">  TEST_NZ(rdma_bind_addr(listener, (struct sockaddr *)&amp;addr));</span><br><span class="line">  TEST_NZ(rdma_listen(listener, <span class="number">10</span>)); <span class="comment">/* backlog=10 is arbitrary */</span></span><br><span class="line"> </span><br><span class="line">  port = ntohs(rdma_get_src_port(listener));</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"listening on port %d.\n"</span>, port);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (rdma_get_cm_event(ec, &amp;event) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> <span class="title">event_copy</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;event_copy, event, <span class="keyword">sizeof</span>(*event));</span><br><span class="line">    rdma_ack_cm_event(event);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (on_event(&amp;event_copy))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_id(listener);</span><br><span class="line">  rdma_destroy_event_channel(ec);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ec 是指向 rdmacm 事件通道的指针。listener是指向侦听器的 rdmacm ID 的指针。我们在创建它时指定了<code>RDMA_PS_TCP</code>，这表明我们需要一个面向连接的可靠队列对。<code>RDMA_PS_UDP</code>将指示无连接、不可靠的队列对。 </p>
<p>然后，我们将此 ID 绑定到套接字地址。通过将端口（<code>addr.sin_port</code>）设置为零，我们指示 rdmacm 选择一个可用端口。我们还指出，我们希望侦听任何可用 RDMA 接口/设备上的连接。 </p>
<p>我们的事件循环从 rdmacm 获取事件，确认事件，然后对其进行处理。未能确认事件将导致rdma_destroy_id（） 阻塞。连接的被动端的事件处理程序仅对三个事件感兴趣：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_connect_request</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_CONNECT_REQUEST)</span><br><span class="line">    r = on_connect_request(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_ESTABLISHED)</span><br><span class="line">    r = on_connection(event-&gt;id-&gt;context);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_DISCONNECTED)</span><br><span class="line">    r = on_disconnect(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    die(<span class="string">"on_event: unknown event."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码结合前面的main函数break的条件可以看出来，这里只关注<code>on_event</code>里面的三种事件，如果不是这三种就会继续循环（等待）；</p>
<p>rdmacm 允许我们将 <code>void *</code>上下文指针与 ID 相关联。我们将使用它来附加连接上下文结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp</span> *<span class="title">qp</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">recv_mr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">send_mr</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> *recv_region;</span><br><span class="line">  <span class="keyword">char</span> *send_region;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它包含一个指向队列对（冗余，但略微简化了代码）、两个缓冲区（一个用于发送，另一个用于接收）和两个内存区域（用于发送/接收的内存必须“注册”到谓词库）的指针。当我们收到连接请求时，如果尚未构建动词上下文，我们首先构建该上下文。然后，在构建了连接上下文结构之后，我们预先发布了我们的接收信息（稍后会详细介绍），并接受连接请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_connect_request</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_init_attr</span> <span class="title">qp_attr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_conn_param</span> <span class="title">cm_params</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"received connection request.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  build_context(id-&gt;verbs);</span><br><span class="line">  build_qp_attr(&amp;qp_attr);</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(rdma_create_qp(id, s_ctx-&gt;pd, &amp;qp_attr));</span><br><span class="line"> </span><br><span class="line">  id-&gt;context = conn = (struct connection *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct connection));</span><br><span class="line">  conn-&gt;qp = id-&gt;qp;</span><br><span class="line"> </span><br><span class="line">  register_memory(conn);</span><br><span class="line">  post_receives(conn);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;cm_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(cm_params));</span><br><span class="line">  TEST_NZ(rdma_accept(id, &amp;cm_params));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们推迟构建谓词上下文，直到收到第一个连接请求，因为<code>rdmacm listener ID 不一定绑定到特定的 RDMA 设备（以及关联的谓词上下文）。但是，我们收到的第一个连接请求将在</code>id-&gt;verbs` 处具有有效的谓词上下文结构。构建谓词上下文涉及设置静态上下文结构、创建保护域、创建完成队列、创建完成通道以及启动线程以从队列中提取完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_context</span> *<span class="title">ctx</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_pd</span> *<span class="title">pd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_comp_channel</span> *<span class="title">comp_channel</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">pthread_t</span> cq_poller_thread;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">s_ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s_ctx-&gt;ctx != verbs)</span><br><span class="line">      die(<span class="string">"cannot handle events in more than one context."</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  s_ctx = (struct context *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct context));</span><br><span class="line">  <span class="comment">//设置静态上下文结构、创建保护域、创建完成队列、创建完成通道</span></span><br><span class="line">  s_ctx-&gt;ctx = verbs;</span><br><span class="line"> </span><br><span class="line">  TEST_Z(s_ctx-&gt;pd = ibv_alloc_pd(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;comp_channel = ibv_create_comp_channel(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;cq = ibv_create_cq(s_ctx-&gt;ctx, <span class="number">10</span>, <span class="literal">NULL</span>, s_ctx-&gt;comp_channel, <span class="number">0</span>));</span><br><span class="line">  TEST_NZ(ibv_req_notify_cq(s_ctx-&gt;cq, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(pthread_create(&amp;s_ctx-&gt;cq_poller_thread, <span class="literal">NULL</span>, poll_cq, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用完成通道允许我们阻塞轮询器线程等待完成。我们创建完成队列，并将<code>cqe</code>设置为 10（<code>cqe</code>是<code>ibv_create_cq</code> 函数里面的第二个参数），表示我们希望在队列上留出 10 个条目的空间。此数字应设置得足够大，以便队列不会溢出。轮询器在通道上等待，确认完成，重新排列完成队列（使用 <code>ibv_req_notify_cq()</code>），然后从队列中提取事件，直到没有事件留下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    TEST_NZ(ibv_get_cq_event(s_ctx-&gt;comp_channel, &amp;cq, &amp;ctx));</span><br><span class="line">    ibv_ack_cq_events(cq, <span class="number">1</span>);</span><br><span class="line">    TEST_NZ(ibv_req_notify_cq(cq, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc))</span><br><span class="line">      on_completion(&amp;wc);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到我们的连接请求。构建动词上下文后，我们必须初始化队列对属性结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(qp_attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qp_attr));</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;send_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;recv_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;qp_type = IBV_QPT_RC;</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;cap.max_send_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先将结构清零，然后设置我们关心的属性。 <code>send_cq</code> 和 <code>recv_cq</code>分别是发送和接收完成队列。<code>qp_type</code> 设置为表明我们想要一个可靠的、面向连接的队列对。队列对功能结构 <code>qp_attr-&gt;cap</code> 用于与动词驱动程序协商最小功能。在这里，我们请求十个挂起的发送和接收（在它们各自的队列中的任何时间），以及每个发送或接收请求一个分散/收集元素（SGE；实际上是一个内存位置/大小元组）。建立队列对初始化属性后，我们调用 rdma_create_qp() 来创建队列对。然后我们为我们的连接上下文结构（结构连接）分配内存，并为我们的发送和接收操作分配/注册内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  conn-&gt;send_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">  conn-&gt;recv_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;send_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd, </span><br><span class="line">    conn-&gt;send_region, </span><br><span class="line">    BUFFER_SIZE, </span><br><span class="line">    IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE));</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;recv_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd, </span><br><span class="line">    conn-&gt;recv_region, </span><br><span class="line">    BUFFER_SIZE, </span><br><span class="line">    IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们分配两个缓冲区，一个用于发送，另一个用于接收，然后用动词注册它们。我们指出需要对这些内存区域进行本地写入和远程写入访问。连接请求事件处理程序中的下一步（变得相当长）是预先发布接收。在接受连接之前必须发布接收工作请求 （WR） 的原因是，基础硬件不会缓冲传入消息 — 如果接收请求尚未发布到工作队列，则传入消息将被拒绝，对等方将收到接收器未就绪 （RNR） 错误。我将在另一篇文章中进一步讨论这个问题，但现在只需说必须在发送之前发布接收。我们将通过在接受连接之前发布收到的邮件，并在建立连接后发送发送来强制执行此操作。发布接收需要我们构建一个接收工作请求结构，然后将其发布到接收队列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  wr.wr_id = (<span class="keyword">uintptr_t</span>)conn;</span><br><span class="line">  wr.next = <span class="literal">NULL</span>;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;recv_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;recv_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_recv(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（任意）<code>wr_id</code>字段用于存储连接上下文指针。最后，完成所有这些设置后，我们已准备好接受连接请求。这是通过调用rdma_accept（）来完成的。 我们需要处理的下一个事件是RDMA_CM_EVENT_ESTABLISHED，这表示已建立连接。这个处理程序很简单 - 它只是发布一个发送工作请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">context</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">snprintf</span>(conn-&gt;send_region, BUFFER_SIZE, <span class="string">"message from passive/server side with pid %d"</span>, getpid());</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"connected. posting send...\n"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(wr));</span><br><span class="line"> </span><br><span class="line">  wr.opcode = IBV_WR_SEND;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;send_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;send_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_send(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与我们用于发布接收的代码没有根本的不同，除了发送请求指定了操作码。此处，IBV_WR_SEND指示必须与对等体上的相应接收请求匹配的发送请求。其他选项包括 RDMA 写入、RDMA 读取和各种原子操作。在 wr.send_flags 中指定IBV_SEND_SIGNALED表示我们需要此发送请求的完成通知。</p>
<p>我们要处理的最后一个 rdmacm 事件是RDMA_CM_EVENT_DISCONNECTED，我们将在其中执行一些清理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">id</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"peer disconnected.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_qp(id);</span><br><span class="line"> </span><br><span class="line">  ibv_dereg_mr(conn-&gt;send_mr);</span><br><span class="line">  ibv_dereg_mr(conn-&gt;recv_mr);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;send_region);</span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;recv_region);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_id(id);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们所要做的就是处理从完成队列中提取的完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;status != IBV_WC_SUCCESS)</span><br><span class="line">    die(<span class="string">"on_completion: status is not IBV_WC_SUCCESS."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;opcode &amp; IBV_WC_RECV) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)(<span class="title">uintptr_t</span>)<span class="title">wc</span>-&gt;<span class="title">wr_id</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received message: %s\n"</span>, conn-&gt;recv_region);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_SEND) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send completed successfully.\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回想一下，在 post_receives（） 中，我们设置了对连接上下文结构的wr_id。就是这样！建造很简单，但不要忘记-lrdmacm。此处提供了被动端/服务器和主动端/客户端的完整代码。（在之后的部分作者讨论了优化）</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://github.com/tarickb/the-geek-in-the-corner" target="_blank" rel="noopener">the-geek-in-the-corner</a></li>
<li><a href="https://thegeekinthecorner.wordpress.com/2010/08/13/building-an-rdma-capable-application-with-ib-verbs-part-1-basics/" target="_blank" rel="noopener">Building an RDMA-capable application with IB verbs, part 1: basics</a></li>
<li><a href="https://thegeekinthecorner.wordpress.com/2013/02/02/rdma-tutorial-pdfs/" target="_blank" rel="noopener">RDMA tutorial PDFs</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2022-05-08T08:58:36.360Z" itemprop="dateUpdated">2022-05-08 16:58:36</time>
</span><br>


        
        Link：<a href="/2022/04/23/RDMA-learning4/" target="_blank" rel="external">http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/</a>
        
    </div>
    
    <footer>
        <a href="http://Tyler-ytr.github.io">
            <img src="/img/Tyler.png" alt="Tyler-yin">
            Tyler-yin
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RDMA/" rel="tag">RDMA</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/&title=《RDMA-learning4》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/&title=《RDMA-learning4》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《RDMA-learning4》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2022/10/06/%E5%B9%B6%E5%8F%91%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">并发算法理论</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2022/04/19/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">项目开发记录</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "NoLhoWnmbSW89zV4zc04RPwx-gzGzoHsz",
            appKey: "SSdRGaHcdjoKc7cJJpOlJIqJ",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Tyler-yin &copy; 2015 - 2022</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/&title=《RDMA-learning4》 — Tyler-yin's blog&pic=http://Tyler-ytr.github.io/img/Tyler.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/&title=《RDMA-learning4》 — Tyler-yin's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《RDMA-learning4》 — Tyler-yin's blog&url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/&via=http://Tyler-ytr.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tyler-ytr.github.io/2022/04/23/RDMA-learning4/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aQW7DMAwEwPz/0+m1ARpnV6yLWh6disBVOD4wpKjHI17Pb+v4mXfPH/9v/i2jhYGBcVnG83C9e6YN/d0Oyf7HsWFgYNyHkSTQ/Pk2iOQ1fYgZAwMDI06Cxyk4KQExMDAwzki4eVh5IYiBgYGx1sS2pLWkfHovjoGBcUFGfur+93+fMt/AwMC4FONZrvYQPxkJrEXyshsGBsbWjPk1iLUjtrbpjeLBwMDYmjFpPs++p1bvg4GBcQPGcePatppt4ZhfvCguh2FgYGzBaK9KTFrWNXxR4WJgYGzKSIKbpOB2LDo/vMPAwNiV0W60ds2rBf9aE4uBgXFZxlpRmCfo/NC/vS728gkGBsbWjHkbuTbObAcSxakhBgbGdowklOSqRF6B5gk0L0AxMDD2ZuTpb+34rO2kJxfFMDAw9ma0zWq7Q07Nm9jo1wMDA2MLRp5e1xraNtzFyQYGBsYNGGvpbzIwmBz6f7hggYGBsR0jL+DWCsG1z0eTDQwMjE0Z7eWtPIi2BGwT8Q+9OAYGxg0YyYFXkjrzAWfePH940RgYGDdgTL5+Ut5NxpwYGBh3YPxWuVZ3zGURWReFGBgYGzHyNUmR+TAg/wFYiwEDA+O6jEmSbUOcH9h9mMdiYGBszWgTX1tKTl5T1DxjYGBgxGmxvZaRD1CLC2EYGBgYcRptBw/JmOH0hIuBgfGPGXl517aa7c758BIDA+M+jMmh2NoBWT7gbH8GMDAwtmN8Ac/LslC2ff2IAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '＞﹏＜';
            clearTimeout(titleTime);
        } else {
            document.title = '~\(≧▽≦)/~';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


</body>
</html>
